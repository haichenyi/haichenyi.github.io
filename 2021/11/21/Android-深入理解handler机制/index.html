<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Android--深入理解handler机制 | 海晨忆的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta name="description" content="1. 目录 1–目录 2–前言 3–简单总结 4–Looper的区别：MainLooper和普通Looper 5–handler发送的消息过程 6–MessageQueue怎么把这条消息放进队列的 7–Looper读取消息：loop() 8–MessageQueue读取消息：next() 9–如何提高消息的优先级？同步消息，屏障消息，异步消息 10–handler知识点总结   前言&amp;emsp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Android--深入理解handler机制">
<meta property="og:url" content="https://haichenyi.com/2021/11/21/Android-深入理解handler机制/index.html">
<meta property="og:site_name" content="海晨忆的博客">
<meta property="og:description" content="1. 目录 1–目录 2–前言 3–简单总结 4–Looper的区别：MainLooper和普通Looper 5–handler发送的消息过程 6–MessageQueue怎么把这条消息放进队列的 7–Looper读取消息：loop() 8–MessageQueue读取消息：next() 9–如何提高消息的优先级？同步消息，屏障消息，异步消息 10–handler知识点总结   前言&amp;emsp;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://haichenyi.com/uploads/article/2021-11-21/简单的理解send消息图.png">
<meta property="og:image" content="https://haichenyi.com/uploads/article/2021-11-21/handler知识点.png">
<meta property="og:updated_time" content="2021-11-21T03:37:54.851Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android--深入理解handler机制">
<meta name="twitter:description" content="1. 目录 1–目录 2–前言 3–简单总结 4–Looper的区别：MainLooper和普通Looper 5–handler发送的消息过程 6–MessageQueue怎么把这条消息放进队列的 7–Looper读取消息：loop() 8–MessageQueue读取消息：next() 9–如何提高消息的优先级？同步消息，屏障消息，异步消息 10–handler知识点总结   前言&amp;emsp;">
<meta name="twitter:image" content="https://haichenyi.com/uploads/article/2021-11-21/简单的理解send消息图.png">
  
    <link rel="alternate" href="/atom.xml" title="海晨忆的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/uploads/artistic_image/head.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
  <script>
  let antiquityStorage = window.sessionStorage.getItem('antiquitySessionStorage');
  if (antiquityStorage == '' || antiquityStorage == null) {
    var antiquityLoader = '<div id="loaderbox"><div class="loader"><div class="load-roll"><div class="load-top"></div><div class="load-right"></div><div class="load-bottom"></div></div></div></div>';
    document.write(antiquityLoader);
    document.body.style.overflow = 'hidden'
  }
  </script>
</head>

<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" style="background-image: url(/uploads/artistic_image/bg.jpg)" title="背景图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
        <a class="nav-item" href="/about" title
        
        >简历</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-left">
        <section id="main"><article id="post-Android-深入理解handler机制" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      Android--深入理解handler机制
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2021/11/21/Android-深入理解handler机制/" class="article-date">
  <time datetime="2021-11-21T03:33:57.000Z" itemprop="datePublished">2021-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-源码解析/">Android -源码解析</a>
  </div>

    
  </div>
  
    <span id="busuanzi_container_page_pv">
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
    </span>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud doorframe mac" itemprop="articleBody">
      
        <p><span id="c1"></span></p>
<h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><ul>
<li><a href="#c1">1–目录</a></li>
<li><a href="#c2">2–前言</a></li>
<li><a href="#c3">3–简单总结</a></li>
<li><a href="#c4">4–Looper的区别：MainLooper和普通Looper</a></li>
<li><a href="#c5">5–handler发送的消息过程</a></li>
<li><a href="#c6">6–MessageQueue怎么把这条消息放进队列的</a></li>
<li><a href="#c7">7–Looper读取消息：loop()</a></li>
<li><a href="#c8">8–MessageQueue读取消息：next()</a></li>
<li><a href="#c9">9–如何提高消息的优先级？同步消息，屏障消息，异步消息</a></li>
<li><a href="#c10">10–handler知识点总结</a></li>
</ul>
<p><span id="c2"></span></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;Android程序是一个以消息驱动的程序，页面的跟新，Activity生命周期的变化，点击事件等等都与消息息息相关。</p>
<a id="more"></a>
<p><span id="c3"></span></p>
<h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>&emsp;&emsp;<strong>简单的理解Handler发送消息的流程</strong>：Handler发送消息(message)到MessageQueue，然后，Looper通过loop()方法循环从MessageQueue里面读取消息。然后，发送给对应的target(Handler)。</p>
<p><img src="/uploads/article/2021-11-21/简单的理解send消息图.png" alt="简单的理解send消息图.png"></p>
<p>我们带着问题来理解这个流程，最后，我们在重新总结一下。辣么问题就来了：</p>
<ol>
<li>handler都是一样的，为什么Looper会分Looper.getMainLooper()和普通的Looper？</li>
<li>handler发送的消息过程是什么样子的？</li>
<li>Looper怎么读取消息的？</li>
<li>handler发送消息能发送延时消息，Looper读取到消息之后，怎么确定是立刻发送回去，还是隔多久发送回去？</li>
<li>怎么提升消息的优先级？</li>
<li>我们项目里面可能会用到的Looper.prepare()，Looper.loop()，这是做什么操作？</li>
</ol>
<p>&emsp;&emsp;我们结合源码一起来看一下这些问题：</p>
<p><span id="c4"></span></p>
<h3 id="Looper的区别：MainLooper和普通Looper"><a href="#Looper的区别：MainLooper和普通Looper" class="headerlink" title="Looper的区别：MainLooper和普通Looper"></a>Looper的区别：MainLooper和普通Looper</h3><p>第一个问题，handler都是一样的，为什么Looper会分Looper.getMainLooper()和普通的Looper？我们都知道</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler handler = new Handler(Looper.getMainLooper())</span><br></pre></td></tr></table></figure></div>
<p>通过这个Looper.getMainLooper()方式得到得Handler，可以改变UI，其他的不行，这是为什么呢？我们都知道，UI线程才能改变UI。</p>
<p><strong>ps：app的启动入口是在ActivityThread的main方法。</strong></p>
<p>捡一些 (<del>我看的懂的</del>),呸，是主要的，跟我们聊的这个相关的位置贴出来，源码如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        //loop调用了一个准备MainLooper方法（按照方法的名字意思翻译的）</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        //Looper调用loop()方法进入了循环模式</span><br><span class="line">        Looper.loop();</span><br><span class="line">        //如果走到这里，那就没有进入循环模式，就抛出异常了，异常字面意思很好理解，主线程的loop意外的退出了</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>注释应该写的比较清楚了吧？这里我想说的是，main启动的时候，这个线程就是UI线程，这个是系统给规定的，只有在这个线程里面才能改变UI。</p>
<p>我们再来看看这个Looper.prepareMainLooper()里面做了什么操作</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    //调用prepare方法，传了一个false的Boolean值</span><br><span class="line">    prepare(false);</span><br><span class="line">    //锁</span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        //sMainLooper不等于null，就抛异常</span><br><span class="line">        if (sMainLooper != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //等于null，就把myLooper()方法的返回值赋值给sMainLooper</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//prepare，一个Boolean类型的参数，看名字意思应该是：是否允许退出</span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    //sThreadLocal.get()值不等于null，就抛异常</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //sThreadLocal.get()值等于null，就new一个Looper，放到sThreadLocal中</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Looper的构造方法，我们此时主线程new的时候传的是false</span><br><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    //新建了一个消息队列，MsgQueue，并且把这个boolean传进去了，赋值给mQueue变量</span><br><span class="line">    mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">    //把当前线程赋值给了mThread变量</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line">//消息队列的构造方法，Boolean类型的参数，到这里就应该知道了，表示这个线程是否允许退出，true：允许退出。false：不允许退出</span><br><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    //nativeInit():native方法，不知道是啥，应该是一些需要的初始化</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br><span class="line">//sThreadLocal.get()的值返回回去</span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注释都有了，最开始调用的prepare(false)方法，看完上面的注释，我大致串一下。</p>
<p>ps:说一下这个sThreadLocal变量，我也不知道怎么说，反正就是它的类型是：<strong>ThreadLocal<looper></looper></strong>,它就是一个普通的类，然后泛型是Looper，所以，这个类就是用来放Looper的。大致这么理解</p>
<p>我们再说回这个方法，主要就是，</p>
<ol>
<li>先判断这个变量是不是空的，如果不是空的，就抛异常了，因为Looper是不允许我们自己手动创建的。</li>
<li>如果是空，就创建一个Looper，放进sThreadLocal变量里面；</li>
<li>然后，创建Looper的时候，顺道就创建了MessageQueue。主线程创建的MessageQueue是不允许主动退出的，如果消息队列退出了，退出app了。</li>
<li>并且，Looper的mQueue，mThread也都赋值好了，一个是消息队列，一个是当前线程(这两个变量用的也比较多)。</li>
</ol>
<p>prepare()方法，到这里就说完了，我们再看剩下的代码，往上面翻一下，再看一下。</p>
<p>ps：sMainLooper变量，类型就是Looper</p>
<p>剩下的代码就是一个锁方法，</p>
<ol>
<li>判断sMainLooper是不是不等于null，如果，不等于null就抛出了异常</li>
<li>如果等于null，就把上面创建的looper，赋值给sMainLooper</li>
</ol>
<p>&emsp;我们Looper.getMainLooper()获取的Looper就是这个sMainLooper，也就是我们当前线程(UI线程)的Looper，我们只有绑定了这个looper的handler才能改变UI，因为，这个handler是在给UI线程传递消息。</p>
<p>&emsp;&emsp;为什么不等于null就抛出异常了呢?因为sMainLooper只在系统的时候创建，不能在其他的时候创建，如果，在其他的时候创建，说明系统启动的时候没有创建Looper，那么，主线程就没法通信，这是有问题的。</p>
<p><strong>第一个问题我说明白了吧？Looper.getMainLooper()获取到的是主线程的Looper，跟它绑定的handler能改变UI，没有跟它绑定的hanler都不能改变UI</strong></p>
<p><span id="c5"></span></p>
<h3 id="handler发送的消息过程"><a href="#handler发送的消息过程" class="headerlink" title="handler发送的消息过程"></a>handler发送的消息过程</h3><p>第二个问题，handler发送的消息过程是什么样子的？</p>
<p>说到这里，我们<strong>先聊一下Message类</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class Message implements Parcelable &#123;</span><br><span class="line">    public int what;</span><br><span class="line">    public int arg1;</span><br><span class="line">    public int arg2;</span><br><span class="line">    public Object obj;</span><br><span class="line">    ...</span><br><span class="line">    public long when;</span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /*package*/ Handler target;</span><br><span class="line">    ...</span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /*package*/ Message next;</span><br><span class="line">    /** @hide */</span><br><span class="line">    public static final Object sPoolSync = new Object();</span><br><span class="line">    private static Message sPool;</span><br><span class="line">    private static int sPoolSize = 0;</span><br><span class="line">    private static final int MAX_POOL_SIZE = 50;</span><br></pre></td></tr></table></figure></div>
<p>&emsp;&emsp;写代码这么长时间，我们发了那么多消息，是不是都没有仔细看看Message的成员变量？看看上面这几个变量。</p>
<ol>
<li>what，arg1，arg2，obj可能我们用的比较多。</li>
<li>这个long 类型的when，很重要，是消息放在队列哪个位置的重要依据。是放在队头？还是队尾？（<strong>重点</strong>）</li>
<li>Handler类型的target变量，我们之前没注意过吧？字面意思：目标。目标handler（<strong>重点</strong>）</li>
<li>下面还有两个Message类型的变量，一个next，一个sPool；next字面意思：下一条消息。pool：水池。类型又是Message；那么，sPool：池子的消息</li>
<li>Object类型的sPoolSync：异步池子。根据经验来看，碰到过很多这种Object类型的东西，大部分都是加锁用的。synchronized(sPoolSync)，一般都是这样用</li>
<li>int类型的两个变量，sPoolSize值是0，再就是MAX_POOL_SIZE，值是50。字面的意思就是池子的大小是0，池子的最大值是50.</li>
</ol>
<p>&emsp;&emsp;什么池子啊，什么最大值啊。我相信很多人跟我的反应都是一样的，线程池，复用。所以这里就是消息池，消息能复用，消息池最大的消息个数是50个，异步。</p>
<p>&emsp;&emsp;延申到这里，引出我想问的第一个问题，消息的创建，消息创建的两种方式：一种是new出来，一种是obtain的方式，它有一系列的重载方法。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//第一种：new的方式</span><br><span class="line">Message msg1 = new Message();</span><br><span class="line">msg1.what = 1;</span><br><span class="line">msg1.arg1 = 20;</span><br><span class="line">handler.sendMessage(msg1);</span><br><span class="line"></span><br><span class="line">//第二种：obtain的方式</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.what =1;</span><br><span class="line">msg1.arg1 = 20;</span><br><span class="line">handler.sendMessage(msg);</span><br></pre></td></tr></table></figure></div>
<p>第一种没啥好说的，我们看第二种：Message.obtain()</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">        //加锁</span><br><span class="line">        synchronized (sPoolSync) &#123;</span><br><span class="line">            //判断sPool是否为空</span><br><span class="line">            if (sPool != null) &#123;</span><br><span class="line">                //sPool不为空，就复用sPool msg对象</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                //然后，把m的next赋值给sPool</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                //然后，把已经去出去的msg的额next置空</span><br><span class="line">                m.next = null;</span><br><span class="line">                m.flags = 0; // clear in-use flag</span><br><span class="line">                //这时候，消息池已经去出去了一条消息，消息池大小就减一</span><br><span class="line">                sPoolSize--;</span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //sPool为空，就new一个msg对象</span><br><span class="line">        return new Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>简单的理解就是，不需要重新创建消息，从消息池里面取出一条消息，赋值给我们需要创建的msg对象。</p>
<p>这里为什么要加锁？什么情况下需要加锁？当然是防止并发呀，handler可以随时随地的发消息，所以，为了防止并发，加锁。</p>
<p>问题来了，这个sPool是什么时候赋值的呢？我们创建消息的时候没有赋值。创建的时候没有赋值，我们在Message类里面，检索sPool对象，我们找到如下方法：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">    void recycleUnchecked() &#123;</span><br><span class="line">        //重置一些列的成员变量</span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = 0;</span><br><span class="line">        arg1 = 0;</span><br><span class="line">        arg2 = 0;</span><br><span class="line">        obj = null;</span><br><span class="line">        replyTo = null;</span><br><span class="line">        sendingUid = UID_NONE;</span><br><span class="line">        workSourceUid = UID_NONE;</span><br><span class="line">        when = 0;</span><br><span class="line">        target = null;</span><br><span class="line">        callback = null;</span><br><span class="line">        data = null;</span><br><span class="line">        //就是这里，加锁</span><br><span class="line">        synchronized (sPoolSync) &#123;</span><br><span class="line">            //当前消息池子是否小于限制的最大值</span><br><span class="line">            if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                //把sPool赋值给next</span><br><span class="line">                next = sPool;</span><br><span class="line">                //sPool赋值现在的消息</span><br><span class="line">                sPool = this;</span><br><span class="line">                //消息池子大小加1</span><br><span class="line">                sPoolSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>看这个方法名就应该能猜到，消息回收的时候调用的。所以，在消息回收的时候，就把这条消息重置，把这条回收的消息赋值给sPool，这里就是赋值的位置。在消息回收的时候赋值。</p>
<p>所以，只要你并发量不大，你每次都是obtain创建消息，基本上都是复用的，不会重新创建消息。</p>
<p><strong>消息说完了，跑题了，跑题了，言归正传</strong></p>
<p><strong>handler发送消息的流程</strong></p>
<p>欢迎来到走进科学之Android消息发送流程，我们来一步一步的剖析这条消息是怎么一步一步放进消息队列的。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.what =1;</span><br><span class="line">msg1.arg1 = 20;</span><br><span class="line">handler.sendMessage(msg);</span><br></pre></td></tr></table></figure></div>
<p>我们来看这个sendMessage的源码。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessage(@NonNull Message msg) &#123;</span><br><span class="line">        //是不是眼熟，没错，它实际上调用的就是我们延时消息的方法，只不过，这个延时的时间是0</span><br><span class="line">        return sendMessageDelayed(msg, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//我们再来看看这个sendMessageDelayed方法</span><br><span class="line">public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123;</span><br><span class="line">        //这里有个判断时间，小于0，就赋值给0，所以，发送延时消息的时候时间传递负数，会立马接收到消息，知道是为什么了吧？</span><br><span class="line">        if (delayMillis &lt; 0) &#123;</span><br><span class="line">            delayMillis = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里又调用的sendMessageAtTime方法</span><br><span class="line">        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里我想说的是SystemClock.uptimeMillis()：表示系统开机时间</span><br><span class="line">//我们再来看看这个sendMessageAtTime方法</span><br><span class="line"></span><br><span class="line">public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123;</span><br><span class="line">        //这里有一个消息队列的判断，这个消息队列是在Handler创建的时候赋值的。</span><br><span class="line">        //可以点进去看一下。Hander构造方法传递一个Looper，Looper构造方里面创建了msgQueue，就是这个。</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        //如果是空，就抛异常，因为消息队列都没有，循环啥？</span><br><span class="line">        if (queue == null) &#123;</span><br><span class="line">            RuntimeException e = new RuntimeException(</span><br><span class="line">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里又调用了enqueueMessage</span><br><span class="line">        return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,</span><br><span class="line">            long uptimeMillis) &#123;</span><br><span class="line">        //这里，我们前面说消息的时候，说很重要，就是在handler发送消息的这里赋值，这个值也是后面Looper发送给哪个handler的依据。</span><br><span class="line">        msg.target = this;</span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line">        //这个是判断你的这个消息是不是异步，提升消息优先级的位置。同步消息，同步屏障，异步消息。</span><br><span class="line">        if (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里就开始进入到消息队列了</span><br><span class="line">        return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>&emsp;&emsp;msg.target是后面Looper拿到这条消息之后，发送的目的地，不然，Looper怎么知道要发送给谁(handler)？</p>
<p>&emsp;&emsp;提升消息优先级的位置。同步消息，同步屏障，异步消息。也是比较重要，后面再细唠。</p>
<p><span id="c6"></span></p>
<h3 id="MessageQueue怎么把这条消息放进队列的"><a href="#MessageQueue怎么把这条消息放进队列的" class="headerlink" title="MessageQueue怎么把这条消息放进队列的"></a>MessageQueue怎么把这条消息放进队列的</h3><p>到这里handler的发送就完了，MessageQueue怎么把这条消息放进去的呢？方法如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        //判断有没有目标handler，如果没有，直接就抛异常，都没有这个目的地，我最后取出这条消息，我发给谁？所以，直接就抛异常</span><br><span class="line">        if (msg.target == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //加锁，不加锁，如果很多消息同时需要加紧队列就会出问题</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            //判断这条消息是否正在使用，如果正在使用，那也抛异常。为什么消息会正在使用呢？</span><br><span class="line">            //我们前面说了obtain方式消息是复用的，发送消息会并发，所以，是吧？</span><br><span class="line">            if (msg.isInUse()) &#123;</span><br><span class="line">                throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果，当前msgQueue正在退出，把消息回收了。</span><br><span class="line">            //比方说，你新建线程请求网络，网络请求完，线程一般就会死掉了，线程都没有了，MsgQueue当然要退出了。</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = new IllegalStateException(</span><br><span class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //走到这里，消息就准备放进消息队列了，就是放在那里的问题</span><br><span class="line">            //给消息加个标记，表示消息正在使用。跟前面那个判断正好对应</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            //这个时间，还记不记得？系统开机时间+你延时的时间</span><br><span class="line">            msg.when = when;</span><br><span class="line">            //把消息队列的当前消息赋值给p</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            //是否需要唤醒线程，唤醒跟休眠都是native方法。</span><br><span class="line">            boolean needWake;</span><br><span class="line">            //当前消息是空，说明当前消息队列没有消息，就直接把我们传递的这条消息加进队列</span><br><span class="line">            //我加进来的这条消息的执行时间是0，时间是不会有负数的，如果传进来是负数，都被改成0了，所以，我加的这条消息应该是最先执行的，所以，要加进队列</span><br><span class="line">            //加进来的这条消息的执行时间小于当前线程的执行时间，我加进来的这条消息执行的时间，比你当前消息队列循环的时间小，说明，我要在它的前面执行，要加进队列</span><br><span class="line">            //上面这个时间小的问题，你可以理解成，消息队列循环的时间是延时10秒处理的，我新进的这条消息是要延时5秒，所以，要放在它的前面</span><br><span class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">               //走到这里，说明新加消息需要放在队首 //我新加的消息放进来了之后，要把当前消息的后面，也就是我新加消息的next</span><br><span class="line">                //因为，我新加的消息要在它的前面执行</span><br><span class="line">                msg.next = p;</span><br><span class="line">                //然后，把我新加消息赋值给当前消息变量</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">         //走到这个else里面，就说明当前消息不需要放到队首，就循环判断看它要被放在哪 </span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                //进入死循环</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    //如果当前msg的下一个消息是空，表示没有消息了，for循环就要中止了，需要把新加消息放进来了</span><br><span class="line">                    //如果当前消息的下一条消息的执行时间在新加的执行时间的后面，说明，新加消息要在这条消息的前面执行。所以，for循环就要中止了，需要把新加消息放进来了</span><br><span class="line">                    if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //把当前消息放在新加消息的后面</span><br><span class="line">                msg.next = p; </span><br><span class="line">                //把新加消息，放在当前执行消息的后面。此时，消息就插件队列了</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">            //是否需要唤醒消息队列开始循环获取消息，是native层面做的事情。</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>总结下来就是：<strong>三个条件</strong></p>
<ol>
<li>根据当前队列是否空闲(p == null)</li>
<li>当前消息执行的时间when(when == 0)</li>
<li>当前队列执行的消息是否需要在新增消息的后面执行(when &lt; p.when)</li>
</ol>
<p>&emsp;&emsp;来判断当前消息是否需要插到队首，只要满足上面的任意一个条件，就需要放进队首；否则，for循环判断当前消息需要放到消息队列的哪个位置。需要插队的话就记得把队列中后面的消息放到当前消息的后面。</p>
<p>再重复一遍，这个时间是<strong>SystemClock.uptimeMillis() + delayMillis</strong>，系统开机时间+你传递的延时时间。</p>
<p>到这里，消息就被插件消息队列了。代码基本上每行都有注释，一遍没有看懂的话就多看几遍。</p>
<p><span id="c7"></span></p>
<h3 id="Looper读取消息：loop"><a href="#Looper读取消息：loop" class="headerlink" title="Looper读取消息：loop()"></a>Looper读取消息：loop()</h3><p>消息已经放进队列了，第二个问题就结束了，接下来就是第三个问题：<strong>Looper怎么读取消息的？</strong></p>
<p>Looper是通过loop()方法循环读取消息的。代码如下：</p>
<p>代码比较多，我把无关的(<del>看不懂的</del>)都去掉了<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">        //获取当前线程的looper</span><br><span class="line">        final Looper me = myLooper();</span><br><span class="line">        //如果，等于null，就抛异常，看异常的消息就应该看的出来，说没有在当前线程调用Looper.prepare()方法</span><br><span class="line">        //Looper.prepare()这个方法就是创建Looper的</span><br><span class="line">        if (me == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //获取当前线程的消息队列</span><br><span class="line">        final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        //进入死循环读取消息</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //读取队列中的下一条消息，可能会阻塞线程</span><br><span class="line">            Message msg = queue.next(); </span><br><span class="line">            //如果，没有消息了，就退出循环，进入休眠状态</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">                // No message indicates that the message queue is quitting.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            //获取观察者模式的对象</span><br><span class="line">            final Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            Object token = null;</span><br><span class="line">            if (observer != null) &#123;</span><br><span class="line">                //这里应该是这个观察者对象发送了一个消息正在分发的消息</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            try &#123;</span><br><span class="line">            //msg.target：是不是很眼熟？就是需要接收这条消息的handler //通过这个handler调用dispatchMessage方法，发送消息 msg.target.dispatchMessage(msg);</span><br><span class="line">                if (observer != null) &#123;</span><br><span class="line">                   //然后，观察者发送一个消息分发完成的消息 observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            &#125; catch (Exception exception) &#123;</span><br><span class="line">                if (observer != null) &#123;</span><br><span class="line">                   //如果出现了异常，这个观察者就发送一个消息分发异常的消息 observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                throw exception;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            //眼熟不？就是前面说的，消息回收，重复利用，就是在消息分发完成之后触发</span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>我们先看一下这个handler的dispatchMessage方法：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(@NonNull Message msg) &#123;</span><br><span class="line">        //这个Message的callback是什么时候赋值的呢？就是创建Message的时候，可以回过头去看一下</span><br><span class="line">        if (msg.callback != null) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mCallback != null) &#123;</span><br><span class="line">                if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //这个方法，眼熟吗？看下面，我们新建handler的时候，不就重写了这个方法吗？</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Handler handler = new Handler(Looper.getMainLooper())&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(@NonNull Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></div>
<p>到此，消息的发送，入队，取消息，处理，就形成了闭环了。整个流程：</p>
<ol>
<li>新建handler，发送消息sendMessage</li>
<li>此时消息的创建obtain复用模式，后面可能会造成正在使用的异常，所以，需要加锁同步一下</li>
<li>然后，消息进队，target(目的地的handler)和when(执行的时间系统开机时间+延时时间)</li>
<li>判断的三个条件，是放进队首(队列中是空的，时间是0，时间在队列消息时间的前面)，还是队中(需要循环判断队列中是否还有消息和时间)</li>
<li>通过loop方法取出来消息，通过这个消息的target发送消息</li>
</ol>
<p>我们接下来说第四个问题：<strong>handler发送消息能发送延时消息，Looper读取到消息之后，怎么确定是立刻发送回去，还是隔多久发送回去？</strong></p>
<p>我们上面分析完，好像并没有看到这个延时消息的问题啊，Looper的loop方法是，只要queue.next()返回给它消息了，它就直接发送回去了，没有什么延时。</p>
<p><span id="c8"></span></p>
<h3 id="MessageQueue读取消息：next"><a href="#MessageQueue读取消息：next" class="headerlink" title="MessageQueue读取消息：next()"></a>MessageQueue读取消息：next()</h3><p>重点就在这里queue.next()，读取消息。这里也是提升消息优先级的位置(同步屏障，异步消息)。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">    Message next() &#123;</span><br><span class="line">        </span><br><span class="line">        final long ptr = mPtr;</span><br><span class="line">        //通过注释翻译过来就是：loop已经退出了，或者应用正在尝试重启一个looper，就直接return null</span><br><span class="line">        if (ptr == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">        //下一次循环的时间，单位是：秒</span><br><span class="line">        int nextPollTimeoutMillis = 0;</span><br><span class="line">        //开始进入死循环去读取消息</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">                //不知道啥意思。</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line">            //这是一个native方法，看名字，大概的意思应该就是循环一次，经过nextPollTimeoutMillis长的时间</span><br><span class="line">            //就是底层C/C++经过这么长时间之后，触发一次循环</span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">            </span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                // Try to retrieve the next message.  Return if found.</span><br><span class="line">                final long now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = null;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                //屏障消息的实质就是创建一条target为null的消息</span><br><span class="line">                //看这里的if条件，正常的消息target不等于null，这里的判断是不会进入的。</span><br><span class="line">                if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                    // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                    //再看这里的do...while循环，退出的条件是找到一条不为空的异步消息。</span><br><span class="line">                    //msg.isAsynchronous():异步消息返回true，取反之后就是false，更前面&amp;&amp;，就是false，就退出do..while循环了</span><br><span class="line">                    do &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                //消息不为空</span><br><span class="line">                if (msg != null) &#123;</span><br><span class="line">                    //当前时间小于消息需要执行的时间，说明是延时消息。</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                        //修改这个下次循环的时间，前面说的native调用的时间，就是根据这个变量判断的。</span><br><span class="line">                        //时间就是消息执行的时间-系统开机时间=延时时间</span><br><span class="line">                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //否则就是一条实时消息，就是正常的赋值流程，返回这条消息给looper，然后发送出去</span><br><span class="line">                        // Got a message.</span><br><span class="line">                        mBlocked = false;</span><br><span class="line">                        if (prevMsg != null) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = null;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        return msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //消息是空，就表示没有更多消息了</span><br><span class="line">                    nextPollTimeoutMillis = -1;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>流程就是：</p>
<ol>
<li>先判断looper有没有，系统有没有重启，如果重启了，looper没有，那就直接返回一个null对象，Looper接收到了一个null对象，会直接return</li>
<li>然后，判断是不是屏障消息(屏障消息消息的target等于null)，如果是屏障消息，就进行do..while循环，直到取出一条异步消息为止</li>
<li>正常的判断消息，是同步消息还是延时消息，同步消息立刻返回，延时消息，提醒底层多长时间之后再调用我</li>
</ol>
<p>&emsp;&emsp;看到了吗？MessageQueue取消息的流程，通过msg的执行时间与当前系统的开机时间进行比较，延时消息就是判断了延时多长时间之后，告诉底层多长时间之后，你还要调用一次这个取消息的方法。这就是延时消息的实现。</p>
<p><span id="c9"></span></p>
<h3 id="如何提高消息的优先级？同步消息，屏障消息，异步消息"><a href="#如何提高消息的优先级？同步消息，屏障消息，异步消息" class="headerlink" title="如何提高消息的优先级？同步消息，屏障消息，异步消息"></a>如何提高消息的优先级？同步消息，屏障消息，异步消息</h3><p>既然说到这里，我们就直接聊一下这个消息的优先级</p>
<p>ps：这里的异步消息，同步消息，并不是说多线程去处理消息。异步消息是有一个属性是true</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//同步消息</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">//异步消息，调用了一个setAsynchronous并且设置为true</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.setAsynchronous(true);</span><br></pre></td></tr></table></figure></div>
<p>我们平时发消息是下面这个样子的：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Message msg1 = Message.obtain(handler,new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Log.v(&quot;hcy&quot;,&quot;这是一条延时3秒的消息&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">handler.sendMessageDelayed(msg1,3*1000);</span><br><span class="line"></span><br><span class="line">Message msg = Message.obtain(handler, new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Log.v(&quot;hcy&quot;,&quot;这是一条延时5秒的异步消息&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">handler.sendMessageDelayed(msg,5*1000);</span><br><span class="line">Log.v(&quot;hcy&quot;,&quot;两条消息都发送完了&quot;);</span><br></pre></td></tr></table></figure></div>
<p>上面就是new了两条消息，一条同步消息，一条异步消息，如果没有屏障消息的情况下，同步消息和异步消息是一样的，没啥区别。程序运行完，过三秒钟同步消息回调，再过两秒打印异步消息回调，上面消息的打印结果如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021-11-21 08:53:10.363 29452-29452/com.haichenyi.myapplication V/hcy: 两条消息都发送完了</span><br><span class="line">2021-11-21 08:53:13.366 29452-29452/com.haichenyi.myapplication V/hcy: 这是一条延时3秒的消息</span><br><span class="line">2021-11-21 08:53:15.365 29452-29452/com.haichenyi.myapplication V/hcy: 这是一条延时5秒的异步消息</span><br></pre></td></tr></table></figure></div>
<p>那么，什么是屏障消息呢？怎么实现呢？我们先说怎么实现的。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Message msg1 = Message.obtain(handler,new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;这是一条延时3秒的消息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">handler.sendMessageDelayed(msg1,3*1000);</span><br><span class="line"></span><br><span class="line">Message msg = Message.obtain(handler, new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;这是一条延时5秒的异步消息&quot;);</span><br><span class="line">        //异步消息处理完移除消息屏障</span><br><span class="line">        try &#123;</span><br><span class="line">            Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">            Method removeSyncBarrier = msgQueue.getDeclaredMethod(&quot;removeSyncBarrier&quot;, int.class);</span><br><span class="line">            removeSyncBarrier.invoke(Looper.myQueue(),token);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">    msg.setAsynchronous(true);</span><br><span class="line">&#125;</span><br><span class="line">handler.sendMessageDelayed(msg,5*1000);</span><br><span class="line">try &#123;</span><br><span class="line">    //启动消息屏障</span><br><span class="line">    Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">    Method postSyncBarrier = msgQueue.getDeclaredMethod(&quot;postSyncBarrier&quot;);</span><br><span class="line">    token = (int) postSyncBarrier.invoke(Looper.myQueue());</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">Log.v(&quot;hcy&quot;,&quot;两条消息都发送完了&quot;);</span><br></pre></td></tr></table></figure></div>
<p>打印结果如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021-11-21 09:05:36.915 29743-29743/com.haichenyi.myapplication V/hcy: 两条消息都发送完了</span><br><span class="line">2021-11-21 09:05:41.922 29743-29743/com.haichenyi.myapplication V/hcy: 这是一条延时5秒的异步消息</span><br><span class="line">2021-11-21 09:05:41.949 29743-29743/com.haichenyi.myapplication V/hcy: 这是一条延时3秒的消息</span><br></pre></td></tr></table></figure></div>
<p>&emsp;&emsp;代码执行完之后，先是过了5秒回调了异步消息，然后立刻回调了同步消息，为什么呢？因为，同步消息是延时3秒执行呀，异步消息是延时5秒执行，因为加了消息屏障，会把异步消息的优先级提到同步消息的前面，所以，执行完异步消息，同步消息的执行时间早就过了，肯定要立刻执行呀。</p>
<p>说了这么多，那么，这个提升优先级是怎么实现的呢？透过现象去看本质。两段代码的区别，就是通过反射，执行了两个方法<strong>postSyncBarrier</strong>,<strong>removeSyncBarrier</strong>。其中还有一个带参数的方法。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//执行消息屏障</span><br><span class="line">try &#123;</span><br><span class="line">    Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">    Method postSyncBarrier = msgQueue.getDeclaredMethod(&quot;postSyncBarrier&quot;);</span><br><span class="line">    token = (int) postSyncBarrier.invoke(Looper.myQueue());</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除消息屏障</span><br><span class="line">try &#123;</span><br><span class="line">    Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">    Method removeSyncBarrier = msgQueue.getDeclaredMethod(&quot;removeSyncBarrier&quot;, int.class);</span><br><span class="line">    removeSyncBarrier.invoke(Looper.myQueue(),token);</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们先来看看这个消息屏障的方法：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">@TestApi</span><br><span class="line">//我们反射调用的是这个方法，它最终执行的是一个同样名字的带参的重载方法</span><br><span class="line">public int postSyncBarrier() &#123;</span><br><span class="line">    return postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最终执行到这里</span><br><span class="line">private int postSyncBarrier(long when) &#123;</span><br><span class="line">//以来还是老规矩，加锁，防止多线程调用</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        //token比较重要，是移除屏障的标记</span><br><span class="line">        final int token = mNextBarrierToken++;</span><br><span class="line">        //常规的msg的创建，msg执行的时间是系统的开机时间</span><br><span class="line">        final Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        //把这个token值赋值给了msg的arg1变量</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line">        //说白了，下面就是链表操作了，不停的移动指针</span><br><span class="line">        //prev：上一条消息变量</span><br><span class="line">        Message prev = null;</span><br><span class="line">        //p：消息。</span><br><span class="line">        //mMessages：这个变量眼熟不？我们前面消息从队列中取的时候就是那个next()方法，</span><br><span class="line">        //在进入for循环里面，判断是否是屏障消息之前，是不是也同样是给一个成员变量赋值，赋值的值也是mMessages。</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        //执行时间不等于0，前面取的时候那三个条件，有一个时间等于0，就插进消息队首，这里我觉得也可以这样理解</span><br><span class="line">        if (when != 0) &#123;</span><br><span class="line">            //这里是一个while循环，字面理解就是当前消息不等于null，当前消息的执行时间，小于屏障消息的执行时间，就继续循环。直到这两个条件不满足为止</span><br><span class="line">            //结合上下文的意思就是，我执行这个屏障消息的时候，如果发现队列里面还有消息的执行时间在我这个屏障消息的前面，就继续让它先执行。</span><br><span class="line">            while (p != null &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                //把当前消息赋值给变量prev</span><br><span class="line">                prev = p;</span><br><span class="line">                //把当前消息的下一条消息，赋值给p变量(当前消息变量)</span><br><span class="line">                p = p.next;</span><br><span class="line">                //继续while循环</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //经过上面的while循环之后，就找准了屏障消息该插入的为止了</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">        //如果prev不等于null，表示，消息队列里面还有需要在屏障消息前面执行的消息</span><br><span class="line">        //队列就变成了：prev-屏障消息-当前消息</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果prev等于null，就表示消息队列里面没有需要在屏障消息执行前面执行的消息了</span><br><span class="line">            //队列也就变成了：屏障消息-当前消息</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回这个token值。移除屏障消息的时候需要用到</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面这个执行消息屏障说的很清楚了吧？多看注释，多理解。</p>
<p>我们再来看看这个移除消息屏障</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">@TestApi</span><br><span class="line">public void removeSyncBarrier(int token) &#123;</span><br><span class="line">    //加锁</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        //两个变量赋值</span><br><span class="line">        Message prev = null;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        //这个while循环，第一个条件：当前消息不等于null(当前消息队列还有消息)</span><br><span class="line">        //第二个条件：当前消息得目的地不为空(我们屏障消息这里是等于空的，这里应该是为了判断其他地方调用这个方法)</span><br><span class="line">        //然后就是第三个条件，我们传进来的token值，就是上面执行屏障消息时候的返回值，当时赋值给了arg1。这里比较，如果相同，那么，这条消息就是屏障消息</span><br><span class="line">        //第二个条件和第三个条件是或的关系，满足一条就行。</span><br><span class="line">        //屏障消息就要移除，链表的常规移除操作</span><br><span class="line">        while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            //其实就是：原来是：上一条消息——屏障消息——下一条消息</span><br><span class="line">            //变成了：上一条消息——下一条消息</span><br><span class="line">        &#125;</span><br><span class="line">        //到这里就移除完了</span><br><span class="line">        //上面while循环完，发现当前消息是空，说明消息队列中没有消息了，直接抛异常</span><br><span class="line">        if (p == null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The specified message queue synchronization &quot;</span><br><span class="line">                        + &quot; barrier token has not been posted or has already been removed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        final boolean needWake;</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == null || mMessages.target != null;</span><br><span class="line">        &#125;</span><br><span class="line">        //消息回收</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        // If the loop is quitting then it is already awake.</span><br><span class="line">        // We can assume mPtr != 0 when mQuitting is false.</span><br><span class="line">        //native层的是否需要唤醒服务</span><br><span class="line">        if (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>总结一下这个提升消息优先级的方式就是：把你想发送的消息定义view异步消息发送，光这样还不行，还要发送一条屏障消息，具体流程：</p>
<ol>
<li>往消息队列里面插入一条target为null的消息</li>
<li>MessageQueue.next()方法读取的时候，会先判断这条消息是不是屏障消息，如果是，他就会执行do..while循环，直到找到一条异步消息为止。</li>
<li>MessageQueue拿到消息之后，正常的取消息流程</li>
<li>在你执行完这条异步消息之后，记得要移除屏障消息，不然所有的异步消息都在同步消息前面执行。</li>
</ol>
<p>其实有个更简单的方法，handler发消息的api都给出来了</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//发送消息到队列前面</span><br><span class="line">handler.sendMessageAtFrontOfQueue(msg1);</span><br></pre></td></tr></table></figure></div>
<p>经过上面的整个流程之后，最后一个问题就比较简单了，自己看一下源码吧，我给出结论:</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepare():给当前线程创建Looper，MessageQueue的过程，这个MessageQueue是可退出的</span><br><span class="line"></span><br><span class="line">Looper.loop():从头到尾都在说loop()，循环读取消息。</span><br></pre></td></tr></table></figure></div>
<p><span id="c10"></span></p>
<h3 id="handler知识点总结"><a href="#handler知识点总结" class="headerlink" title="handler知识点总结"></a>handler知识点总结</h3><p>总结一下handler的东西：整理了一个流程图：</p>
<p><img src="/uploads/article/2021-11-21/handler知识点.png" alt="handler知识点.png"></p>

      
    </div>
    
      <footer class="article-footer">
        完
      </footer>
    
  </div>
  
    
<nav id="article-nav">
  <div class="article-nav-block">
    
      <a href="/2021/11/28/Android-MVVM之ViewModel/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption"></strong>
        <div class="article-nav-title">
          
            Android--MVVM之ViewModel
          
        </div>
      </a>
    
  </div>
  <div class="article-nav-block">
    
      <a href="/2021/11/20/Android——触摸事件传递机制/" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title">Android——触摸事件传递机制</div>
        <strong class="article-nav-caption"></strong>
      </a>
    
  </div>
</nav>

    
  
  
</article>
</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box avatar-item">
    <img class="avatar" src="/uploads/artistic_image/head.jpg" title="头像来自网络"></img>
    <h3 class="avatar-name">
      
        海晨忆
      
    </h3>
    <p class="avatar-slogan">
      先谋生，再谋爱。人间值得，未来可期。
    </p>
  </div>
</div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-Socket/">Android -Socket</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-加密算法/">Android -加密算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-常用功能/">Android -常用功能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-框架/">Android -框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-源码解析/">Android -源码解析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-自定义view/">Android -自定义view</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-设计模式/">Android -设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-基础/">JAVA -基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA-并发/">JAVA -并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-SpringBoot/">Java -SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin/">kotlin</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库-JDBC/">数据库 -JDBC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库-MySQL/">数据库 -MySQL</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-box">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/28/Android-MVVM之ViewModel/">Android--MVVM之ViewModel</a>
          </li>
        
          <li>
            <a href="/2021/11/21/Android-深入理解handler机制/">Android--深入理解handler机制</a>
          </li>
        
          <li>
            <a href="/2021/11/20/Android——触摸事件传递机制/">Android——触摸事件传递机制</a>
          </li>
        
          <li>
            <a href="/2021/08/09/JAVA-TCP，UDP/">JAVA-TCP，UDP</a>
          </li>
        
          <li>
            <a href="/2021/07/27/JAVA—公平锁，非公平锁，悲观锁，乐观锁，死锁/">JAVA—公平锁，非公平锁，悲观锁，乐观锁，死锁</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      
        <a class="hrf" style="display: block;" href="https://github.com/haichenyi" title target='_blank'
        >Github</a>
      
        <a class="hrf" style="display: block;" href="https://www.jianshu.com/u/6077ee440c37" title target='_blank'
        >简书</a>
      
        <a class="hrf" style="display: block;" href="https://blog.csdn.net/qq_27634797" title target='_blank'
        >CSDN</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box footers global-width">
    &copy;2017-2021 海晨忆 &nbsp;&nbsp;
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">简历</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>