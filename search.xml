<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android自定义View]]></title>
    <url>%2F2018%2F02%2F08%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVP+Dagger+RxJava+Retrofit+OkHttp的简单框架]]></title>
    <url>%2F2018%2F02%2F08%2FMVP-Dagger-RxJava-Retrofit-OkHttp%E7%9A%84%E7%AE%80%E5%8D%95%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Netty的简单使用，实现socket通讯]]></title>
    <url>%2F2018%2F02%2F08%2FNetty%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[自从用了netty框架，妈妈再也不用担心我的socket通讯了&emsp;&emsp;题外话，很多人都把JDK1.4提供的NIO称之为异步非阻塞I/O；其实，并不然，从严格意义上面讲，它只能称为非阻塞I/O。在JDK1.7提供的NIO 2.0，新增了异步的套接字通道Channel，它才是真正的异步非阻塞I/O。下表是不同I/O模型的对比： 表1-1 几种I/O模型和同能对比 同步阻塞I/O(BIO) 伪异步I/O 非阻塞I/O(NIO) 异步I/O(AIO) 客户端个数：I/O线程 1:1 M:N(M可以大于N) M:1(1个I/O线程处理多个客户端连接) M:0(不需要启动额外的I/O线程，被动回调) I/O类型(阻塞) 阻塞I/O 阻塞I/O 非阻塞I/O 非阻塞I/O I/O类型(同步) 同步I/O 同步I/O 同步I/O(I/O多路复用) 异步I/O API使用难度 简单 简单 非常复杂 复杂 调试难度 简单 简单 复杂 复杂 可靠性 非常差 差 高 高 吞吐量 低 中 高 高 简介&emsp;&emsp;Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 &emsp;&emsp;也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。 &emsp;&emsp;“快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。——百度百科 优点 API使用简单，开发门槛低 功能强大，预置了多种编解码功能，支持多种主流协议 性能高，通过与业界其他主流NIO框架相比，netty的综合性能最高 成熟，稳定，Netty已经修复了已经发现的所有的JDK NIO BUG，业务开发人员不用再为NIO的bug而烦恼 社区活跃，版本迭代周期短，发现bug可以及时被修复，同时有更多的新功能加入 经历了大规模的商界业务考验，只能得到了验证 粘包、拆包概念&emsp;&emsp;TCP是一个流协议，所谓的流，就是没有界限的一串数据。可以考虑河里的流水，他们并没有界限。tcp底层并不了解业务层数据的具体含义，他会根据tcp缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被tcp拆分成多个包进行发送，也可能把多个小包封装成一个大数据一起发送，这就是所谓的tcp粘包，拆包问题 产生原因 应用程序write写入的字节大小大于套接口发送缓冲区的大小 进行MSS大小的tcp分段 以太网帧的payload大于MTU进行IP分片 解决办法 消息定长，每个报文大小固定长度，不够的补0 包尾增加回车换行符进行分割。例如：FTP协议 将消息分为消息头和消息体。消息头中包含消息的总长度字段 更复杂的应用层协议 Netty框架的解决办法&emsp;&emsp;LineBasedFrameDecoder和StringDecoder两个类 LineBasedFrameDecoder&emsp;&emsp;LineBasedFrameDecoder的工作原理是依次遍历ByteBuf中的可读字节，判断看是否有”\r”或者”\r\n”，如果有就以此为结束位置，从可读索引位置到结束区间的字节就组成了一行。他是以换行符为结束标志的解码器，支持携带结束符和不带结束符两种解码方式。同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读取的异常流 StringDecoder&emsp;&emsp;StringDecoder的功能就非常简单，就是将接收到的对象换成字符串，然后继续调用后面的handler，LineBasedFrameDecoder+StringDecoder组合就是按换行符切换文本解码器，他被设计用来支持TCP粘包和拆包。Netty支持其他其他符号的解码器(DelimiterBasedFrameDecode) &emsp;&emsp;说了这么多，代码来了，就是用Netty实现的心跳。对于懒癌晚期，已经风装好，可以直接拿过去用，注释也写的很清楚 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import android.util.Log;import io.netty.bootstrap.Bootstrap;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import io.netty.util.CharsetUtil;/** * @author 海晨忆 * @date 2018/2/6 * @desc */public class SocketTcp &#123; private static SocketTcp socketTcp = new SocketTcp(); private Channel channel = null; private EventLoopGroup group; private int port; private String host; public static SocketTcp getInstance() &#123; return socketTcp; &#125; public SocketTcp setPort(int port) &#123; this.port = port; return this; &#125; public SocketTcp setHost(String host) &#123; this.host = host; return this; &#125; public void connect() &#123; if (channel != null) return; if (group == null) &#123; //NIO线程组 group = new NioEventLoopGroup(); &#125; try &#123;//配置Bootstrap Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; //以换行符为结束标记 ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); pipeline.addLast(new LineBasedFrameDecoder(Integer.MAX_VALUE)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket()); //以&quot;$_&quot;作为分隔符 /*ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); String s = &quot;$_&quot;; ByteBuf byteBuf = Unpooled.copiedBuffer(s.getBytes()); pipeline.addLast(new DelimiterBasedFrameDecoder(Integer.MAX_VALUE,byteBuf)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket());*/ &#125; &#125;); //发起异步连接操作 ChannelFuture channelFuture = bootstrap.connect(host, port).sync(); channel = channelFuture.channel(); //等待服务端监听端口关闭 channel.closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; disConnect(); &#125; &#125; /** * 断开tcp连接. */ private void disConnect() &#123; if (null != group) &#123; group.shutdownGracefully(); &#125; group = null; channel = null; &#125; public void sendMessage(String msg) &#123;//连接成功后，通过Channel提供的接口进行IO操作 try &#123; if (channel != null &amp;&amp; channel.isOpen()) &#123; channel.writeAndFlush(msg).sync(); Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg); &#125; else &#123; reConnect(); throw new Exception(&quot;channel is null | closed&quot;); &#125; &#125; catch (Exception e) &#123; reConnect(); e.printStackTrace(); &#125; &#125; /** * 重连. */ private void reConnect() &#123; new Thread(this::connect); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.example.zwang.myapplication.socket;import android.os.SystemClock;import android.util.Log;import java.util.concurrent.TimeUnit;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.EventLoop;import io.netty.channel.SimpleChannelInboundHandler;public class MyHeartSocket extends SimpleChannelInboundHandler&lt;Object&gt; &#123; private ChannelHandlerContext ctx; private boolean isConnect = false; @Override protected void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception &#123; Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;); ByteBuf msg1 = (ByteBuf) msg; byte[] bytes = new byte[msg1.readableBytes()]; msg1.readBytes(bytes); String s = new String(bytes, &quot;UTF-8&quot;); Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;); isConnect = true; if (this.ctx == null) &#123; synchronized (MyHeartSocket.class) &#123; if (this.ctx == null) &#123; this.ctx = ctx; MyAppHeart(); &#125; &#125; &#125; &#125; private void MyAppHeart() &#123; new Thread(() -&gt; &#123; while (ctx != null &amp;&amp; isConnect) &#123; String data = &quot;123&quot;; byte[] bytes = data.getBytes(); if (isConnect) &#123; ctx.writeAndFlush(Unpooled.buffer(bytes.length).writeBytes(bytes)); SystemClock.sleep(3000); &#125; &#125; &#125;).start(); &#125; @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; EventLoop loop = ctx.channel().eventLoop(); loop.schedule(() -&gt; SocketTcp.getInstance().connect(), 5, TimeUnit.SECONDS); super.channelInactive(ctx); Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;); isConnect = false; &#125; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; super.userEventTriggered(ctx, evt); Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.exceptionCaught(ctx, cause); Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;); this.ctx.close(); this.ctx = null; &#125;&#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO编程和NIO编程简介]]></title>
    <url>%2F2018%2F02%2F07%2FIO%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;传统的同步阻塞I/O通讯模型，导致的结果就是只要有一方处理数据缓慢，都会影响另外一方的处理性能。按照故障设计原则，一方的处理出现问题，不应该影响到另外一方才对。但是，在同步阻塞的模式下面，这样的情况是无法避免的，很难通过业务层去解决。既然同步无法避免，为了避免就产生了异步。Netty框架就一个完全异步非阻塞的I/O通讯方式 同步阻塞式I/O编程&emsp;&emsp;简单的来说，传统同步阻塞的I/O通讯模式，服务器端处理的方式是，每当有一个新用户接入的时候，就new一个新的线程，一个线程只能处理一个客户端的连接，在高性能方面，并发高的情景下无法满足。伪代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; public void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); while (true) &#123; socket = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; new TimerServerHandler(socket).run(); &#125; &#125;).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //释放资源 if (server != null) &#123; try &#123; server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; server = null; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimerServerHandler implements Runnable &#123; private Socket socket; public TimerServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; BufferedReader in = null; PrintWriter out = null; try &#123; in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); out = new PrintWriter(this.socket.getOutputStream(), true); String currentTime = null; String body = null; while (true) &#123; body = in.readLine(); if (body == null) break; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); //释放in，out，socket资源 &#125; &#125;&#125; &emsp;&emsp;上面这个就是最原始的服务端IO的代码，这里我就给出的是最简化的，当有新的客户端接入的时候，服务端是怎么处理线程的，可以看出，每当有新的客户端接入的时候，总是回新创建一个线程去服务这个新的客户端 伪异步式编程&emsp;&emsp;后来慢慢演化出一个版本“伪异步”模型，新增加一个线程池或者消息队列，满足一个线程或者多个线程满足N个客户端，通过线程池可以灵活的调用线程资源。通过设置线程池的最大值，防止海量并发接入造成的线程耗尽，它的底层实现依然是同步阻塞模型，伪代码如下：1234567891011121314151617181920212223242526272829303132333435import com.example.zwang.mysocket.server.TimerServerHandler;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; private void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); TimeServerHandlerExecutePool executePool = new TimeServerHandlerExecutePool(50, 1000); while (true) &#123; socket = server.accept(); executePool.execute(new TimerServerHandler(socket)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //释放资源 &#125; &#125;&#125; 12345678910111213141516171819202122import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimeServerHandlerExecutePool &#123; private ExecutorService executor; public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123; executor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize, 120L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize)); &#125; public void execute(Runnable task) &#123; executor.execute(task); &#125;&#125; &emsp;&emsp;“伪异步”的代码和传统同步的唯一区别就是在于，首先先创建了一个时间服务处理类的线程池，当有新的客户端接入的时候，先将socket请求封装成task，然后调用线程池的execute方法执行，从而避免了每一个新请求创建一个新线程。由于线程池和消息队列都是有限的，因此，无论客户端的并发量多大，它都不会导致线程个数过于大，而造成的内存溢出。相对于传统的同步阻塞，是一种改良。 &emsp;&emsp;但是他没有从更本上解决同步的问题，伪异步的问题在于，他还是有一方处理出现问题还是会影响到另一方。因为： &emsp;&emsp;当对socket的输入流进行读取操作的时候，它会一直阻塞直到一下三种方式发生： 有数据可读 可读数据已经读取完 发生空指针或者I/O异常。 这意味者，当读取inputstream方处理速度缓慢(不管是什么原因造成的速度缓慢)，另一方会一直同步阻塞，直到这一方把数据处理完. &emsp;&emsp;当调用outputstream的write方法写输出流的时候，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。学过TCP/IP相关知识的人都直到，当消息的接收方处理消息缓慢，不能及时的从TCP缓冲区读取数据，这将会导致发送方的TCP缓冲区的size一直减少，直到0.缓冲区为0，那么发消息的一方将无法将消息写入缓冲区，直到缓冲区的size大于0 &emsp;&emsp;通过以上。我们了解到读和写的操作都是同步阻塞的，阻塞的时间取决于对方的I/O线程的处理速度和网络I/O的传送速度。从本质上面看，我们无法保证对方的处理速度和网络传送速度。如果，我们的程序依靠与对方的处理速度，那么，他的可靠性将会非常差。 NIO编程&emsp;&emsp;官方叫法new I/O，也就是新的IO编程，更多的人喜欢称它为：Non-block IO即非阻塞IO。 &emsp;&emsp;与Socket和serverSocket类对应，NIO提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现，这两种都支持阻塞式编程和非阻塞式编程。开发人员可以根据自己的需求选择合适的编程模式。一般低负载，低并发的应用程序选择同步阻塞的方式以降低编程的复杂度。高负载，高并发的不用想了，非阻塞就是为了解决这个问题的 缓冲区Buffer &emsp;&emsp;Buffer是一个对象，它包含一些写入或者读出的数据。再NIO中加入buffer对象，体现了新库和旧库的一个重要区别。在面向流的io中，可以直接把数据读取或者写入到stream对象中。在NIO库中，所有数据操作都是通过缓冲区处理的。 &emsp;&emsp;缓冲区实质上是一个数组，通常是一个字节数组（ByteBuffer），基本数据类型除了boolean没有，其他都有，如ShortBuffer,CharBuffer等等 通道Channel &emsp;&emsp;Channel是一个通道，双向通道，网络数据都是通过Channel读取，写入的。是的，没错，Channel它既可以进行读操作，也可以进行写操作。而流只能是一个方向。只能读操作或者只能写操作，而channel是全双工，读写可以同时进行。channel可以分为两大类：网络读写的SelectableChannel和文件操作的FileChannel。我们前面提到的SocketChannel和ServerSocketChannel都是SelectableChannel的子类。 多路复用器Selector &emsp;&emsp;selector多路复用器，他是java NIO编程的基础，熟练的掌握selector对于NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单的讲就是他会不断的轮询注册的channel，如果一个Channel发生了读写操作，这个Chnnel就会处于就绪状态，会被selector轮询出来，通过SelectorKey获取就绪Channel集合，进行后续的IO操作。一个selector对应多个Channel &emsp;&emsp;由于原生NIO编码比较麻烦和复杂，我这里就给出了思路的伪代码。下一篇我们将用NIO中的Netty框架实现Socket通信，编码简单，一行代码解决烦人粘包、拆包问题。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 服务端nio过程的伪代码 * * @param port 端口号 * @throws IOException IOException */ private void init(int port) throws IOException &#123; //第一步：打开ServerSocketChannel，用于监听客户端连接，它是所有客户端连接的父管道 ServerSocketChannel socketChannel = ServerSocketChannel.open(); //第二步：监听绑定端口，设置连接模式为非阻塞模式， socketChannel.socket().bind(new InetSocketAddress(InetAddress.getByName(&quot;IP&quot;), port)); socketChannel.configureBlocking(false); //第三步：创建Reactor线程，创建多路复用器，并启动线程。 Selector selector = Selector.open(); new Thread().start(); //第四步：将ServerSocketChannel注册到Reactor线程的多路复用器上，监听accept事件 SelectionKey key = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第五步：多路复用器在线程run方法的无线循环体内轮询准备就绪的key int num = selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator(); while (it.hasNext()) &#123; SelectionKey next = it.next(); //deal with io event... &#125; //第六步：多路复用器检测到有新客户端接入，处理新的接入请求，完成TCP三次握手，建立物理链路 SocketChannel channel = socketChannel.accept(); //第七步：设置客户端为非阻塞模式 channel.configureBlocking(false); channel.socket().setReuseAddress(true); //第八步：将新接入的客户端注册到reactor线程的多路复用器上，监听读操作，读取客户端发送的消息 SelectionKey key1 = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第九步：异步读取客户端消息到缓冲区， /*int readNumber = channel.read(&quot;receivebuff&quot;);*/ //第十步：对byteBuffer进行编解码，如果有半包信息指针reset，继续读取到后续的报文，将解码成功消息封装成task，投递到业务线程池，进行业务逻辑编排 Object massage = null; while (buff.hasRemain()) &#123; buff.mark(); Object massage1 = decode(btyeBuffer); if (massage1 == null) &#123; byteBuffer.reset(); break; &#125; massageList.add(massage1); &#125; if (!byteBuffer.hasRemain()) &#123; byteBuffer.clean(); &#125; else &#123; byteBuffer.compact(); &#125; if (massageList != null &amp;&amp; !massageList.isEmpty()) &#123; for (Object massage3 : massageList)&#123; handlerTask(massage3); &#125; &#125; //第十一步：将POJO对象encode成ByteBuff，调用SocketChannel的异步write接口，将异步消息发送到客户端 socketChannel.write(buffer); &#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
</search>
