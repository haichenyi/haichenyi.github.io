<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA-TCP，UDP]]></title>
    <url>%2F2021%2F08%2F09%2FJAVA-TCP%EF%BC%8CUDP%2F</url>
    <content type="text"><![CDATA[1. 目录 1–目录 2–概念 3–优缺点 4–三次握手 5–四次握手 6–通信流程 2. 概念&emsp;&emsp;首先，需要确定的就是他们是socket通信的两种协议。 &emsp;&emsp;TCP:一种面向连接，全双工可靠信道的传输层协议 &emsp;&emsp;UDP:一种无连接的，不可靠的传输层协议 3. 优缺点 类型 安全 有序 速度 对象个数 开销 方式 TCP 安全 有序 慢 1:1 大 面向字节流 UDP 不安全 无序 快 1:1，1:N，N:N，N:1 小 面向报文 是否安全：TCP是采用的全双工可靠信道，很安全。UDP采用得是不可靠得传输协议 是否有序：TCP：有序，一个传完下一个才能继续。UDP：无序，只管发送，不管有没有接收到 传输速度：TCP：慢。必须上一个传完，下一个才能传。UDP：快，它可以一直发，不管你有没有接收到 面向对象：TCP：面向连接1:1。UDP：无连接，1:N。一个很老得比喻，也很形象。你把TCP理解成个人视频，把UDP理解成群视频。 开销：TCP：开销大，首部20个字节。UDP开销小：首部8个字节 4. 三次握手&emsp;&emsp;我们都知道TCP是全双工可靠信道。什么是信道？感觉打字不如贴图，如图： &emsp;&emsp;然后，我们来看看这个TCP的通信图 已知：两个对象A和B，两个信道：信道1和信道2。 第一次握手：A从信道1中给B发消息：我要跟你连接了。（说明：A可以从信道1发消息） 第二次握手：B从信道2中给A回消息：好的，我同意了。（说明：B可以从信道2发消息，B可以从信道1收消息） 第三次握手：A从信道1中给B回消息：那我们开始连接吧（A可以从信道2收消息）。B收到之后就建立了连接。 为什么必须要三次握手，2次不行吗？ &emsp;&emsp;全双工信道只能单方向发消息。如果是2次握手：表示A可以从信道1发消息。B可以从信道1收消息，信道2发消息。但是，B并不知道A能不能从信道2收到消息。所以，2次没法建立建立。 5. 四次挥手第一次挥手：A从信道1给B发消息：我的事情都处理完了，我要跟你断开连接了。 第二次挥手：B从信道1收到消息后，从信道2给A回一个消息：我知道了。然后，B继续处理未处理完的事情。 第三次挥手：B的事情处理完之后，B从信道2给A发消息：我的事情都处理完了，我要跟你断开连接了。 第四次挥手：A从信道2收到B发来的断开连接的消息之后。A从信道1给B回复：好的，我知道了，我们都断开吧。然后，A断开1，2信道。B从信道1收到了A的确认消息之后。B也断开1，2信道。 5. 通信流程 先获取Socket套接字对象，绑定端口号，新开线程连接服务器。 然后通过套接字获取它的输入流和输入流。 新开两个线程，监听outputstream，和inputstream。输入流负责读从服务器返回的数据，输出流负责本地向服务器发送数据。 这个时候就需要注意拆包，粘包的问题，返回数据需要统一格式，读数据的时候可以根据这个格式来区分是否是一条完整的数据。 再就是需要监听网络状态的变化，若切换网络导致连接中断，这个时候就需要捕获异常，释放资源，再重新连接。 &emsp;&emsp;一般如果没有限制必须要用原生的写，我一般都是用Netty，之前也写过一篇Netty用法的文章：Netty的简单使用，实现socket通讯 &emsp;&emsp;解决粘包，拆包:约定好每一条消息的规则。怎么约定呢？ 举个栗子： 定长。每条消息都是固定长度，不够补0。每次只读取一个固定长度的信息，这样自然就把每条消息分开了。 设置特定的结束符。双方约定好，每条消息的结尾跟一个特殊的符号，表示这条消息结束。这样也能把每条消息分开 每条消息的头部，定义好这条消息的长度。每次解析的时候，先解析这个长度，再开始解析数据。]]></content>
      <categories>
        <category>JAVA -基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA—公平锁，非公平锁，悲观锁，乐观锁，死锁]]></title>
    <url>%2F2021%2F07%2F27%2FJAVA%E2%80%94%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;这几个锁都可以从前面一篇线程同步器AQS里面找到影子,我先把前面一篇的加锁流程图拿过来用一用。 &emsp;&emsp;上面这个流程图是上一篇最开始讲的时候的一张流程图，后面写的时候，后面的流程图都没有画。这一片我们来画一下后面的流程图。 公平锁，非公平锁&emsp;&emsp;前面一篇讲的时候，我说过了，我们当时做的是一个公平锁。这个公平锁和非公平锁的主要区别就是在这个队列。 &emsp;&emsp;我们前文讲过了，线程1拿到了锁，线程2，3，4就全部放进队列中等待，那么，流程图如下： &emsp;&emsp;如上图，我们理想状态是：线程1释放锁的时候，队列中的第一个元素，也就是线程2拿到锁，然后，开始执行。 &emsp;&emsp;但是，往往不如意，谁规定的一共就只有4个线程呢？如果，我们正当1释放锁的同时，又有一个线程5进来了，我们要怎么操作呢？流程图如下： &emsp;&emsp;公平锁和非公平锁的区别就在这里： 公平锁会把线程5放进队列中，放到线程4的后面，线程2获取到锁，然后执行自己的任务 非公平锁则是，线程1释放锁之后，状态变成了0，线程5去竞争锁，获取到锁之后，状态state又变成了1，线程2被唤醒之后，正准备去获取锁的时候，一看，状态state是1，又进入等待状态。 &emsp;&emsp;所以，公平锁就是释放锁之后，谁等待得时间长，谁先执行。非公平锁则是，释放锁之后，谁先获取到锁，谁先执行。可能后进的执行，也可能先进的先执行。 &emsp;&emsp;ReentrantLock，初始化的时候传true就是公平锁，传false就是非公平锁，默认是非公平锁。下面就是ReentrantLock的构造方法。 1234567891011121314151617/** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */public ReentrantLock() &#123; sync = new NonfairSync();&#125;/** * Creates an instance of &#123;@code ReentrantLock&#125; with the * given fairness policy. * * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy */public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 悲观锁锁，乐观锁&emsp;&emsp;悲观锁：操作之前加锁，操作完成之后解锁。我们前文讲的buy方法就是悲观锁，进入方法就加锁，方法执行完就解锁。还有我们常用的synchronized关键字，就是悲观锁的典型代表。 &emsp;&emsp;乐观锁：乐观锁是一种思想，比方说，我们前文提到的CAS机制，就是乐观锁的一种实现。当我们操作一个变量做加减操作的时候，我们多个线程可以同时做这个操作，但是到具体更新这个值的时候，去判断。典型代表就是Atomic原子类。这个原子类的实现也是CAS机制。 &emsp;&emsp;性能问题：多个线程同时执行，悲观锁，就只有一个线程操作，其他线程挂起等待，释放锁之后，再切换回来。乐观锁，所有的线程都一起执行，最后执行冲突检测和数据更新操作。没有挂起等待，上下文的切换，所以，乐观锁的性能肯定比悲观锁好。但是，实际上真的是这样吗？答案是否定的。乐观锁的性能不一定比悲观锁好。 &emsp;&emsp;前面，我们说到乐观锁是在最后更新得时候，去判断。那么怎么判断呢？早期1.5版本之前的CAS操作是有3个参数内存位置(V)、原值(A)、新值(B)。我们在更新的时候，先判断A是否满足，满足就更新成B上一篇文章已经说过了。不满足，那就再循环一边重复判断。极端情况下，要是线程足够的多，并且一直不满足，那是不是一直循环判断(CAS自旋)？那就一直占用CPU。这样性能肯定不好。 &emsp;&emsp;synchronized在JDK1.5之前的确性能很差，但是在1.6的时候就已经做了优化了，从无锁状态，到偏向锁状态，再到轻量级锁状态，最后到重量级锁状态。这几个状态会随着竞争情况逐渐升级（锁不但可以升级还可以降级）。现在synchronized的性能跟ReentrantLock差不多。 &emsp;&emsp;所以，悲观锁的性能不一定比乐观锁差，乐观锁的性能不一定比悲观锁好。根据实际情况去选择悲观锁和乐观锁。那到底怎么选择呢？ &emsp;&emsp;之前在网上看到过这么一组数据，启用多个线程进行计数相加到一亿，首先是synchronized方式 &emsp;&emsp;当线程数为8时，性能明显提升，但是8到32个线程来说，每个线程的平均时间基本差不多，基本没有提升，到了64个线程的时候，性能又有一点提升。 如果换成CAS实现多线程累加数为一亿，时间又会怎么样呢？ &emsp;&emsp;在线程数相对较少的时候，CAS实现比较快，性能优于synchronized,当线程数多于8后，CAS实现明显开始下降，反而时间消耗高于synchronized； &emsp;&emsp;总结：synchronized是java提供的又简单方便，性能优化又非常好的功能，建议大家常用；CAS的话，线程数大于一定数量的话，多个线程在循环调用CAS接口，虽然不会让其他线程阻塞，但是这个时候竞争激烈，会导致CPU到达100%，同时比较耗时间，所以性能就不如synchronized了。 死锁概念&emsp;&emsp;死锁是指：多个进程在运行过程中因争夺某一种资源，而造成的僵持状态，若无外力作用，他们都将无法向前推进。 举个栗子： 小明在看电视，小红在玩手机，小明对小红说：你把手机给我玩，我把点视给你看；小红却说：你把点视给我看，我再把手机给你玩。 分析： 电视，手机都可以看作一种资源。 小明在看电视，小红在玩手机：表示电视分配给小明了，小明对电视持有锁；手机分配给小红了，小红对手机持有锁 小明对小红说，你把手机给我玩，我把点视给你看：小明想获取到手机的锁之后，再释放自己电视的锁。 小红却说，你把点视给我看，我再把手机给你玩：小红想获取电视的锁之后，再释放自己手机的锁 &emsp;&emsp;所以，小明和小红都在等待对方释放锁，自己拿到想要的资源之后，释放自己资源的锁。这里谁都拿不到锁，就无线的等待下去。这就是死锁。 产生条件 互斥条件：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。(就是这里的电视只能给小明看，手机只能给小红玩) 占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。（小明等着小红释放手机资源，小红等着小明释放电视资源） 不剥夺条件：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来（小明在看电视的时候，小红不能说，我要看电视，你给我看。小红在玩手机的时候，小明不能说，我要玩手机，你把手机给我玩。我们要讲文明，不能耍流氓） 环路等待条件：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源（小明等着小红释放手机资源，小红等着小明释放电视资源） 解决办法&emsp;&emsp;如果产生死锁只能重启。所以，我们在开发过程中要尽量避免死锁，比方说：著名的银行家算法。只要上面四种中的任意一种不满足，就不可能造成死锁：比方说占有等待，我们可以用共享锁的方式AQS里面每个加锁的方法都有一个try开头的方法。可以看一下acquire和tryAcquire的区别。这就破坏了第二个条件，等待。]]></content>
      <categories>
        <category>JAVA -并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA—线程同步器AQS]]></title>
    <url>%2F2021%2F07%2F19%2FJAVA%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%99%A8AQS%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;每一项技术的提出都是为了解决某一个问题，带着问题来理解技术，使得印象你对这个技术的理解印象更加深刻。 并发&emsp;&emsp;举个栗子：现在有一个需求，网络请求分两批（A,B两个批次），A批次并行请求，B批次串行请求按顺序一个一个请求，有一个总超时时间，B批次每一次请求都有一个超时时间，A批次并发请求先请求，在规定时间内没有返回，再开始请求B批次，谁先返回用谁的。 &emsp;&emsp;这个是我们项目里面简化过后的一个逻辑，实际逻辑，比这个还要复杂。怎么实现这个功能呢？ &emsp;&emsp;带着这个问题来进入我们的正题，什么是并发？ 并发是一种现象：同时运行多个程序或者多个任务需要被处理的现象。 这些任务可能是并行的，也可能是串行的，和CPU的核心数无关，是操作系统进程调度和CPU上下文切换达到的结果。 解决并发的思路就是把分解，把一个大任务分解成多个小任务来执行 &emsp;&emsp;像我们上面所说的需求就是分解成一个一个的网络请求，一部分并行请求，一部分串行请求。并行请求简单来说，对应我们应用里面就是多线程，多线程同时执行；串行请求对应我们应用里面就是单线程，一个线程执行完了，另一个线程才开始。这里不考虑多进程的问题。 并发为什么会造成线程不安全的问题&emsp;&emsp;我们先来聊聊cpu是怎么执行指令： 首先，cpu执行指令的过程中，不可避免会执行读写操作，而这个操作都是从主存（也就是物理内存）中去读写 但是，cpu执行指令速度很快，程序运行过程中的临时变量都是放在主存当中的，如果全部都是从主存中去读写，读写很耗时，这样就浪费了cpu的性能 最后，为了解决这个问题，就出现了高速缓存的概念。我们先把变量读取到告诉缓存中，然后，再高速缓存中操作完之后，再刷新到主存当中。 &emsp;&emsp;java的内存模型规定，所有的变量都在主存当中，类似于物理内存，每个线程都有自己的工作空间，也就是对应上面的高速缓存，每一个线程都有一个自己的高速缓存。 &emsp;&emsp;线程对变量的操作必须在自己的工作空间内，不能直接操作主存，而且，一个线程也不能访问另一个线程的工作空间。 &emsp;&emsp;那么，我们如果多个线程同时对一个变量做加1操作，如下面的add1方法。我们thread1和thread2把a的值同时复制到自己的工作空间中时，都是0，然后同时进行加1操作，同时刷新到主存当中，那最后，我们获取到的最终的值就是1，而不是我们想要的2.这就是并发造成的线程不安全的问题 简单的同步器&emsp;&emsp;我们项目里面遇到的并发问题，基本上就是多线程访问同一变量的问题，比方说，简单的举个栗子，两个线程对同一个int值做加1操作，然后打印出来。 123456789101112131415161718192021public int a = 0;@org.junit.Testpublic void add1() &#123; Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; a++; System.out.println(&quot;thread1:a=&quot; + a); &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; a++; System.out.println(&quot;thread2:a=&quot; + a); &#125; &#125;); thread1.start(); thread2.start();&#125; &emsp;&emsp;因为这里直接用的基本类型，极端情况下，线程1，线程2同时执行，里面的a++操作也是同时执行，那这里两个打印都是1，虽然，这里我没有复现出来。但是，这种情况肯定是存在的。那么，怎么避免这种情况呢？ &emsp;&emsp;我们可以写一个简单的线程同步器，就是加锁操作，如下： 123456789101112131415161718192021222324252627282930313233343536private Object lock = new Object();public int a = 0;@org.junit.Testpublic void add1()&#123; Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; //先获取到lock 对象的锁 synchronized (lock)&#123; try &#123; //在lock对象上执行wait()方法,让其进入休眠,等待有人唤醒自己 lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; a++; System.out.println(&quot;thread1:a=&quot; + a); &#125; &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; //获取lock的锁 synchronized (lock)&#123; a++; System.out.println(&quot;thread2:a=&quot; + a); //唤醒正在lock对象上等待的线程 lock.notify(); &#125; &#125; &#125;); thread1.start(); thread2.start();&#125; &emsp;&emsp;这里，我们用到的object类的wait和notify方法。等待和唤醒。当线程1执行到lock.wait();方法时，线程1会进入等待状态。当线程2执行lock.notify();时，会唤醒线程1，执行线程1的后续a++，打印操作。 &emsp;&emsp;那么，这里会有一个问题，如果线程2先执行，线程1后执行，那么线程1将永远的等待下去，这也是这样写的一个弊端。这还只是2个线程，实际项目中往往比这个复杂多了。为了解决这弊端，就引出了我们的线程同步器AQS(AbstractQueuedSynchronizer) &emsp;&emsp;并且，这个同步器，java.util包下面都已经给好了实现类，比方说：Semaphore，ReentrantLock，CountDownLatch等等都是，并且，我们用到的java线程池ThreadPoolExecutor中的Worker的实现也是。如下图： 线程同步器AQS(AbstractQueuedSynchronizer)&emsp;&emsp;线程同步器就是为了解决并发引起的线程不安全的问题。线程安全的三大特性：原子性，可见性，有序性。 原理&emsp;&emsp;简单点来说就是，它维护一个状态state，还有一个CLH队列。 &emsp;&emsp;CLH时一个双端队列，队列中每一个节点都放着正在等待获取资源的线程。当线程现在通过CAS原子算法比较预期值的方式去获取资源，也就是判断这里的state状态，是不是有等待获取资源的线程可以使用，如果时有，那就直接使用，如果没有，那就会将这个线程封装成一个节点Node，插入到CLH队列的尾部等待被唤醒。其他线程执行完之后，调用release释放一部分资源，那么，正在等待的队列就会被唤醒，去执行自己的任务。大致是这个意思，当然，AQS还有中断等其他的操作 简单的AQS同步器&emsp;&emsp;还是类似于上面那个例子，不过，都是访问同一个变量，业务背景换一下，换成一个库存秒杀，通过访问服务器，一共10件物品，我现在有20个线程去同时请求，哪些能抢到，哪些不能抢到？ 123456789101112131415161718192021222324public int count = 10; @org.junit.Test public void test3() &#123; for (int i = 1; i &lt;= 20; i++) &#123; final int finalI = i; new Thread(new Runnable() &#123; @Override public void run() &#123; buy(finalI); &#125; &#125;).start(); &#125; &#125; public void buy(int i) &#123; if (count != 0) &#123; count--; System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;库存还剩:&quot; + count + &quot;件&quot;); &#125; else &#123; System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;已经被抢光了&quot;); &#125; &#125; &emsp;&emsp;就像上面这样模拟一个简单的秒杀场景，库存10件，20个用户抢，实际情况肯定不止。我们看一下这样写的打印，如下图： &emsp;&emsp;我们看到这个最终虽然有10个用户的确抢到了，但是，我们看一下打印，打印是从8个开始的，不是从9开始的。我们理想的应该是如下这个图： &emsp;&emsp;这个图是我把buy方法加上了synchronized关键字，我给它锁住了。当执行buy方法的时候，另一个线程如果也进来执行buy，它会等待，等待前一个buy方法执行完，它才开始执行。 &emsp;&emsp;那么，直接用这个关键字就好了呀，还要啥自行车？天真，存在即合理。synchronized关键字锁比较重，不适合这种秒杀场景。 &emsp;&emsp;言归正传，上面两个从8开始，结合我们前面说的并发的问题，是不是就可以联想到，如果，多个线程同时，同一时刻访问，然后，数据库的库存同时减1，是不是就会出现一件商品，卖给多个人的情况？ &emsp;&emsp;有同学就会想，那么这么巧，同时访问，同一时刻，那你想想天猫双十一，那些节假日的秒杀场景，会出现什么问题？ &emsp;&emsp;这个时候线程同步器就出现了，我们不能对用户做限制，我们不能说张三你必须在某一个时间内访问，李四在某一个时间内访问，所以，我们能控制的只有服务器，也就是这里的buy方法。 &emsp;&emsp;也就是说，我们这里用的是悲观锁的方式，进入buy方法就立刻加锁，运行完buy方法就解锁。后面应用里面再聊这个悲观锁，乐观锁之类的。我们就把buy方法改成如下这样了： 123456789101112131415161718192021222324252627282930 MyOwnLock ownLock = new MyOwnLock(); public void buy(int i) &#123; //加锁 ownLock.lock(); if (count != 0) &#123; count--; System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;库存还剩:&quot; + count + &quot;件&quot;); &#125; else &#123; System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;已经被抢光了&quot;); &#125; //解锁 ownLock.unLock(); &#125; /** * @ClassName: MyOwnLock * @Description: * @Author: 海晨忆 * @Date: 2021/7/15 11:07 */public class MyOwnLock &#123; public void lock() &#123; &#125; public void unLock() &#123; &#125;&#125; &emsp;&emsp;如上代码，现在，我们要做的就是完善MyOwnLock类的加锁和解锁方法。 &emsp;&emsp;我们想想这个流程，多个用户同时下单，实际上对于代码来讲，就是多个线程同时请求服务器，调用这里的buy方法，去减少库存，我们需要做的就是保证这里减少库存不能出问题。 &emsp;&emsp;怎么保证这个减少库存不能出问题呢？就是我们前面说的并发的问题，也就是这里的线程安全的问题。线程安全的三大特性：原子性，可见性，有序性。我们保证这三个特性就好了。 &emsp;&emsp;第一个线程进来，我们就标记一下，已经有线程进来在执行了，我们就改变这个标记，后面的线程感知到这个改变之后，就必须等待。那这个标记，怎么让其他线程感知到呢？ &emsp;&emsp;volatile关键字的两大特性：可见性，有序性 &emsp;&emsp;可见性，就是可以让其他线程感知到。那么，就解决了这个问题，我们用计数器的方式来做这个标记。我们是悲观锁的方式，始终只能有一个线程访问，必须等这个线程访问完了，其他线程才能访问。 &emsp;&emsp;对应成代码就是，这个计数器变量初始化是0，加锁成功之后，就加1，后面的线程进来的时候，判断这个计数器是不是0，如果不是0，就表示有线程正在访问，不能进行加锁操作；如果是0，就表示没有，可以进行加锁操作。那么我们就开始写代码： 12345678910111213141516171819202122232425262728293031323334353637383940package com.example.myapplication;/** * @ClassName: MyOwnLock * @Description: * @Author: 海晨忆 * @Date: 2021/7/15 11:07 */public class MyOwnLock &#123; private volatile int state; private Thread currentHolder; public void lock() &#123; Thread currentThread = Thread.currentThread(); int state = getState(); if (state == 0) &#123; setCurrentHolder(currentThread); &#125; &#125; public void unLock() &#123; &#125; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; &#125; public Thread getCurrentHolder() &#123; return currentHolder; &#125; public void setCurrentHolder(Thread currentHolder) &#123; this.currentHolder = currentHolder; &#125;&#125; &emsp;&emsp;直接用if(state==0)来判断就可以了吗？volatile关键字只能保证可见性，有序性，并不能保证原子性，所以，volatile并不是真正的线程安全，只是大多数情况下还是比较有用的，而，我们这里要保证线程安全，就需要保证原子性，原子性怎么保证呢？ &emsp;&emsp;这里就出现了关键的CAS算法了，Compare And Swap比较互换。这个算法java里面是怎么实现的呢？我们java里面有一个Unsafe类，他的里面全是native方法，提供的都是硬件级别的原子操作。我们用到的就是这个类里面的几个方法，CAS的操作也是这些方法实现的compareAndSwapXXX。具体的可以在网上搜一下这个类，然后仔细的看一下，这里，我简单的介绍一个： 123456789101112131415161718192021/*** * Compares the value of the object field at the specified offset * in the supplied object with the given expected value, and updates * it if they match. The operation of this method should be atomic, * thus providing an uninterruptible way of updating an object field. * 在obj的offset位置比较object field和期望的值，如果相同则更新。这个方法 * 的操作应该是原子的，因此提供了一种不可中断的方式更新object field。 * * @param obj the object containing the field to modify. * 包含要修改field的对象 * @param offset the offset of the object field within &lt;code&gt;obj&lt;/code&gt;. * &lt;code&gt;obj&lt;/code&gt;中object型field的偏移量 * @param expect the expected value of the field. * 希望field中存在的值 * @param update the new value of the field if it equals &lt;code&gt;expect&lt;/code&gt;. * 如果期望值expect与field的当前值相同，设置filed的值为这个新值 * @return true if the field was changed. * 如果field的值被更改 */public native boolean compareAndSwapObject(Object obj, long offset, Object expect, Object update); &emsp;&emsp;所以，加锁流程就变成了如下图的样子， &emsp;&emsp;根据这个流程，代码就变成了如下的样子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example.myapplication;/** * @ClassName: MyOwnLock * @Description: * @Author: 海晨忆 * @Date: 2021/7/15 11:07 */public class MyOwnLock &#123; private volatile int state; private Thread currentHolder; public void lock() &#123; if (acquire())&#123; return; &#125; &#125; public boolean acquire()&#123; Thread currentThread = Thread.currentThread(); int state = getState(); if (state == 0) &#123; if (compareAndSwapState(0,1)) &#123; setCurrentHolder(currentThread); &#125; return true; &#125; return false; &#125; public void unLock() &#123; &#125; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; &#125; public Thread getCurrentHolder() &#123; return currentHolder; &#125; public void setCurrentHolder(Thread currentHolder) &#123; this.currentHolder = currentHolder; &#125;&#125; &emsp;&emsp;加锁流程就完了吗？这才哪到哪，我们现在加锁就第一个拿到锁的线程开始用了，那后面没有拿到锁的线程怎么办呢？难道全部丢掉不管吗？ &emsp;&emsp;当然不行。那怎么办呢？我们先用一个队列，把没有拿到锁的线程存起来，排好队，等第一个线程执行完了之后，释放锁的时候，再直接唤醒等待的线程即可； &emsp;&emsp;把阻塞的线程全放进队列（并且要线程安全，高并发的情况下迅速 入队，出队）中，当T1释放锁是，直接唤醒T2。队列选择用ConcurrentLinkedQueue（基于CAS算法，保证入队，出队安全） &emsp;&emsp;那么，要怎么做呢？要怎么等待呢？最简单的就是写一个死循环，一直循环去判断锁有没有用完。但是，这样会一直占用CPU，消耗性能。 用sleep？Thread.sleep可能造成等待时间过长，你没法知道休眠的时间，如果，线程1执行完只需要200毫秒，你这里休眠了1000毫秒，那就浪费了800毫秒了。 那用Thread.yield()可以了吧？答案是不行，这个线程让步，虽然把cpu的时间片让出去给其他线程用了，但是，最后，我们需要唤醒的时候，怎么办呢？ &emsp;&emsp;我们最后唤醒，是要指定唤醒哪一个线程，这里我们还是用到刚才Unsafe里面的两个方法，park和unPark。park阻塞线程，让出cpu的使用权，unPark解除阻塞，唤醒某一个线程。 &emsp;&emsp;这里我们用它的包装类LockSupport。所以，加锁代码就变成这样子了： 12345678910111213141516private ConcurrentLinkedQueue&lt;Thread&gt; waiterQueue = new ConcurrentLinkedQueue&lt;&gt;();public void lock() &#123; if (acquire()) &#123; return; &#125; Thread currentThread = Thread.currentThread(); waiterQueue.add(currentThread); for (; ; ) &#123; if (currentThread != waiterQueue.peek() &amp;&amp; acquire()) &#123; waiterQueue.poll(); return; &#125; LockSupport.park(currentThread); &#125;&#125; &emsp;&emsp;获取锁的方法也要做相应的调整，如下： 123456789101112public boolean acquire() &#123; Thread currentThread = Thread.currentThread(); int state = getState(); if (state == 0) &#123; boolean temp = waiterQueue.size() == 0 || currentThread == waiterQueue.peek(); if (temp &amp;&amp; compareAndSwapState(0, 1)) &#123; setCurrentHolder(currentThread); &#125; return true; &#125; return false;&#125; &emsp;&emsp;解锁就比较简单了 12345678910111213public void unLock() &#123; if (Thread.currentThread() != currentHolder) &#123; throw new RuntimeException(&quot;出错啦&quot;); &#125; int state = getState(); if (compareAndSwapState(state, 0)) &#123; setCurrentHolder(null); Thread firstThread = waiterQueue.peek(); if (firstThread != null) &#123; LockSupport.unpark(firstThread); &#125; &#125;&#125; &emsp;&emsp;判断当前线程是不是持有锁的线程，如果不是，那就抛异常如果是，那就获取状态state，通过cas算法，置换为0的状态。 &emsp;&emsp;最后运行完，结果如下： 总结：上面我说的简单的线程同步器，只是AQS的一个主要的思想，CAS算法，计数器，线程队列。还有线程中断，独占模式，共享模式，公平锁，不公平锁等等。看完我这个，然后再去看源码应该会更容易懂。]]></content>
      <categories>
        <category>JAVA -并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android模拟点击]]></title>
    <url>%2F2021%2F07%2F07%2FAndroid%E6%A8%A1%E6%8B%9F%E7%82%B9%E5%87%BB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本篇介绍实现模拟点击的两种方式： performClick(); MotionEvent事件 &emsp;&emsp;举个栗子：我们现在需要实现点击A按钮，触发B按钮点击事件的效果：两个按钮在布局里面随便创建就好了。 &emsp;&emsp;第一种方式就是：调用performClick事件 123456789101112131415Button btn1 = findViewById(R.id.btn1);final Button btn2 = findViewById(R.id.btn2);btn1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.v(&quot;wz&quot;,&quot;btn1&quot;); btn2.performClick(); &#125;&#125;);btn2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.v(&quot;wz&quot;,&quot;btn2&quot;); &#125;&#125;); &emsp;&emsp;这种方式很简单，但是有一个弊端，就是不会传递触摸点坐标，只是模拟一下btn2的点击事件。 &emsp;&emsp;第二种方式就是：MotionEvent事件123456789101112131415161718192021222324252627282930Button btn1 = findViewById(R.id.btn1);final Button btn2 = findViewById(R.id.btn2);btn1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.v(&quot;wz&quot;,&quot;btn1&quot;); long downTime = SystemClock.uptimeMillis(); long eventTime = SystemClock.uptimeMillis()+100; float upX = btn2.getX()+50; float upY = btn2.getY()+50; MotionEvent obtainDown = MotionEvent.obtain(downTime, eventTime, ACTION_DOWN, upX, upY, 0); long downTime1 = SystemClock.uptimeMillis(); long eventTime1 = SystemClock.uptimeMillis()+100; float upX1 = btn2.getX()+50; float upY1 = btn2.getY()+50; MotionEvent obtainUp = MotionEvent.obtain(downTime1, eventTime1, MotionEvent.ACTION_UP, upX1, upY1, 0); btn2.dispatchTouchEvent(obtainDown); btn2.dispatchTouchEvent(obtainUp); obtainDown.recycle(); obtainUp.recycle(); Log.v(&quot;wz&quot;,&quot;downTime:&quot;+downTime+&quot; ,eventTime:&quot;+eventTime+&quot; ,upX:&quot;+upX+&quot; ,upY:&quot;+upY+&quot; ,downTime1:&quot;+downTime1+&quot; ,eventTime1:&quot;+eventTime1+&quot; ,upX1:&quot;+upX1+&quot; ,upY1:&quot;+upY1); &#125;&#125;);btn2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.v(&quot;wz&quot;,&quot;btn2&quot;); &#125;&#125;); &emsp;&emsp;这种方式比较麻烦，用到的就是view的事件分发，一个简单的点击事件的触发就是down和up组成，当然还有平移我们这里不考虑。 &emsp;&emsp;第一步，先用MotionEvent.obtain创建两个事件：一个down事件，一个up事件，创建的时候需要传递坐标点，传你目标view的范围内的坐标就行。 &emsp;&emsp;第二步，通过目标view，也就是这里的btn2去把这两个事件分发出去，通过dispatchTouchEvent分发，这样就完成了一次模拟点击事件，分发完记得回收 &emsp;&emsp;这样，就完成了一次模拟点击，并且坐标也传递了。因为，创建这两个事件的时候就传递了。解决了performClick的弊端。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列-消息(RabbitMQ)（二十）]]></title>
    <url>%2F2019%2F11%2F27%2FSpringBoot%E7%B3%BB%E5%88%97-%E6%B6%88%E6%81%AF-RabbitMQ-%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;大多数应用当中，可通过消息服务中间件来提升系统的异步通信和扩展解耦能力。 简介消息服务中两个重要的概念 &emsp;&emsp;消息代理和目的地：当消息发送者发送消息之后，将由消息代理接管，消息代理保证消息发送到指定的目的地。 消息发送的两种方式： 队列(Queue)：点对点消息通信(point-to-point) 主题(Topic)：发布(publish)/订阅(subscribe)式消息通信 &emsp;&emsp;开始说了，消息可以提升系统的异步通信和扩展解耦能力。异步通信，我们之前讲异步任务的时候已经说过了。给用户发送邮件就是最好，最直接的例子。 &emsp;&emsp;至于，扩展解耦能力，最好最直接的例子就是流量削峰，举个例子：整点秒杀。库存只有100件，用户有10000个人，整点用户讲发送10000个请求，难道每个都请求数据库吗？这个时候，我们就可以做个限制，用户发送的请求先到消息队列，然后，再由消息队列统一管理，哪些请求时可以到数据库的，哪些请求时不可以到数据库的，这样就解决了数据库的抗压能力。 实现&emsp;&emsp;点对点式 消息发送者发送消息之后，消息代理将消息放在一个队列当中，消息接收者从队列中获取消息内容，消息读取后移除队列 消息只有唯一的发送者和接收者，但并不是说只能有一个接收者 &emsp;&emsp;发布订阅式 发送者(发布者)发送消息到主题(topic)，多个接收者(订阅者)监听(订阅)这个主题，那么，就会在消息到达的同时收到消息 JMS和AMQP JMS:Java message service ：Java消息服务基于JVM消息代理规范，ActiveMQ,HornetMQ就是JMS的实现 AMQP:advanced message Queue Protocol：高级消息队列协议，也是消息代理的规范，兼容JMS，RabbitMQ就是AMQP的实现。 对比 类型 JMS AMQP 定义 Java api 网络线级协议 跨语言 否 是 跨平台 否 是 model 提供两种消息模式：peer-2-peer，pub/sub 提供五种消息模式：direct exchange，fanout exchange，topic change，headers exchange，system exchange。本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分 支持消息类型 多种消息类型：TextMessage，MapMessage，BytesMessage，StreamMessage，ObjectMessage，Message （只有消息头和属性） byte[]类型，当实际应用中有复杂消息时，可以序列化之后再发送 综合评价 JMS定义了java api层面的标准，在Java体系中，多个client均可通过JMS进行交互，不需要修改代码，但是其对跨平台支持较差 AMQP天然具有跨平台，跨语言特性 RabbitMQ简介&emsp;&emsp;RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。 核心概念Message &emsp;&emsp;消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等 Publisher &emsp;&emsp;消息的生产者，也是一个向交换器发布消息的客户端应用程序 Exchange &emsp;&emsp;交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange有4种类型：direct(默认)，fanout,topic,和headers，不同类型的Exchange转发消息的策略有所区别。 Queue &emsp;&emsp;消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。 Binding &emsp;&emsp;绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和Queue的绑定可以是多对多的关系。 Connection &emsp;&emsp;网络连接，比如一个TCP连接。 Channel &emsp;&emsp;信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。 Consumer &emsp;&emsp;消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 Virtual Host &emsp;&emsp;虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。 Broker &emsp;&emsp;表示消息队列服务器实体 流程 &emsp;&emsp;AMQP的消息路由过程跟JMS存在一些差异，增加了Exchange和Binding的角色 JMS流程： 生产者(publisher)生成某个消息(Message)，发送到某个队列(Queue)上 消费者(Consumer)监听这个队列(Queue)，消费消息 RabbitMQ流程： 生产者(publisher)生成某个消息(Message)，把这个消息发送给我们的消息代理服务器上(Broker) 服务器收到消息之后，把这个消息给到一个合适的交换器(Exchange),(服务器有非常多的交换器) 交换器(Exchange)收到这个消息之后，根据路由键(Binding绑定关系)把这个消息给一个或者多个消息队列(Queue)(服务器有很多个消息队列) 消费者(Consumer)连接上队列之后取出消息 重点就是：交换器和队列的绑定 重点就是：交换器和队列的绑定 重点就是：交换器和队列的绑定 &emsp;&emsp;我们上面说了Exchange有4种，不同类型转发的消息策略不同，那么，这个策略是什么呢？其中，header和direct交换器完全一致，但是header性能上差很多，基本上不用了 重点start direct交换器：当我们发送消息时的路由键和绑定中的key完全一致的时候，交换器就将消息发送到该队列当中。它时完全匹配单播模式 fanout交换器：当我们消息发送到fanout交换器时，不管交换器与队列绑定的路由键时什么，fanout交换器都会把这个消息发送给每一个队列，跟UDP广播类似，fanout交换器发送消息最快。 topic交换器：该交换器允许我们对路由键做模糊匹配，有选择性的发送给某一个或者多个队列。两个通配符:井号(#)和星号(*)。其中：井号：匹配0个或者多个单词。星号：匹配一个单词。 重点end 安装&emsp;&emsp;首先，打开我们的虚拟机，用SecureCRT连接我们的虚拟机，我用的SecureCRT，至于你用的啥连接虚拟机，随便你。 &emsp;&emsp;然后，用docker安装带manager版本的rabbit，带manager的版本自带图形化界面，容易操作。从docker hub上面搜索，我安装的是 1docker pull rabbitmq:3.8.1-management &emsp;&emsp;接着，新建容器，记得带端口号,-d后台运行，映射两个端口号，起自己的名字，加上镜像id 1docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq 镜像id &emsp;&emsp;接下来，就可以访问了，通过虚拟机的ip地址加上端口号，账号密码都是guest 1虚拟机ip地址:15672 &emsp;&emsp;我们在图上，就能看到我们前面说过的：Connection，Channel，Exchange，Queue等等。 &emsp;&emsp;最后面那个admin，我们能够设置用户名和密码，就是我们前面登录的guest，并且，能够设置访问的Virtual Hosts。 &emsp;&emsp;我们看一下最上面的流程图和消息发送流程，我就举一个例子： 首先，我们先创建一个交换器名字叫：haichenyi 其次，我们再创建一个队列，名字也叫：haichenyi 接着，我们将这交换器和队列绑定到一起 然后，我们随便发送一条消息 最后，查看消息队列 PS： 我们在创建Exchange和Queue的时候，有一个选项：Durability，意思是是否可持久化，也就是，服务器重启之后这个东西是否还存在。就选默认的durable就行了，可持久化的 我们在Exchange和Queue绑定的时候，发送消息的时候，都要填一个Routing key，就是上文我们说的绑定规则。 &emsp;&emsp;这就是整个流程，这都是页面操作，下面说一下代码里面怎么写，很简单。 用法&emsp;&emsp;首先，添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; &emsp;&emsp;然后，就是配置：两个可能出错的位置，我已经注释标明了 1234567spring.rabbitmq.host=192.168.113.22#这里端口号要用5672，不能用15672，15672是后台管理页面的端口号spring.rabbitmq.port=5672#这里的用户民和密码还有virtual-host要对应上，新建的账号要记得给权限spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/ &emsp;&emsp;代码怎么写呢？ 12345678910111213141516171819202122232425262728@SpringBootTestclass SellApplicationTests &#123; @Autowired RabbitTemplate rabbitTemplate; @Test void contextLoads() &#123; //message需要自己构造一个；定义消息体内容和消息头 //rabbitTemplate.send(exchange,routingKey,message); //Object默认当成消息体，只需传入要发送的对象，自动序列化发送给RabbitMQ //rabbitTemplate.convertAndSend(exchange,routingKey,Object); //对象会被默认序列化之后发送 User user = new User(&quot;海晨忆&quot;,25); rabbitTemplate.convertAndSend(&quot;haichenyi&quot;,&quot;haichenyi&quot;,user); &#125; @Test void getMsg()&#123; //queueName:需要从哪个队列中收消息 User user = (User) rabbitTemplate.receiveAndConvert(&quot;haichenyi&quot;); System.out.println(user.getName()); System.out.println(user.getAge()); &#125; &#125; &emsp;&emsp;可以向上面这样测试，发送和接收。实际应用中，我们要向下面这样写： 启动类上添加@EnableRabbit注释，开启Rabbit监听功能 在我们接收的方法添加@RabbitListener注解，queues是一个数组，方法的参数是发送的数据类型。 12345678910@Servicepublic class UserService &#123; @RabbitListener(queues = &quot;haichenyi&quot;) public void receive(User user)&#123; System.out.println(&quot;收到消息：&quot;+user); System.out.println(user.getName()); System.out.println(user.getAge()); &#125;&#125; &emsp;&emsp;以上，就是RabbitMQ的简单使用了，上面的Exchange，Queue都是在管理界面创建绑定的，代码里面怎么创建绑定呢？ 123456789101112131415161718@Autowired RabbitAdmin rabbitAdmin; @Test void createExchange()&#123; //以declare开头的都是创建，这里是创建一个Exchange，需要传一个Exchange对象 //我们点击过去看，是一个接口，我们就看它的实现类。可以看到5种实现类 rabbitAdmin.declareExchange(new DirectExchange(&quot;wang.exchange&quot;)); //创建一个queue队列 rabbitAdmin.declareQueue(new Queue(&quot;wang.queue&quot;)); //destination：目的地 //Binding.DestinationType destinationType：类型,枚举类：队列和交换器两种 //exchange：交换器 //routingKey：路由键 //arguments：头信息 //绑定有两种绑定方式，一种是把交换器往队列上面绑定，一种是把队列往交换器上面绑定 rabbitAdmin.declareBinding(new Binding(&quot;wang.queue&quot;,Binding.DestinationType.QUEUE,&quot;wang.exchange&quot;,&quot;wang.key&quot;,null)); &#125; &emsp;&emsp;然后，发消息的操作就跟前面写的一样了]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列-Docker（十九）]]></title>
    <url>%2F2019%2F11%2F13%2FSpringBoot%E7%B3%BB%E5%88%97-Docker%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 &emsp;&emsp;容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。 &emsp;&emsp;我们spring boot项目，什么地方需要用到dockers呢？我们最后项目发布，发到服务器上面，环境怎么搭建？如果就用Linux命令会很麻烦，用Docker，简单的几行命令就可以了。 &emsp;&emsp;服务器其实就是一个操作系统，我们的项目跑在上面也是需要环境的，我们本地是windows系统，跑项目需要环境，服务器现在一般都是centOS系统，当然也需要环境。 核心概念 docker镜像(images)：Docker镜像用于创建Docker容器的模板 docker容器(container)：Docker容器是独立运行的一个或者一组应用 docker客户端(client)：客户端通过命令或者其他工具一起使用docker api与docker守护进程 docker主机(host)：一个物理或者虚拟的机器用于执行docker守护进程和容器 docker仓库(registry)：docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。docker hub提供了庞大的镜像集合供使用 &emsp;&emsp;举个例子，我们一般操作流程是这样的： 先用VirtualBox启动一个虚拟机，启动的是centOS系统，装上docker程序（docker主机）。这个对应的就是我们项目最后发布的服务器。 然后，用SecureCRT连上我们这个虚拟机。（docker客户端）。 接着，通过docker从docker 仓库中下载我们需要的镜像，比方说：mysql镜像，redis镜像等等。 最后，启动这个镜像，就相当于创建一个容器。启动镜像，就相当于配置好了环境。比方说：启动一个mysql镜像，就相当于创建了一个mysql容器，就可以用mysql数据库了。可以启动的那个多个镜像，并且，每个镜像都是独立运行的，互不干扰（沙箱机制）。 Docker安装查看centOS版本： 12//docker要求CentOS系统内核版本要高于3.10uname -r 升级软件包及内核： 12345//因为，我们安装的docker是最新版本的//但是，内核版本低可能不兼容，所以，要更新//如果，后面安装成功之后，启动的时候出错，那么就先卸载docker，更新内核//重启之后，再重新安装docker就行了yum update 安装docker 1yum install docker 卸载docker 1yum remove docker-* 启动docker 1systemctl start docker 将docker作为开机启动 1systemctl enable docker 常用操作 名称 命令 说明 检索 docker search 关键字（eg：docker search redis） 我们经常去docker hub上检索镜像的详细信息，不用再本地敲命令搜索。如镜像的TAG 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest版本 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像，镜像id可以通过列表查看 运行 docker run -d –name 自定义名字 安装的容器名字（eg:docker run –d –name myredis redis） –name：自定义容器名 -d：后台运行 列表 docker ps（查看运行中的容器） 加上-a；可以查看所有容器 停止 docker stop container-name/container-id 停止当前你运行的容器 启动 docker start container-name/container-id 启动容器 删除 docker rm container-id 删除指定容器 端口映射 -p 6379:6379 -p: 主机端口(映射到)容器内部的端口 容器日志 docker logs container-name/container-id PS:我们docker run的时候一般都是跟上端口映射，不然访问不到。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—Run启动原理（十八）]]></title>
    <url>%2F2019%2F11%2F11%2FSpringBoot%E7%B3%BB%E5%88%97-Run%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;需要搞清楚几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner &emsp;&emsp;新建一个空项目，就勾选web，找到启动类，每个方法上面写的注释，可以看一下： 1234567891011121314151617@SpringBootApplicationpublic class SellApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SellApplication.class, args); &#125;&#125;//上面run方法点进来public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123; return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args); &#125;public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; return new SpringApplication(primarySources).run(args); &#125; 看到这里，就应该看到了，启动流程分为两步 创建SpringApplication对象 运行run方法 创建SpringApplication对象1234567891011121314151617181920212223//上面的构造方法点进去//这里与1.5版本不一样的地方就是，//2.X这里调用了重载的构造方法，而1.5这里调用的是一个initialize()方法，这个方法里面的内容，与下面两个参数的重载方法差不多public SpringApplication(Class&lt;?&gt;... primarySources) &#123; this(null, primarySources); &#125;//下面这个就是this调用的重载的构造方法@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; //保存主配置类，1.5里面这里有个非空判断，用if做的，这里换成的断言做判断 Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); //判断当前是否一个web应用 this.webApplicationType = WebApplicationType.deduceFromClasspath(); //从类路径下找到META‐INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起 来 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); //从类路径下找到ETA‐INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass(); &#125; setInitializers()方法&emsp;&emsp;看方法名就知道，这个是初始化方法，初始化什么东西呢？再看传的参数ApplicationContextInitializer，就是一开始我们提到的类。我们看这个是怎么获取的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//第一步：private SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));&#125;//第二步：private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123; ClassLoader classLoader = getClassLoader(); // Use names and ensure unique to protect against duplicates //看这里的导入方法SpringFactoriesLoader.loadFactoryNames(type, classLoader) Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); AnnotationAwareOrderComparator.sort(instances); return instances; &#125; //第三步：public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123; String factoryTypeName = factoryType.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList()); &#125;//第四步，就是这里了。看这里面的实现private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) &#123; return result; &#125; try &#123; //一眼看过去。很明显，这里就是classLoader.getResources()，导入的本地的资源。看这个传的参数,我放到这个方法下面去了 Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); //这里通过一个while循环，加载本地配置的ApplicationContextInitializer while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; String factoryTypeName = ((String) entry.getKey()).trim(); for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123; result.add(factoryTypeName, factoryImplementationName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex); &#125; &#125; /** * The location to look for factories. * &lt;p&gt;Can be present in multiple JAR files. */public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; &emsp;&emsp;所以，从上面的源码，我们一步一步点击进去看，我们就能发现，他最终都是加载到 META-INF/spring.factories 目录下的 ApplicationContextInitializer 当然，到目前为止这里只是初始化 setListeners()方法&emsp;&emsp;一眼就能看出来，这里是设置监听方法 1setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); &emsp;&emsp;一眼看过去，这个setListener方法传的参数熟不熟悉？就是我们上面初始化的时候传的参数是同一个方法。所以，这里设置监听设置哪些监听方法也是META-INF/spring.factories 目录下的listener方法，我们看一下这个文件内容： &emsp;&emsp;这些都是是自动配置类的内容 运行Run方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META‐INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); //准备环境，创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准 备完成 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //这里是新增的，点击去看，就是再properties文件中配置你需要忽略的bean configureIgnoreBeanInfo(environment); //这个是打印spring的logo banner图 Banner printedBanner = printBanner(environment); /创建ApplicationContext；这个下面有下介绍 context = createApplicationContext(); //看一下参数，这个就是做异常报告处理的 exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded()； prepareContext(context, environment, listeners, applicationArguments, printedBanner); //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //2.x里面是空方法 afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; //返回这个IOC容器 return context; &#125; getRunListeners()方法&emsp;&emsp;我们看到上面第一个有注释的位置：getRunListeners方法 12345private SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));&#125; &emsp;&emsp;方法熟悉吗？就是我们上面初始化的时候调用的那个方法，只是这里的参数传的是：SpringApplicationRunListener,我们看最开始说的，这就是我们要了解的第二个内容，回调都是怎么调用的 &emsp;&emsp;方法里面的注释也写了，先获取监听事件，然后回调starting方法，我们看一下这个接口有那些回调方法： 123456789101112131415161718192021222324public interface SpringApplicationRunListener &#123; default void starting() &#123; &#125; default void environmentPrepared(ConfigurableEnvironment environment) &#123; &#125; default void contextPrepared(ConfigurableApplicationContext context) &#123; &#125; default void contextLoaded(ConfigurableApplicationContext context) &#123; &#125; default void started(ConfigurableApplicationContext context) &#123; &#125; default void running(ConfigurableApplicationContext context) &#123; &#125; default void failed(ConfigurableApplicationContext context, Throwable exception) &#123; &#125;&#125; &emsp;&emsp;就这些回调，这里还用了1.8的新特性，default关键字，接口里面的方法可以有方法体 prepareEnvironment()&emsp;&emsp;看到第二个写注释的位置，眼熟吗？可不就是跟上面回调方法名字相同么？我们点进去看一下 1234567891011121314151617private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) &#123; // Create and configure the environment ConfigurableEnvironment environment = getOrCreateEnvironment(); configureEnvironment(environment, applicationArguments.getSourceArgs()); ConfigurationPropertySources.attach(environment); //这里划重点，这里就调用的environmentPrepared的回调方法 listeners.environmentPrepared(environment); bindToSpringApplication(environment); if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; ConfigurationPropertySources.attach(environment); return environment; &#125; &emsp;&emsp;准备完环境之后，调用environmentPrepared的回调 createApplicationContext()12345678910111213141516171819202122protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; switch (this.webApplicationType) &#123; case SERVLET: contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); &#125; &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex); &#125; &#125; return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass); &#125; &emsp;&emsp;创建applicationContext，这里跟1.5不一样，1.5就只有两种：一种是web的ioc容器，一种是默认的ioc容器。2.X这里有三种：DEFAULT_CONTEXT_CLASS，DEFAULT_SERVLET_WEB_CONTEXT_CLASS，DEFAULT_REACTIVE_WEB_CONTEXT_CLASS，实际字符串比较长，可以去看一下源码。然后用BeanUtils通过反射创建。 prepareContext()方法123456789101112131415161718192021222324252627282930313233private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; //将environment放到context中 context.setEnvironment(environment); postProcessApplicationContext(context); //初始化 applyInitializers(context); //这里回调contextPrepared方法 listeners.contextPrepared(context); if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // Add boot specific singleton beans ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); if (printedBanner != null) &#123; beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); &#125; if (beanFactory instanceof DefaultListableBeanFactory) &#123; ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.lazyInitialization) &#123; context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()); &#125; // Load the sources Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); load(context, sources.toArray(new Object[0])); //这里回调contextLoaded()方法 listeners.contextLoaded(context); &#125; &emsp;&emsp;准备上下文环境;将environment保存到ioc中；而且applyInitializers() 12345678protected void applyInitializers(ConfigurableApplicationContext context) &#123; for (ApplicationContextInitializer initializer : getInitializers()) &#123; Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(), ApplicationContextInitializer.class); Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;); initializer.initialize(context); &#125; &#125; &emsp;&emsp;这里就将我们一开始从配置文件里面读取，然后创建ApplicationContextInitializer初始化。 &emsp;&emsp;当环境准备好之后，就回调了SpringApplicationRunListener的contextPrepared()； &emsp;&emsp;当所有的都准备好了之后，回调SpringApplicationRunListener的contextLoaded()； &emsp;&emsp;到这里，所有的环境都准备好了，需要打印的logo也加进去了。 refreshContext()&emsp;&emsp;刷新容器这个方法，我们可以点到具体的功能实现里面，可以看到，这里就是扫描，创建，加载所有的组件，配置类，组件，自动配置等。 &emsp;&emsp;到这里，这个方法创建完之后，所有的控制器就创建完了，所有的组件，bean等，都在控制台打印出来了。如果是web应用，还会创建嵌入式的tomcat。我们spring boot项目内嵌tomcat，就是在这里创建的。 afterRefresh()&emsp;&emsp;1.5版本这个方法里面回调的是callRunners方法，而2.X版本，现在这是个空方法里面并没有实现。callRunners被提出来了，放到了最后面。 started(),running()&emsp;&emsp;在1.5版本这里，也就是afterRefresh()之后，应该是调用的SpringApplicationRunListeners的finished()方法。 &emsp;&emsp;在2.X版本之后，去掉了finished方法，改成了调用started方法，然后调用running方法。我们上面有一个starting方法，从这里名字就可以看出来，相当于，首先是正在启动当中，然后就是启动完成了，正在运行了。 callRunners()1234567891011121314private void callRunners(ApplicationContext context, ApplicationArguments args) &#123; List&lt;Object&gt; runners = new ArrayList&lt;&gt;(); runners.addAll(context.getBeansOfType(ApplicationRunner.class).values()); runners.addAll(context.getBeansOfType(CommandLineRunner.class).values()); AnnotationAwareOrderComparator.sort(runners); for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123; if (runner instanceof ApplicationRunner) &#123; callRunner((ApplicationRunner) runner, args); &#125; if (runner instanceof CommandLineRunner) &#123; callRunner((CommandLineRunner) runner, args); &#125; &#125; &#125; &emsp;&emsp;从IOC容器中(不是配置文件)获取所有的的ApplicationRunner和CommandLineRunner进行回调。这也是最开始说的两个注意的地方 &emsp;&emsp;并且，这里有个先后顺序，先回调的ApplicationRunner，后回调的CommandLineRunner &emsp;&emsp;这里也是run方法，最后执行的地方。从这里就是真正的开启了run。 &emsp;&emsp;最后一步，返回那个context就是返回IOC容器对象。到这里，我们的spring boot就启动完成了。 &emsp;&emsp;这就是我们的spring boot的启动原理。初始化，listener的回调，Runner的回调都说的很清楚。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—Redis（十七）]]></title>
    <url>%2F2019%2F11%2F06%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94Redis%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前面一篇说到了spring boot自带的缓存SimpleCache，我们也聊到了他的底层实际上就是HashMap，并且这个缓存是放在内存当中的，这样弊端也是有的，比如：内存大小，当服务器关闭之后，缓存就没了等等。 简介&emsp;&emsp;实际开发中，一般使用缓存中间件：Redis，EHCache，MemCache等等，今天，我们就来聊聊，经常听到的——Redis。 &emsp;&emsp;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）——来自官方介绍 &emsp;&emsp;不去追究原理，我们可以这样理解Redis： 支持多种数据类型，redis支持set,zset,list,hash,string这五种数据类型，操作方便。 作为一个内存数据库，最担心的，就是万一机器死机宕机，数据就会消失掉。redis使用RDB和AOF做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。 与服务器解耦，缓存是一个单独的服务器，当我们项目重启的时候，缓存依然存在。 我们只用的话，它就是给我们提供了一系列方法的接口，我们只用调用它的API即可。 用法&emsp;&emsp;第一步，添加启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; &emsp;&emsp;第二步，配置你的服务器地址，不配置的话，默认是本地：配置信息一样在 自动配置类——data包——redis包——RedisProperties类 里面去找 12#指定redis服务器地址，指定的是本地spring.redis.host=127.0.0.1 &emsp;&emsp;第三步，添加了redis的配置类，当数据库添加复杂数据的时候，也能以Json的格式正常显示。 1234567891011121314151617181920212223@Configuration@EnableCachingpublic class RedisConfig extends CachingConfigurerSupport&#123;@Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setConnectionFactory(factory); //key序列化方式 template.setKeySerializer(redisSerializer); //value序列化 template.setValueSerializer(jackson2JsonRedisSerializer); //value hashmap序列化 template.setHashValueSerializer(jackson2JsonRedisSerializer); return template; &#125;&#125; &emsp;&emsp;第四步，正常写接口，在service层里面，自己去把数据写进缓存里面， 12345678910111213141516171819202122232425262728293031package com.haichenyi.springboottask.service;import com.haichenyi.springboottask.Provider;import com.haichenyi.springboottask.mapper.ProviderMapper;import com.haichenyi.springboottask.utils.RedisClient;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * @Desc * @Auther 海晨忆 * @Time 2019/11/6 */@Servicepublic class ProviderService &#123; @Autowired ProviderMapper providerMapper; @Autowired RedisClient redisClient; public Provider getProviderById(Integer pid) &#123; Provider provider = (Provider) redisClient.get(pid); if (provider != null) &#123; return provider; &#125; Provider provider1 = providerMapper.getProviderByPid(pid); redisClient.set(pid, provider1); return provider1; &#125;&#125; &emsp;&emsp;如上代码，我们通过id获取一个Provider，我们先从缓存去取，如果，取不到，说明缓存没有，那么，我们就去从数据库去取，取到之后，再把这条数据放进缓存里面。 &emsp;&emsp;就是上一篇讲默认缓存的注解的功能，redis里面需要我们自己去实现。 &emsp;&emsp;这里的 RedisClient 类，是自己封装的redis使用的类，至于redis怎么使用，redis的中文官网的命令页面写的很清楚。 &emsp;&emsp;记得本地电脑装一个Redis服务。然后再本地装一个redis可视化工具。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—缓存及其源码分析（十六）]]></title>
    <url>%2F2019%2F11%2F05%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E7%BC%93%E5%AD%98%E5%8F%8A%E5%85%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;缓存是每个项目都用到的为了提高接口响应效率，降低数据库的查询压力，从而提高系统性能。所以，缓存对于一个项目来说是至关重要的。 简介&emsp;&emsp;spring 3+之后，就定义了CacheManager和Cache接口来统一不同的缓存技术。 CacheManager：缓存管理器，用于管理各种Cache缓存组件 Cahce：定义了各种操作，Spring在Cache接口下提供了各种xxCache的实现；比如：ConcurrentMapCache，RedisCache，JCacheCache等等 源码解析&emsp;&emsp;这里我以默认缓存为例：ConcurrentMapCache &emsp;&emsp;上面说了，缓存只用配置就可以直接使用，所以，配置，一说到配置，我们就会想到之前说的自动配置类AutoConfigure。如下图： &emsp;&emsp;我们看到，自动配置类目录下面有一个cache包，这就是缓存自动配置的包，我们熟悉的类就有CacheProperties这个类，我们点进去看： &emsp;&emsp;我们熟悉的prefix就在这里了，也就是我们在全局配置类里面的键。 &emsp;&emsp;这里，配置的一般都是这个类里面的全局变量，我把这个CacheType给框出来了（下面的cacheNames这个list变量也很重要），上面的注释的意思是说，缓存类型，默认情况下，是根据环境自动检测的。 &emsp;&emsp;我们上面说到CacheManager和Cache接口是用来同意管理不同的缓存技术。不同的，也就是指的我们这里的缓存类型。所以，我们这里的缓存类型肯定有好几种，然后，这里又讲是根据环境自动检测的。也就是我们配置好的。也就是我们在全局配置类里面配置好的 1spring.cache.xxx=xxx &emsp;&emsp;既然是配置，肯定是定义了之后才能配置的，没定义，怎么可能配置，spring又不是神。那，定义了那些种类的缓存技术呢？我们看一下CacheType类 &emsp;&emsp;定义的，就这10种：GENERIC，JCACHE，EHCACHE，HAZELCAST，INFINISPAN，COUCHBASE，REDIS，CAFFEINE，SIMPLE，NONE。作为一个初学者，我想一眼看过去，我们能看到熟悉的Redis，学后天，Redis框架肯定要学。 &emsp;&emsp;我们现在，什么都没有配置，默认的缓存类型就是这个Simple，可以在Cache目录下面的CacheAutoConfiguration类中看到selectImports方法，在这里打断点，我们debug模式运行，我们就能看到它导入的缓存类型，然后，每个进行检测，看匹配哪一个。 &emsp;&emsp;我们就看一下SimpleCacheConfiguration是怎么实现的 &emsp;&emsp;我们看到了，SimpleCacheConfiguration默认使用的是：ConcurrentMapCacheManager，我们，看一下这个Manager是怎么实现的 &emsp;&emsp;这类，实现的就是CacheManager接口，而CacheManager接口就只有两个方法，就是上图中的两个方法setCacheNames 和 getCache &emsp;&emsp;先说一下数据是怎么缓存的，缓存是一个容器，这个容器怎么获取的呢？就是通过这里的name，name是获取这个容器的key，然后里面的数据存放形式，都是key-value的形式存放的。这个key也是我们定义的，value就是数据库查询的数据。如下图。 &emsp;&emsp;这个setCacheNames，就是，我们配置的cacheNames的值，它会获取好之后，将这些值封装成list，通过setCacheNames方法赋值给这里的变量cacheMap。我们可以看一下这个变量： 1private final ConcurrentMap&lt;String, Cache&gt; cacheMap = new ConcurrentHashMap&lt;&gt;(16); &emsp;&emsp;然后就是这个getCache方法，上面的setCacheNames以cacheName为键去存这个Cache，这个就是刚好相反，获取方法，通过cacheName去获取这个Cache。 &emsp;&emsp;然后，我们现在是获取到了这个缓存容器，那么，我们要怎么从这个缓存容器中去获取我们对应的数据呢？ &emsp;&emsp;我们看到上面那个变量是Map是以String为键，以Cache为值，我们最开始说过了，Cache和CacheManager是用来管理不同缓存技术的接口，所以，这里的值不可能是一个接口对象，肯定是它的实现类，我们再仔细看上面两个方法的实现类，我们会看到 12345//setCacheNames方法this.cacheMap.put(name, createConcurrentMapCache(name));//getCache方法cache = createConcurrentMapCache(name); &emsp;&emsp;很明显，这里就是Cache对象是怎么创建的，我们点到这个方法里面去看： 1234567891011/** * Create a new ConcurrentMapCache instance for the specified cache name. * @param name the name of the cache * @return the ConcurrentMapCache (or a decorator thereof) */ protected Cache createConcurrentMapCache(String name) &#123; SerializationDelegate actualSerialization = (isStoreByValue() ? this.serialization : null); return new ConcurrentMapCache(name, new ConcurrentHashMap&lt;&gt;(256), isAllowNullValues(), actualSerialization); &#125; &emsp;&emsp;所以，它这里是new的ConcurrentMapCache肯定是Cache的实现类。我们看到这个构造方法，第二个参数是一个hashMap，而我们的缓存容器里面也是以键值对的方式存储数据的。我们再看这个ConcurrentMapCache &emsp;&emsp;一共就只有三个全局变量，第一个name，是我们前面传过来的cacheName，第二个是Map类型，第三个是SerializationDelegate类型的变量，序列化的一个什么东西。排除法判断，只可能这个Map就是用来存放我们的缓存数据的。我们搜索这个变量，我们会看到如下几个方法： 1234567891011121314151617181920212223242526272829303132 //获取缓存数据 @Override@Nullableprotected Object lookup(Object key) &#123; return this.store.get(key);&#125; //存放 @Overridepublic void put(Object key, @Nullable Object value) &#123; this.store.put(key, toStoreValue(value));&#125;//通过key移除数据@Overridepublic void evict(Object key) &#123; this.store.remove(key);&#125;//清空所有数据@Overridepublic void clear() &#123; this.store.clear();&#125; //清空所有数据@Overridepublic boolean invalidate() &#123; boolean notEmpty = !this.store.isEmpty(); this.store.clear(); return notEmpty;&#125; &emsp;&emsp;至此，缓存怎么存放，怎么获取都说完了。 用法&emsp;&emsp;与前面差不多，都是在启动类上面开启，在方法上面标记注解就行了 @EnableCaching：在启动类上，开启基于注解的缓存 @Cacheable：标在方法上，返回的结果会进行缓存(先查缓存中的结果，没有则调用方法并将结果放到缓存中) @CachePut：保证方法被调用后，又将对应缓存中的数据更新（先调用方法，调完方法再将结果放到缓存） @CacheEvict：清除缓存 &emsp;&emsp;@Cacheable，@CachePut，@CacheEvict三个注解都有几个重要的属性： cacheNames：缓存的名字。 key: 作为缓存中的Key值，可以使用SpEL表达式指定（不指定，key就是参数值），缓存结果是方法返回值 &emsp;&emsp;上面两个属性是前面我们一直都在强调的比较重要的属性，然后，清除缓存的注解中还有两个属性需要了解: allEntries =true : 指定清除这个缓存中所有数据。 beforeInvocation = true : true在方法之前执行；默认false在方法之后执行,出现一场则不会清除缓存 &emsp;&emsp;我这里值贴出来缓存相关的类： 1234567891011121314151617181920212223@Servicepublic class UserService &#123; @Autowired UserMapper userMapper; @Cacheable(cacheNames = &quot;user&quot;, key = &quot;#id&quot;) public User getUser(Integer id) &#123; return userMapper.getUserById(id); &#125; @CachePut(cacheNames = &quot;user&quot;, key = &quot;#result.id&quot;) public User updateUser(User user) &#123; userMapper.updateUser(user); return user; &#125; @CacheEvict(cacheNames = &quot;user&quot;, key = &quot;#result&quot;) public Integer deleteUser(Integer id) &#123; userMapper.deleteUserById(id); return id; &#125;&#125; 总结&emsp;&emsp;第一步：默认采用的是SimpleCacheConfiguration 使用 ConcurrentMapCacheManager &emsp;&emsp;第二步：getCache 获取的是 ConcurrentMapCache 缓存对象进行存取数据,它使用ConcurrentMap对象进行缓存数据。 @Cacheable(cacheNames = “user”, key = “#id”) 第一次请求时： &emsp;&emsp;第三步：当发送第一次请求时，会从getCache(name)中获取，看有没有ConcurrentMapCache缓存对象,如果没有 则创建出来, 并且创建出来的key就是通过 @Cacheable(cacheNames = “user”)标识的name值 &emsp;&emsp;第四步：接着会从ConcurrentMapCache里面调用lookup获取缓存数据,通过key值获取的, 默认采用的是service方法中的参数值,如果缓存中没有获取到,则调用目标方法进行获取数据（即从数据库中查询）,获取之后则再将它 放到缓存中(key=参数值,value=返回值) 第二次请求时： &emsp;&emsp;第五步：如果再次调用 则还是先ConcurrentMapCacheManager.getCache()获取缓存对象,如果有则直接返回, 如果没有则创建 &emsp;&emsp;第六步：然后再调用 ConcurrentMapCache.lookup方法从缓存中获取数据, 如果缓存有数据则直接响应回去,不 会再去调用目标方法 第三次请求与第二次一样 如果缓存中没有缓存管理器,则与第一次请求一致]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—邮件（十五）]]></title>
    <url>%2F2019%2F10%2F31%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E9%82%AE%E4%BB%B6%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;邮件发送是必不可少的，不管是注册邮件，还是广告。 &emsp;&emsp;spring boot中已经集成的mail的启动器，所以，我们只用配置好就行了。 &emsp;&emsp;引入启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; &emsp;&emsp;那么，需要配置什么内容呢？我们之前讲过，需要配置的东西，spring boot都给我们提前准备好了，都在自动配置类AutoConfigure那个类里面，我们可以找一找，里面有个mail包，这个就是邮件的相关配置类。 &emsp;&emsp;我们可以看到上面的prefix中的spring.mail就是我们的配置文件中的前缀，这个类里面的公共变量，就是我们配置文件中的键。我们这里配置了四个值。 1234567#配置邮箱账号spring.mail.username=371965177@qq.comspring.mail.password=XXXXXXX#配置发送邮件服务器spring.mail.host=smtp.qq.com#配置ssl安全连接spring.mail.properties.smtp.ssl.enable = true &emsp;&emsp;这里的密码，我们不能填，我们的QQ号密码吧？需要在你的QQ邮箱去设置。生成授权码即可。直接百度一下：QQ邮箱怎么生成授权码，有教程。然后，把生成的授权码填到这里就行了。配置就这么多 &emsp;&emsp;怎么发送邮件呢？也很简单，分两种，一种是简单的文字邮件，一种是复杂带附件的邮件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.haichenyi.springboottask;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;import org.springframework.mail.javamail.MimeMessageHelper;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;import java.io.File;@SpringBootTestclass SpringBootTaskApplicationTests &#123; @Autowired JavaMailSenderImpl javaMailSender; @Test void contextLoads() &#123; //简单邮件 SimpleMailMessage message = new SimpleMailMessage(); //邮件标题 message.setSubject(&quot;测试邮件功能标题&quot;); //邮件内容 message.setText(&quot;测试邮件内容&quot;); //发件人，必须要跟配置的相同 message.setFrom(&quot;371965177@qq.com&quot;); //收件人 message.setTo(&quot;1640200266@qq.com&quot;); javaMailSender.send(message); &#125; @Test public void testMail() throws MessagingException &#123; //带附件邮件，通过createMimeMessage()方法获取对象 MimeMessage mimeMessage = javaMailSender.createMimeMessage(); //这里带附件的邮件需要用到这个帮助类 MimeMessageHelper messageHelper = new MimeMessageHelper(mimeMessage,true); messageHelper.setSubject(&quot;测试邮件功能标题&quot;); //可以发送html语句，第一个参数是内容，第二个参数设置为true即可。 messageHelper.setText(&quot;&lt;h1 style=&apos;color;blue&apos;&gt;测试邮件内容&lt;/h1&gt;&quot;,true); //addAttachment添加附件的方法。第一个是名字，第二个是file messageHelper.addAttachment(&quot;1.txt&quot;,new File(&quot;D:\\Download\\t.txt&quot;)); messageHelper.setFrom(&quot;371965177@qq.com&quot;); messageHelper.setTo(&quot;1640200266@qq.com&quot;); //这里发送的还是MimeMessage对象，并不是那个帮助类对象 javaMailSender.send(mimeMessage); &#125;&#125; &emsp;&emsp;每一行都有注释，已经写的很清楚了，就不做过多的解释了。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—异步任务与定时任务（十四）]]></title>
    <url>%2F2019%2F10%2F31%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[异步任务&emsp;&emsp;什么时候用异步，就是耗时操作的时候就可以用到异步，比如：批量处理数据，批量发邮件等等。 &emsp;&emsp;用法与前面的事务管理类似，spring 3+之后，就已经内置了 @Async 来处理异步任务。我们使用两个注解即可。 @EnableAysnc 启动类上开启基于注解的异步任务 @Aysnc 标识的方法会异步执行 如： 1234567891011121314151617181920212223242526272829303132333435@EnableAsync@SpringBootApplicationpublic class SpringBootTaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootTaskApplication.class, args); &#125;&#125;@Servicepublic class HelloService &#123; @Async public void add() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;批量操作&quot;); &#125;&#125;@RestControllerpublic class HelloController &#123; @Autowired HelloService helloService; @GetMapping(&quot;/hello&quot;) public String hello() &#123; helloService.add(); return &quot;success&quot;; &#125;&#125; &emsp;&emsp;当我们请求这个hello接口时，如果不使用@Async标记方法，那么，线程就会阻塞，我们会在add方法执行完之后，才会返回success。这显然不是我们想要的。 &emsp;&emsp;如果用@Async标记方法，那么，线程就不会阻塞，我们请求hello接口，会立刻返回success，过了三秒钟，才会批量处理完成。这才是我们想要的。 定时任务&emsp;&emsp;定时定点的执行某个任务，就需要用到定时任务。比如，当服务器启动之后，比如，每天晚上23点上传日志，每个月1号给用户发送邮件等等。 &emsp;&emsp;用法都类似： @EnableScheduling 启动类上开启基于注解的定时任务 @Scheduled 标识的方法会进行定时处理 唯一不一样的地方，也是个难点就是cron表达式 先举个例子：在上面例子的基础上加上 123456789101112131415161718192021222324252627282930@EnableScheduling@EnableAsync@SpringBootApplicationpublic class SpringBootTaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootTaskApplication.class, args); &#125;&#125;@Servicepublic class HelloService &#123; @Async public void add() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;批量操作&quot;); &#125; @Scheduled(cron = &quot;1-5 * * * * *&quot;) public void scheduledTaskt() &#123; System.out.println(&quot;执行定时任务&quot;); &#125;&#125; &emsp;&emsp;这个定时任务就是,每分钟的1秒到5秒各执行一次，一共5次。 &emsp;&emsp;cron表达式一共六个值，每个值都要有。一个都不能少，分别代表的含义是：秒 分 时 日 月 星期几 位置 取值范围 可指定的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 时 0-23 , - * / 日 1-31 , - * ? / L W C 月 1-12 , - * / 星期 0-7或SUN-SAT 0和7都是周日，1-6是周一到周六 , - * ? / L C # &emsp;&emsp;特殊字符的含义：|特殊字符|代表含义||:-:|:-:||,|枚举，一个位置上指定多个值，以逗号 ， 分隔||-|区间||*|任意||/|步长，每隔多久执行一次||?|日/星期冲突匹配 ,指定哪个值,另外个就是?||L|最后||W|工作日||C|和calendar联系后计算过的值||#|这个月的第几个星期几，4#2，第2个星期四| 比如： 1234567891011121314151617181920211-5 * * * * 1到5秒，每秒都触发任务 */5 * * * * 每隔5秒执行一次0 */1 * * * 每隔1分钟执行一次 0 0 5-15 * * 每天5-15点整点触发0 0-5 14 * * 在每天下午2点到下午2:05期间的每1分钟触发0 0/5 14 * * 在每天下午2点到下午2:55期间的每5分钟触发0 0/5 14,18 * * 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发0 0/30 9-17 * * 朝九晚五工作时间内每半小时0 0 12 ? * WED 表示每个星期三中午12点0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发0 0 23 L * ? 每月最后一天23点执行一次0 15 10 LW * ? 每个月最后一个工作日的10点15分0秒触发任务0 15 10 ? * 5#3 每个月第三周的星期五的10点15分0秒触发任务 最后附上在线生成cron表达式的链接： http://cron.qqe2.com]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—事务管理（十三）]]></title>
    <url>%2F2019%2F09%2F17%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我们操作数据库，事务管理是必不可少的一部分。 什么是事务&emsp;&emsp;我们在开发企业应用时，用户的一个操作对应数据库可能是多步操作相结合完成的。在这个多个步骤中，其中的一步，可能出现异常，导致后面的步骤无法向下进行，那么，用户的这个操作，可能就没有进行完，前面已经进行的步骤数据就需要回退。 举个总所周知的栗子： &emsp;&emsp;银行的转账，A给B转账，转1000块钱，A的钱需要扣1000，B的钱需要加1000，而，银行的系统在A扣1000块钱之后，B加1000块钱的时候，出现的异常，A的钱扣了，B的钱没有加，这该怎么办？这就需要用到我们的事务管理了。 &emsp;&emsp;事务就是保证用户的每个操作都是可靠的，事务中的每一个步操作都必须成功执行，如果，其中某一个步骤出现了异常，那么就回退到事务开始未进行操作的状态。 &emsp;&emsp;事务管理是Spring框架中最为常见的功能之一，我们在SpringBoot开发应用时，大部分情况下也需要使用事务。 事务管理操作步骤&emsp;&emsp;理论上就只有两步： @EnableTransactionManagement：标记在启动类 @Transactional：标记的service层 &emsp;&emsp;为什么说理论上只需要两步呢？因为，在SpringBoot中，当我们使用 spring-boot-starter-data-jdbc 或者是 spring-boot-starter-data-jpa 依赖的时候，框架会自动帮我们注入 入DataSourceTransactionManager 或者 JpaTransactionManager 。所以，我们不需要进行任何额外的配置，就直接可以使用 @Transactional 注解进行管理事务。 &emsp;&emsp;还有几点需要注意的地方： Hibernate创建表，默认类型是 MyISAM， 是非事务安全的，即使你加上了上面的注解，也不起作用。 Innodb 类型的表才是事务安全的。 需要在你的配置文件中指定： spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect 事务的隔离级别和传播行为&emsp;&emsp;除了指定事务管理器之后，还能对事务进行隔离级别和传播行为的控制，下面分别详细解释： 隔离级别&emsp;&emsp;隔离级别是指在发生并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读、不可重复读、幻读。 脏读：A事务执行的过程中，修改了id=1的数据，这个时候还没有提交，此时，B读取了修改之后id=1的数据，而A事务却回滚了，这样B事务就形成了脏读。 比方说：A的银行卡里原来有1000块钱，买东西花了300，还有700，这个时候A的媳妇查银行卡的余额，一看只剩下700了，然后，A又不喜欢那个东西，把东西退掉了，买东西的钱又退回银行卡了，这个时候，A的媳妇查的钱这个事务就是脏读。回来之后一阵毒打，什么跪键盘，跪榴莲。唉，脏读，真惨。 不可重复读：A事务先读取了id=1的数据，然后执行后面的逻辑，这个时候，B事务修改了id=1的数据，A在执行后面逻辑的时候，又读取了一遍id=1的数据，这个时候发现，两次读取的数据不相同，这就是不可重复读。 比方说：A发工资了，银行卡里发了1000块钱，每天早上查一遍，中午查一遍，好安心。早上9点上班的时候查了一遍余额有1000块钱，A的媳妇，十点多的时候买了个包包花了500块钱，A中午查的时候就剩下500了，他就去找他媳妇理论啊，你干啥了，咋就只剩下500了，他媳妇一听就来气啊，每个月挣这么点钱，我买个包包怎么了，然后就是一阵毒打，跪键盘，跪榴莲。唉，不可重复读，真惨。 幻读：A事务先根据条件查询到了N条数据，然后，B事务新增了M条复合A事务查询条件的数据，导致A事务再次查询的时候，查询到了N+M条数据，就产生了幻觉。 比方说：A的媳妇查询A名下有多少张银行卡，一开始查询有2张（建行，农行），然后，A换了新工作，需要重新再邮政开工资卡。这一天，A的媳妇又查了一遍A名下的银行卡，咦，怎么多了一张邮政的，长能耐了，背着老娘藏私房钱了，于是，就把A一阵毒打，是跪键盘，跪榴莲。唉，幻读，真惨。 &emsp;&emsp;怎么避免上面的三种情况呢？我们可以看 org.springframework.transaction.annotation.Isolation 枚举类中定义了五个表示隔离级别的值： DEFAULT： 这个是默认值，表示使用底层数据库的默认隔离级别，对绝大多数数据库而言，这个值通常就是 READ_COMMITTED。 READ_UNCOMMITTED： 该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。 该级别不能防止脏读和不可重复读， 因此很少使用该隔离级别。 READ_COMMITTED： 该隔离级别表示一个事务只能读取另一个事务已经提交的数据。 该级别可以防止脏读，这也是大多数情况下的推荐值，性能最好。 REPEATABLE_READ： 该隔离级别表示一个事务在整个执行过程中可以多次重复执行某个查询，并且每次返回的数据都相同，即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。 该级别可以防止脏读和不可重复读。 SERIALIZABLE： 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说， 该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 12//指定方式：@Transactional(isolation = Isolation.DEFAULT) 传播行为&emsp;&emsp;传播行为是指，如果在开始当前事务之前，已经存在一个事务，此时可以指定这个要开始的这个事务的执行行为。 &emsp;&emsp;我们可以看 org.springframework.transaction.annotation.Propagation 枚举类中定义了6个表示传播行为的枚举值： REQUIRED:（默认）如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 SUPPORTS:如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 MANDATORY:如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 REQUIRES_NEW:创建一个新的事务，如果当前存在事务，则把当前事务挂起。 NOT_SUPPORTED:以非事务方式运行，如果当前存在事务，则把当前事务挂起。 NEVER:以非事务方式运行，如果当前存在事务，则抛出异常。 NESTED:如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED 。 12//指定方式：@Transactional(propagation = Propagation.REQUIRED) &emsp;&emsp;关于这个事务的隔离级别和传播行为，我们一般都不用特别的去指定，用默认的就行了，除非有特别的要求，默认的隔离级别和传播行为满足绝大多数要求。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—Spring Data JPA（十二）]]></title>
    <url>%2F2019%2F09%2F11%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94Spring-Data-JPA%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是 Spring Data&emsp;&emsp;Spring Data 是 Spring Boot 底层默认进行数据访问的技术 , 为了简化构建基于 Spring 框架应用的数据访问技术，包括非关系数据库、Map-Reduce 框架、云数据服务等；另外也包含对关系数据库的访问支持。 &emsp;&emsp;Spring Data 包含多个模块： Spring Data Commons 提供共享的基础框架，适合各个子项目使用，支持跨数据库持久化 Spring Data JPA Spring Data KeyValue Spring Data LDAP Spring Data MongoDB Spring Data Redis Spring Data REST Spring Data for Apache Cassandra Spring Data for Apache Geode Spring Data for Apache Solr Spring Data for Pivotal GemFire Spring Data Couchbase (community module) Spring Data Elasticsearch (community module) Spring Data Neo4j (community module) Spring Data统一的核心接口&emsp;&emsp;Spring Data项目为大家提供统一的API来对不同的数据访问层进行操作。 Repository：统一的根接口即所有接口的父接口，其他接口继承该接口 CrudRepository：基本的增删改查接口,提供了最基本的对实体类CRUD操作 PagingAndSortingRepository：增加了分页和排序操作 JpaRepository：增加了批量操作，并重写了父接口一些方法的返回类型 &emsp;&emsp;Spring Data JPA、JPA与Hibernate 关系 &emsp;&emsp;JPA是一种规范，而Hibernate是实现这种规范的底层实现，SpringData JPA对持久化接口JPA再抽象一层，针对持久化业务再进一步统一简化。 SpringData JPA的简单使用&emsp;&emsp;JPA的底层遵守是ORM(对象关系映射)规范，因此JPA其实也就是java实体对象和关系型数据库建立起映射关系，通过面向对象编程的思想操作关系型数据库的规范。 首先，导包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.haichenyi&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-jpa&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-jpa&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--jdbc的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jpa的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web项目的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql的包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--简化set/get的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 其次，创建映射bean类 12345678910111213141516171819package com.haichenyi.springbootjpa.entity;import lombok.Data;import javax.persistence.*;//使用JPA注解配置映射关系@Entity//说明它是和数据表映射的类@Table(name = &quot;tbl_hobby&quot;)//指定对应映射的表名，省略默认表名就是类名@Datapublic class Hobby &#123; @Id//标识主键 @GeneratedValue(strategy = GenerationType.IDENTITY)////标识自增长主键 private Integer id; @Column(name = &quot;name&quot;, length = 10)//这是和数据表对应的一个列即字段名 private String name; @Column//没有写，表字段名与这里的字段名相同 private Integer time;&#125; &emsp;&emsp;需要注意的是，这里需要写set/get方法，不然，数据存不进去。这里我用了 @Data 注解，所以，就不需要写了。注释写的很清楚了，就不一一解释了。 接着，写Repository 1234567891011package com.haichenyi.springbootjpa.repository;import com.haichenyi.springbootjpa.entity.Hobby;import org.springframework.data.jpa.repository.JpaRepository;/** * 自定义接口继承JpaRepository，就会crud及分页等基本功能 *///指定的泛型&lt;操作的实体类，主键的类型&gt;public interface HobbyRepository extends JpaRepository&lt;Hobby, Integer&gt; &#123;&#125; 再然后，就是Controller，跟之前写的一样 123456789101112131415161718192021222324252627package com.haichenyi.springbootjpa.controller;import com.haichenyi.springbootjpa.entity.Hobby;import com.haichenyi.springbootjpa.repository.HobbyRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.Optional;@RestControllerpublic class HobbyController &#123; @Autowired HobbyRepository hobbyRepository; @GetMapping(&quot;/hobby/&#123;id&#125;&quot;) public Hobby getHobbyInfo(@PathVariable(&quot;id&quot;) Integer id) &#123; Optional&lt;Hobby&gt; hobbyOptional = hobbyRepository.findById(id); return hobbyOptional.get(); &#125; @GetMapping(&quot;/save&quot;) public Hobby saveHobby(Hobby hobby) &#123; System.out.println(hobby); return hobbyRepository.save(hobby); &#125;&#125; 最后，就只配置了 1234567891011121314spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver jpa: show-sql: true hibernate: ddl-auto: update database-platform: org.hibernate.dialect.MySQL5InnoDBDialect main: allow-bean-definition-overriding: true &emsp;&emsp;这样写完就行了。就这四步： 映射表 Repository接口 Controller 配置文件]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—MyBatis（十一）]]></title>
    <url>%2F2019%2F09%2F07%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94MyBatis%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇，Druid是用于处理数据库连接池与后台监控。 &emsp;&emsp;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。——百度百科 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; &emsp;&emsp;MyBatis添加依赖跟SpringBoot的其他启动器不一样，MyBatis需要写版本号，因为，SpringBoot并没有MyBatis的启动器。 用法注解的方式&emsp;&emsp;先看一下项目结构： &emsp;&emsp;首先，我们先在连接的数据库里面创建表，添加几条数据。 &emsp;&emsp;然后，创建pojo类User，对应我的表 12345678910111213141516package com.haichenyi.springbootjdbc.pojo;import lombok.Data;@Datapublic class User &#123; public Long UserId; public String Username; public String password; public String nickName; public String headImg; public Integer age; public Integer sex; public String address; public String desc;&#125; &emsp;&emsp;接着，创建mapper接口 12345678910111213package com.haichenyi.springbootjdbc.mapper;import com.haichenyi.springbootjdbc.pojo.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapperpublic interface UserMapper &#123; @Select(&quot;select * from userinfo&quot;) List&lt;User&gt; getUserInfo();&#125; &emsp;&emsp;就是一个普通的接口，用 @Mapper 标识了。然后写了一个获取用户信息的方法。 @Select 里面是sql语句。 &emsp;&emsp;用 @Mapper 标识的接口，在运行的过程中，会帮我们生成实现类，到时候，我们直接通过这个接口的引用调用这个方法即可。我们也可以在入口的位置用 @MapperScan 标识包名，应用启动的时候，会给这个包下面的所有接口都生成实现类。如下 123456789101112131415package com.haichenyi.springbootjdbc;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@MapperScan(&quot;com.haichenyi.springbootjdbc.mapper&quot;)@SpringBootApplicationpublic class SpringBootJdbcApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootJdbcApplication.class, args); &#125;&#125; &emsp;&emsp;最后，就是我们的controller层了。 123456789101112131415161718192021package com.haichenyi.springbootjdbc.controller;import com.haichenyi.springbootjdbc.mapper.UserMapper;import com.haichenyi.springbootjdbc.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class UserController &#123; @Autowired UserMapper userMapper; @RequestMapping(&quot;/getUserInfo&quot;) public List&lt;User&gt; getUserInfo() &#123; return userMapper.getUserInfo(); &#125;&#125; &emsp;&emsp;这样，我们就可以通过 http://localhost:8080/getUserInfo 读到数据库中的数据了 &emsp;&emsp;只这样，我们读到的数据，如果表字段与pojo类的字段不一一对应，我们可能读到的数据为空，所以，我们要开启驼峰命名，开启之后MyBatis会帮我们一一对应好。怎么开启呢？就在我们前面的JdbcConfig中添加如下方法即可。就跟我们前面一篇Druid添加配置类似。 1234567891011121314/** * MyBatis自定义配置 * * @return ConfigurationCustomizer */ @Bean public ConfigurationCustomizer configurationCustomizer() &#123; return configuration -&gt; &#123; //开启驼峰命名 configuration.setMapUnderscoreToCamelCase(true); //开启二级缓存 configuration.setCacheEnabled(true); &#125;; &#125; &emsp;&emsp;这样就可以了。 xml的方式&emsp;&emsp;前面和后面都是一样的，就是中间那不创建mapper接口不一样。xml中怎么创建mapper呢？ &emsp;&emsp;首先，还是创建一个正常的接口，定义方法。如下：注释写的很清楚了。 12345678910111213package com.haichenyi.springbootjdbc.mapper;import com.haichenyi.springbootjdbc.pojo.User;import org.apache.ibatis.annotations.Select;import java.util.List;//这里如果没有@Mapper注解，那就在启动类添加@MapperScan注解，上面已经说过怎么添加了。两种方式都可以，标记mapper的接口还是需要的public interface UserMapper &#123;//这里的sql语句就不需要了，sql语句在xml里面配置。// @Select(&quot;select * from userinfo&quot;) List&lt;User&gt; getUserInfo();&#125; &emsp;&emsp;然后，添加两个xml，一个是config，一个是写sql语句的。路径需要注意，先在resources目录下创建一个mybatis目录，在mybatis目录下创建mybatis-config.xml，在mybatis目录下创建mapper目录，然后在mapper目录下创建你的mapper.xml文件，如下： &emsp;&emsp;这个是写mybatis配置文件的，名字我写的是：mybatis-config.xml，这个路径12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!--开启驼峰命名--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; &emsp;&emsp;然后就是创建mapper.xml，这里，我们以UserMapper.xml为例： 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace要是你前面创建mapper接口的全路径，这样才能对应--&gt;&lt;mapper namespace=&quot;com.haichenyi.springbootjdbc.mapper.UserMapper&quot;&gt; &lt;!--id：是你前面接口里面创建的方法名--&gt; &lt;!-- resultType：这里的返回类型就是你接口读取数据对应的bean类，不管你需要的是集合，还是单个对象，这里都是你bean类， 如果你读取的是多条数据，它会自动帮你封装成list，拿到这个list，你再去做你其他的处理 --&gt; &lt;select id=&quot;getUserInfo&quot; resultType=&quot;com.haichenyi.springbootjdbc.pojo.User&quot;&gt; select * from userinfo &lt;/select&gt;&lt;/mapper&gt; &emsp;&emsp;注释写的很清楚了。 &emsp;&emsp;再就是配置这个两个xml路径了，你需要在你的全局配置文件中配置好，指定对应的路径： 12345mybatis: #核心配置文件路径 config-location: classpath:mybatis/mybatis-config.xml #映射配置文件路径 mapper-locations: classpath:mybatis/mapper/*.xml &emsp;&emsp;为啥非要创建一个mapper目录，再创建mapper文件呢？就是这里好指定。mapper文件肯定不止一个，难道你要一个一个的配置吗？这样写只用指定一个就可以了。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—Druid（十）]]></title>
    <url>%2F2019%2F09%2F05%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94Druid%EF%BC%88%E5%8D%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一个企业项目中最重要的部分那就是数据库了，对数据库的连接，读写是重中之重。在SpringBoot中数据库怎么连接呢？ 数据库的连接&emsp;&emsp;这里以MySql为例，还不会用MySql数据库的童鞋，可以看我之前的博客，数据库相关。 &emsp;&emsp; 第一步， 我们首先在pom.xml中添加jdbc相关的启动器。 1234567891011&lt;!--jdbc启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--mysql驱动包--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; &emsp;&emsp; 第二步， 在配置文件中配置连接数据库的信息： 123456789101112spring: datasource: #连接数据库的账号 username: root #连接数据库的密码 password: 123456 #连接数据库的url url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8 #连接数据库的驱动类 #mysql8之前用的是：com.mysql.jdbc.Driver。 #mysql8之后用的是：com.mysql.cj.jdbc.Driver driver-class-name: com.mysql.cj.jdbc.Driver &emsp;&emsp; 添加如上信息，就基本上完成了。测试一下连接就可以了。在我们的测试类中添加如下代码，看看打印的数据即可。 123456789101112131415161718192021222324252627package com.haichenyi.springbootjdbc;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootJdbcApplicationTests &#123; @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException &#123; System.out.println(&quot;dataSource: &quot; + dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(&quot;connection: &quot; + connection); connection.close(); &#125;&#125; &emsp;&emsp; 我们这里是测试数据库是否连接成功，我们才获取的这个连接，打印出来，我们项目里面实际操作数据库的时候，不需要我们获取这个连接，然后通过这个连接再去操作数据库。这是不需要，MyBatis通过Mapping注解直接操作数据库，我们只用写sql语句就可以了。 Druid连接数据库&emsp;&emsp; DRUID是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是目前最好的连接池。 &emsp;&emsp; 上面的配置继续保留。 &emsp;&emsp; 第一步： 我们在pom.xml里面添加druid的依赖： 123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.20&lt;/version&gt;&lt;/dependency&gt; &emsp;&emsp; 第二步： 在yml文件中添加如下代码： 1234567891011121314151617181920212223242526272829303132333435363738spring: # 数据库访问配置 datasource: #账号 username: root #密码 password: 123456 #连接的url url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8 #驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 主数据源，默认的 type: com.alibaba.druid.pool.DruidDataSource # 下面为连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 5 minIdle: 5 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 25 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙 filters: stat,wall,logback # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true &emsp;&emsp; 这样，就可以了。继续运行刚才的测试方法，你会发现，打印数据里面数据源已经变成了DruidDataSource。 &emsp;&emsp; 你如果是debug运行的，并且，你的断点打在connection那里，你会发现，我们yml文件中的补充配置，没起作用，是为什么呢？ &emsp;&emsp; 我们按住CTRL，鼠标左键点补充配置里面的任意一个变量，都点不动，我们点上面的type，url等等，都能点，我们点过去看，我们会发现跳到了 DataSourceProperties 。这个类，顾名思义这是数据源配置文件类。我们大致看一下这个类的代码： &emsp;&emsp; 用红色框框，框出来的地方是不是很眼熟？ &emsp;&emsp; 首先，我们先看注解 @ConfigurationProperties， 这个注解就是表示这个类是配置类，然后，我们看括号里面的参数 prefix， 顾名思义：前缀，前置代码。 &emsp;&emsp; 如上图，上面的红色框框的内容，就由prefix决定，下面红色框框的内容，就由这个类的变量决定。我们上面的补充设置不起作用，就是因为这个配置文件里面没有这些变量，SpringBoot识别不了，所以，不起作用。SpringBoot不是万能的，它配置了的东西，可以识别，没有配置的，识别不了。 &emsp;&emsp; 怎么样让上面的补充配置起作用呢？有多种方式： &emsp;&emsp; 第一种方式如下： 简单粗暴，添加一个配置类即可 1234567891011121314151617package com.haichenyi.springbootjdbc.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;@Configurationpublic class JdbcConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource dataSource()&#123; return new DruidDataSource(); &#125;&#125; &emsp;&emsp; 这个方式就相当于，把我们上面的这个 DataSourceProperties配置类，换成了 DruidDataSource类。 &emsp;&emsp; 第二种方式如下： 比较麻烦，也不算特别麻烦：说白了就是加载局部配置。 &emsp;&emsp;首先，在resources目录下，新建一个jdbc.properties文件 12345678910111213141516171819202122232425262728293031323334#账号druid.datasource.username=root#密码druid.datasource.password=123456#连接的urldruid.datasource.url=jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8#驱动类druid.datasource.driverClassName=com.mysql.cj.jdbc.Driver# 主数据源，默认的# druid.datasource.type=com.alibaba.druid.pool.DruidDataSource# 下面为连接池的补充设置，应用到上面所有数据源中# 初始化大小，最小，最大druid.datasource.initialSize=5druid.datasource.minIdle=5druid.datasource.maxActive=20# 配置获取连接等待超时的时间druid.datasource.maxWait=60000# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒druid.datasource.timeBetweenEvictionRunsMillis=60000# 配置一个连接在池中最小生存的时间，单位是毫秒druid.datasource.minEvictableIdleTimeMillis=300000druid.datasource.validationQuery=SELECT 1 FROM DUALdruid.datasource.testWhileIdle=truedruid.datasource.testOnBorrow=falsedruid.datasource.testOnReturn=false# 打开PSCache，并且指定每个连接上PSCache的大小druid.datasource.poolPreparedStatements=truedruid.datasource.maxPoolPreparedStatementPerConnectionSize=25# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙druid.datasource.filters=stat,wall,logback# 通过connectProperties属性来打开mergeSql功能；慢SQL记录druid.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500# 合并多个DruidDataSource的监控数据druid.datasource.useGlobalDataSourceStat=true &emsp;&emsp;就是把我们刚才在全局配置中配置的信息，在专门的jdbc的配置文件中配置一遍。然后，修改我们的JdbcConfig类。如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.haichenyi.springbootjdbc.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import javax.sql.DataSource;import java.sql.SQLException;@Configuration@PropertySource(value = &quot;classpath:config/jdbc.properties&quot;, ignoreResourceNotFound = true)public class JdbcConfig &#123; @Value(&quot;$&#123;druid.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;druid.datasource.password&#125;&quot;) private String password; @Value(&quot;$&#123;druid.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;druid.datasource.driverClassName&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;druid.datasource.initialSize&#125;&quot;) private Integer initialSize; @Value(&quot;$&#123;druid.datasource.minIdle&#125;&quot;) private Integer minIdle; @Value(&quot;$&#123;druid.datasource.maxActive&#125;&quot;) private Integer maxActive; @Value(&quot;$&#123;druid.datasource.maxWait&#125;&quot;) private Long maxWait; @Value(&quot;$&#123;druid.datasource.timeBetweenEvictionRunsMillis&#125;&quot;) private Long timeBetweenEvictionRunsMillis; @Value(&quot;$&#123;druid.datasource.minEvictableIdleTimeMillis&#125;&quot;) private Long minEvictableIdleTimeMillis; @Value(&quot;$&#123;druid.datasource.validationQuery&#125;&quot;) private String validationQuery; @Value(&quot;$&#123;druid.datasource.testWhileIdle&#125;&quot;) private Boolean testWhileIdle; @Value(&quot;$&#123;druid.datasource.testOnBorrow&#125;&quot;) private Boolean testOnBorrow; @Value(&quot;$&#123;druid.datasource.testOnReturn&#125;&quot;) private Boolean testOnReturn; @Value(&quot;$&#123;druid.datasource.maxPoolPreparedStatementPerConnectionSize&#125;&quot;) private Integer maxPoolPreparedStatementPerConnectionSize; @Value(&quot;$&#123;druid.datasource.poolPreparedStatements&#125;&quot;) private Boolean poolPreparedStatements; @Value(&quot;$&#123;druid.datasource.filters&#125;&quot;) private String filters; @Value(&quot;$&#123;druid.datasource.connectionProperties&#125;&quot;) private String connectionProperties; @Value(&quot;$&#123;druid.datasource.useGlobalDataSourceStat&#125;&quot;) private Boolean useGlobalDataSourceStat; @Bean public DataSource dataSource() throws SQLException &#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUsername(username); druidDataSource.setPassword(password); druidDataSource.setUrl(url); druidDataSource.setDriverClassName(driverClassName); druidDataSource.setInitialSize(initialSize); druidDataSource.setMinIdle(minIdle); druidDataSource.setMaxActive(maxActive); druidDataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis); druidDataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); druidDataSource.setValidationQuery(validationQuery); druidDataSource.setTestOnBorrow(testOnBorrow); druidDataSource.setTestOnReturn(testOnReturn); druidDataSource.setTestWhileIdle(testWhileIdle); druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); druidDataSource.setPoolPreparedStatements(poolPreparedStatements); druidDataSource.setFilters(filters); druidDataSource.setConnectionProperties(connectionProperties); druidDataSource.setUseGlobalDataSourceStat(useGlobalDataSourceStat); return druidDataSource; &#125;&#125; &emsp;&emsp;就是加载配置文件，然后在DataSource里面赋值。这样，就可以了。 Druid后台监控&emsp;&emsp;之所以用Druid连接池，还有很大一部分原因就是它的监控功能。它能很好的监控DB连接池和SQL语句的执行情况。在上面的JdbcConfig类中添加如下两个方法即可。 12345678910111213141516171819202122232425262728293031323334353637/** * 配置Druid监控 * * @return StatViewServlet */@Beanpublic ServletRegistrationBean servletRegistrationBean() &#123; ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //访问的用户名密码 map.put(StatViewServlet.PARAM_NAME_USERNAME, &quot;haichenyi&quot;); map.put(StatViewServlet.PARAM_NAME_PASSWORD, &quot;123456&quot;); //允许访问的ip，默认是所有ip map.put(StatViewServlet.PARAM_NAME_ALLOW, &quot;&quot;); //禁止访问的ip map.put(StatViewServlet.PARAM_NAME_DENY, &quot;192.168.1.1&quot;); bean.setInitParameters(map); return bean;&#125;/** * 配置一个监控的filter * * @return WebStatFilter */@Beanpublic FilterRegistrationBean filterRegistrationBean() &#123; FilterRegistrationBean&lt;WebStatFilter&gt; bean = new FilterRegistrationBean&lt;&gt;(); bean.setFilter(new WebStatFilter()); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //移除这些监听 map.put(WebStatFilter.PARAM_NAME_EXCLUSIONS, &quot;*.js,*.css,/druid/*,*.gif,*.jpg,*.png&quot;); bean.setInitParameters(map); //拦截所有请求，全部都要走druid监听 bean.setUrlPatterns(Collections.singletonList(&quot;/*&quot;)); return bean;&#125; &emsp;&emsp;注释写的很清楚了，控制台怎么访问呢？ http://localhost:8080/druid。访问控制台]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—自定义拦截器（九）]]></title>
    <url>%2F2019%2F09%2F05%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88%E4%B9%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;拦截器拦截请求做额外的处理。 举个栗子：登录拦截器，拦截所有的请求，必须登录之后才能访问。 12345678910111213141516171819202122package com.haichenyi.springbootbill.interceptors;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 登录拦截器 */public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(&quot;user&quot;); if (user != null) &#123; return true; &#125; request.setAttribute(&quot;msg&quot;, &quot;您还没有登录，请先登录！&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request, response); return false; &#125;&#125; &emsp;&emsp;新建LoginInterceptor实现HandlerInterceptor接口。这个接口有三个方法，pre，post，after， 看这个名字就可以想到这三个方法是怎么调用的，发送请求前，发送过程中，发送请求成功之后，所以，根据自己的需求，实现对应的方法即可。 &emsp;&emsp;我这里是登录拦截器，所以，在发送请求之前就要拦截，走自己的逻辑，如果，没有登陆过，就跳转登录界面，所以，我这里就实现了发送请求之前的回调，即preHandle方法。 &emsp;&emsp;然后，在你的SpringMvcConfiguration里面加上拦截器即可。 123456789101112131415161718192021222324252627282930313233343536373839package com.haichenyi.springbootbill.config;import com.haichenyi.springbootbill.component.MyLocalResolver;import com.haichenyi.springbootbill.interceptors.LoginInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.LocaleResolver;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MySpringMvcConfig &#123; @Bean public WebMvcConfigurer webMvcConfigurer() &#123; return new WebMvcConfigurer() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;main/login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;main/login&quot;); registry.addViewController(&quot;/main/index.html&quot;).setViewName(&quot;main/index&quot;); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/&quot;, &quot;/index.html&quot;, &quot;/login&quot;) .excludePathPatterns(&quot;/css/*&quot;,&quot;/img/*&quot;,&quot;/images/*&quot;,&quot;/js/*&quot;); &#125; &#125;; &#125; @Bean public LocaleResolver localeResolver() &#123; return new MyLocalResolver(); &#125;&#125; &emsp;&emsp;实现addInterceptors方法，添加拦截器，然后添加了 addPathPatterns 拦截所有带这个参数的请求。接着，又添加了 excludePathPatterns 不拦截所有带这个参数的请求。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—国际化（八）]]></title>
    <url>%2F2019%2F09%2F02%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;所谓的国际化就是语言切换。中文切换到其他语种。 &emsp;&emsp;国际化的信息，这些都是需要开发人员在配置类中配置好的。SpringBoot会自动加载这些配置类。 举个栗子：以登录界面为例，我们的登录界面输入账号、密码框的左边，会有这两个提示，我们就自动修改这两个提示。 创建配置文件&emsp;&emsp;首先，你要在你的resources目录下面新建i18n目录，当然，不是必须的，可以不创建，直接创建文件。之所以创建这个目录，只是便于管理。 &emsp;&emsp;然后，在i18n目录下面创建配置文件，操作如下： &emsp;&emsp;在i18n的目录下面，新建一个Resources Bundle类型的文件，名字叫login &emsp;&emsp;点击+号，创建中文，英文两种语言的配置文件。中文叫 zh_CN，英文叫 en_US，这两种类型是写死的。 &emsp;&emsp;根据如上操作，分别创建key为login.username，login.password，并且分别创建好对应的内容。这个key，页面会用到。 PS：不要忘记了，在全局配置文件中配置好，spring.messages.basename=i18n.login，这里现在是只有一个登陆页面需要国际化，如果有多个页面需要，比方说注册页面，就在后面添加。如：spring.messages.basename=i18n.login,i19n.register这样的方式，中间用逗号隔开即可。 修改页面显示内容&emsp;&emsp;按照上面的步骤，创建好了之后，在你页面需要国际化的view，分别按如下的方式获取值： 123456789&lt;!--th:text=&quot;#&#123;上面命名的key&#125;&quot;--&gt;&lt;div class=&quot;inputbox&quot;&gt; &lt;label for=&quot;user&quot; th:text=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/label&gt; &lt;input id=&quot;user&quot; type=&quot;text&quot; name=&quot;username&quot; required/&gt; &lt;/div&gt; &lt;div class=&quot;inputbox&quot;&gt; &lt;label for=&quot;mima&quot; th:text=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/label&gt; &lt;input id=&quot;mima&quot; type=&quot;password&quot; name=&quot;password&quot; required/&gt; &lt;/div&gt; 自定义区域解析器&emsp;&emsp;区域解析器LocaleResolver，按如下的方式实现即可。 1234567891011121314151617181920212223242526272829package com.haichenyi.springbootbill.component;import org.springframework.util.StringUtils;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;/** * 自定义区域解析器 */public class MyLocalResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; String l = httpServletRequest.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault(); if (!StringUtils.isEmpty(l)) &#123; String[] s = l.split(&quot;_&quot;); locale = new Locale(s[0], s[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125; &emsp;&emsp;最后，在你对应的超链接的地方传 zh_CN 和 en_US 即可实现。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—热部署与SpringMVC扩展功能（七）]]></title>
    <url>%2F2019%2F08%2F30%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E7%83%AD%E9%83%A8%E7%BD%B2%E4%B8%8ESpringMVC%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[热部署&emsp;&emsp;默认情况下，在开发中我们修改一个项目文件后，想看到效果不得不重启应用，这会导致浪费大量时间，我们希望不重启应用的情况下，程序可以自动部署（热部署）。 &emsp;&emsp;第一步：禁用缓存 12#开发环境下关闭thymeleaf模板缓存，thymeleaf默认是开启状态。记得发布的时候要打开spring.thymeleaf.cache=false &emsp;&emsp;第二步：添加热部署依赖 12345&lt;!--热部署--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; &emsp;&emsp;第三步：手动编译文件 &emsp;&emsp;IDEA中，修改文件后都是自动保存的，并不会手动编译，所以，需要手动编译一下。Ctrl + F9 （推荐使用）或 Build -&gt; Build Project。 SpringMVC 扩展功能举个栗子：我要访问前面都是在controller里面，写方法，方法里面可以写逻辑，跳转某一个页面。我现在不需要写逻辑，就直接跳转就行了。我可以这样写。 12345678910111213package com.haichenyi.springbootwebthymeleaf.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/success&quot;).setViewName(&quot;success&quot;); &#125;&#125; 新建一个类，继承WebMvcConfigurer，并用@Configuration标识 实现addViewControllers方法，里面registry里面像上面添加就行了，前面传链接名字，后面传视图名字即可。 &emsp;&emsp;这只是添加控制层，还有其他的功能。可以看WebMvcConfigurer接口的方法。需要什么功能，实现什么方法就行了。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—Thymeleaf（六）]]></title>
    <url>%2F2019%2F08%2F29%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94Thymeleaf%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[引用公共片段 th:fragment,th:replace,th:insert&emsp;&emsp;很多页面有很多相同的内容，比方说header和foot，这样的内容就需要公共片段引用了，修改一个地方就全部都改了。类似于android里面提取公共方法一样的道理。 方式如下图： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;公共片段&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--通过th:fragment申明公共片段--&gt;&lt;div th:fragment=&quot;header_common&quot;&gt;这里是公共片段的内容&lt;/div&gt;&lt;!--通过id申明公共片段--&gt;&lt;div id=&quot;header_common_id&quot;&gt;这里是公共片段的内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--引入公共片段--&gt;&lt;div th:replace=&quot;header :: header_common&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;header :: #header_common_id&quot;&gt;&lt;/div&gt; 总共分为两步： 创建header.html的文件，里面定义公共片段的内容，用th:fragment标明，值为header_common 在你需要用到这个公共部分的位置，通过th:fragment申明的片段用th:relpace引入，值为 文件名 空格 双冒号 空格 th:fragment的值。也就是这里的 header :: header_common 通过id申明的片段用th:replace引入，值为 文件名 空格 双冒号 空格 # th:fragment的值。也就是这里的 header :: #header_common_id th:insert 和 th:replace的区别 &emsp;&emsp;th:insert和th:replace都可以引入片段，用的方式是一样的，两者的区别在于 th:insert： 保留引入时使用的标签 th:replace：不保留引入时使用的标签, 将声明片段直接覆盖当前引用标签 迭代器 th:each&emsp;&emsp; 首先，创建一个实体类User。如下： 1234567891011121314151617181920212223242526package com.haichenyi.springbootwebthymeleaf.pojo;public class User &#123; private String username; private Integer age; //1:女，2:男 private Integer sex; public String getUsername() &#123; return username; &#125; public Integer getAge() &#123; return age; &#125; public Integer getSex() &#123; return sex; &#125; public User(String username, Integer age, Integer sex) &#123; this.username = username; this.age = age; this.sex = sex; &#125;&#125; &emsp;&emsp;其次，在controller创建一个获取User的方法。如下： 123456789@RequestMapping(&quot;/userInfo&quot;)public String getUserInfo(Model model) &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(&quot;小雪&quot;, 18, 1)); userList.add(new User(&quot;小红&quot;, 18, 1)); userList.add(new User(&quot;小东&quot;, 18, 2)); model.addAttribute(&quot;userList&quot;, userList); return &quot;userInfo&quot;;&#125; &emsp;&emsp;这里，我用的model返回的数据，添加了一个属性以”userList”为键。页面直接获取这个键，就能拿到对应的值。之后返回userInfo页面。 &emsp;&emsp;最后页面的使用，如下，创建userInfo.html专门使用这个： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;用户信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;user:$&#123;userList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.sex==1?&apos;女&apos;:&apos;男&apos;&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;ul&gt; &lt;li th:each=&quot;user:$&#123;userList&#125;&quot; th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- user : 第1个值,代表每次迭代出对象,名字任意取 iterStat : 第2个值,代表每次迭代器内置对象, 名字任意取, 并有如下属性: index : 当前迭代下标 0 开始 count : 当前迭代下标 1 开始 size : 获取总记录数 current : 当前迭代出的对象 even/odd : 当前迭代是偶数还是奇数 (1开始算,返回布尔值) first : 当前是否为第一个元素 last : 当前是否为最后一个元素 --&gt; &lt;tr th:each=&quot;user,iterStat:$&#123;userList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.sex==1?&apos;女&apos;:&apos;男&apos;&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;iterStat.index&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;iterStat.count&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;iterStat.size&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;iterStat.current&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;iterStat.even&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;iterStat.first&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;iterStat.last&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;注意的地方就是： th:each=”user:${userList}”，这里可以参考java里面的foreach循环，冒号前面是当前循环的变量(冒号前面可以有两个值)，冒号后面是集合。这个集合怎么获取到的？就是通过userList这个键。第二步存的。 拿到这个集合中的每一个变量值了，用就很简单了。 条件判断12345678910&lt;h3 th:if=&quot;not $&#123;#lists.isEmpty(userList)&#125;&quot;&gt;th:if判断,如果此文字显示说明有值&lt;/h3&gt;&lt;h3 th:unless=&quot;$&#123;#lists.isEmpty(userList)&#125;&quot;&gt;th:unless判断,如果此文字显示说明有值&lt;/h3&gt;&lt;div th:switch=&quot;$&#123;flag&#125;&quot;&gt; &lt;p th:case=&quot;1&quot; th:text=&quot;女&quot;&gt;&lt;/p&gt; &lt;p th:case=&quot;2&quot; th:text=&quot;男&quot;&gt;&lt;/p&gt; &lt;!--上面两条都不生效，则下面th:case=&quot;*&quot;生效，类似于default--&gt; &lt;p th:case=&quot;*&quot; th:text=&quot;未知&quot;&gt;&lt;/p&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—Thymeleaf（五）]]></title>
    <url>%2F2019%2F08%2F27%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94Thymeleaf%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;SpringBoot官方不推荐使用JSP，因为内嵌Tomcat，Jetty容器不支持以jar的方式运行JSP。SpringBoot中提供了大量模板引擎，包含Freemarker，Mastache，Thymeleaf等。而SpringBoot官方推荐使用Thymeleaf作为模板引擎，因为Thymeleaf提供了完美的SpringMVC的支持。 添加启动器12345&lt;!-- thymeleaf 模板启动器 --&gt; &lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 添加模板文件存放位置&emsp;&emsp; 模板文件，就是我们创建的HTML文件，将创建好的 HTML 页面放到 classpath:/templates/ 目录下， Thymeleaf 就能自动渲染。就是我们的 resources/templates/目录。 使用&emsp;&emsp; 自动渲染数据从哪里来呢？跟写APP端的接口差不多，就是少了响应@ResponseBody注解。如下： 12345678910111213141516171819202122232425262728package com.haichenyi.springbootwebthymeleaf.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController &#123; /** * APP接口 * @return 返回一个字符串 */ @ResponseBody @RequestMapping(&quot;/hello&quot;) public String sayHello() &#123; return &quot;hello&quot;; &#125; /** * 返回模板文件 * @return 返回名字叫success的HTML页面 */ @RequestMapping(&quot;/hello1&quot;) public String sayHello1() &#123; return &quot;success&quot;; &#125;&#125; 项目结构图如下： &emsp;&emsp; 如上所示，当访问 http://localhost:8080/hello的时候，返回的是一个字符串叫hello。当访问http://localhost:8080/hello1的时候，他会转到我们上面说的templates目录下的success.html页面。 thymeleaf语法使用HTML中添加命名空间1xmlns:th=&quot;http://www.thymeleaf.org&quot; 简单的使用123456789/** * 返回模板文件 * @return 返回名字叫success的HTML页面 */ @RequestMapping(&quot;/hello1&quot;) public String sayHello1(Map&lt;String,Object&gt; map) &#123; map.put(&quot;name&quot;,&quot;我是海晨忆&quot;); return &quot;success&quot;; &#125; &emsp;&emsp;还上啊上面的那个方法，添加了一个map参数。这个参数就是返回给success界面的数据存放容器。存放了一个键值对，键是name &emsp;&emsp;界面怎么使用呢？ 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;success模板文件&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;success 模板文件&lt;/p&gt;&lt;p2 th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/p2&gt;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;就这样，直接使用这个键即可。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—全局配置（四）]]></title>
    <url>%2F2019%2F08%2F23%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;用IDEA可以直接创建SpringBoot项目，创建Moudle的时候，在选Maven的地方，选择Sping Initializr即可，很简单。前面讲过了IDEA生成Maven项目，并且嵌入SpringBoot，直接创建Spring Boot项目就是IDEA直接帮我们依赖，并且生成Application和properties文件。其它，也没啥大的区别，就不多说了。 &emsp;&emsp;本篇要讲的是SpringBoot的配置文件，分为两种： properties yml &emsp;&emsp;之前，搜SpringBoot的配置文件怎么写的时候，看到网上很多博客都有文件内容，但是有两种写法，就是这两种配置文件的不同写法。 &emsp;&emsp;举个栗子，我现在要修改服务器启动的端口号，用properties怎么修改呢？很简单： &emsp;&emsp;如上图所示，是不是很简单？ 1server.port=8081 &emsp;&emsp;用yml怎么修改呢？也不难： &emsp;&emsp;如上图所示：也不难 12server: port: 808 &emsp;&emsp;看到了上面两个图片，应该也已经发现了，两个配置文件存放位置都在resource目录下面。或者在类路径的”/config”路径下 &emsp;&emsp;这两种写法要怎么写呢？ properties： 等号连接，右边是值 yml：key: value 表示一对键值对（冒号后面必须要有空格） 使用空格缩进表示层级关系 左侧缩进的空格数目不重要，只要同一层级的元素左侧对齐即可 key 与 value 大小写敏感 PS: yml不管是存map，还是list，都要记得key后面的冒号一定要跟空格，再写值 &emsp;&emsp;举个栗子，我们定义一个bean类，在配置文件里面赋值，在项目里面取出来用。比方说：我们项目里面定义一个Userbean类。 12345678910111213141516package com.haichenyi.springboot.pojo;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Data@Component@ConfigurationProperties(prefix = &quot;user&quot;)public class User &#123; private String username; private String nickname; private String password; private Integer age;&#125; &emsp;&emsp;这里有几点需要注意： 这里的bean类，必须要有写set/get方法，不然赋不了值，我这里没写是因为我用的@Data这个注解，它默认帮我们创建了set/get方法 @ConfigurationProperties注解就是 告诉SpringBoot将配置文件中对应属性的值，映射到这个组件类中,进行一 一绑定，prefix = “user”的作用就是配置文件中的前缀名，哪个前缀与下面的所有属性进行一一映射 @Component 注解就是将当前组件也就是这个bean类作为SpringBoot中的一个组件，才能使用容器提供的 然后就是在配置文件中赋值，properties或者是yml，都可以： 12345678910111213141516171819properties中： server.port=8081user.username=s19734682suser.age=20user.password=123456user.nickname=林汐痕yml中：server: port: 8088 //这个user就是上面说的配置文件中的前缀名user: nickname: 海晨忆 username: pk19734682 password: 123456 age: 18 &emsp;&emsp;怎么使用呢？直接在controller中用这个user就可以了 12345678910111213141516171819package com.haichenyi.springboot.controller;import com.haichenyi.springboot.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class SayController &#123; @Autowired private User user; @ResponseBody @RequestMapping(&quot;/say&quot;) public String say() &#123; return &quot;hello &quot; +user; &#125;&#125; &emsp;&emsp;就这样，请求这个接口就能打印值。 &emsp;&emsp;还有通过@Value指定值的方式 1234567891011@Controllerpublic class SayController &#123; @Value(&quot;$&#123;user.nickname&#125;&quot;) private String nickname; @ResponseBody @RequestMapping(&quot;/say&quot;) public String say() &#123; return &quot;hello &quot; + nickname; &#125;&#125; @PropertySource 加载局部配置文件&emsp;&emsp;什么叫加载局部配置文件呢？就是加载指定的配置文件，并不是从properties或者是yml中加载。怎么加载呢？如下图： 第一步， 在resources目录下创建xxx.properties/xxx.yml，这个xxx你自己命名。我这里创建的是user.properties/user.yml。记得语法不要写错了 第二步， 在你的组件的地方加上@PropertySource注解。图上有，可以导入多个局部配置，用逗号隔开，每个局部配置的写法就是 “classpath:文件名” 之前导入全局的配置的时候加的注解也需要，不能删除。 第三步， 之前是怎么使用的，现在还是怎么使用。 @ImportResource加载xml配置文件&emsp;&emsp;Spring Boot框架并不推荐用xml加载配置文件，这个是Spring加载文件的方式。项目中如果必须要用到xml加载文件，要怎么办呢？ 举个栗子：我要加载一个Service类到项目中。Spring Boot有注解可以直接使用，这里，我们通过xml加载。 第一步， 创建一个service。 1234567package com.haichenyi.springboot.service;public class UserService &#123; public void say() &#123; System.out.println(&quot;xml...&quot;); &#125;&#125; 第二步， 在resources目录下，创建spring config的xml配置文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.haichenyi.springboot.service.UserService&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; &emsp;&emsp;如上，添加了一个bean类，两个属性，id和class。class指向刚才创建的类，id用于获取这个类。 第三步， 在我们的引导类中加上 @ImportResource 注解 123456789101112131415package com.haichenyi.springboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ImportResource;@ImportResource(locations = &quot;classpath:springboot01.xml&quot;)@SpringBootApplicationpublic class SpringBootInitApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootInitApplication.class, args); &#125;&#125; 第四步， 通过ApplicationContext的getBean方法获取，传的参数就是在xml中定义的id。如下： 1234567891011121314151617181920212223242526272829303132package com.haichenyi.springboot;import com.haichenyi.springboot.pojo.User;import com.haichenyi.springboot.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.ApplicationContext;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootInitApplicationTests &#123; @Autowired User user; @Test public void contextLoads() &#123; System.out.println(user); &#125; @Autowired ApplicationContext context; @Test public void textXml() &#123; UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.say(); &#125;&#125; 自定义配置类向容器中注入组件(SpringBoot推荐)举个栗子：跟上面xml的例子一样。 第一步， 跟上面一样，创建一个service 第二步， 创建配置类： 123456789101112131415package com.haichenyi.springboot.custom;import com.haichenyi.springboot.service.UserService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class UserConfig &#123; @Bean public UserService userService2() &#123; return new UserService(); &#125; &#125; 需要注意的地方： @Configuration 用于标识当前类是一个配置类，用来表示对应spring配置文件 @Bean 标识的方法用于向容器注入组件 方法的返回值就是注入容器中的组件对象 方法名是这个组件对象的 id值 第三步， 就是使用了，跟上面第四步一样。不需要上面的第三步。 Profile多环境支持&emsp;&emsp;profile是Sping用来针对不同的环境要求，提供不同的配置支持。什么不同的环境呢？比方说：开发环境，生产环境。 &emsp;&emsp;全局 Profile 配置使用的文件名可以是application-{profile}.properties / application-{profile}.yml 。如：application-dev.properties / application-prod.properties 举个栗子： &emsp;&emsp;我们的项目环境分为 开发 （dev）和 生产（prod）环境 ，开发环境下端口号为 8081，生产环境下端口号为8082。 通过properties文件指定 &emsp;&emsp;如上图，创建了两个文件：application-dev.properties，application-prod.properties，里面内容很简单，就是指定端口号。server.port=8081 &emsp;&emsp;然后，我们在application.properties文件中指定激活哪一个文件即可。 12345//激活application-dev.properties配置spring.profiles.active=dev//激活application-prod.properties配置spring.profiles.active=prod 通过yml文件指定&emsp;&emsp;不用新建文件，直接在application.yml写就可以了。 PS:需要用三个减号隔开，表示不同的文档块。 123456789101112131415161718spring: profiles: active: prod #激活哪个profile , 当前激活的是 prod 开发环境---server: port: 8081spring: profiles: dev #指定属于哪个环境, dev 环境时使用---server: port: 8081spring: profiles: prod #指定属于哪个环境, prod 环境时使用]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—@SpringBootApplication源码解析（三）]]></title>
    <url>%2F2019%2F08%2F22%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94-SpringBootApplication%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇，内容很少，说了一下SpringBoot的底层是怎么依赖的。这一篇讲一下SpringBoot底层源码是怎么实现的。 &emsp;&emsp;从SpringBoot的入口开始。第一篇的时候说过了，最好把入口文件放在最外层的包下面，至于原因就不多阐述了。 &emsp;&emsp;说说这个 @SpringBootApplication注解的原理,点进去看一下： 如下图： 主要就是这三个注解： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan @SpringBootConfiguration&emsp;&emsp;SpringBootConfiguration这个注解是由Configuration注解实现的。 @Configuration&emsp;&emsp;从名字上就可以判断出，这个注解是跟SpringBoot配置相关的，@Configuration，这个注解是Spring底层的一个注解，之前都是配置xml，SpringBoot推荐我们用配置类来描述配置，配置类是什么呢？就用@Configuration标记的类。 &emsp;&emsp;Configuration这个注解是由Component注解实现。 @Component&emsp;&emsp;这个注解的意义就是，把当前的配置类添加到spring容器中，表示是一个组件。 @EnableAutoConfiguration&emsp;&emsp;EnableAutoConfiguration这个注解是由AutoConfigurationPackage和@Import({AutoConfigurationImportSelector.class})注解实现 @AutoConfigurationPackage&emsp;&emsp;这个注解从名字上面看出来是自动配置包，这是什么意思呢？在第一篇我们就说过了入口要放在最外层的包，至于原因，已经讲过了，因为SpringBoot会自动将引导类 @SpringBootApplication标注的类所在的包以及下面所有子包里面所有的组件扫描到Spring容器中统一管理。就是这个注解实现的。那么，这个注解是怎么实现的呢？就是通过它的这个 @Import({Registrar.class})，下面就是Registrar类的源码了 123456789101112static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; Registrar() &#123; &#125; public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()); &#125; public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata)); &#125; &#125; &emsp;&emsp;就是通过下面这个代码注册进去的。 1AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()); @Import({AutoConfigurationImportSelector.class})&emsp;&emsp;这个注解是干什么用的呢？ 它会把项目里面所有需要导入的组件以全类名的方式返回，将这些组件添加到容器中。 会给容器中注入非常多的自动配置类，就是导入并配置好当前项目中所需要的组件,省去我们手动编写配置去注入组件。 &emsp;&emsp;怎么实现的呢？打开AutoConfigurationImportSelector类，找到如下代码： 1List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); 找到getCandidateConfigurations方法，如下： 12345protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); return configurations; &#125; 找到loadFactoryNames方法，如下： 1234public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList()); &#125; 找到loadSpringFactories方法，里面有 1Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;); 这里就是我们的配置，我们这个配置具体是在哪呢？如下图 @ComponentScan&emsp;&emsp;这个注解的主要作用就是，被该注解标识的类会被Spring容器纳入管理。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—底层依赖（二）]]></title>
    <url>%2F2019%2F08%2F22%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E5%B1%82%E4%BE%9D%E8%B5%96%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前面，我们创建了一个Spring Boot的hello world，我们仅仅添加了一个spring-boot-starter-parent，它是怎么帮我们实现这个依赖的呢？我们可以点进去看一下Ctrl+鼠标左键，如下图： &emsp;&emsp;我们发现它，还有一个父级依赖spring-boot-dependencies，我们继续点进去看，如下图： &emsp;&emsp;在这个pom文件里面，我们发现了，它定义很多个框架的版本号，这里就是，我们在自己项目里面引入框架不需要加版本号的原因。因为，它帮我们定义好了，它会自动依赖这里定义的版本。spring测试通过的，不会有冲突。 &emsp;&emsp;我们后面还依赖了一个spring-boot-starter-web这个框架，这里分两部分： spring-boot-starter：spring boot的场景启动器 web：web相关的如：Tomcat、springMVC等等 &emsp;&emsp;我们可以看一下，我们这里的web启动器的内容是什么。如下图： &emsp;&emsp;我们可以看到，它帮我们依赖了很多框架，这就是为什么，我们只添加了一个依赖，我们的项目就依赖的很多个框架的原因，这些都是spring boot帮我们依赖好的。所以，没什么特殊的，一切都是从最简单的开始的。 &emsp;&emsp;spring boot有很多的场景启动器，如下图： &emsp;&emsp;你需要用到什么样的功能，依赖响应的场景启动器即可。]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列—Hello World（一）]]></title>
    <url>%2F2019%2F08%2F22%2FSpringBoot%E7%B3%BB%E5%88%97%E2%80%94Hello-World%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;终于要正式开始了java后台之路，虽然，之前断断续续的看过过黑马的java web视频，但是，都是好几年前的视频，很老了，感觉用处比较大的就是MySQL数据库操作，之前也写过几篇关于MySQL数据库操作的博客。目前，java后台最火的框架就属Spring Boot了。它是spring家族的衍生框架，并不是加强某个功能，它是为了简化配置，提高开发效率。 Spring Boot概要Spring Boot 介绍&emsp;&emsp;随着动态语言的流行(Ruby,Node.js等等)，java作为静态语言，他的开发显得格外的笨重；繁多的配置、低效的开发效率、复杂的部署流程以及第三方技术整合难度大。 &emsp;&emsp;在上述环境下，Spring Boot由此诞生，它的设计是为了尽快的启动和运行。它使用”习惯优于配置”(就是Spring Boot初始化了大量的配置，让你可以无需配置就能直接运行，当然，你也可以更改)的理念让你的项目快速的运行起来。并且，使用Spring Boot可以让你很容易创建一个独立运行(运行jar，内嵌servlet容器即Tomcat)、准生产力强的基于spring的项目。 Spring Boot 优点 快速构建spring项目 无需依赖外部servlet容器即Tomcat，应用无需打成WAR包；项目可以打成Jar包直接运行 提供一系列的 start pom来简化maven的依赖加载 无需配置XML，开箱即用，简化开发，同时也可以修改默认值来满足特定需求 Spring Boot并不是对Spring功能上的加强，而是提供了一种快速使用Spring的方式 极大的提高了开发和部署效率 Spring Boot 入门开发环境要求&emsp;&emsp;每一个版本的Spring Boot，对系统的环境要求都不一样。我这里用的Spring Boot 2.1.7版本，它需要的 jdk8，兼容12 Maven 3.3+ 修改Maven配置文件&emsp;&emsp;首先，你需要先下载Maven，然后安装。找到安装目录下的config文件夹，点进去找到setting.xml配置文件，进行如下修改 12345678910111213141516171819202122232425262728&lt;!--开始处更改下载依赖的存放路径， 以下目录需要已经创建--&gt;&lt;localRepository&gt;D:\apache-maven-3.6.1\repository&lt;/localRepository&gt;&lt;!--在 mirrors 标签下 添加阿里云maven私服库--&gt; &lt;mirrors&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;name&gt;nexus-aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirrors&gt; &lt;!--在 profiles 标签下指定jdk版本--&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 修改IDEA配置 &emsp;&emsp;如上图，我们打开IDEA的setting界面，找到MAVEN，在Maven Home Directory这一栏选择，我们刚才Maven安装的路径，当这一栏选好之后，第三栏的本地仓库路径会自动修改，然后，我们修改第二栏，选择我们上面修改的setting.xml文件。这样修改完成之后，我们maven项目在线依赖的库都存放在我们自己定义的存放文件夹下面。 创建SpringBoot项目&emsp;&emsp;这里创建的是Maven项目，然后嵌入SpringBoot框架，这样你就不会因为直接创建SpringBoot项目生成的文件不知道是干什么用的造成的困惑。创建Maven项目之后的项目结构，如下图： &emsp;&emsp;如上图，有三个文件夹和一个pom.xml文件。 java文件夹：存放java代码 resources文件夹：存放资源文件 test文件夹：单元测试 pom.xml：依赖库 &emsp;&emsp;Maven项目会自动帮我们创建pom.xml文件，不用我们手动创建，我们先在pom.xml文件下添加如下依赖： 123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &emsp;&emsp;关于这个我想说的就是，spring-boot-starter-parent是一个父级依赖，它是一个特殊的starter，这个依赖提供了常用的SpringBoot依赖库，使用它之后，我们SpringBoot常用库就不需要指定Version，这样，我们就避免了冲突，不兼容等问题。之前Android项目总是碰到依赖包冲突，这一点SpringBoot很nice。 &emsp;&emsp;添加完成这两个之后，我们就可以创建controller，也就是接口了。12345678910111213package com.haichenyi.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.POST) public String hello() &#123; return &quot;hello world!&quot;; &#125;&#125; &emsp;&emsp;我这里类用@RestController注解标明，你也可以用@Controller，当你用@Controller的时候，你的方法上面还要加另外一个注解@ResponseBody。 &emsp;&emsp;再就是方法名称，在你的方法上面加@RequestMapping，里面的value值就是你的接口名称，后面的method就是你需要访问接口的方式。 &emsp;&emsp;再就是最后一步，创建一个引导类，它的主要作用就是启动我们的SpringBoot项目。 1234567891011package com.haichenyi;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class HelloApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloApplication.class, args); &#125;&#125; &emsp;&emsp;到这里，我们就完成了，我们最后看一下项目结构图： PS:在这里，我们需要注意的是我们这个启动类最好放在最外层的包下面，因为这个启动类在启动的时候，会加载它这个包下面及其所有子包下面所有组件到spring容器中统一管理，你如果把这个启动类写在其它包下面，有可能就加载不到有的组件。 &emsp;&emsp;启动项目，不用我们手动部署到Tomcat，我们直接点击这个启动类的main方法，左边的启动按钮，run application就可以了。 &emsp;&emsp;最后，请求接口，因为，我这里定义的方式是post请求，所以，不能直接浏览器访问，你也可以把这个方式去掉，就可以了。 12//http协议+ip+port+接口名http://localhost:8080/hello 项目打jar包添加依赖 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; &emsp;&emsp;选择项目右边的Maven—moudle名称—Lifecycle—package—run maven build即可。如下图： &emsp;&emsp;然后，在控制台找到这个jar的路径，在我们的DOS命令界面用如下命令运行，即可： 1java -jar 刚才打好的jar包全名称包括后缀名]]></content>
      <categories>
        <category>Java -SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dagger2整个流程解析（一）]]></title>
    <url>%2F2019%2F07%2F31%2Fdagger2%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;众所周知，dagger的入门是比较难的，在嵌入之前，我先说一下这个dagger必要的东西，也是比较常见的东西，几个注解 @Component，@Singleton，@Module，@Provides，@Inject &emsp;&emsp;大致的整个流程如下： 编译的时候，先找构造方法由@Inject标记的类，生成对应的Factory.class类，这个类里面通过new生成对应的对象 然后，moudle里面，每一个由@Provider标记的方法，都会生成一个对应的Factory.class文件，这里返回的对象，就是刚才由new生成的对象 最后，我们通过component获取对象的时候，就找moudle去取。moudle取的对象就是之前new生成的 &emsp;&emsp;也可以这样理解： @Component直到桥梁的作用，告诉application,activity我能给你提供哪些对象 当Component中返回对象时，它会到@Module中去找这个对象创建没 @Module中的方法很多，它不可以每个方法的识别一次，它只找@Provider标记的方法 &emsp;&emsp;后文的说明都是依赖于kotlin框架 &emsp;&emsp;这里我拿如下方法来说明整个流程： 如上图：在AppComponent里面的getSpHelper()方法，返回对象就是SpHelper，前面我们说了，component里面需要的对象要在moudle里面找，moudle里面需要的对象要在@Inject的地方生成，所以，moudle里面也要有对应的方法：如下图： 这里的，整个SpHelper是个什么东西呢？参数SpReal又是个什么东西呢？他就是一个sharePreference的接口。SpReal是SpHelper的实现类，如下图： 这个就是一个普通的接口，与dagger2搭不上边。我们看他的实现类： 如上图：类SpReal实现SpHelper接口，并且，它的构造方法用@Inject标记了。这里就跟我们的dagger2搭上关系了，我们就需要找SpReal对应的Factory.clss文件。如下图： 如上图，SpReal_Factory类有三个方法，两个get()方法返回SpReal对象，静态的newInstance()方法也是返回SpReal对象，静态的create()方法，返回的是当前类的对象。那么，这里的调用顺序是什么呢？ 我们在转过头来看看moudle里面方法对应的Factory：如下图 如上图，左边我们看到AppMoudle生成了三个对应的Factory文件，为什么会生成三个？因为，我们的AppMoudle里面有三个方法是用注解@Provides标记的，可以回过头去看一下AppMoudle的内容。 我们仔细看一下，我们需要的这个类的内容AppModule_ProvideSpHelperFactory，一共有四个方法：一个构造方法，一个get方法，一个create方法，一个provideSpHelper方法。 是不是很眼熟这个providerSpHelper方法，并且他的返回值也是SpHelper，没错，这个方法就是我们AppMoudle里面定义的方法，在这里生成的对应的方法，它只是参数多了一个AppModule，为什么会多了这个参数呢？带着这个问题，我们看这个方法的实现： 可以点击跳转这个方法，你会发现，它跳转回我们的AppMoudle方法里面对应的provideSpHelper()方法。回过头来想，我们的AppMoudle就是一个类，里面的provideSpHelper()就是一个普通的方法，怎么调用这个方法呢？就只有用 对象.方法名() 调用，所以，这里参数就多加了一个AppMoudle。 上面解释了为什么多了一个参数，我们再来看一下这个方法的实现。如下图： 如上图，就是一个非空判断，如果为空就抛出空指针异常，如果不为空，就返回第一个参数。第一个参数是什么呢？第一个参数，不就是，我们上面说的对象调用方法名么？我们来看一下它这里是怎么实现的。如下图 咦，怎么又返回来了？回到AppMoudle类了，它没有给我们实现啊？我们再想想，首先这个方法，返回的是第一个参数的值，第一个参数又是一个调用我们AppMoudle里面的方法，我们AppMoudle这个方法的返回值，就是这里这个方法的返回值。我们看一下，我们方法的返回值是什么？ 我们方法的返回值，不就是传进来的参数么？那我们再看看这里方法传进来的参数是什么？ 它这里的传的参数，就是这个方法的第二个参数。到这里，我们又断了，依然不知道，这个参数从哪来的。 冷静下来想一想，调用方法，参数从哪里来？我们从方法里面实现怎么看的到，我们肯定是要在调用方法的地方看。所以，我们就要找到在哪调用这个方法的。既然是写在AppComponent里面，那我们就找他的编译后生成的文件，也就是DaggerAppComponent，如下图： 一眼看过去，这么多东西，怎么看？我又想到，这个DaggerAppComponent类是由AppComponent生成的类，通过上面的判断，这个类里面也应该有我在AppComponent定义的方法的实现才对，搜一下getSpHelper方法，果不其然。如下图： 如上图，我们可以看到这个方法的实现，类点方法名，说明整个方法是静态的，我们点过去一看。如下图： 不就是，我们前面说的那个静态方法吗？这样就跟我们前面分析的都串起来了。我们前面的问题是什么？不就是不知道这个方法的第二个参数从哪来的吗？现在，我们看到了，就是在这里new出来的。 至于第一个参数AppMoudle从哪来的？我们可以接着分析一下。如下图 我们可以看到这个appMoudle定义的是一个全局的变量，我们就要找，在哪里初始化的？如下图： 我们发现它是在构造方法里面初始化的，我们就要找在哪里调用的这个构造方法。如下图 我们发现，在这个Builder类里面的build()方法调用的这个构造方法，我们就找在哪里调用的这个build()方法。如下图： 我们发现，是AndroidInjector这个接口里面的抽象Builder类，这个抽象Builder类实现的是AndroidInjector.Factory，我们要找的就是这个create()方法。 所以，这里在我们的Application里面初始化的，也就是我这里的MyApp里面初始化的。这个参数怎么传递的？如下图： 在create方法里面调用build()之前还调用了seedInstance()方法，这里是抽象类的方法，要想知道这个方法是怎么实现的，那就得看他的实现类。这个Builder的实现类是谁？想一想上面是怎么跳转过来的？不想这个，我们也可以点这个类进行跳转。如下图 如上图，我们可以看到有两个地方调用，一个是ActComponent，一个是AppComponent，前面一个是activity相关的，我们还没有说到，我们现在一直说的都是Application相关的。所以，这里跳转的地方，肯定是Application。如下图 这个方法还过时了，正好，我们这个Builder抽象类还用@Deprecated标记了。诶？那这里还是没有实现啊，这也是一个抽象类。这个是抽象类，AppComponent又是一个接口，所以，我们要找这个AppComponent接口的实现类。如下图： 如上图，AppComponent的实现类，就是DaggerAppComponent类。我们在这个类里面找Builder的实现类就可以了。找找找，如下图 如上图，这里有seedInstance方法和build两个方法，而且都是@Override的，从父类继承过来的，我们在看看AndroidInjector类。如下图： 正好，它有这两个方法，并且还都是抽象方法。所以，这个类就是它的实现类。所以，调用的seedInstance方法，就是这里的这个方法。如下图： 这个方法就是做了一个赋值操作，赋值之前做了一个非空检验。所以，在执行build()的时候这个seedInstance对象已经赋值了，不是空。所以这里就走通了。如下图 如上的构造方法就走通了，那么appMoudle就有值了，那么我们前面的问题。如下图： 我们之前就是在这里，不知道这个appMoudle是怎么赋值的，这里已经走通了。这就是通过AppComponent过去getSpHelper()的整个流程了]]></content>
      <categories>
        <category>Android -源码解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一场由dagger2引发的一些思考]]></title>
    <url>%2F2019%2F07%2F31%2F%E4%B8%80%E5%9C%BA%E7%94%B1dagger2%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;用了好几年的dagger2，从dagger2.android。就只有当时刚开始用dagger的时候深入的了解过，后来就再也没有深入的时候研究过。这几天又研究了一下，做个总结。 &emsp;&emsp;就拿之前写的kotlin的框架来说，它用的是dagger2.android。从dagger2.android。最明显的就是，需要我们自己写的东西越来越少了，框架帮我们做的事情越来越多了，以至于，我们对这个过程越来越看不懂了。也就有了我这篇博客。 先说这嵌入过程吧。 1.依赖12345678//dagger2_startdef dagger = &quot;2.23.2&quot;implementation &quot;com.google.dagger:dagger-android:$dagger&quot;implementation &quot;com.google.dagger:dagger-android-support:$dagger&quot; // if you use the support librarieskapt &quot;com.google.dagger:dagger-android-processor:$dagger&quot;implementation &quot;com.google.dagger:dagger:$dagger&quot;kapt &quot;com.google.dagger:dagger-compiler:$dagger&quot;//dagger2_end 2.DaggerApplication&emsp;&emsp;新建类AppMoudle，并用注解@Moudle标记，暂时先不添加任何内容 1234@Moduleclass AppModule &#123;&#125; &emsp;&emsp;新建接口AppComponent，并实现AndroidInjector接口，泛型先空着，添加如下代码： 1234567@Singleton@Component(modules = [AndroidSupportInjectionModule::classAppModule::class])interface AppComponent : AndroidInjector&lt;MyApp&gt; &#123; @Component.Builder abstract class Builder : AndroidInjector.Builder&lt;MyApp&gt;()&#125; &emsp;&emsp;这里的MyAPP是我们下面新建的Application &emsp;&emsp;新建MyApp，继承DaggerApplication并实现它的抽象方法，添加如下代码： 123456789class MyApp : DaggerApplication() &#123; override fun applicationInjector(): AndroidInjector&lt;out DaggerApplication&gt; = DaggerAppComponent.builder().create(this) override fun onCreate() &#123; super.onCreate() &#125;&#125; &emsp;&emsp;这个时候，你的项目应该报错，因为你没有DaggerAppComponent这个类，你现在编译一遍，应该就是能生成 DaggerAppCompatActivity&emsp;&emsp;让你的BaseActivity类，继承这个DaggerAppCompatActivity &emsp;&emsp;新建ActComponent接口，并且实现AndroidInjector接口，泛型传你的BaseActivity，如下： 12345@Subcomponent(modules = [AndroidSupportInjectionModule::class])interface ActComponent : AndroidInjector&lt;BaseActivity&lt;BasePresenter&lt;BaseView&gt;&gt;&gt; &#123; @Subcomponent.Builder abstract class Builder : AndroidInjector.Builder&lt;BaseActivity&lt;BasePresenter&lt;BaseView&gt;&gt;&gt;()&#125; &emsp;&emsp;新建AllActivityModule类，添加如下代码： 12345@Module(subcomponents = [ActComponent::class])abstract class AllActivitiesModule &#123; @ContributesAndroidInjector internal abstract fun contributeMainActivityInjector(): MainActivity&#125; &emsp;&emsp;这个MainActivity是你的主页面，并且继承你的BaseActivity。 &emsp;&emsp;至此，配置就完成了，你就可以像之前一样，用@Inject标记构造方法，然后，定义变量的地方用@Inject就可以直接用了。 PS: 我这里用的kotlin，kotlin参数默认是private，dagger2需要参数是public，这里需要加上JvmField注解。并且，要var类型，不能val，因为，val不能二次赋值。如下： 123@JvmField@Injectvar presenter: P? = null &emsp;&emsp;我们之前用dagger2，没有用dagger2.android的时候，application和activity并不是实现的DaggerApplication，DaggerAppCompatActivity这两个，我们做了很多额外的操作，现在，我们都没有做了，为什么一样可以能运行？因为，我们之前做的额外的操作，现在都是这两个继承的类帮我们做了，可以点进去看一下源码。 引发的思考&emsp;&emsp;如标题，引发的思考是什么呢？它这个注解到底是怎么做到的呢？ 问，这里为什么会分AppComponent，ActivityComponent，FragmentComponent，写一个component不好吗？&emsp;&emsp;答： 我不知道对不对，我的理解是：与整个APP生命周期同步即放在AppComponent中，与Activity生命周期同步即放在ActComponent中，与Fragment生命周期同步即放在FragComponent中。 &emsp;&emsp;从这里引申出什么问题呢？那就是生命周期，我的kotlin框架整个生命周期都有处理，框架的README也有说明。说到生命周期同步，就要说到不同步，不同步造成的结果就是内存泄漏，至于常见的什么情况下回造成内存泄漏我就不说了，想到内存泄漏，就联想到了内存，想到内存，我就想到了内存分配。这就是我想说的，内存分配。 内存分配&emsp;&emsp;说到内存分配，我们就先说三个名词：栈，堆，方法区 栈：存放变量的引用 堆：存放new的对象，堆是最占内存的 方法区：存储字节码信息(类，方法等等字节码)，常量，静态变量等等。常量池在方法区中 举个栗子：String b = new String(“a”) 和 String c = “a”，他们内存是怎么分配的？如图： 等于号左边 String b，String c这里的b，c都是引用，所以放在栈中。栈存放引用 等于号右边，new的过程，就是在堆中创建内存的过程，这里的0x123456789就是我们常说的内存地址 常量池里面才是放字符串a &emsp;&emsp;很多面试题都会出这个问题，b==c和b.equal(a) ，他们两个的结果结果都知道，前面是false，后面是true。== 比较的是整个对象，而equals比较的是值。这里b指向的是堆内存中的地址，这个地址才是指向常量池中的字符串a，而c是直接指向常量池中的字符串a &emsp;&emsp;想多说一句就是 == 是怎么比较物理地址的呢？通过比较hashCode的值，在java中是获取不到地址的，不过Object中有个identityHashCodeNative方法，它虽然不是地址，但你可以理解为一个地址对应一个值，这个值就能过identityHashCodeNative来获取，具体怎么算了，这是个native方法我们不知道。不过没关系，只要知道一个地址对应一个值就行了，地址相同这个值就相同。而hashCode默认就是返回这个值，那么如果我们重写了hashCode,按我们的规则来写，可以达到不同的地址，hashCode的值相同，从而得到两个不同的地址用==比较是相同的。 &emsp;&emsp; PS: 我们平时说的 把某某对象置为空，释放内存。这种说法是错误的。 比方说这里，b=null，首先，我们只是把某个对象的引用置为空，并不是把某个对象置为空。释放内存，是java的GC回收机制，释放内存，并不是我们释放内存。当GC扫描到，某个对象没有引用指向它了，它就会释放这个对象占用的内存。说到这里，就又想到GC回收机制与强软弱虚四大引用 GC回收和强软弱虚四大引用强软弱虚四大引用 &emsp;&emsp; 其实我也不知道说啥，就是上面理解了内存分配，这里再看这几句话，应该印象更加深刻一些。 强引用：不论什么情况下，GC回收机制扫描到强引用，都不会管，如果内存不足，则抛出OOM异常 软引用(SoftReference)：GC回收机制扫描到软引用时，当内存足够的时候，不会管，当内存不足的时候，则会回收对应内存 弱引用(WeakReference)：不论什么情况下，只要GC回收机制扫描到弱引用，都会回收对应的内存。 虚引用(PhantomReference)：顾名思义，形同虚设，前面三种都是与生命周期相关，而虚引用不会决定对象的生命周期，如果，一个对象仅持有虚引用，那这个对象就跟没有引用是一样的，不管什么时候，GC回收机制扫描到了这个对象，都有可能会回收对应的内存。为什么说是有可能呢？虚引用必须和引用队列连用，当GC回收机制扫描到一个对象，并准备回收它的时候，发现它还存在虚引用，那么，GC会把这个虚引用先加入到与它关联的引用队列中。所以，当GC发现一个对象有虚引用，并且，这个虚引用已经存在与之关联的引用队列当中了，就会回收这个对象。 &emsp;&emsp; GC回收机制判断是否回收内存，都是先判断对象的引用是否存在，引用存放在栈中。 GC回收机制 &emsp;&emsp; 说到GC回收机制，就先聊聊JVM堆的相关知识，一说要JAVA虚拟机，那就要聊聊java是跨平台语言了，它是怎么实现跨平台的呢？ &emsp;&emsp; java程序是跨平台的语言，它是怎么实现跨平台的？ &emsp;&emsp;java程序依赖于JVM（java虚拟机），java程序必须运行在JVM上，JVM是用C、C++开发的，不同的平台是不同的JVM，但是，不管是什么类型的JVM都能运行java程序，这就是所谓的java跨平台。但是，不同JVM编译java程序生成的字节码是一样的，但是编译生成的机器码是不一样的，所以跨平台的是java程序，而不是编译生成的机器码。 &emsp;&emsp;JVM堆，也就是我们上面那个图的堆，JVM堆分为三部分 新域：也就是年轻代，分为三部分，一部分：Eden，另两个部分是辅助空间分别是：From Space，To Space 旧域：也就是老年代 永久域：从配置角度看，永久域是独立于JVM的，大小为4M &emsp;&emsp;程序员无法手动释放内存，只能释放引用，内存释放只能由GC释放，程序员可以手动触发GC：System.gc()， 或者是当内存不够用的时候，GC会自动启动，或者是APP空闲的时候，也会启动回收机制。 &emsp;&emsp;GC执行的过程： 新建的对象都首先存放在Eden中，如果对象太大，可能直接进入老年代，也就是旧域中。 GC开始执行，都是从Eden或者是From Space把对象copy到To Space中，至于中间的算法，有好几种，标记算法，标记幸存次数，还有复制算法，具体怎么实现的，我不知道。当把对象移动到To Spce之后，此时的To Space变成了From Space，之前的From Space变成了To Space。然后，继续循环 循环一次次数之后，对象达到了移动到旧域的条件，就把对象移动到旧域。 最后，GC就会释放旧域的对象所占用的内存 PS：以上都是个人观点，不保证完全正确，没有漏洞。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Tomcat安装与启动]]></title>
    <url>%2F2019%2F07%2F25%2FTomcat%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;搭建android框架的时候总是会遇到测试网络请求没有接口的问题，今天就自己搭建一个服务器Tomcat。不用写web项目就能直接获取到数据 &emsp;&emsp;一.Tomcat主页跳转下载 &emsp;&emsp;二.Download——版本(点击)——Binary Distributions——Core——zip(点击)，该版本是解压版，解压就可以用，无需安装。如下图 &emsp;&emsp;三.下载完成之后，我把zip放在Dpan根目录，解压到当前文件夹即可。如下图 &emsp;&emsp;四.配置环境变量。两个地方要注意 12新建环境变量：CATALINA_HOME=D:\apache-tomcat-9.0.22如下图： 123456789修改Path变量：%CATALINA_HOME%\lib%CATALINA_HOME%\lib\servlet-api.jar%CATALINA_HOME%\lib\jsp-api.jar把上面三个放在Path后面 &emsp;&emsp;五.添加用户，进入config目录，我这里是D:\apache-tomcat-9.0.22\conf，找到tomcat-users.xml，新增如下用户，我这里把它的注释都去掉了 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;tomcat-users xmlns=&quot;http://tomcat.apache.org/xml&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot; version=&quot;1.0&quot;&gt;&lt;role rolename=&quot;manager-wz&quot;/&gt; &lt;role rolename=&quot;admin-wz&quot;/&gt; &lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;admin-wz&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;admin&quot; roles=&quot;manager-wz&quot;/&gt;&lt;/tomcat-users&gt; &emsp;&emsp;六.进入D:\apache-tomcat-9.0.22\bin目录下，双击startup.bat文件，即可启动Tomcat &emsp;&emsp;七.浏览器输入 123http://localhost:8080http://127.0.0.1:8080 即可访问主页 PS:启动的时候控制台中文乱码：找到confi目录下的logging.properties文件 12345java.util.logging.ConsoleHandler.encoding = utf-8改为java.util.logging.ConsoleHandler.encoding = GBK &emsp;&emsp;八.新建json文件。进入 1D:\apache-tomcat-9.0.22\webapps\examples 新建txt文件，修改内容为json格式的字符串，我这里是 1&#123;&quot;code&quot;:&quot;200&quot;,&quot;msg&quot;:&quot;请求成功&quot;,&quot;data&quot;:&quot;asdf&quot;&#125; 修改名字，并且把.txt改成.json &emsp;&emsp;九.重启Tomcat，浏览器输入 1http://127.0.0.1:8080/examples/xxx.json 即可访问到文件 &emsp;&emsp;十.手机访问电脑Tomcat 电脑，手机都连接到同一局域网内 需要关闭防火墙。需要关闭防火墙。需要关闭防火墙。控制面板–&gt;系统和安全–&gt;Windows防火墙–&gt;启用或关闭Windows防火墙–&gt;关闭 手机浏览器输入地址：http://电脑IP地址:8080/， 即可访问tomcat主页]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android开发中的小技巧（持续更新...）]]></title>
    <url>%2F2019%2F07%2F25%2FAndroid%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;android开发中那些不为人知的小技巧 1. 不需要读写权限就可以操作的目录&emsp;&emsp;一谈起要做文件的读写操作，应在脑海中的就是先申请读写权限，没有读写权限就不让对应的操作。那为什么SP也是把数据存本地，缺不需要读写权限呢？ &emsp;&emsp;只要是存储在你的APP目录下面，就不需要读写权限。而，手机上面APP目录有两种：一种是手机内部，一种是SD卡目录。怎么获取呢？ 1234567891011121314//手机内部：APP目录下默认有两个文件夹，一个是cache，一个是files//cache目录cacheDir.absolutePath//files目录filesDir.absolutePath//手机内部的APP目录怎么获取呢？cacheDir.parentfilesDir.parent//手机外部APP目录//cache目录externalCacheDir.absolutePath//APP目录externalCacheDir.parent &emsp;&emsp;以上这些目录不需要存储权限就可以做操作。但是，在APP卸载的时候，这些数据都会被删除。其他的目录都是需要存储权限的。 123456789Environment.getDataDirectory(): /dataEnvironment.getRootDirectory(): /systemEnvironment.getDownloadCacheDirectory(): /cacheEnvironment.getExternalStorageDirectory(): /storage/emulated/0--------------------- 作者：海晨忆 来源：CSDN 原文：https://blog.csdn.net/qq_27634797/article/details/49495611 版权声明：本文为博主原创文章，转载请附上博文链接！ &emsp;&emsp;以上这些目录都需要存储权限。我们可以这样理解： 只要是通过Context.get能获取到的目录，都不需要存储权限。 只要是通过Environment.get能获取到的目录，都需要存储权限。 2. dp转px不需要context也能转12345678910111213/** * 返回你需要的值：如：这里你传20，单位你传dp，返回值就是你这个手机对应的20dp * * @param value 数据 * @param unit 单位：dp为&#123;@link TypedValue#COMPLEX_UNIT_DIP&#125;, * sp为&#123;@link TypedValue#COMPLEX_UNIT_SP&#125;, * px为&#123;@link TypedValue#COMPLEX_UNIT_PX&#125;, * 其它请看&#123;@link TypedValue#applyDimension(int, float, DisplayMetrics)&#125; * @return 具体长度数值 */public static float digitValue(final float value, final int unit) &#123; return TypedValue.applyDimension(unit, value, Resources.getSystem().getDisplayMetrics());&#125; 持续更新…]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin之协程一简单使用]]></title>
    <url>%2F2019%2F07%2F16%2Fkotlin%E4%B9%8B%E5%8D%8F%E7%A8%8B%E4%B8%80%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;kotlin协程用于线程切换，kotlin里面不需要new Thread，并且，协程的开销小于new Thread。有三种写法：runBlocking，launch，async 既然协程的出现可以取代Thread，我们这里想要验证的是： 会不会阻塞主线程？ 协程里面的代码是怎么执行的？按顺序执行还是并行? 协程里面能不能更新页面？ 依赖&emsp;&emsp;协程需要额外依赖一个库协程用于android的库，它会自动依赖官方提供的那个协程的代码库。1implementation &apos;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.0-M2&apos; runBlocking用法：1234567891011121314override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) runBlocking &#123; Log.e(&quot;wz&quot;, &quot;for_start&quot;) for (i in 0..5) &#123; Log.e(&quot;wz&quot;, i.toString()) &#125; Log.e(&quot;wz&quot;, &quot;for_end&quot;) tvName.text = &quot;for_end&quot; &#125; Log.e(&quot;wz&quot;, &quot;runBocking外&quot;) &#125; 结果： &emsp;&emsp;从打印顺序上看，runBlocking的执行顺序是从上往下执行的，并且能更新页面。回答上面的三个问题： 会阻塞线程 从上往下按顺序执行的 可以更新页面 &emsp;&emsp;java里面有Thread，所以线程休眠用Thread.sleep()。kotlin里面既然协程可以取代Thread，所以，kotlin也有自己的休眠方法，也就是上面的delay()，注意，这里delay只能用在协程里面，不能用在外面。 GlobalScope.launch用法： 1234567891011121314override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) GlobalScope.launch &#123; Log.e(&quot;wz&quot;, &quot;for_start&quot;) for (i in 0..5) &#123; Log.e(&quot;wz&quot;, i.toString()) &#125; Log.e(&quot;wz&quot;, &quot;for_end&quot;) tvName.text = &quot;for_end&quot; &#125; Log.e(&quot;wz&quot;, &quot;协程外&quot;) &#125; 结果： &emsp;&emsp;从打印顺序上面看，launch是先执行外面的代码，然后执行协程里面的代码，并且更新了页面。回答上面的三个问题: 不会阻塞线程 既然不会阻塞线程，那就是并行的 能更新页面 GlobalScope.async用法： 1234567891011121314override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) GlobalScope.async &#123; Log.e(&quot;wz&quot;, &quot;for_start&quot;) for (i in 0..5) &#123; Log.e(&quot;wz&quot;, i.toString()) &#125; Log.e(&quot;wz&quot;, &quot;for_end&quot;) tvName.text = &quot;for_end&quot; &#125; Log.e(&quot;wz&quot;, &quot;协程外&quot;) &#125; 结果： &emsp;&emsp;从打印顺序上看，跟launch是一样的，并且也更新了页面。所以结论更launch是一样的。 &emsp;&emsp;都一样的话，那么launch和async有什么区别呢？他们俩的返回值不一样。launch的返回值：Job，而async的返回值：Deferred。async与await()联用。 &emsp;&emsp;Job是一个接口，有join，cancel，cancelAndJoin等等方法，Deferred实现了Job接口。 &emsp;&emsp;launch和async的区别：launch返回值是job，而async的返回值是：把async的最后一行封装成Deferred返回。 1234567891011val job = GlobalScope.launch &#123; &#125; Log.e(&quot;wz&quot;, job.toString()) runBlocking &#123; val b = GlobalScope.async &#123; 1111 &#125;.await() Log.e(&quot;wz&quot;, b.toString()) &#125; async并发&emsp;&emsp;我们项目里面有时候会碰到，我们做某个功能的时候，需要拿到两个数据A,B。我们要先算出A，接着算出B，最后，拿到这两个数据再做处理。那么，time(总) = time(A)+time(B)。 &emsp;&emsp;用async，我们可以怎么处理呢？ 123456789101112131415161718runBlocking &#123; measureTimeMillis &#123; val n1 = GlobalScope.async &#123; doA() &#125; val n2 = GlobalScope.async &#123; doB() &#125; val time = n1.await() + n2.await() Log.e(&quot;wz&quot;, time.toString()) &#125; &#125;suspend fun doA(): Int &#123; //做其他操作花费2秒钟 return 3 &#125;suspend fun doB(): Int &#123; //做其他操作花费4秒钟 return 4 &#125; &emsp;&emsp;前面，我们得到结论async是不阻塞线程的，所以，doA和doB是同时进行的。当同时获取到A,B的结果所花费的时间，是doA和doB中花费时间长的那一个，所以，这里花费的总时间是4秒钟，而不是6秒]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin之内部类，匿名内部类与伴生对象]]></title>
    <url>%2F2019%2F06%2F14%2Fkotlin%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[内部类&emsp;&emsp;kotlin的内部类与java的内部类有点不同java的内部类可以直接访问外部类的成员，kotlin的内部类不能直接访问外部类的成员，必须用inner标记之后才能访问外部类的成员 123456789101112131415class AAA&#123; var a = 0 class BBB&#123; //此时，BBB类的内部是不能直接用a变量的 var b = a //编译无法通过 &#125;&#125;class AAA&#123; var a = 0 inner class BBB&#123; //此时，BBB类的内部是可以直接用a变量的 var b = a //编译可以通过 &#125;&#125; 匿名内部类&emsp;&emsp;匿名内部类主要是针对那些获取抽象类或者接口对象而来的。最常见的匿名内部类点击事件： 1234567//java,匿名内部类的写法btn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); &emsp;&emsp;上面这个是java匿名内部类的写法，kotlin没有new关键字，那么kotlin的匿名内部类该怎么写呢？ 123456btn1.setOnClickListener(object : View.OnClickListener&#123; override fun onClick(v: View?) &#123; print(&quot;1111&quot;) &#125; &#125;) &emsp;&emsp;方法的参数是一个匿名内部类，先写object:，然后写你的参数类型View.OnClickListener{}，然后编译器会出提示，让你补齐即可。 &emsp;&emsp;kotlin还有一个写法lambda 表达式，非常之方便，这个是java，jdk1.8里面包含的 1btn1.setOnClickListener &#123; print(&quot;1111&quot;) &#125; 单例模式(object)&emsp;&emsp;说道这个object就让我想到了kotlin里面的单例模式，kotlin里面用object标记的类，默认在初始化时候自己生成单例，这也是为什么我们再混合开发的时候，java里面调用会有INSTANCE这个东西。 123456object AAA&#123; var a = 10 fun getName() : String&#123; return &quot;海晨忆&quot; &#125;&#125; &emsp;&emsp;上面这个类AAA，默认就有单例，所以可以直接AAA.getName()，这样调用方法。AAA.a这样直接使用变量，混合模式的时候，我们的调用方式是”AAA.INSTANCE.getName()” &emsp;&emsp;我们java里面写的工具类都是用static表示，kotlin里面就不需要，直接把你的工具类的class表示换成object，然后在这个工具类里面正常写方法，就可以直接用类.方法调用，常量也是一样的 伴生对象(companion object)&emsp;&emsp;伴生对象对应的java里面的就是一个类中的静态变量，静态方法。但是，这里编译之后对应的java文件，并不是静态的，而是通过单例调用的。伴生对象的写法： 12345678910111213141516171819202122class SecondActivity : AppCompatActivity() &#123; companion object &#123; var c: Int = 10 fun getName(): String &#123; return c.toString() &#125; class CCC &#123; var d: Int = 11 &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_second) &#125;&#125;//在其他位置的调用方式：SecondActivity.cSecondActivity.getName()SecondActivity.Companion.CCC().d object，companion object，扩展方法的区别&emsp;&emsp;昨天写的扩展方法，我们说到，它编译之后对应的java文件生成的方法都加上了final static，所以，我们说它是静态的。 &emsp;&emsp;今天的这两个object和伴生对象，通过查看它编译之后的java文件，他的属性，方法都是加了final，并没有static，但是，object标识的类在初始化的时候生成了final static类型的INSTANCE变量 ，伴生对象在初始化的时候生成了final static类型的Companion变量 PS:最好写个demo看一下对应的java文件，印象深刻，查看方式：Tools –&gt; Kotlin –&gt; Show Kotlin ByteCodes]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin之扩展方法]]></title>
    <url>%2F2019%2F06%2F14%2Fkotlin%E4%B9%8B%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;kotlin的扩展方法类似于java工具类，但是又优于java的工具类。 扩展方法&emsp;&emsp;扩展方法的写法，新建一个File类型的kt文件，不是Class类型，不是Interface类型，不是枚举类型，不是Object类型，就是File类型 &emsp;&emsp;然后直接定义方法，跟kotlin定义方法相同，需要什么方法就定义什么方法，唯一的区别就是在方法名的前面可以加上”类型.”，格式如下 1234//类型可以省略，即任意类型fun 类型.方法名(参数...):返回值&#123; &#125; 举个例子： 123456789//两个数相加，任意类型都可以调用fun add(a: Int, b: Int): Int &#123; return a + b&#125;//加载图片，只有ImageView类型可以调用fun ImageView.loadUrl(imgUrl: String) &#123; Glide.with(this.context).load(imgUrl).into(this)&#125; 调用的例子： 12345678910111213141516171819package com.haichenyi.aloe.mykotlinimport android.os.Bundleimport android.support.v7.app.AppCompatActivityimport kotlinx.android.synthetic.main.activity_second.*class SecondActivity : AppCompatActivity()&#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_second) val a = 1 val b = 2 //调用两个数相加 add(a, b) //调用加载图片 img.loadUrl(&quot;&quot;) &#125;&#125; 这里需要注意的是： 如果方法没有加类型，就是随便什么类型都能调用，就是只要是项目在内的其他任意地方都可以调用这个方法 第二个是ImageView类型才能调用，要记得是变量调用，而不是类型调用，变量调用方法。就像我这里的img变量，就是ImageView类型的 写法我们都知道用Glide加载图片，最后into方法传递的是一个ImageView类型的view，我上面写的this，这里的this就是指的是当前方法前面类型的变量，也就是这里的ImageView类型的变量，也就是我们调用的时候的img变量 扩展方法，其实最后生成java文件的时候，就是在方法的前面加上了static final ，没什么神奇的，最后跟我们java里面工具类的原理是一样的。 Activity间的跳转1startActivity(Intent(this@MainActivity,SecondActivity::class.java)) 密封类sealed&emsp;&emsp;java中没有密封类的概念，这个是kotlin独有的，他能使我们的代码更加安全。 &emsp;&emsp;kotlin的类默认是final，不能被继承，sealed修饰的类可以被继承，因为它修饰的是open，这里只是把open隐藏了。 &emsp;&emsp;为什么说它能使我们的代码更加安全呐？举个例子： 12345678lateinit var obj : Anyvar b = when(obj)&#123; 1 -&gt; 2 is String -&gt; 3 3,4 -&gt; &quot;obj等于3或者等于4&quot; in 10..20 -&gt; &quot;obj在10到20之间&quot; else -&gt; true&#125; &emsp;&emsp;这个是我们之前说过的when的表达式，我们之前讲过when表达式最后必须要加else，不然编译通过不了。或者你能保证else前面的条件语句包括else条件的情况，那就不用加。一般情况下，我们都加else。我们看一下下面这个写法 123456789101112131415161718sealed class AAA &#123;&#125;class BBB : AAA() &#123;&#125;class CCC : AAA() &#123;&#125;fun QQQ(aaa: AAA): Int = when (aaa) &#123; is BBB -&gt; 10 is CCC -&gt; 11 &#125; &emsp;&emsp;我们这里类AAA是用sealed标识的，类BBB,CCC都继承AAA。我们方法QQQ需要传递一个AAA对象，里面用when做判断，这里就不需要加else，因为这里的条件只有两种，一种是类BBB,一种是类CCC，没有第三种。如果AAA，没有用sealed标识，这里还可以加其他条件，编译都可以通过，因为判断不出来，所以，代码就不安全。]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin之构造函数(constructor)]]></title>
    <url>%2F2019%2F06%2F12%2Fkotlin%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-constructor%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;java中的构造函数是与类名相同即可，kotlin里面的构造函数是用constructor关键字表示。 &emsp;&emsp;kotlin里面的构造函数分为主构造函数和次构造函数。主构造函数只能有一个，次构造函数个数不限制，可以有一个或者多个 constructor&emsp;&emsp;啥是主构造方法？啥是次构造方法呢？ 1234567891011121314151617181920212223242526272829//主构造方法如下，跟在类名后面class Person constructor(name:String)&#123; &#125;class Person constructor()&#123; &#125;//当主构造方法没有任何注解或者可见性修饰符时，可以省略，写成下面这样class Person &#123; &#125;//这种就是有注解标记的主构造方法，不能省略class Person @Inject internal constructor()&#123; &#125;//次构造方法，一个无参的次构造方法，一个有一个参数的次构造方法class Person &#123; constructor()&#123; &#125; constructor(name:String)&#123; &#125;&#125; &emsp;&emsp;我们可以看到主构造方法是没有方法体的，那么，我们需要初始化的数据应该放到哪呢？kotlin提供了init方法，给我们初始化数据。 123456789101112131415class Person constructor()&#123; init&#123; print(&quot;111&quot;) &#125; init&#123; println() print(&quot;222&quot;) &#125;&#125;var p = Person()//这里我们会看到打印台打印:111，换行打印222//这里构造方法是按顺序执行的//我都是自己写代码跑的结果，不想贴图了，自己写了跑一边，印象会更加深刻 &emsp;&emsp;那么，问题来了，次构造方法有方法体，会执行这个init模块吗？ 123456789101112class Person&#123; constructor()&#123; println() print(&quot;111&quot;) &#125; init&#123; print(&quot;222&quot;) &#125;&#125;//这里我们会看到打印台打印:222，换行打印111 结论：不管是什么构造方法，先执行init模块逻辑，后执行构造方法的逻辑 this，super&emsp;&emsp;简单的说一下继承,this和super两个关键字，跟java差不多； &emsp;&emsp;this是调用自己的，super是调用父类的 12345678910111213141516171819202122232425open class AAA &#123; constructor(name: String) &#123; Log.v(&quot;wz&quot;, &quot;$name A&quot;) &#125; constructor(name: String, age: Int) &#123; Log.v(&quot;wz&quot;, &quot;我是AAA的两个参数的构造方法&quot;) &#125; init &#123; Log.v(&quot;wz&quot;, &quot;222&quot;) &#125; &#125; class BBB : AAA &#123; constructor(name: String) : this(name, 0) &#123; Log.v(&quot;wz&quot;, &quot;我是BBB的一个参数的构造方法&quot;) &#125; constructor(name: String, age: Int) : super(name, age) &#123; Log.v(&quot;wz&quot;, &quot;我是BBB的两个参数的构造方法&quot;) &#125; &#125; var b = BBB(&quot;小王&quot;) &emsp;&emsp;类BBB继承类AAA，其中BBB分别有一个参数的构造方法和两个参数的构造方法；一个参数的构造方法用的this关键字调用自己的两个参数的构造；而两个参数的构造方法用的super关键字调用的父类两个参数的构造方法；这里控制台打印的数据： 1234222我是AAA的两个参数的构造方法我是BBB的两个参数的构造方法我是BBB的一个参数的构造方法 重写set/get方法说到了这个类，讲一下怎么重写属性的set/get方法 123456789101112131415161718open class Person &#123; var name: String = &quot;&quot; set(value) &#123; field = value + &quot;www&quot; &#125; get() &#123; return field + &quot;zzz&quot; &#125; var age: Int = 0 set(value) &#123; field = if (value &gt;= 20) 20 else value &#125; get() &#123; return field * 2 &#125; var address: String = &quot;&quot; &#125; &emsp;&emsp;这里一个person类，里面有三个属性：name，age，address；在name和age下面分别写了set，get方法，address没写。 重点： 你想重写哪个属性的set，get方法，就在哪个属性下方写set，get方法，不用成对出现，可以只重写set方法，也可以只重写get方法 用field表示你想要的值 &emsp;&emsp;这里，我就只重写了name和age的set，get方法，没有重写address的set，get方法 &emsp;&emsp;这里，我再存名字的时候在名字的后面加上了www，在获取的时候又加上了zzz，也就是说，如果你这里name传的是”小王”，那么你用get方法取到的name的值应该是”小王wwwzzz” &emsp;&emsp;存age的时候，自己分析一下吧，很简单。]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin之扩展函数let，run，also，apply]]></title>
    <url>%2F2019%2F06%2F11%2Fkotlin%E4%B9%8B%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0let%EF%BC%8Crun%EF%BC%8Calso%EF%BC%8Capply%2F</url>
    <content type="text"><![CDATA[举个例子 123456789open class Person &#123; var name: String = &quot;&quot; var age: Int = 0 var address: String = &quot;&quot; override fun toString(): String &#123; return &quot;Person($name)&quot; &#125;&#125; &emsp;&emsp;新建一个Person类，有三个属性，重写了toString方法。 &emsp;&emsp;这里有个关键字open，只有用open标识的类才能被继承。 12345678910111213141516171819202122232425262728293031var person1 = Person().let &#123; it.name = &quot;张三let&quot; it.age = 24 it.address = &quot;浦东新区&quot; 10&#125;Log.v(&quot;wz&quot;, person1.toString())//10var person2 = Person().run &#123; this.name = &quot;张思run&quot; this.age = 25 this.address = &quot;青浦区&quot; 20&#125;Log.v(&quot;wz&quot;, person2.toString())//20var person3 = Person().also &#123; it.name = &quot;张武also&quot; it.age = 26 it.address = &quot;黄浦区&quot; 30&#125;Log.v(&quot;wz&quot;,person3.toString())//Person(张武also)var person4 = Person().apply &#123; this.name = &quot;张柳apply&quot; this.age = 27 this.address = &quot;崇明区&quot; 40&#125;Log.v(&quot;wz&quot;,person4.toString())//Person(张柳apply) 上面打印的结果： person1——let——10 person2——run——20 person3——also——Person(张武also) person4——apply——Person(张柳apply) 总结： let,run以最后一行的结果为返回值；also,apply返回对象本身。 在他们的方法体中，let,also用it代指本身；run,apply用this代指本身。 PS:充分了解他们的用法，以及返回值的区别，可以实现链式调用实现功能模块，使代码清晰，一目了然。]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin之基础]]></title>
    <url>%2F2019%2F06%2F11%2Fkotlin%E4%B9%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;自从18年上一家公司用kotlin做了项目之后，新公司就没有用过kotlin了，都快要忘完了，最近又想起来了，再捡了一下吧。 定义变量的方式&emsp;&emsp;java：类型+变量名+值+逗号1int a = 5; &emsp;&emsp;kotlin：var/val+变量名+(:类型)+值(ps:类型可省略) &emsp;&emsp;var：可变变量（可以重新分配值） &emsp;&emsp;val：只读变量（初始化的时候必须赋值，不能修改） 1234var c:int c = 5var c = 5 val b = 5 函数&emsp;&emsp;java：public/private/protected+返回类型+方法名+括号参数+大括号方法体 123456public void add(int a ,int b)&#123; &#125;public int add1(int a,int b)&#123; return a+b;&#125; &emsp;&emsp;kotlin：fun+方法名+括号参数+(:返回类型)+大括号方法体 &emsp;&emsp;返回类型Unit类型，对应java的void，即无返回值，可省略 1234567891011fun add(a:int,b:int):Unit&#123; &#125;fun add(a:int,b:int)&#123; &#125;fun add1(a:int,b:int):int&#123; return a+b &#125; if表达式(java中三目运算符)&emsp;&emsp;把a和b两个数中值大的赋值给c1234java：三目运算符int c = a &gt; b ? a : bkotlin：if表达式val c = if( a &gt; b) a else b for循环123456789101112131415161718192021222324252627282930//javaList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;c&quot;);list.add(&quot;d&quot;);for (int j = 0; j &lt;= list.size(); j++) &#123; Log.v(&quot;wz&quot;, list.get(j));&#125;//kotlinval list = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)for(item in list)&#123; Log.v(&quot;wz&quot;,item)&#125;//上面这个for循环等同于forEachlist.forEach&#123; Log.v(&quot;wz&quot;,it)&#125;//上面两种循环拿不到下标for(index in list.indices)&#123; //美元符号的用法见后面 Log.v(&quot;wz&quot;,&quot;第$index 个item的值是$&#123;list[index]&#125;&quot;)&#125;//上面这种就可以拿到for循环的下标//kotlin中String类型的变量也可以for循环遍历每一个char的值 美元符号($)&emsp;&emsp;把$符号放在变量前面，输出的就是变量的值123456val i = 3Log.v(&quot;wz&quot;,&quot;i的值是：$i&quot;)//输出的是：i的值是：3Log.v(&quot;wz&quot;,&quot;i的值是：$3&quot;)//输出的是：i的值是：$3 == 和 ===的区别&emsp;&emsp;类似于java中的==和equals的区别 &emsp;&emsp;java：==判断值是否相等，equals判断物理地址是否相等 &emsp;&emsp;kotlin：==判断物理地址是否相等，===判断值是否相等 数据类型的转换:toInt(),toBoolean()等等12345678//java中不同数据类型的相互转换是强转String s = &quot;1&quot;;int a = (int)s;//kotlin中没有强转提供了转换的方法var s = &quot;1&quot;var a = s.toInt()var a1 = s.toBoolean() is运算符&emsp;&emsp;个人觉得is运算符类似于java中的instanceof关键字12345678910111213141516//java：判断某个变量是否是某个类型的String s = &quot;1&quot;;if(s instanceof String)&#123; &#125;//kotlin：判断某个变量是否是某个类型var s = &quot;1&quot;if(s is String)&#123; &#125;//既然上面说了is是个运算符，运算符当然可以加非if(s !is String)&#123;&#125; 空指针和lateinit&emsp;&emsp;要明确一点：java中才会有空指针异常，kotlin中不存在空指针异常，因为它有非空判断机制 &emsp;&emsp;比方说，我们如果要在kotlin定义一个Bitmap变量，我们知道Bitmap是非常占内存的，用完之后我们要手动置空 &emsp;&emsp;在类型的后面加上问号，用的时候也要加问号才能用，表示不为空的时候才会往下走，如果为空就不会往下走了 12var bitmap:Bitmap? = nullvar w = bitmap?.width &emsp;&emsp;那么，我们如果要定义一个不可能为空的对象怎么定义呢？ 12lateinit var bitmap:Bitmapbitmap.width 黑科技：when表达式和Any(任意类型)&emsp;&emsp;when表达式取代java中的switch，when的返回值依据每一个条件的返回值来定，可以返回任意类型，从上往下按顺序执行，else不能少 12345678lateinit var obj : Anyvar b = when(obj)&#123; 1 -&gt; 2 is String -&gt; 3 3,4 -&gt; &quot;obj等于3或者等于4&quot; in 10..20 -&gt; &quot;obj在10到20之间&quot; else -&gt; true&#125; &emsp;&emsp;比方说这里，先定义个可以是任意类型变量的的obj，如果传进来的是Int类型的1，则返回int类型的2。如果传进来的是String类型的变量，则返回int类型的3。其他，则返回boolean类型的true &emsp;&emsp;when可以取代 if-else if链。如 1234567val x = 10when &#123; x &lt; 10 -&gt; &quot;x小于10&quot; x in 10..20 -&gt; &quot;x在10到20之间&quot; x in 21..40 -&gt; &quot;x在21到40之间&quot; else -&gt; &quot;x大于40&quot;&#125; 区间&emsp;&emsp;顾名思义：在某个范围内123456789101112131415161718//等同于 x &gt;= 1 &amp;&amp; x &lt;= 4(包括1，包括4)，从1到4x in 1..4 //1，2，3，4//等同于 x &gt;= 1 &amp;&amp; x &lt; 4(包括1，不包括4)，从1到4x in 1 until 4 //1，2，3//包括1，包括4 ，从4到1x in 4 downTo 1 //4，3，2，1//从1到8，每隔两个循环一次，也就是1，3，5，7i in 1..8 step 2//从8到1，每隔两个循环一次，也就是8，6，4，2i in 8 downTo 1 step 2//从8到1，每隔两个，并且要满足能整除3的，这里就是6i in (8 downTo 1 step 2).filter &#123; it % 3 == 0 &#125;//上面的关键字filter，还有map等，用过RxJava的应该很眼熟]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android——Tensorflow-Lite简单使用]]></title>
    <url>%2F2019%2F06%2F11%2FAndroid%E2%80%94%E2%80%94Tensorflow-Lite%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;项目里面用到了tflite，用于做简单的图片处理，不是判断图片是什么类型，就是传进去图片，生成新图片，类似于前面一篇讲的GPUImage的滤镜功能，但是比滤镜功能更加强大。 &emsp;&emsp;我这里要做的就是集成，拿人家训练好的模型直接来用，我不用去训练模型。 第一步 依赖1234567891011//依赖库implementation &apos;org.tensorflow:tensorflow-lite:0.0.0-nightly&apos;android &#123; ··· //set no compress models aaptOptions &#123; noCompress &quot;tflite&quot; &#125;&#125; 第二步 加载训练模型&emsp;&emsp;网上很多介绍资料都是把训练模型直接copy到项目main目录下的assets目录（不存在就创建）与java目录平级，自然，这样的加载方式就是 1234567891011121314151617181920212223242526// load infer model private void loadModel(String model) &#123; try &#123; tflite = new Interpreter(loadModelFile(model)); Log.d(TAG, model + &quot; model load success&quot;); tflite.setNumThreads(4); load_result = true; &#125; catch (IOException e) &#123; Log.d(TAG, model + &quot; model load fail&quot;); load_result = false; e.printStackTrace(); &#125; &#125; /** * Memory-map the model file in Assets. */ private MappedByteBuffer loadModelFile(String model) throws IOException &#123; AssetFileDescriptor fileDescriptor = getApplicationContext().getAssets().openFd(model + &quot;.tflite&quot;); FileInputStream inputStream = new FileInputStream(fileDescriptor.getFileDescriptor()); FileChannel fileChannel = inputStream.getChannel(); long startOffset = fileDescriptor.getStartOffset(); long declaredLength = fileDescriptor.getDeclaredLength(); return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength); &#125; &emsp;&emsp;一个tflite文件就好几M，甚至十几M，全部copy到项目里面不显示，所以，我们一般项目里面用都是先下载，然后再使用，那，这样的方式，我们要怎么加载训练模型呢？ &emsp;&emsp;我们先分析一下再assets目录下面怎么加载的？说白了就是新建一个Interpreter对象，就是加载模型。上面的方法都过时了，我们可以找到Interpreter类，里面你会看到如下的方法 123456789//第一个参数传tflite文件，第二个参数传一个Interpreter静态内部类对象public Interpreter(@NonNull File modelFile, Interpreter.Options options) &#123; this.wrapper = new NativeInterpreterWrapper(modelFile.getAbsolutePath(), options);&#125; //所以，我们自己项目里面加载模型，用如下方式即可Interpreter.Options options = new Interpreter.Options();options.setNumThreads(4);tflite = new Interpreter(new File(&quot;&quot;), options); 第三步 执行run方法1tflite.run(in, out); &emsp;&emsp;通过执行这个run方法，获取我们需要的东西，第一个参数，输入对象，第二个参数，输出参数。 重点，敲黑板 重点，敲黑板 重点，敲黑板 &emsp;&emsp;重点就在这里，这里的输入和输出参数要怎么传？我这里训练模型是用Python做的，它需要传入一个四维数组，所以，输出我们自然也要用一个四维数组接收。 &emsp;&emsp;这里的四维数组怎么传递呐？就要说到Android里面的bitmap知识了，它的每个像素点都是一个ARGB数组。即透明度，红色，绿色，蓝色。我们前面的灰色滤镜之类的东西，实际上就是改变RGB三原色的值，让颜色变成灰色，然后改变亮度之类的就是改变每个管道的透明度。网上有很多这样的知识。 &emsp;&emsp;再来说说这个四维数组，我项目里面用到的这个四维数组：1 X 256 X 256 X 3，这几个值怎么理解呢？ 123451：表示一张图片256X256：表示图片的宽高3：表示RGB色值 &emsp;&emsp;那我们怎么把bitmap对象，转换成我们需要的四维数组呐？ 1234567891011121314151617181920212223242526272829303132333435//定义了一个一维数组，里面就是我们需要的参数，便于修改private int[] ddims = &#123;1, 256, 256, 3&#125;; /** * 获取图片的四维数组 * @param bitmap bitmap对象 * @param ddims 参数数组 * @return 图片四维数组 */public float[][][][] getScaledMatrix(Bitmap bitmap, int[] ddims) &#123; //新建一个1*256*256*3的四维数组 float[][][][] inFloat = new float[ddims[0]][ddims[1]][ddims[2]][ddims[3]]; //新建一个一维数组，长度是图片像素点的数量 int[] pixels = new int[ddims[1] * ddims[2]]; //把原图缩放成我们需要的图片大小 Bitmap bm = Bitmap.createScaledBitmap(bitmap, ddims[1], ddims[2], false); //把图片的每个像素点的值放到我们前面新建的一维数组中 bm.getPixels(pixels, 0, bm.getWidth(), 0, 0, ddims[1], ddims[2]); int pixel = 0; //for循环，把每个像素点的值转换成RBG的值，存放到我们的目标数组中 for (int i = 0; i &lt; ddims[1]; ++i) &#123; for (int j = 0; j &lt; ddims[2]; ++j) &#123; final int val = pixels[pixel++]; float red = ((val &gt;&gt; 16) &amp; 0xFF); float green = ((val &gt;&gt; 8) &amp; 0xFF); float blue = (val &amp; 0xFF); float[] arr = &#123;red, green, blue&#125;; inFloat[0][i][j] = arr; &#125; &#125; if (bm.isRecycled()) &#123; bm.recycle(); &#125; return inFloat; &#125; &emsp;&emsp;上面代码注释写的很清楚了吧？每一行都有注释，for循环的作用也标的很清楚，通过这个方法，我们得到的就是我们想要的四维数组了，这里的四维数组的格式，图片的大小，都是tflite文件建模型的时候设置好的，看你们训练模型的工程师是怎么定义的，你就怎么传。 &emsp;&emsp;然后，新建一个一模一样格式的数组去接收输出值，也是一个四维数组，那么，我们怎么把这个四维数组转换成我们需要的bitmap呢？ 123//创建bitmap的方法，Bitmap.createBitmap(@NonNull @ColorInt int[] colors, int width, int height, Config config); &emsp;&emsp;就是这个方法，传一个一维颜色数组，图片的宽高，还有一个图片的格式，那我们这里就是要把这个四维数组转成一个一维的颜色数组了。 123456789101112131415161718192021222324252627/** * 四维数组转成bitmap对象 * @param outArr 数组 * @param ddims 格式 * @return bitmap */public Bitmap getBitmap(float[][][][] outArr, int[] ddims) &#123; //获取图片的三维数组 float[][][] temp = outArr[0]; int n = 0; //新建一个接收的颜色数组，长度就是图片的宽高之积，类似于上面的像素那个数组 int[] colorArr = new int[ddims[1] * ddims[2]]; //for循环遍历把图片的ARGB色值转成一个颜色值，放入颜色数组中 for (int i = 0; i &lt; ddims[1]; i++) &#123; for (int j = 0; j &lt; ddims[2]; j++) &#123; float[] arr = temp[i][j]; int alpha = 255; int red = (int) arr[0]; int green = (int) arr[1]; int blue = (int) arr[2]; int tempARGB = (alpha &lt;&lt; 24) | (red &lt;&lt; 16) | (green &lt;&lt; 8) | blue; colorArr[n++] = tempARGB; &#125; &#125; //创建bitmap对象 return Bitmap.createBitmap(colorArr, ddims[1], ddims[2], Bitmap.Config.ARGB_8888);&#125; &emsp;&emsp;至此，我们就拿到了，我们需要的bitmap对象了，然后再做后续的逻辑即可。 项目链接]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图片滤镜——GPUImage]]></title>
    <url>%2F2019%2F06%2F11%2F%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E2%80%94%E2%80%94GPUImage%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;GPUImage图片滤镜处理的第三方开源库，对照IOS版的GPUImage写的,部分功能尚未完善，目前也有很多种滤镜，常用的滤镜基本上都有，请先浏览一遍github上面的用法。 依赖的库123456789repositories &#123; jcenter()&#125;dependencies &#123;//这个版本号2.x.x，具体的数字看，github官方说明//README.md下方Download后面的版本号 implementation &apos;jp.co.cyberagent.android:gpuimage:2.x.x&apos;&#125; 注意事项一、图片变形&emsp;&emsp;Android版目前没有IOS那么多类，那么多用法，我们用的最多的就是GPUImageView这个自定义view，继承的FrameLayout，并不是继承的ImageView，所以，它这里显示图片的时候，会有图片变形的问题。我的处理方法： 先用Glide获取图片的宽高 然后获取GPUImageView的LayoutParams，动态设置控件的宽高 二、内存溢出 图片过大造成的内存溢出，压缩图片，推荐使用鲁班压缩 频繁使用GPUImage获取Bitmap的getBitmapWithFilterApplied()方法，造成Bitmap过多的内存泄漏，推荐用WeakReference(弱引用)标记Bitmap，GC自动回收 显示大图和缩略图，一般都是一个大图和多种添加滤镜后的效果图(这个是缩略图)，这里缩略图再通过getBitmapWithFilterApplied获取之前，最好吧原图按照规则缩小之后再获取显示，这样也能尽可能的减少内存的占用，点击缩略图显示大的效果图的时候，并不是改变bitmap，是给gpuIamgeView对象设置你点击目标图使用滤镜即可，这样也可以避免内存过多的消耗 三、滤镜添加 单一滤镜的添加 1234//这里以添加黑白滤镜为例GPUImageView gpuImageView = findViewById(R.id.img);gpuImageView.setImage(bitmap);gpuImageView.setFilter(new GPUImageGrayscaleFilter()); 组合滤镜的添加GPUImageFilterGroup 12345678910GPUImageView gpuImageView = findViewById(R.id.img);gpuImageView.setImage(bitmap);GPUImageFilterGroup filterGroup = new GPUImageFilterGroup();//把你需要添加的滤镜放到GPUImageFilterGroup容器里面，//这里我添加了灰色滤镜，曝光度滤镜和饱和度滤镜理论上可以添加无数个filterGroup.add(new GPUImageGrayscaleFilter());filterGroup.add(new GPUImageExposureFilter());filterGroup.add(new GPUImageSaturationFilter());//把这个容器添加到GPUImageViewgpuImageView.setFilter(filterGroup); 多张图片的滤镜 1234567891011121314//这里以GPUImageTwoInputFilter为例（可以加到组合滤镜里面）,它有多个子类//我们这里用GPUImageChromaKeyBlendFilter为例//实现的效果是一个过渡效果，从原图过渡到目标图GPUImageView gpuImageView = findViewById(R.id.img);//设置原图gpuImageView.setImage(bitmap);//新建滤镜对象，并且把目标图设置给滤镜GPUImageChromaKeyBlendFilter keyBlendFilter = new GPUImageChromaKeyBlendFilter();//设置目标图keyBlendFilter.setBitmap(bitmap1);//平滑的过渡方法，改变参数的值即可keyBlendFilter.setSmoothing(progressFloat);//把滤镜设置给GPUImageViewgpuImageView.setFilter(keyBlendFilter); 四、微调（敏感度问题）&emsp;&emsp;只要构造方法，方法带参数的，都可以微调，这里微调的取值范围，Filter源码的类注释上面都有。如果，我们把seekBar的取值范围设置成类注释上面的范围，你滑动很小距离的seekBar，图片变化就会很大，所以，我们一般都是缩小范围再使用。 12345678910111213141516171819//第一个参数seekBar是最大值，第二个参数是最小值，第三个参数是默认值，第四个参数是seekbar分几段//mapSeekBarBean.put(TYPE_SATURATION, new SeekBarBean(2, 0, 0.5f, 10));mapSeekBarBean.put(TYPE_SATURATION, new SeekBarBean(100, 0, 50f, 2));//mapSeekBarBean.put(TYPE_BRIGHTNESS, new SeekBarBean(1, -1, 0.5f, 10));mapSeekBarBean.put(TYPE_BRIGHTNESS, new SeekBarBean(100, 0, 50f, 2));//mapSeekBarBean.put(TYPE_EXPOSURE, new SeekBarBean(10, -10, 0.5f, 0));mapSeekBarBean.put(TYPE_EXPOSURE, new SeekBarBean(100, 0, 50f, 2));//mapSeekBarBean.put(TYPE_CONTRAST, new SeekBarBean(4, 0, 0.25f, 0));mapSeekBarBean.put(TYPE_CONTRAST, new SeekBarBean(100, 0, 25f, 2));mapSeekBarBean.put(TYPE_POSTERIZE, new SeekBarBean(256, 0, 100f, 3));//mapSeekBarBean.put(TYPE_HIGH_LIGHT_SHADOW, new SeekBarBean(1, 0, 0f, 0));mapSeekBarBean.put(TYPE_HIGH_LIGHT_SHADOW, new SeekBarBean(100, 0, 0f, 2));mapSeekBarBean.put(TYPE_SHARPEN, new SeekBarBean(100, 0, 50f, 3));//mapSeekBarBean.put(TYPE_GAMMA, new SeekBarBean(3, 0, 0.33f, 0));mapSeekBarBean.put(TYPE_GAMMA, new SeekBarBean(100, 0, 33f, 3));//mapSeekBarBean.put(TYPE_OPACITY, new SeekBarBean(1, 0, 1f, 0));mapSeekBarBean.put(TYPE_OPACITY, new SeekBarBean(100, 0, 100f, 2));//mapSeekBarBean.put(TYPE_VIBRANCE, new SeekBarBean(1, 0, 0f, 0));mapSeekBarBean.put(TYPE_VIBRANCE, new SeekBarBean(100, 0, 0f, 2)); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//这里是最终设置的值switch (entrySet.getKey()) &#123; case TYPE_SATURATION: //最后面*2是范围（0,2） float f1 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 2; filters.add(new GPUImageSaturationFilter(f1)); break; case TYPE_BRIGHTNESS: float f2 = entrySet.getValue().getProgress(); if (f2 == 50) &#123; f2 = 0f; &#125; else &#123; //后面的*0.7是范围（-1,1），以中间0为准，分成两部分（-1,0），（0,1） //负数为变暗，正数为变亮,本应该*1 f2 = (float) (((f2 - 50) / 50) * 0.4); &#125; filters.add(new GPUImageBrightnessFilter(f2)); break; case TYPE_EXPOSURE: float f3 = entrySet.getValue().getProgress(); if (f3 == 50) &#123; f3 = 0f; &#125; else &#123; //后面的*1是范围（-10,10），以中间0为准，分成两部分（-10,0），（0,10） //负数为变暗，正数为变亮，本应该*10 f3 = ((f3 - 50) / 50) * 1; &#125; filters.add(new GPUImageExposureFilter(f3)); break; case TYPE_CONTRAST: //最后面*4是范围（0,4） float f4 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 4; filters.add(new GPUImageContrastFilter(f4)); break; case TYPE_POSTERIZE: filters.add(new GPUImagePosterizeFilter((int) entrySet.getValue().getProgress())); break; case TYPE_HIGH_LIGHT_SHADOW: GPUImageHighlightShadowFilter highlightShadowFilter = new GPUImageHighlightShadowFilter(); float f9 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1; highlightShadowFilter.setHighlights(1 - f9); highlightShadowFilter.setShadows(f9); filters.add(highlightShadowFilter); break; case TYPE_SHARPEN: float f5 = entrySet.getValue().getProgress(); if (f5 == 50) &#123; f5 = 0f; &#125; else &#123; //后面的*4是范围（-4,4），以中间0为准，分成两部分（-4,0），（0,4） //负数为变暗，正数为变亮，本应该*4 f5 = ((f5 - 50) / 50) * 4; &#125; filters.add(new GPUImageSharpenFilter(f5)); break; case TYPE_GAMMA: //最后面*3是范围（0,3） float f6 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 3; filters.add(new GPUImageGammaFilter(f6)); break; case TYPE_OPACITY: float f7 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1; filters.add(new GPUImageOpacityFilter(f7)); break; case TYPE_VIBRANCE: float f8 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1; filters.add(new GPUImageVibranceFilter(f8)); break; default: &#125; 用法&emsp;&emsp;上面的注意事项里面已经说了简单的用法了，怎么获取滤镜后的图片呢？ 123456//这个方法是获取bitmap对象，至于怎么保存，那就是你自己做了gpuImageView.getGPUImage().getBitmapWithFilterApplied();//当然，库也提供了保存图片的方法：保存的文件夹名称，文件名字，回调方法gpuImageView.saveToPictures(folderName,fileName,OnPictureSavedListener)//其中回调方法里面返回的uri，不能直接传给File，会找不到路径，需要转换一下 12345678910111213141516171819202122/** * 根据Uri获取文件的路径 * * @param context context * @param contentURI uri * @return 文件路径 */ public static String getRealPathFromURI(Context context, Uri contentURI) &#123; String result; Cursor cursor = context.getContentResolver().query(contentURI, new String[]&#123;MediaStore.Images.ImageColumns.DATA&#125;, null, null, null); if (cursor == null) &#123; result = contentURI.getPath(); &#125; else &#123; cursor.moveToFirst(); int index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA); result = cursor.getString(index); cursor.close(); &#125; return result; &#125; 项目就不贴出来了。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JDBC的简单使用——MySQL]]></title>
    <url>%2F2018%2F10%2F11%2FJDBC%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94MySQL%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前面几篇学了基本的SQL语句和用工具操作数据库，今天讲一下用代码操作数据库。 连接MySQL&emsp;&emsp;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java &emsp;&emsp;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java &emsp;&emsp;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java 代码如下： 1234567891011//1、获取驱动类,路动类路径：com.mysql.jdbc.DriverClass.forName(&quot;com.mysql.jdbc.Driver&quot;);//获取url：jdbc:mysql://ip:端口号/数据库名称String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;//用户名String username = &quot;root&quot;;//密码String password = &quot;123&quot;;//获取Connection对象Connection connection = DriverManager.getConnection(url, username, password);System.out.print(connection); &emsp;&emsp;总的来说，先要获取驱动类，然后就是获取Connection对象，就是一行代码DriverManager.getConnection(url, username, password);能走通，就说明连接上了。 修改数据库123456789101112131415161718192021@Test public void test1() throws ClassNotFoundException, SQLException &#123; //获取驱动类 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //获取url String url = &quot;jdbc:mysql://localhost:3306/test4&quot;; //用户名 String username = &quot;root&quot;; //密码 String password = &quot;123&quot;; //获取Connection对象 Connection connection = DriverManager.getConnection(url, username, password); System.out.print(connection); //获取Statement对象 Statement statement = connection.createStatement(); //String sql=&quot;INSERT INTO employee (eid,ename,edid) VALUES(null,&apos;小红&apos;,2)&quot;; String sql = &quot;UPDATE employee SET edid=1 WHERE ename=&apos;小红&apos;&quot;; statement.executeUpdate(sql); statement.close(); connection.close(); &#125; &emsp;&emsp;就是在连接数据库之后，通过Connection对象获取Statement对象，通过Statement对象的execute方法执行对应的SQL语句，最后记得关闭 查询数据库1234567891011121314151617181920212223242526272829303132333435363738394041@Test public void test3() &#123; Connection con = null; Statement state = null; ResultSet resultSet = null; try &#123; String driverClassName = &quot;com.mysql.jdbc.Driver&quot;; String url = &quot;jdbc:mysql://localhost:3306/test4&quot;; String username = &quot;root&quot;; String password = &quot;123&quot;; Class.forName(driverClassName); con = DriverManager.getConnection(url, username, password); state = con.createStatement(); String querySQL = &quot;SELECT * FROM employee&quot;; resultSet = state.executeQuery(querySQL); List&lt;Map&lt;String, String&gt;&gt; mapList = new ArrayList&lt;&gt;(); while (resultSet.next()) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;ename&quot;, resultSet.getString(&quot;ename&quot;)); map.put(&quot;edid&quot;, String.valueOf(resultSet.getInt(&quot;edid&quot;))); mapList.add(map); &#125; System.out.print(mapList.size()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if (resultSet != null) &#123; resultSet.close(); &#125; if (state != null) &#123; state.close(); &#125; if (con != null) &#123; con.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &emsp;&emsp;查询数据库需要注意的地方就是： 执行SQL语句的方法是executeQuery()，只能执行查询语句。 他有一个返回值ResultSet，然后循环这个Set对象，获取数据，他提供了一个移动光标的方法next()，当他为null的时候，返回false，结束循环。 还提供了一系列的get方法，传表每一栏的下标index，或者每一栏的名称，获取对应的值。值的类型要与get的类型相同。值为int，就用getInt，值为String就用getString 最后记得关闭连接，倒着关闭。 PreparedStatement&emsp;&emsp;上面用自己拼接sql语句的方式查询数据库，会容易被sql攻击。所以，我们需要用PreparedStatement来防止被sql攻击，具体方式如下： 123456789101112131415161718192021222324public boolean login(String username, String password) throws Exception &#123; Connection connection = null; PreparedStatement pstat = null; ResultSet rs = null; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/test4&quot;; String user = &quot;root&quot;; String psw = &quot;123&quot;; connection = DriverManager.getConnection(url, user, psw); String sql = &quot;select * from t_user where username=? and psw=?&quot;; pstat = connection.prepareStatement(sql); pstat.setString(1, username); pstat.setString(2, password); rs = pstat.executeQuery(); return rs.next(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; if (rs != null) rs.close(); if (pstat != null) pstat.close(); if (connection != null) connection.close(); &#125; &#125; &emsp;&emsp;如上，是一个登录接口，传用户名，密码给后台，后台查询数据库，我们在获取了connection之后，通过connection调用prepareStatement方法，需要传一个sql模板。 1String sql = &quot;select * from t_user where username=? and psw=?&quot;; &emsp;&emsp;什么是sql模板呢？就是吧需要动态传的参数用问好代替。我们上面这个查询语句，需要动态变化的就是username和psw。然后，我们调用PreparedStatement的setXxx方法，去设置值，第一个参数表示给第几个值赋值，第二个参数就是需要赋值的值 1234//给第一个参数赋值为usernamepstat.setString(1, username);//给第二个参数赋值为passwordpstat.setString(2, password); 大数据存储&emsp;&emsp;这里以存mp3为例 12345CREATE TABLE t_binary( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(50), DATA MEDIUMBLOB) &emsp;&emsp;如上，首先创建一张表去存数据，数据类型不要错了，BLOB类型。 123456789101112@Test public void test1() throws SQLException, IOException &#123; Connection connection = JDBCUtils.getConnection(); String sql=&quot;INSERT INTO t_binary VALUE(?,?,?)&quot;; PreparedStatement pstat = connection.prepareStatement(sql); pstat.setInt(1,1); pstat.setString(2,&quot;KenT - 唱给谁听.mp3&quot;); byte[] bytes= IOUtils.toByteArray(new FileInputStream(&quot;D:/CloudMusic/KenT - 唱给谁听.mp3&quot;)); Blob blob=new SerialBlob(bytes); pstat.setBlob(3,blob); pstat.executeLargeUpdate(); &#125; &emsp;&emsp;上面test1就是存的方法，步骤： 先连接数据库，获取Connection对象 然后，获取PreparedStatement对象，设置参数，其中blob参数，Blob是一个接口，先获取他的实现类SerialBlob，这个实现类的构造方法需要传一个byte[]数组，所以，我们只用把需要存储的文件转成byte[]数组就可以了 最后，执行sql语句就可以了 这里需要注意的是，要在my.ini服务器配置文件中设置最大存储12//这个大小大于你的存储文件即可max_allowed_packet=20M &emsp;&emsp;[mysqld]下边的是服务器配置，[mysql]下边的是客户端配置 &emsp;&emsp;接下来就是怎么取文件了 1234567891011121314@Test public void test2() throws SQLException, IOException &#123; Connection connection = JDBCUtils.getConnection(); String sql=&quot;SELECT * FROM t_binary WHERE name=?&quot;; PreparedStatement pstat = connection.prepareStatement(sql); pstat.setString(1,&quot;KenT - 唱给谁听.mp3&quot;); ResultSet rs = pstat.executeQuery(); if (rs.next())&#123; Blob blob = rs.getBlob(&quot;data&quot;); InputStream in = blob.getBinaryStream(); FileOutputStream out = new FileOutputStream(&quot;D:/cgst.mp3&quot;); IOUtils.copy(in,out); &#125; &#125; &emsp;&emsp;需要说的就是获取到ResultSet之后，获取到Blob，通过他的getBinaryStream()方法，转成输入流，拿到输入流之后，转成File即可 批处理12345678910111213141516@Test public void test6() throws SQLException &#123; Connection connection = JDBCUtils.getConnection(); String sql = &quot;INSERT INTO t_user VALUE(?,?,?)&quot;; PreparedStatement pstat = connection.prepareStatement(sql); for (int i = 0; i &lt; 10000; i++) &#123; pstat.setInt(1, i + 1); pstat.setString(2, &quot;user&quot; + i); pstat.setString(3, i % 2 == 0 ? &quot;男&quot; : &quot;女&quot;); pstat.addBatch(); &#125; long start = System.currentTimeMillis(); pstat.executeBatch(); long end = System.currentTimeMillis(); System.out.print(end - start); &#125; &emsp;&emsp;注意点： 每添加一条数据，调用一遍pstat.addBatch(); 当数据添加完以后，调用pstat.executeBatch();执行sql语句 mysql要开启批处理功能，不然慢到你无法想象。在获取Connection传的url后面，添加rewriteBatchedStatements=true。完整urljdbc:mysql://localhost:3306/test4?rewriteBatchedStatements=true]]></content>
      <categories>
        <category>数据库 -JDBC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作（五）——多表查询]]></title>
    <url>%2F2018%2F10%2F11%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[合并结果集 union all(包含相同行)、union(去除相同行)&emsp;&emsp;把查询的结果合并到一起。要求： 查询的结果列数相同，列类型相同 1234567891011121314151617181920create table emp( eid int, ename varchar(50), eage int);create table stu( sid int, sname varchar(50));//合并结果集（加上all，包含相同的行）select eid,ename from empunion allselect * from stu;//合并结果集（去掉all，去除相同行）select eid,ename from empunionselect * from stu; 连接查询内连接方言： select * from 表1,表2 where 条件 12345表a有三条数据：q，w，e表b有两条数据：h，jselect * from a,b;得出的结果是表a与表b的笛卡尔集，也就是会得到6条数据，分别：qh,qj,wh,wj,eh,ej 12345678去除无用的笛卡尔集，加上where后面的条件连表查询会有附表的外键=主表的主键这个条件select * from student,teacher where student.tid=teacher.tid;查询学生的全部信息，需要查询学生表和老师表，条件是学生表里面的老师id等于老师表里面的老师id，这样查出来的结果就是我们想要的结果 12345678910例子：要求打印员工姓名，工资以及部分名称 员工姓名，工资在emp表，部门名称在dept表select emp.ename,emp.sal,dept.dnamefrom emp,deptwhere emp.did=dept.did;如果嫌弃表名字太长了可以这样：select e.ename,e.sal,d.dnamefrom emp e,dept dwhere e.did=d.did; 标准： select * from 表1 别名1 inner join 表2 别名2 on 条件1234567别名都是可选的，条件跟上面写的一样。两者的区别就只有二个：1、方言连接两个表是用逗号，标准连接两个表是用 inner join2、条件：方言用where，标准用onselect e.ename,e.sal,d.dnamefrom emp e inner join dept dwhere e.did=d.did; 外连接 一主一次左外连接 left outer join ,左表为主表，右表为次表,左表中不论满足不满足条件都查询出来，右表中对应的位置用null补位1234查询所有员工名称，工资以及部门名称，部门名称为null的填无部分select e.ename as 姓名,e.sal as 工资,d.ifnull(dname,&apos;无部门&apos;) as 部门名称from emp e left outer join dept dwhere e.did=d.did; 右外连接 right outer join 与左外对应 子查询 一条sql语句中有多个select关键字,ALL,ANY,IN1234567891011121314//查询员工中最高工资员工的详细信息select * from emp where sal=MAX(sal);//上面这个写法是错误的，条件中是不能出现集合函数//上面这个写法是错误的，条件中是不能出现集合函数//上面这个写法是错误的，条件中是不能出现集合函数//1、先查最高工资select MAX(sal) from emp;//2、最高工资的员工信息select * from emp where sal=(select MAX(sal) from emp);//上面这个写法才是正确的//上面这个写法才是正确的//上面这个写法才是正确的 出现的位置： 1、from后作为表 2、where后作为条件1234上面那条sql语句就是作为条件//查询部门等于30的员工的姓名和年龄select e.name,e.age from (select * from emp where did=30) e;//上面这条就是from后面作为表 1、打印高于平均工资的所有人的信息(单行单列作为条件)1select * from emp where (sal&gt;select AVG(sal) from emp); 2、打印大于30部门的所有员工工资的员工信息(多行单列作为条件)1select * from emp where sal &gt; ALL (select sal from emp where did=30); 3、打印大于30部门任意一人员工工资的员工信息1select * from emp where sal&gt; ANY (select sal from emp where did = 30); 4、打印工作和部门与张三相同的员工信息1select * from emp where (job,did) IN (select job,did from emp where ename=&apos;张三&apos;); 练习题前提条件已知四张表1234员工表emp(eid,ename,job,emid,etime,sal,edid)部门表dept(did,dname,dloc)薪资等级表salgrade(grade,losal,hisal)领导表mgr(mid,mname,mtime) 1、查询至少有一个员工的部门，显示部门编号，部门名称，部门位置，部门人数12345678910111213141516分析：1、列：d.did，d.dname，d.dloc，部门人数2、表：dept d，emp e条件：e.did=d.did//查询部门编号，部门名称，部门位置select * from dept;//查询部门人数select e.did,count(*) from emp group by e.did;//把上面查询的两张表内连接select * from dept inner join select e.did,count(*) from emp group by e.did;//加上条件，给出别名select d.*,z1.cnt from dept d inner join (select did,count(*) cnt from emp group by e.did) z1 where d.did=z1.did; 2、查询所有员工名称及其直接上级领导名称12345678910分析：1、列：e.ename，m.mname2、表：emp e，mgr m条件：e.emid=m.mid//查询员工名称select ename from emp;//查询领导名称select mname from mgr;select ename from emp e left outer join (select mname from mgr ) m on e.emid = m.mid; 3、列出受雇佣日期早于直接上级的所有员工编号，姓名，以及部门名称12345678910111213141516171819202122232425分析：1、列：e.eid,e.ename,d.dname2、表：emp，mgr，dept//查询受雇佣日期早于直接上级领导的员工信息select etime from emp;select mtime from mgr;select * from emp einner join select mtime from mgr mon e.emid=m.mid and e.etime&lt;m.mtime//再把部门名称加上(select eid,ename,edid from emp einner join select mtime from mgr mon e.emid=m.mid and e.etime&lt;m.mtime) z1 left outer join select dname from dept d on z1.edid = d.did;或者select e.eid,e.ename,d.dnamefrom emp e,mgr m,dept dwhere e.emid=m.mid and e.etime&lt;m.mtime and e.edid=d.did; 4、列出部门名称和这些部门的员工信息，同事列出没有员工的部门12345678分析：1、列：员工信息，和部门名称，没有员工的部门也要列出来2、表：emp,deptselect e.*,d.dname from emp e right outer join dept don e.edid=d.did; 5、列出最低薪资大于15000的各种工作以及从事此工作的人数123456789分析：1、列：工作类型，人数2、表：emp条件：min(sal)&gt;15000select job,count(*)from empgroup by jobhaving min(sal)&gt;15000 6、列出在销售部工作的员工姓名，假定不知道销售部的部门编号12345678分析：1、列：员工姓名2、表：emp,dept条件：e.edid=d.didselect enamefrom emp ewhere e.edid=(select did from dept where dname=&apos;销售部&apos;); 7、列出薪资高于公司平均工资的所有员工信息，所在部门名称，上级领导，工资等级12345678910111213141516171819202122232425262728分析：1、列：员工信息，部门名称，上级领导名称，工资等级2、表：emp,dept,mgr条件：sal&gt;avg(sal),e.edid=d.did,e.emid=m.mid//先查询高出平均工资的员工信息select * from emp where sal&gt;(select avg(sal) from emp);//把后面的表一个一个的加上去//加部门名称select e.*,d.dnamefrom emp e left outer join dept d on e.edid=d.didwhere e.sal&gt;(select avg(sal) from emp)//加上级领导名称select e.*,d.dname,m.mnamefrom emp e left outer join dept d on e.edid=d.did left outer join mgr m on e.emid = m.midwhere e.sal&gt;(select avg(sal) from emp)//最后加工资等级select e.*,d.dname,m.mname,s.gradefrom emp e left outer join dept d on e.edid=d.did left outer join mgr m on e.emid = m.mid left outer join salgrade s on e.sal between s.losal and hisalwhere e.sal&gt;(select avg(sal) from emp) 8、列出与张三从事相同工作的所有员工以及部门名称12345678910111213分析：1、列：所有员工，部门名称2、表：emp，dept条件：张三的工作相同，e.edid=d.didselect e.*,d.dname from emp e left outer join dept don e.edid=d.didwhere e.job=(select job from emp where ename=&apos;张三&apos;);或者select e.*,d.dname from emp e,dept d where e.edid=did and e.job=(select job from emp where ename=&apos;张三&apos;); 9、列出薪资高于30部门的所有员工薪资的员工的姓名和薪资，部门名称 123select e.ename,e.sal,d.dname from emp e left outer join dept dwhere e.sal &gt; all (select sal from emp where edid=30) and e.edid = d.did;]]></content>
      <categories>
        <category>数据库 -MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作（四）——多表之间的关系]]></title>
    <url>%2F2018%2F10%2F11%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[主键与外键1、一张表可以有多个外键 2、外键是表的主键，可以是别的表，也可以是本身（少见） 3、外键可以为null，可以重复，但是不能不存在，必须要查的到 创建语法 foreign key(本表的列名) references 关联的表名(关联表的主键) 123456789101112131415161718192021222324252627282930//创建一个部门表CREATE TABLE dept( did INT PRIMARY KEY AUTO_INCREMENT, dname VARCHAR(50));//插入几条数据INSERT INTO dept(did,dname) VALUE(NULL,&apos;销售部&apos;);INSERT INTO dept(did,dname) VALUE(NULL,&apos;技术部&apos;);INSERT INTO dept(did,dname) VALUE(NULL,&apos;人力部&apos;);INSERT INTO dept(did,dname) VALUE(NULL,&apos;保洁部&apos;);//创建一个员工表，这里的的edid是一个外键，对应部门表的主键didCREATE TABLE employee( eid INT PRIMARY KEY AUTO_INCREMENT, ename VARCHAR(50), edid INT, CONSTRAINT fk_empl_dept FOREIGN KEY(edid) REFERENCES dept(did));//或者CREATE TABLE employee( eid INT PRIMARY KEY AUTO_INCREMENT, ename VARCHAR(50), edid INT);alter table employee add CONSTRAINT fk_empl_dept FOREIGN KEY(edid) REFERENCES dept(did);//上面这样也可以设置外键 一对一关系 把从表的主键设置成外键与主表的主键关联1234567891011121314151617create table emp( eid int primary key auto_increment, ename varchar(50));create table hmp( hid int primary key auto_increment, hname varchar(50), constraint fk_hmp_emp foreign key(hid) references emp(eid));//如上，这样创建的两张表emp与hmp就是一对一的关系//插入数据insert into emp values(1,&apos;张三&apos;);insert into hmp values(1,&apos;李四&apos;);//这样张三跟李四就对应上了 多对多关系 两个主表+一个关联表123456789101112131415161718192021222324252627282930313233343536373839404142create table teacher( tid int primary key auto_increment, tname varchar(50));create table student( sid int primary key auto_increment, sname varchar(50));create table stu_tea( tid int, sid int, constraint fk_student foreign key(sid) references student(sid), constraint fk_teacher foreign key(tid) references teacher(tid));//这里的stu_tea就是关联表。多对多并不是说多张表对应多张表//插入数据insert into teacher values(1,&apos;黄老师&apos;);insert into teacher values(2,&apos;李老师&apos;);insert into teacher values(3,&apos;赵老师&apos;);insert into student values(1,&apos;张三&apos;);insert into student values(2,&apos;李四&apos;);insert into student values(3,&apos;王五&apos;);insert into student values(4,&apos;赵六&apos;);//这里黄老师教过张三，李四insert into stu_tea values(1,1);insert into stu_tea values(1,2);//李老师教过王五，赵六insert into stu_tea values(2,3);insert into stu_tea values(2,4);//赵老师教过张三，李四，王五，赵六insert into stu_tea values(3,1);insert into stu_tea values(3,2);insert into stu_tea values(3,3);insert into stu_tea values(3,4);//上面这样，一个学生对应多个老师，一个老师也对应多个学生，叫做多对多的关系 一对多关系 一方不变，另一方在变化123456789101112131415161718192021222324//我们一开始创建的员工表与部门表就是一对多create table dept( did int primary key auto_increment, dname varchar(50));create table emp( eid int primary key auto_increment, ename varchar(50) edid int, constraint fk_emp_dept foreign key(edid) references dept(did));//这里的一就是部门表（主表），多就是员工表（附表）//插入数据insert into dept values(10,&apos;技术部&apos;);insert into dept values(20,&apos;人事部&apos;);//张三，李四属于技术部，王五属于人事部insert into emp values(null,&apos;张三&apos;,10);insert into emp values(null,&apos;李四&apos;,10);insert into emp values(null,&apos;王五&apos;,20);//一个部门对应多个员工，一对多]]></content>
      <categories>
        <category>数据库 -MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作（三）——数据库的备份与恢复]]></title>
    <url>%2F2018%2F10%2F11%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[数据库的备份与恢复备份：mysqldump -u用户名 -p密码 数据库名&gt;生成的脚本路径 12//末尾没有分号，也不要登录mysqldunp -uroot -p123 school&gt;C:a.sql 恢复：mysqldump -u用户名 -p密码 数据库名&lt;生成的脚本路径 或者：登录之后，切换到需要恢复的数据库，输入：source 生成的脚本路径 123//要先删除school数据库，再重新创建数据库，这两步需要登录//执行下面sql语句，不要登录，末尾没有分号mysqldunp -uroot -p123 school&lt;C:a.sql 乱码问题找到你的mysql的安装目录，找到my.ini文件，更bin目录同级，修改如下代码：1234567891011[mysqld]character-set-server=utf8 [client]default-character-set=utf8 [mysql]default-character-set=utf8 修改完之后，不仅是要重新连接数据库，必须要重启数据库 修改完之后，不仅是要重新连接数据库，必须要重启数据库 修改完之后，不仅是要重新连接数据库，必须要重启数据库 net stop mysql net start mysql 主键 primary key创建表的时候直接设置123456789101112CREATE TABLE emp( esid CHAR(12) PRIMARY KEY, ename VARCHAR(20), esal INT);CREATE TABLE emp( esid CHAR(12), ename VARCHAR(20), esal INT, PRIMARY KEY(esid)); 修改主键 alter table 表名 add primary key(键名)1alter table emp add primary key(esid); 删除主键 alter table 表名 drop primary key 主键自增长 auto_increment12345CREATE TABLE emp( esid int PRIMARY KEY auto_increment, ename VARCHAR(20), esal INT); 非空约束 not null12345CREATE TABLE emp( esid int PRIMARY KEY auto_increment, ename VARCHAR(20) not null, esal INT); 唯一约束 not null unique12345CREATE TABLE emp( esid int PRIMARY KEY auto_increment, ename VARCHAR(20) not null unique, esal INT);]]></content>
      <categories>
        <category>数据库 -MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作（二）——DQL]]></title>
    <url>%2F2018%2F10%2F11%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94DQL%2F</url>
    <content type="text"><![CDATA[DQL关键字：select、from、where、group by、having、roder by 基本查询&emsp;&emsp;查询所有：select * from 表名;1select * from t_stu; &emsp;&emsp;查询部分列select 列名,...列名 from 表名;1select stu_num,stu_name from t_stu; &emsp;&emsp;查询去除完全重复的列select distinct * from 表名;12select distinct * from t_stu;select distinct stu_age from t_stu; &emsp;&emsp;也可以查询同时做加、减、乘、除运算操作：1234//把查询出来的年龄都乘以2倍。select stu_age*2 from t_stu;//如果查出来的年龄为null，就设置为29select ifnull(stu_age,29) from t_stu; &emsp;&emsp;做连接字符串操作：CONCAT1234//把名字和年龄拼接起来select CONCAT(stu_name,stu_age) from t_stu;select CONCAT(&apos;我的名字是：&apos;,stu_name,&apos;，我今年&apos;,stu_age,&apos;岁&apos;) from t_stu; &emsp;&emsp;给列起别名：as123select stu_age as 年龄 from t_stu;select stu_age as 年龄,stu_name as 姓名 from t_stu;select CONCAT(stu_name,stu_age) as 描述 from t_stu; 条件查询&emsp;&emsp;跟前面一篇讲的更新，删除里面设置条件的方法是一样的。where后面跟条件123456//查询年龄大于等于20的学生select * from t_stu where stu_age&gt;=20;//查询年龄在15到25岁之间的学生select * from t_stu where stu_age between 15 and 25;//查询名字叫zhangsan,lisi,wangwu.zhaoliu的学生select * from t_stu where stu_name in(&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhangliu&apos;); &emsp;&emsp;模糊查询like1234567891011//一个字加一个下划线，两个字就是两个下划线//查询名字中张开头，并且是两个字的学生.select * from t_stu where stu_name like &apos;张_&apos;;//查询名字是三个字的学生select * from t_stu where stu_name like &apos;___&apos;;//百分号%匹配0~N个字符//查询名字中以雷结尾的学生select * from t_stu where stu_name like &apos;%雷&apos;;//查询名字中包含晓的学生select * from t_stu where stu_name like &apos;%晓%&apos;; 排序 order by1234567// desc:降序，asc：升序//按学生年龄升序排列select * from t_stu ORDER BY stu_age ASC;//按学生年龄降序排列select * from t_stu ORDER BY stu_age DESC;//年龄相同的时候，按名字降序排列。可以无限添加排序条件select * from t_stu ORDER BY stu_age ASC,stu_name DESC; 聚合函数(纵向查询)计数count123//只要不为null，就+1select count(*) from t_stu;select count(stu_age) from t_stu; 计算和sum12//计算学生年龄加起来的总数select sum(stu_age) from t_stu; 最大值max,最小值min1234//查询年龄中最大的select max(stu_age) from t_stu;//查询年龄中最小的select min(stu_age) from t_stu; 平均值avg1select avg(stu_age) from t_stu; 分组查询group by写法：select 条件,聚合函数,...,聚合函数 from 表名 group by 条件; 分组查询必须都是聚合函数，并且，上面两个位置的条件必须相同 12345678910//按老师分组查询，每组老师名下的学生个数select stu_teacher,count(*) from t_stu group by stu_teacher;//分组前条件，不满足条件的没有参加分组//按老师分组查询，查询每组老师名下年龄大于20岁的学生的个数select stu_teacher,count(*) from t_stu where stu_age&gt;20 group by stu_teacher;//having 分组后条件//按老师分组查询，查询老师名下年龄大于20岁的学生，并且剔除学生个数小于5个的老师select stu_teacher,count(*) from t_stu where stu_age&gt;20 group by stu_teacher having count(*)&lt;5; limit(MySQL特有的)123456//从下标0开始，往后查询5条数据select * from t_stu limit 0,5;//分页查询，比方说如果你要查第N页的数据，每页数据M条//(当前页-1)*每页的数据数select * from t_stu limit (N-1)*M,M;]]></content>
      <categories>
        <category>数据库 -MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作（一）——DDL、DML、DCL]]></title>
    <url>%2F2018%2F10%2F11%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94DDL%E3%80%81DML%E3%80%81DCL%2F</url>
    <content type="text"><![CDATA[MySQL:&emsp;&emsp;启动：net start mysql &emsp;&emsp;停止：net stop mysql &emsp;&emsp;登录：mysql -u root -p 例如：mysql -uroot -p123 -hlocalhost &emsp;&emsp;退出：exit或者quit DDL操作：&emsp;&emsp;加上if exists或者if not exists：都是如果存在，或者如果不存在，就不做相关操作 &emsp;&emsp;查询当前有哪些数据库：show databases; &emsp;&emsp;创建数据库：CREATE DATABASE if not exists 数据库的名字 CHARSET=utf8;例如：CREATE DATABASE if not exists employee CHARSET=utf8;创建一个编码为utf-8的employee数据库。不存在就创建，存在就不管。 &emsp;&emsp;删除数据库：DRAP DATABASE if exists 数据库名称;例如：DRAP DATABASE if exists employee;删除employee数据库，如果存在就删除，不存在就不管。 &emsp;&emsp;修改数据库编码方式：ALTER DATABASE 数据库名称 CHARACTER SET utf8; &emsp;&emsp;切换数据库：use 数据库名称; &emsp;&emsp;创建表：CREATE TABLE if not exists 表名(列名 列类型,...,列名 列类型); 1234567891011CREATE TABLE if noe exists t_stu( stu_num char(11), stu_name varchar(50), stu_age int, stu_sex varchar(10) ); &emsp;&emsp;显示当前数据库包含的表：show tables; &emsp;&emsp;显示当前表结构：desc 表名称; &emsp;&emsp;删除表：drop table 表名称; &emsp;&emsp;新增列：alter table 表名 add(列名 列类型,...,列名 列类型); 1234567alter table t_stu add( stu_address varchar(100), stu_phone char(11) ); &emsp;&emsp;修改列类型：alter table 表名 modify 列名 列新类型; 1alter table t_stu modify stu_address varchar(50); &emsp;&emsp;修改列名：alter table 表名 change 原始列名 新列名 列类型; 1alter table t_stu change stu_address stu_addr varchar(100); &emsp;&emsp;删除列：alter table 表名 drop 列名;1alter table t_stu drop stu_address; &emsp;&emsp;修改表名：alter table 原始表名 rename to 新表名; DML操作：为了好操作，先用一下查询的命令，查询表的所有记录： select * from 表名; &emsp;&emsp;插入一行记录：INSERT INTO 表名 (列名,...,列名)VALUES(列值,...,列值);123456789INSERT INTO t_stu( stu_num,stu_name,stu_age,stu_sex,stu_phone )VALUES( &apos;test_num_001&apos;,&apos;张三&apos;,18,&apos;man&apos;,&apos;13888888888&apos; ); &emsp;&emsp;修改所有数据：update 表名 set 列名=列值,...,列名=列值; 1update t_stu set name=&apos;wangwu&apos;; &emsp;&emsp;修改数据(单个条件)：update 表名 set 列名=列值,...,列名=列值 where 列名=列值; 1update t_stu set stu_name=&apos;zhangsan&apos; where stu_num=&apos;testNum_00001&apos;; &emsp;&emsp;修改数据(多个条件)：update 表名 set 列名=列值,...,列名=列值 where 列名=列值 or 列名=列值;12345678910//or,或者update t_stu set stu_age=28 where stu_num=&apos;testNum_0001&apos; or stu_name=&apos;zhangliu&apos;;//and，并且update t_stu set stu_age=28 where stu_age&gt;=25 and stu_age&lt;=30;//between...and...在什么区间内update t_stu set stu_age=28 where stu_age between 25 and 30;//in(...)update t_stu set stu_age=28 where stu_name in (&apos;zhangsan&apos;,&apos;lisi&apos;);//is null，是null。不能是stu_name=nullupdate t_stu set stu_age=28 where stu_name is null; &emsp;&emsp;删除记录：DELETE FROM 表名 where ...;12//这里where后面的条件跟前面的update是一样的写法DELETE FROM t_stu where stu_age = 28; DCL操作：&emsp;&emsp;创建用户：1234//只要是写用户名的位置都可以设置固定ip，或者不固定ipCREATE USER 用户名@IP地址 IDENTIFIED BY &apos;密码&apos;;//固定ip登录CREATE USER 用户名@&apos;%&apos; IDENTIFIED BY &apos;密码&apos;;//任意ip登录CREATE USER zhangSan@&apos;%&apos; IDENTIFIED BY &apos;123&apos;; &emsp;&emsp;给用户授权：123456GRANT 权限1,权限2,...,权限n ON 数据库名称.* TO 用户名@ip地址;GRANT 权限1,权限2,...,权限n ON 数据库名称.* TO 用户名@&apos;%&apos;;GRANT CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT ON school.* TO zhangSan@&apos;%&apos;;//给所有权限GRANT ALL ON school.* TO zhangSan@&apos;%&apos;; &emsp;&emsp;撤销权限：1REVOKE 权限1,权限2,...,权限n ON 数据库名称.* FROM 用户名@&apos;%&apos;; &emsp;&emsp;查看用户权限：1SHOW GRANTS FOR 用户名@ip地址; &emsp;&emsp;删除用户：1DROP USER 用户名@ip地址;]]></content>
      <categories>
        <category>数据库 -MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android——MQTT推送]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E2%80%94%E2%80%94MQTT%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[整体介绍&emsp;&emsp;最近公司用到的推送MQTT。不想过多的介绍背景什么的，我就直接讲怎么实现这个功能。 &emsp;&emsp;他这个原理长连接，这个不用多讲，用法类似于EventBus，需要先订阅，然后通过topic再发送消息。topic是什么呢？我先来讲讲整体流程： 先连接服务器，要先建立长连接 然后需要订阅topic，连接之后才能订阅topic 最后就是通过topic推送消息，接收消息 一步一步讲： 第一步，与服务器建立连接&emsp;&emsp;先丢代码，然后看注释： 12345678910111213141516171819private void initPush() &#123; // 服务器地址（协议+地址+端口号） String uri = host; client = new MqttAndroidClient(this, uri, clientId); // 设置MQTT监听并且接受消息 client.setCallback(mqttCallback); //Mqtt的一些设置 conOpt = new MqttConnectOptions(); conOpt.setAutomaticReconnect(true); // 清除缓存 conOpt.setCleanSession(true); // 设置超时时间，单位：秒 conOpt.setConnectionTimeout(10); // 心跳包发送间隔，单位：秒 conOpt.setKeepAliveInterval(20); myTopic = String.format(TOPIC_SUB, mDeviceId); Log.e(TAG,&quot;myTopic_________&quot;+myTopic); doClientConnection(); &#125; &emsp;&emsp;上面的这些参数，我碰到了两个问题。 &emsp;&emsp;上面的这些参数，我碰到了两个问题。 &emsp;&emsp;上面的这些参数，我碰到了两个问题。 第一个问题，与服务器建立连接，你得先有一个服务器吧？我根据网上的步骤，创建了一个apache-apollo服务器，并且启动了，也启动成功了，我建立连接的时候，总是失败。然后，找啊找，找啊找。问题没有解决，但是，我找到了一个可以用的服务器，也就是这里的uri，不要设置MqttConnectOptions的用户名和密码，设置了他会拒绝 1private String host = &quot;tcp://test.mosquitto.org:1883&quot;; 第二个问题，我连接成功之后，不一会，他就会自动断开连接，或者，推送完消息之后，他就会断开连接。然后，网上搜原因，找啊找，诶，我找到了。MqttAndroidClient的构造方法： 12345678910111213141516/** * Constructor - create an MqttAndroidClient that can be used to communicate with an MQTT server on android * * @param context * object used to pass context to the callback. * @param serverURI * specifies the protocol, host name and port to be used to * connect to an MQTT server * @param clientId * specifies the name by which this connection should be * identified to the server */ public MqttAndroidClient(Context context, String serverURI, String clientId) &#123; this(context, serverURI, clientId, null, Ack.AUTO_ACK); &#125; 看第三个参数，clientId，指定一个名字，用来连接服务器的身份标识。就是说，你设置的这个值，是你在服务器的唯一标识，不能跟其他用户的相同。我把这个clientId直接用uuid生成，就没问题了。 第二步，订阅topic&emsp;&emsp;回到上面，接着往下面走， 12345678910111213141516171819202122232425262728293031323334/** * 连接MQTT服务器 */ private void doClientConnection() &#123; if (!client.isConnected() &amp;&amp; isConnectIsNormal()) &#123; try &#123; client.connect(conOpt, null, iMqttActionListener); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 判断网络是否连接 */ private boolean isConnectIsNormal() &#123; ConnectivityManager connectivityManager = (ConnectivityManager) this.getApplicationContext() .getSystemService(Context.CONNECTIVITY_SERVICE); if (connectivityManager != null) &#123; NetworkInfo info = connectivityManager.getActiveNetworkInfo(); if (info != null &amp;&amp; info.isAvailable()) &#123; String name = info.getTypeName(); Log.e(TAG, &quot;MQTT当前网络名称：&quot; + name); return true; &#125; else &#123; Log.e(TAG, &quot;MQTT 没有可用网络&quot;); return false; &#125; &#125; else &#123; return false; &#125; &#125; &emsp;&emsp;这个方法就是用来连接服务器的，首先判断是否正在连接，后面那个是判断当前有没有网络。再就是这个iMqttActionListener监听了 123456789101112131415161718192021// MQTT是否连接成功 private IMqttActionListener iMqttActionListener = new IMqttActionListener() &#123; @Override public void onSuccess(IMqttToken arg0) &#123; Log.e(TAG, &quot;连接成功 &quot;); try &#123; // 订阅myTopic话题 client.subscribe(myTopic, 0); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(IMqttToken arg0, Throwable arg1) &#123; Log.e(TAG, &quot;连接失败&quot;); arg1.printStackTrace(); // 连接失败，重连 &#125; &#125;; &emsp;&emsp;讷，就是这里，你如果服务器有问题，他一直走onFailure方法。服务器连接成功之后，就是订阅topic。我来说说这个 1client.subscribe(myTopic, 0); &emsp;&emsp;首先，这个主题，是你自己跟服务器商量好的，随便什么都可以。为什么要订阅主题呢？我提前给你瞅瞅推送消息是怎么推送的 &emsp;&emsp;第二个参数，消息的类型qos，有三种：0、1、2 0代表“至多一次”，消息发布完全依赖底层 TCP/IP 协议。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送 1代表“至少一次”，确保消息到达，但消息重复可能会发生 2代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。 &emsp;&emsp;简单说明下，如果发送的是临时的消息，例如给某topic所有在线的设备发送一条消息，丢失的话也无所谓，0就可以了。如果需要客户端保证能接收消息，需要指定QoS为1 1client.publish(topic, new MqttMessage(msg.getBytes())); &emsp;&emsp;讷，推送消息，是根据topic推送的，第二个参数，就是你要推送的具体消息。我个人认为，你可以理解成就类似于键值对的形式， 不同的用户可以订阅相同的主题 不同的用户可以订阅相同的主题 不同的用户可以订阅相同的主题 &emsp;&emsp;这个就是跟其他长连接不同的地方，底层，其实都一样，虽然我没有看底层的代码。想也想的到，服务器肯定是根据这个主题，去找对应的用户，然后推送消息。而其他的长连接就是直接指定用户。跑题了，跑题了。 第三步，推送、接收消息&emsp;&emsp;当你连接服务器成功之后，就要推送消息了，我用的EventBus发的 1234567891011121314151617181920212223242526272829private void publishData(String msg) &#123; String topic = myTopic; try &#123; Log.e(TAG,&quot;给__&quot;+topic+&quot;__topic发送的消息为：&quot;+msg); client.publish(topic, new MqttMessage(msg.getBytes())); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; // MQTT监听并且接受消息 private MqttCallback mqttCallback = new MqttCallback() &#123; @Override public void messageArrived(String topic, MqttMessage message) throws Exception &#123; Log.e(TAG,&quot;接受到__&quot;+topic+&quot;__topic的消息为：&quot;+new String(message.getPayload())); &#125; @Override public void deliveryComplete(IMqttDeliveryToken arg0) &#123; Log.e(TAG,&quot;deliveryComplete&quot;); &#125; @Override public void connectionLost(Throwable arg0) &#123; // 失去连接，重连 Log.e(TAG,&quot;失去连接&quot;); &#125; &#125;; &emsp;&emsp;当你的clientId重复的时候，他就会一直走connectionLost方法。到这里，基本上就讲完了，要注意的是，退出的时候，记得要释放资源 123456789101112@Override public void onDestroy() &#123; try &#123; if (client != null &amp;&amp; client.isConnected()) &#123; client.disconnect(); &#125; &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; EventBus.getDefault().unregister(this); super.onDestroy(); &#125; 网上很多都是直接讲整体流程，重来不讲中间碰到的问题。难受 项目链接]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android—React Native编程]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E2%80%94React-Native%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[个人博客：haichenyi.com。感谢关注 新公司，新的开始，新的技术&emsp;&emsp;新公司的项目，用到的RN编程，之前完全没有碰到过，遇到新技术，之前完全没有碰到过怎么办？google、百度咯。通过不屑的努力，找到了恋猫月亮 的三篇关于RN的文章。我感觉还是很不错的。 从Android到React Native开发（一、入门） 从Android到React Native开发（二、通信与模块实现） 从Android到React Native开发（三、自定义原生控件支持） &emsp;&emsp;可以先浏览上面的第一篇入门，再过来看我这篇文章，我这篇文章就是讲怎么运行一个RN，我只是针对我的项目，把RN的部分提取了出来，上面大佬讲的比较全面。 React Native环境配置开发工具：android studio。我不知道为什么要换开发工具。AS不好吗？环境还是跟你之前开发的一样配置，不用变 python安装：python官网，下载安装。记得配置环境变量。不用非要按照他那个上面说的去安装。安装完成之后cmd里面敲python然后回车，看到如下界面: node.js安装：node也是一样，百度安装,配置完环境变量。cmd里面敲 npm -v然后回车，看到如下界面 最后，跑如下命令： 12345//安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global//React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。npm install -g react-native-cli &emsp;&emsp;至此，RN的配置就完成了。记得配置NDK环境，然后就是上你们公司的svn，或者git去down项目下来,应该还会有一个错误，那就是找不到react.gradle的路径，找到你添加依赖的那个gradle，在最上面添加如下代码： 1apply from: &quot;../../node_modules/react-native/react.gradle&quot; 这个配置应该是添加greenDao那个是一样的，这样就能找到了react.gradle 项目结构如下： &emsp;&emsp;我用箭头标记了，你down下来的项目，应该是没有node_modules文件夹的，这个文件夹是怎么产生的呢？你在cmd进入你down的项目，就是图片上面的文件目录，跑如下命令即可 1npm install 当命令运行完，就可以跑项目了。 React Native项目搭建&emsp;&emsp;同鞋，你有freeStyle吗？有没有用过WebView？WebView就是在你的xml里面新增了一个WebView控件，RN也一样，他的这个控件就是ReactRootView。所以，这个控件哪里来？当然是添加依赖了 12//版本号你自己找compile &apos;com.facebook.react:react-native:0.50.3&apos; 最终的作用代码就是： 1mReactRootView.startReactApplication(mReactInstanceManager, &quot;XXX&quot;, null); &emsp;&emsp;这个ReacRootView对象，你可以new出来，也可以写在xml里面findViewById。只要你能获取到这个对象就可以了，然后就是这个方法： 1startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName, @Nullable Bundle initialProperties) 三个参数 ReactInstanceManager reactInstanceManager String moduleName @Nullable Bundle initialProperties 第一个参数：ReactInstanceManager就像配置WebView的参数，那些什么配置client允许js弹窗啊，新的页面直接覆盖原来的页面，并不是新建一个页面之类的参数，对应的这里，就是配置ReactInstanceManager12345678910111213ReactInstanceManagerBuilder builder = ReactInstanceManager.builder(); builder = builder .setApplication(getApplication()) .setBundleAssetName(&quot;index.android.bundle&quot;) .setJSMainModulePath(&quot;index.android&quot;); mReactInstanceManager = builder .addPackage(new MainReactPackage()) .addPackage(new YzgHDReactPackage())// .setUseDeveloperSupport(!Global.ISPRD) .setUseDeveloperSupport(true) .setInitialLifecycleState(LifecycleState.RESUMED) .build(); &emsp;&emsp;前面的builder的初始化是必须要写的，setApplication，如果你没有自己写application，那就直接getApplication，如果，你有自己实现application那就传你的application对象。 &emsp;&emsp;setBundleAssetName和setJSMainModulePath都是写死的，后面的名字也是写死的。 &emsp;&emsp;然后就是添加package，在package里面添加module。这里就是JS和Android相互调用的地方。package里面要实现ReactPackage，在createNativeModules里面去添加moudle 第二个参数：String moduleName这个moudleName是怎么来的？就是我们前面设置的MoudlePath那个JS里面的。这里的路径应该是index.android.js，是一个js文件，打开之后，最下面有如下代码： 1AppRegistry.registerComponent(&apos;zzz&apos;, () =&gt; XXX); 这里的zzz就是我们这里需要传的名字 第三个参数：Bundle initialProperties这里应该是传一个bundle，传输的数据，传个null就可以了 React Native流程&emsp;&emsp;前面的整个配置都配置完成之后，Android这边只用新建方法，给RN调用就可以了。新建的方法要用@ReactMethod标记。辣么，这个方法新建在哪呢？————Module，就是对应我们前面package里面添加的module。都说RN每个模块是独立的，怎么独立呢？就是这样独立的。每个模块功能对应一个module，每个都有该功能对应的方法。我就拿我这里的UserModule来举个例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class UserModule extends IModule implements NoticeListener&#123; public static final String MODULE_NAME = &quot;User_Module&quot;; private ReactApplicationContext mContext; public UserModule(ReactApplicationContext reactContext) &#123; super(reactContext); this.mContext = reactContext; &#125; @Override public String getName() &#123; return MODULE_NAME; &#125; /** * 用户登录接口 * @param params * @param callback */ @ReactMethod public void doLogin(String params, final Callback callback)&#123; HashMap&lt;String,String&gt; map = GsonTool.gson2Map(params); if(map == null || map.size() &lt;= 0)&#123; callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;参数异常&quot;))); return; &#125; final String userName = map.get(&quot;userName&quot;); final String password = map.get(&quot;password&quot;); if(TextUtils.isEmpty(userName) || TextUtils.isEmpty(password))&#123; callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;用户名或密码不能为空&quot;))); return; &#125; //登录 new Handler().post(new Runnable() &#123; @Override public void run() &#123; String result = new UserBridge().doLogin(userName,password, Global.DEVICE_ID,Global.APP_VERSION_NAME); callback.invoke(result); &#125; &#125;); &#125; &emsp;&emsp;这里我就粘贴出来了部分代码，module要继承IModule，这个是一个抽象类，他继承ReactContextBaseJavaModule，最主要就是继承它，继承之后，我像说的就是这两个方法，getName()和注解的方法doLogin()。 &emsp;&emsp;我们可以看到，这个getName最终返回的是一个User_Module，这个字符串是怎么确定的呢？这个登录的方法名称是怎么确定的呢？ &emsp;&emsp;这些东西都是在js里面定义好的，这里是一个登录方法，我们打开登录的js。 PS: 这里应该是通过js去确定我们这边的方法名，并不是通过这里的名称去确定js的。 &emsp;&emsp;我就不把JS代码，贴出来了，只贴出伪代码，打开js之后，搜索NativeModules。你应该会搜到类似的代码： 1const &#123; User_Module, Shop_Module &#125; = NativeModules; 这里有两个Module，没错，就是两个。我们这里现在只关注User_Module，然后，我们搜索 User_Module，你会看到如下代码： 1234567891011121314151617181920_onLogIn = () =&gt; &#123; const &#123; username, password &#125; = this.userInfo; if (username.length &lt;= 0) return this._modal.Alert(&apos;请输入用户名&apos;); if (password.length &lt;= 0) return this._modal.Alert(&apos;请输入密码&apos;); this._button.setButton(false, &apos;正在登录...&apos;); const params = &#123; userName: username, password &#125;; // 登录 const _dologin = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123; const data = Other.callHandle(values) || &#123;&#125;; if (data.status) &#123; resolve(&apos;登录成功&apos;); &#125; else &#123; reject(data.message); &#125; &#125;); &#125;); &#125;; 其他的一切，我们都不用管，我们在意的是 12345678User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123; const data = Other.callHandle(values) || &#123;&#125;; if (data.status) &#123; resolve(&apos;登录成功&apos;); &#125; else &#123; reject(data.message); &#125; &#125;); &emsp;&emsp;上面这个是我的项目里面的js，你们搜到的肯定跟我的不一样，我这里要说的是，怎么确定name的返回值，和注解方法。我们看到了，name就是这里的User_Module，方法就是这里的doLogin，android里面写用@ReactMethod标记，然后就是参数了，这里两个参数，一个是String，json格式的。用ArrayMap存储好key—value之后，转成字符串即可。第二个参数就是callback。android与JS通信，发送数据，就是一个方法 1callback.invoke(&quot;data&quot;) 他需要什么，你就发送什么。上面是RN主动调用Android方法，辣么，Android怎么主动调用RN方法呢？其实也很简单 123456//发送给RN if (mReactInstanceManager.getCurrentReactContext() != null) &#123; mReactInstanceManager.getCurrentReactContext() .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class) .emit(PUSH_DATA_RN, mqttBean.info); &#125; 就是获取ReactContext对象，通过调用getJSModule方法，参数传DeviceEventManagerModule.RCTDeviceEventEmitter.class这个类就可以了，然后通过调用emit方法，第一个参数，就是RN规定的方法名称，第二个参数就是需要传给RN的数据。为什么这样写呢？我们再来看看RN那边是怎么写的 123DeviceEventEmitter.addListener(&quot;push_data_rn&quot;,(data)=&gt;&#123; alert(data) &#125;) 他就是通过这DeviceEventEmitter类添加addListener方法，传两个参数，第一个参数就是我们规定的名称，第二个参数就是一个回调，有一个参数，就是用来接收我们的数据，最后做的处理就是简单的弹窗，当然，这是我自己测试用的，最后RN要怎么坐，就是我要担心的问题了。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android转场动画——共享元素]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[这个东西其实很简单，我这里只是做一个简单的记录。 XML代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!--第一个Activity的xml布局，需要共享的元素，加上transitionName属性。至于名字，你随便定义，要保持相同--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;bottom&quot; tools:context=&quot;com.haichenyi.activitytransitionanimation.MainActivity&quot;&gt; &lt;ImageView android:id=&quot;@+id/img&quot; android:layout_width=&quot;300dp&quot; android:layout_height=&quot;200dp&quot; android:transitionName=&quot;wang&quot; android:src=&quot;@mipmap/bg&quot;/&gt; &lt;Button android:id=&quot;@+id/btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;跳转&quot;/&gt;&lt;/LinearLayout&gt;&lt;!--第二个activity的xml布局--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/img&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; android:src=&quot;@mipmap/bg&quot; android:transitionName=&quot;wang&quot;/&gt; &lt;Button android:id=&quot;@+id/btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;back&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; java代码如下： 123456789101112131415161718192021222324252627/** * Author: 海晨忆. * Date: 2018/3/29 * Desc: */public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //共享元素转场动画，只支持android 5.0，所以加一个判断 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; startActivity(new Intent(MainActivity.this, Step1Activity.class), ActivityOptions.makeSceneTransitionAnimation(MainActivity.this, findViewById(R.id.img), &quot;wang&quot;).toBundle()); &#125; else &#123; startActivity(new Intent(MainActivity.this, Step1Activity.class)); &#125; &#125; &#125;); &#125;&#125; 上面代码，就是一个Button点击跳转。这个共享元素的核型代码，就是一个方法： 12ActivityOptions.makeSceneTransitionAnimation(Activity activity, View sharedElement, String sharedElementName) 三个参数： Activity activity：activity对象，这个不用多说了 View sharedElement：共享元素的那个控件 String sharedElementName：共享元素控件的那个transitionName属性的值。前面xml里面的注释讲过要相同，有三个位置用到这个：跳转activity的xml里面，跳转的目标activity的xml里面，再就是这里，跳转的代码这里需要设置。 就这么简单。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android——PorterDuffXfermode]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E2%80%94%E2%80%94PorterDuffXfermode%2F</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;PorterDuffXfermode是什么鬼？个人理解，简单的来讲就是做两个Bitmap操作的，什么操作呢？有裁剪，合并等等，有16种图形混合模式。先举一个简单的例子，我们在慢慢讲： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Author: 海晨忆 * Date: 2018/3/28 * Desc: */public class MyCustomView extends View &#123; private int width = 300; private int height = 300; private Bitmap dstBmp; private Bitmap srcBmp; private Paint mPaint; public MyCustomView(Context context) &#123; this(context, null); &#125; public MyCustomView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MyCustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; private void initView() &#123; setLayerType(View.LAYER_TYPE_SOFTWARE, null); srcBmp = makeSrc(width, height); dstBmp = makeDst(width, height); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2); canvas.drawColor(Color.BLUE); int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); @SuppressLint(&quot;DrawAllocation&quot;) PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN); mPaint.setXfermode(xfermode); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerID); &#125; private Bitmap makeDst(int w, int h) &#123; Bitmap dst = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas mCanvas = new Canvas(dst); Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.RED); mCanvas.drawOval(new RectF(0, 0, w, h), mPaint); return dst; &#125; private Bitmap makeSrc(int w, int h) &#123; Bitmap src = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas mCanvas = new Canvas(src); Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.YELLOW); mCanvas.drawRect(0, 0, w, h, mPaint); return src; &#125;&#125; 效果图如下： &emsp;&emsp;上面画了一个圆形bitmap，画了一个矩形bitmap，设置了一个模式 PorterDuff.Mode.SRC_IN 就变成了上面的形状，这是怎么做到的呢？带着我们的问题，进入我们的主题。 注意点&emsp;&emsp;为什么我要拿一个大标题来写这个呢？因为，我当时卡在这里很久，然后踩着巨人的肩膀，我才踏过去的。 首先，两个图形必须都是Bitmap，直接用Canvas画形状，做操作，是达不到效果的。重要的事情说三遍：两个图形必须都是Bitmap。两个图形必须都是Bitmap。两个图形必须都是Bitmap 其次，避免不必要的麻烦，请先关闭硬件加速。重要的事情说三遍：请先关闭硬件加速。请先关闭硬件加速。请先关闭硬件加速 然后，两个bitmap的大小最好一样。 最后，我要强调的是：先绘制的是目标图，后绘制的是源图。 &emsp;&emsp;这里一直说bitmap，辣么，怎么生成这个bitmap，生成这个bitmap之后怎么画图形呢？如下代码： 12345678910//第一步，我们先创建一个bitmap对象Bitmap dst = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);//第二步，我们通过这个bitmap对象创建一个画布，//说白了，就是new 一个画布，把bitmap放到画布的构造方法里面 Canvas mCanvas = new Canvas(dst); Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.RED);//最后，在这个画布上面的所有操作，最后都是呈现在bitmap上面。//就像这里的，在这个画布上面画了一个椭圆，其实，最后我们的bitmap就是一个椭圆 mCanvas.drawOval(new RectF(0, 0, w, h), mPaint); &emsp;&emsp;可以，bitmap会创建了，再就是我们前面说的两个bitmap，先绘制的是目标图，后绘制的是源图，一个是dst（目标图片，下层，先画），一个是src（源图片，上层，后画）。就是我们上面的自定view里面的onDraw()方法里面，用onDraw的canvas画的东西。 &emsp;&emsp;我们如果不用这个xfermode模式，我们的代码应该是这样的： 12345678@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2); canvas.drawColor(Color.BLUE); canvas.drawBitmap(dstBmp, 0, 0, mPaint); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); &#125; &emsp;&emsp;很简单的几行代码，把画布移到正中间，给画布加一个背景蓝色，先画dst，后画src，跑出来的效果图应该是下面这样的： &emsp;&emsp;我们如果加上这个xfermode模式里面的 PorterDuff.Mode.SRC_IN模式，代码如下： 12345678910111213@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2); canvas.drawColor(Color.BLUE); int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); @SuppressLint(&quot;DrawAllocation&quot;) PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN); mPaint.setXfermode(xfermode); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerID); &#125; &emsp;&emsp;比上面的代码，就多加了一个xfermode模式，他们要是同一个画笔，用完之后，记得要把这个模式置null这个saveLayer等会讲，先不说。跑出来的效果图，如下： &emsp;&emsp;前面，我们一直都在强调dst先画，src后画，如果调换一下，会是什么样的结果呢？代码我就不贴出来了，就把那两个drawBitmap调换一个位置，跑出来的效果图，如下： &emsp;&emsp;很明显，跟我们的预期结果不一样。这是为什么呢？带着我们的问题进入下一节。 十六种模式和saveLayer()十六种模式 名字 含义 名字 含义 CLEAR 清除模式［0，0］，即最终所有点的像素的alpha 和color 都为 0，所以画出来的效果只有白色背景 SRC 显示上层绘制图片 DST 显示下层绘制图片 SRC_OVER 正常绘制显示，上下层绘制叠盖 DST_OVER 上下层都显示，下层居上显示 SRC_IN 取两层绘制交集。显示上层 DST_IN 取两层绘制交集，显示下层 SRC_OUT 取上层绘制非交集部分 DST_OUT 取下层绘制非交集部分 SRC_ATOP 取下层非交集部分与上层交集部分 DST_ATOP 取上层非交集部分与下层交集部分 XOR 异或：去除两图层交集部分 DARKEN 取两图层全部区域，交集部分颜色加深 LIGHTEN 取两图层全部，点亮交集部分颜色 MULTIPLY 取两图层交集部分叠加后颜色 SCREEN 取两图层全部区域，交集部分变为透明色 PS：名称前面都应该有：PorterDuff.Mode ，例如：PorterDuff.Mode.CLEAR &emsp;&emsp;什么？有的看不懂什么意思？没关系，我也没指望你一次就看懂，我们先来说一说saveLayer()，且听我娓娓道来。 saveLayer()&emsp;&emsp;这个方法是干嘛用的？保存指定区域内画布的内容。 12public int saveLayer(RectF bounds, Paint paint, int saveFlags) public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags) &emsp;&emsp;后面的saveFlags，有6个值，我们这里用到的 Canvas.ALL_SAVE_FLAG，很明显，表示保存所有内容。我们这里如果把这个方法去掉，会是什么样的结果呢？代码就不贴出来了，就直接注释掉saveLayer的两行代码。还是先画dst，后画src，跑出来的效果图如下： .png) 我们先规定两点： 先画dst，也就是目标图像，是一个圆形。 后画src，也就是源图像，是一个矩形。 代码名称1 顺序 中文名称 形状 dst 先画 目标图像 红色圆形 src 后画 源图像 黄色矩形 &emsp;&emsp;规定好之后，我们再来说一说这个 SRC_IN，我们前面说了：取两层绘制交集。显示上层。首先IN是取交集部分，OUT是取非交集部分。这个就是说最后显示的图形，他们的交集部分，显示src，也就是矩形的颜色，也就是黄色。先画的dst，他自然在src的上层。所以，显示dst的形状，两者交集部分显示src的颜色。可以看下图： &emsp;&emsp;我们再来说说saveLayer的绘制流程：如上图所示，它会创建一个全新图名的bitmap，大小跟你前面指定的保存区域相同，然后，绘制的图形会保存在这个全新透明的bitmap上面，最后把这个透明的bitmap画在画布上面。 &emsp;&emsp;辣么，没有savelayer()方法的绘制流程呢？如下图： 他是直接作用在画布上面的。 常用的PorterDuffXfermode模式介绍SRC模式&emsp;&emsp;只保留源图像的 alpha 和 color ，所以绘制出来只有源图，有时候会感觉分不清先绘制的是源图还是后绘制的是源图，这个时候可以这么记，先绘制的是目标图，不管任何时候，一定要做一个有目标的人，目标在前！（未达到我们的预期效果，感觉有问题） DST模式&emsp;&emsp;只显示目标图片，也就是只显示红色的圆形。 SRC_OVER模式&emsp;&emsp;在目标图片顶部绘制源图像,从命名上也可以看出来就是把源图像绘制在上方，也就是把黄色长方形，画在红色圆形的上面。效果图如下： DST_OVER模式&emsp;&emsp;把目标图像绘制在上方。与前一个相反，把红色圆形画在长方形上面。效果图如下： SRC_IN模式&emsp;&emsp;在两者相交的地方绘制源图像，并且绘制的效果会受到目标图像对应地方透明度的影响。 &emsp;&emsp;有点绕，我分成几段讲出来： &emsp;&emsp;也就是说，两者相交的位置，显示源图像，也就是黄色的矩形，目标图像的透明度为0，然后，&emsp;源图像的其他位置的透明度&emsp;&emsp;会跟源图像与目标图像相交的地方&emsp;&emsp;的目标图像的透明度一样。 &emsp;&emsp;有点绕。其实，就是说源图像的其他地方隐藏，就显示相交的位置。效果图如下： DST_IN模式&emsp;&emsp;跟前面刚好对应，在两者相交的地方绘制目标图像，并且，绘制效果会受到源图像对应地方透明度的影响。我们最是绘制目标图像。效果图如下： SRC_OUT模式&emsp;&emsp;在不相交的地方绘制源图像，相交处根据目标alpha进行过滤，目标色完全不透明时则完全过滤，完全透明则不过滤； DST_OUT模式&emsp;&emsp;同样，可以类比SRC_OUT , 在不相交的地方绘制目标图像，相交处根据源图像alpha进行过滤，完全不透明处则完全过滤，完全透明则不过滤； 太多了，后面就不写了，用的也比较少。 用途，加上上一篇的贝赛尔曲线的水波纹。很明显，我就想做如下效果： 这个圆只是一种，这只是一个demo，这个圆，你可以换成任意的形状。你知道水波纹用贝赛尔曲线怎么做，知道了，PorterDuffXfermode这个模式，两张图片是怎么切割。像这样的，还不就是一个道理。随手拈来。如下图： 这个水波纹的，已经全部封装好了。任意改变背景图片。项目链接]]></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View——贝赛尔曲线]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%E2%80%94%E2%80%94%E8%B4%9D%E8%B5%9B%E5%B0%94%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文针对有一定自定义View的童鞋，最好对贝赛尔曲线有辣么一丢丢了解，不了解也没关系。花5分钟看一下 GcsSloop的 安卓自定义View进阶-Path之贝塞尔曲线。 本文的最终效果图： 思路 首先他是一个只有上半部分的正弦形状的水波纹，很规则。 其次，他这个正弦图左右在移动。 然后，就是它这个自定义View，上下也在移动，是慢慢增加的 最后，优化点：一开始刚出来的时候，它那个水波纹的角度，更达到一定角度后，最后面，快要完成的时候的角度是不一样的。 第一步：画正弦形状的水波纹&emsp;&emsp;有一定自定义View基础的童鞋都知道，一阶贝赛尔画直线，这里的正弦图形是用二阶贝赛尔曲线。至于三阶，四阶，五阶用的都比较少。 &emsp;&emsp;我们这里知道了，这是用的二阶贝赛尔曲线，辣么，方法呢？ 123//不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)mPath.rQuadTo(dx1, dy1, dx2, dy2);//mPath.quadTo(dx1, dy1, dx2, dy2); &emsp;&emsp;Path调用该方法，这里就是传的两个点，也就是四个值，参数的含义：第一个点是控制点，第二个点是终点。前面还有一个起点，通过 1mPath.moveTo(x,y); &emsp;&emsp;这个方法是确定起点。不懂的童鞋，看一下文章开头推荐的文章。我们效果的是一排波浪线，我们上面这个方法只是一个。举个例子： 1234567891011121314151617181920212223242526//构造方法里面初始化private void initView() &#123; path = new Path(); paint = new Paint(); paint1 = new Paint(); paint.setColor(Color.GREEN); paint.setStyle(Paint.Style.STROKE); paint.setStrokeWidth(10); paint1.set(paint); paint1.setColor(Color.RED); &#125;//onDraw里面去画出来 @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.moveTo(0,300); path.quadTo(150, 150, 300, 300); path.quadTo(450, 450, 600, 300); canvas.drawPath(path, paint); canvas.drawCircle(0,300,5,paint1); canvas.drawCircle(150,150,5,paint1); canvas.drawCircle(300,300,5,paint1); canvas.drawCircle(450,450,5,paint1); canvas.drawCircle(600,300,5,paint1); &#125; &emsp;&emsp;上面就是简单的初始化paint，和path，然后画出path，另外，我还画出了5个点，帮助理解。跑出来的效果图如下： &emsp;&emsp;转换成对应的坐标系，手画的，有点丑，知道是这个意思就行了。如下： 画一个正弦图的思路： 首先，把path移动到起点，对应的也就是moveTo(0,300) 然后，确定终点，也就是我们前面说的quadTo()方法的第二个点(300,300) 最后，我们确定控制点，也就是我们前面说的quadTo()方法的第一个点。 辣么，这个控制点是怎么确定的呢？问题就在这里。敲黑板 因为我们画的是一个规则的正弦图，所以，控制点的x坐标肯定是终点x坐标300的一半，也就是150。再就是他的y坐标，其实y坐标是随便定义的。y坐标只是约束这个正弦图形的坡度，对坡度。你把y坐标定义的离终点的y坐标远一点，他的坡度就大一点。离他近一点，坡度就小一点。你如果定义控制点是（150,100），他相对于控制点是(150,150)的坡度就会大一点。因为100距300相差200，150距300相差150。200大于150。对，就是这样。辣么，怎么控制是上半部分的正弦图还是下半部分的正弦图呢？ |y控|&gt;|y终|，上半部分；相反，则是下半部分。 &emsp;&emsp;对了，这里我需要说明的是，上面我们调用了两次quadTo()方法，第二次调用的起点，就是第一次的终点。 &emsp;&emsp;上面效果是调用quadTo()方法，我们再来说一说rQuadTo()方法。上面的注释里面，我们也标明了两者的区别。 辣么，什么叫相对于原点的坐标系？什么叫相对于当前点的坐标系呢？ 我们知道android的坐标系原点是左上角，你可以这样理解，第一种，不带r的方法quadTo()，他的坐标原点(0,0)点始终在左上角，第二种带r的方法rQuadTo()，我们第一次移动到起点(0,300)的时候，这个时候的原点就是(0,300)，所以说此时的终点应该是(300,0),然后确定我们的控制点(150,-150)。辣么，我们调用第二次的时候，此时的终点就是(300,0)，这个时候的终点就是(300,0)，在确定此时的控制点(150,150)。两次的终点都是(300,0)，但是，意义是不一样的。有点绕，但是你理解了相对于原点坐标系，和相对于当前点的坐标系，就很简单了。理解一下，思考5分钟。辣么，上面用带r的怎么写呢？ 123456path.moveTo(0,300);// path.quadTo(150, 150, 300, 300);// path.quadTo(450, 450, 600, 300); path.rQuadTo(150,-150,300,0); path.rQuadTo(150,150,300,0); canvas.drawPath(path, paint); &emsp;&emsp;至此，怎么换一个正弦图，以及，两个方法的区别，已经讲完了，我觉得已经讲的非常清楚了。感觉，没有谁比我讲的还要清楚了。手把手教学。我们这个效果，画一个，肯定不行。要画满一个屏幕。怎么画呢？ &emsp;&emsp;找规律，一个正弦图，我们上面都是围绕这三个点，起点，控制点，终点。要想规则，控制点的x坐标是终点x坐标的一半。再就是，要画满一个屏幕，要在屏幕内部，所以，终点x坐标要小于屏幕宽度。综上所述。 三个点：起点，终点，控制点 控制点的x坐标是终点x坐标的一半 终点x坐标要小于屏幕宽度 我们就开始写代码了： 1234567891011121314151617181920212223 private int startY = 300;//定义起始点的y坐标 private int endX = 300;//定义终点的x坐标 private int controlY = 150;//定义控制点的y坐标 @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.moveTo(0, 300); path.moveTo(0, startY);// path.quadTo(150, 150, 300, 300);// path.quadTo(450, 450, 600, 300);//这里的for循环为什么每次要加2倍的终点x坐标呢？ //你想一想，我们一次for循环，画的图的终点x坐标在哪？ for (int i = 0; i &lt; getWidth(); i += 2*endX) &#123;// path.rQuadTo(150, -150, 300, 0);// path.rQuadTo(150, 150, 300, 0); path.rQuadTo(endX/2, -controlY, endX, 0); path.rQuadTo(endX/2, controlY, endX, 0); &#125; canvas.drawPath(path, paint); &#125; 效果图，如下： &emsp;&emsp;好，到这里，第一步完成了，满屏的水波纹出来了。 第二步，正弦图左右在移动&emsp;&emsp;想一想，这个动画，想一想，想一想，像不像水平位移动画？像不像？越想越像。辣么，我们就去验证一下。写一个动画，这种，明显就是属性动画。既然是左右移动，辣么就肯定是改变x轴的坐标值，改变谁的呢？肯定是起点的啊，只有改变起点的x左边的值，水波纹才会有动的效果 123456789101112131415161718192021222324public void startAnimation()&#123; ValueAnimator animator = ValueAnimator.ofFloat(0, 1); animator.setDuration(1000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Float animatedValue = (Float) animation.getAnimatedValue(); currentStartX = (int) (endX * animatedValue); postInvalidate(); &#125; &#125;); animator.start(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.reset();//不加会有重影，不是我们想要的// path.moveTo(0, 300);// path.moveTo(0, startY); path.moveTo(currentStartX, startY); ...//其他的不变 &#125; 效果图如下： &emsp;&emsp;尼玛，什么鬼？动是动起来了，为啥左边还有一段空白？不要急，想一想为什么？我们之前是从Y轴开始画的，我们这个动画是从左向又移动一个endx的值，所以，我们设置起点的时候，也向左偏移一个endx的值不就好了么？我们再试一试 12345678910111213141516171819@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.reset();// path.moveTo(0, 300);// path.moveTo(0, startY); path.moveTo(-endX + currentStartX, startY);// path.quadTo(150, 150, 300, 300);// path.quadTo(450, 450, 600, 300); //这里的for循环为什么每次要加2倍的终点x坐标呢？ //你想一想，我们一次for循环，画的图的终点x坐标在哪？ for (int i = -endX; i &lt; getWidth() + endX; i += 2 * endX) &#123;// path.rQuadTo(150, -150, 300, 0);// path.rQuadTo(150, 150, 300, 0); path.rQuadTo(endX / 2, -controlY, endX, 0); path.rQuadTo(endX / 2, controlY, endX, 0); &#125; canvas.drawPath(path, paint); &#125; 跑出来的效果图如下： &emsp;&emsp;咦，满脸的嫌弃，这是什么东西啊，空白虽然没了，为什么会卡一下，并且这个也不是我们想要的效果。我们再想一想，我们这个无线循环的动画的原理是什么？ 敲黑板，其实，我们就是多画了一个正弦波形，我们移动之后，跟移动之前一样，也就是位移了两个正弦图，结束后的图形，跟结束前的图形重合，然后一直重复动画，从而让用户感觉是无线循环的动画。 辣么，哪里出问题呢？想一想，为什么达不到我们的效果，肯定是我们水平移动距离的有问题啊。找啊找啊找，找到了，我们这里的endx坐标，是一个完整正弦图形的一半。所以，我们动画移动的距离要乘以2。如下： 12345678currentStartX = (int) (2 * endX * animatedValue);//动画里面的//动画还要加上插值器，从而达到平滑的效果animator.setInterpolator(new LinearInterpolator());辣么，这里距离变了，我们起始点的距离，循环的距离也要变。要不然会有空白path.moveTo(-endX*2 + currentStartX, startY);for (int i = -endX*2; i &lt; getWidth() + endX*2; i += 2 * endX) &#123;...&#125; &emsp;&emsp;综上所述，去除无关代码之后的完整代码，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Author: 海晨忆 * Date: 2018/3/27 * Desc: */public class WaveView1 extends View &#123; private Path path; private Paint paint; private Paint paint1; private int startY = 300; private int endX = 300; private int controlY = 150; private int currentStartX; public WaveView1(Context context) &#123; this(context, null); &#125; public WaveView1(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public WaveView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; private void initView() &#123; path = new Path(); paint = new Paint(); paint1 = new Paint(); paint.setColor(Color.GREEN); paint.setStyle(Paint.Style.STROKE); paint.setStrokeWidth(10); paint1.set(paint); paint1.setColor(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.reset(); path.moveTo(-endX*2 + currentStartX, startY); for (int i = -endX*2; i &lt; getWidth() + endX*2; i += 2 * endX) &#123; path.rQuadTo(endX / 2, -controlY, endX, 0); path.rQuadTo(endX / 2, controlY, endX, 0); &#125; canvas.drawPath(path, paint); &#125; public void startAnimation() &#123; ValueAnimator animator = ValueAnimator.ofFloat(0, 1); animator.setDuration(1000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Float animatedValue = (Float) animation.getAnimatedValue(); currentStartX = (int) (2 * endX * animatedValue); postInvalidate(); &#125; &#125;); animator.start(); &#125;&#125; 跑出来的效果图如下： 完美达到了我们的预期效果。 第三步：自定义View上下移动&emsp;&emsp;经过上面的左右动画，现在这个上下移动的动画就很简单了，很明显是改变起始点y坐标的值，当然，肯定是属性动画。代码如下： 1234567891011121314151617181920212223242526272829303132public void startAnimation() &#123; ...//这是我们的左移动画，没写上来 //这就是我们的竖着移动的动画 ValueAnimator animator1 = ValueAnimator.ofFloat(0, 1); animator1.setDuration(5000); animator1.setInterpolator(new LinearInterpolator()); animator1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Float animatedValue = (Float) animation.getAnimatedValue(); currentStartY = (int) (getHeight() * animatedValue); postInvalidate(); &#125; &#125;); animator1.start(); &#125; //改变我们的初始点的y坐标。不要只写个currentStartY， //光写这个是从下往上移动，你要的是从上往下移动 path.moveTo(-endX*2 + currentStartX, getHeight()-currentStartY); //再就是修改画笔为填充 paint.setStyle(Paint.Style.FILL_AND_STROKE); //并且把path连接成一个闭合图形 ...//这里是onDraw里面的for循环画正弦图形 path.lineTo(getWidth(),getHeight()); path.lineTo(0,getHeight()); path.close(); canvas.drawPath(path, paint); 跑出来的效果图，如下： &emsp;&emsp;到这个位置，基本上已经完成了百分之九十了。我们可以看到开始会有一个问题，结束的时候也有一个问题，这个问题是怎么产生的呢？ 第四步：优化开始和结束的动画&emsp;&emsp;其实，我们可以想一想，一开始，我们这个控制点的Y值，不应该一出来就是写死的，显得太突兀了，一开始，我们应该是慢慢涨，涨到我们规定的值，然后快结束的时候，我们应该是慢慢减，减到0为止。应该是这样才对。 1234567891011121314151617181920212223@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.reset(); int currentControlY = 0; if (currentStartY &lt; controlY) &#123; currentControlY = currentStartY; &#125; else &#123; currentControlY = controlY; &#125; if (getHeight() - currentStartY &lt; controlY) &#123; currentControlY = getHeight() - currentStartY; &#125; path.moveTo(-endX * 2 + currentStartX, getHeight() - currentStartY); for (int i = -endX * 2; i &lt; getWidth() + endX * 2; i += 2 * endX) &#123; path.rQuadTo(endX / 2, -currentControlY, endX, 0); path.rQuadTo(endX / 2, currentControlY, endX, 0); &#125; path.lineTo(getWidth(), getHeight()); path.lineTo(0, getHeight()); path.close(); canvas.drawPath(path, paint); &#125; 效果图如下： 经过上面的操作，就完美的达到了我们的预期效果。(PS：把画笔的宽度去掉) 把这个自定义View优化一下，把方法封装好了。项目链接]]></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android自定义刷新布局——Ultra-Pull-To-Refresh-With-Load-More（二））]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%B7%E6%96%B0%E5%B8%83%E5%B1%80%E2%80%94%E2%80%94Ultra-Pull-To-Refresh-With-Load-More%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[回顾上一篇，我们讲到了Ultra-Pull-To-Refresh的基本用法。分成四步： xml里面定义控件PtrFrameLayout 设置相关属性 添加Header，Footer，并监听 监听刷新过程 思路&emsp;&emsp;目的： 做一个我们自己的自定义刷新的动画（我们先不管动画是什么，不同的需求，动画都不一样） &emsp;&emsp;我们前面讲到的主要类无非就是两个： PtrFrameLayout，Header（Footer），前者是刷新控件，监听刷新过程，后者是头布局（脚布局），以添加头布局为例：我们这里首先就会想到重写这个布局。辣么？怎么重写这个头布局呢？我们先来看看怎么添加这个头布局的： 123456789101112public void setHeaderView(View header) &#123; if (mHeaderView != null &amp;&amp; header != null &amp;&amp; mHeaderView != header) &#123; removeView(mHeaderView); &#125; ViewGroup.LayoutParams lp = header.getLayoutParams(); if (lp == null) &#123; lp = new LayoutParams(-1, -2); header.setLayoutParams(lp); &#125; mHeaderView = header; addView(header); &#125; 它这里实际上就是添加了一个View，所以，我们随便写一个自定义View，继承View就可以传进来 &emsp;&emsp;我们，再来看看另一个方法，就是监听的方法，这里好像也是传的View对象，因为，我们前面写的时候就是传的header： 123public void addPtrUIHandler(PtrUIHandler ptrUIHandler) &#123; PtrUIHandlerHolder.addHandler(mPtrUIHandlerHolder, ptrUIHandler); &#125; &emsp;&emsp;咦，不对啊，这里不是应该传的View对象么？怎么是PtrUIHandler类型的。其实，你看名字就应该看的出来，他这里传的是一个PtrUIHandler对象，点进去看，他就是一个接口。里面是下拉刷新的回调。讲到这里，我们就应该明了了，就是一个自定义View，继承View，实现PtrUIHandler接口。辣么，就开始撸了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Author: 海晨忆 * Date: 2018/3/23 * Desc: */public class MyCustomHeader extends FrameLayout implements PtrUIHandler &#123; public MyCustomHeader(@NonNull Context context) &#123; this(context, null); &#125; public MyCustomHeader(@NonNull Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MyCustomHeader(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; private void initView() &#123; LayoutInflater.from(getContext()).inflate(R.layout.header_layout, this); &#125; @Override public void onUIReset(PtrFrameLayout frame) &#123; &#125; @Override public void onUIRefreshPrepare(PtrFrameLayout frame) &#123; &#125; @Override public void onUIRefreshBegin(PtrFrameLayout frame) &#123; &#125; @Override public void onUIRefreshComplete(PtrFrameLayout frame, boolean isHeader) &#123; &#125; @Override public void onUIPositionChange(PtrFrameLayout frame, boolean isUnderTouch, byte status, PtrIndicator ptrIndicator) &#123; &#125;&#125; &emsp;&emsp;可以看到，我这里面什么都没有，就是继承了FrameLayout布局，实现了PtrUIHandler接口，然后在构造方法里面加载了一个布局，添加进来，布局也很简单，里面就只有一个ImageView。布局如下： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;200dp&quot; android:src=&quot;@drawable/psb17&quot;/&gt;&lt;/merge&gt; &emsp;&emsp;再就是调用了，跟上一篇的调用方式一样。 123456789101112131415final PtrFrameLayout ptrFrameLayout = findViewById(R.id.ptr_frame_layout); MyCustomHeader myCustomHeader = new MyCustomHeader(this); ptrFrameLayout.setHeaderView(myCustomHeader); ptrFrameLayout.addPtrUIHandler(myCustomHeader); ptrFrameLayout.setPtrHandler(new PtrDefaultHandler2() &#123; @Override public void onRefreshBegin(PtrFrameLayout frame) &#123; frame.postDelayed(ptrFrameLayout::refreshComplete, 2000); &#125; @Override public void onLoadMoreBegin(PtrFrameLayout frame) &#123; frame.postDelayed(ptrFrameLayout::refreshComplete, 2000); &#125; &#125;); &emsp;&emsp;然后运行，你就会看到，刷新的header就是你的自定义view。到此，自定义刷新布局就完成了，脚布局方式类似。 &emsp;&emsp;什么鬼？这就没了？刷新布局就一个ImageView就没了？这么敷衍。好歹你也加个动画啊。可以可以，那就加个动画。 &emsp;&emsp;如你所愿，我加了一个帧动画。 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/refresh1&quot; android:duration=&quot;100&quot;/&gt; &lt;item android:drawable=&quot;@drawable/refresh2&quot; android:duration=&quot;100&quot;/&gt; &lt;item android:drawable=&quot;@drawable/refresh3&quot; android:duration=&quot;100&quot;/&gt;&lt;/animation-list&gt; header里面的改动： 12345678910111213141516private void initView() &#123; LayoutInflater.from(getContext()).inflate(R.layout.header_layout, this); imageView = findViewById(R.id.img); animationDrawable = (AnimationDrawable) imageView.getDrawable(); &#125; @Override public void onUIRefreshBegin(PtrFrameLayout frame) &#123; imageView.setImageDrawable(animationDrawable); animationDrawable.start(); &#125; @Override public void onUIRefreshComplete(PtrFrameLayout frame, boolean isHeader) &#123; animationDrawable.stop(); &#125; 在初始化的时候，把动画获取到，然后在刷新的时候开始动画，在刷新完成的时候停止动画。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android下拉刷新，上拉加载——Ultra-Pull-To-Refresh-With-Load-More（一）]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E2%80%94%E2%80%94Ultra-Pull-To-Refresh-With-Load-More%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介Android里面刷新和分页加载是常见的，刷新有Google的SwipeRefreshLayout，但是UI不同意，非要跟IOS一样，那就没办法了。 开源框架链接：Ultra-Pull-To-Refresh-With-Load-More。这个开源框架是基于Ultra-Pull-To-Refresh拓展了一个上拉加载功能。 作者：廖祜秋 依赖12implementation &apos;in.srain.cube:ptr-load-more:1.0.6&apos; 用法整个项目就只有一个核心类：PtrFrameLayout，继承ViewGroup。步骤： xml里面定义控件PtrFrameLayout 设置相关属性 添加Header，Footer，并监听 监听刷新过程 第一步：xml里面定义控件PtrFrameLayout1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;in.srain.cube.views.ptr.PtrFrameLayout android:id=&quot;@+id/ptr_frame_layout&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:cube_ptr=&quot;http://schemas.android.com/apk/res-auto&quot; cube_ptr:ptr_resistance_header=&quot;1.7&quot; cube_ptr:ptr_ratio_of_header_height_to_refresh=&quot;1.2&quot; cube_ptr:ptr_duration_to_back_header=&quot;300&quot; cube_ptr:ptr_duration_to_close_header=&quot;2000&quot; cube_ptr:ptr_keep_header_when_refresh=&quot;true&quot; cube_ptr:ptr_pull_to_fresh=&quot;false&quot; cube_ptr:ptr_resistance_footer=&quot;1.3&quot; cube_ptr:ptr_duration_to_back_footer=&quot;300&quot; cube_ptr:ptr_duration_to_close_footer=&quot;2000&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/colorAccent&quot; android:gravity=&quot;center&quot; android:text=&quot;textView&quot;/&gt; &lt;/LinearLayout&gt;&lt;/in.srain.cube.views.ptr.PtrFrameLayout&gt; 上面就是一个简单的布局，根布局是 PtrFrameLayout ，他的子View可以是任意view。 第二步：设置相关属性我们也看到了，他的布局里面有一些自定义属性，可以在布局里面设置，也可以在java代码里面设置，相关属性含义如下： Resistence：阻尼系数，可以分别设置header和footer。默认: 1.7f，越大，感觉下拉刷新时越吃力。上拉加载也是一样的 Ratio of the Height of the Header to Refresh：触发刷新时移动的位置比例。默认，1.2f，移动达到头部高度1.2倍时可触发刷新操作。下拉刷新，上拉加载都一样。 Duration to Close back：回弹延时。默认 200ms，回弹到刷新或者高度所用时间，可以跟上面一样分开设置，也可以设置一个 Duration to Close Header：刷新完成之后隐藏头部的时间。默认1000mscube_ptr:ptr_duration_to_close_either=”2000” Keep Header while Refreshing：刷新是保持头部，也就是显示头部。默认值 true。false：隐藏头部 Pull to Refresh / Release to Refresh：下拉刷新 / 释放刷新。默认为释放的时候刷新 在java代码中设置方式如下： 1234567891011final PtrFrameLayout ptrFrameLayout = findViewById(R.id.ptr_frame_layout);//配置头部参数,可以在xml中设置// the following are default settings ptrFrameLayout.setResistance(1.7f); ptrFrameLayout.setRatioOfHeaderHeightToRefresh(1.2f); ptrFrameLayout.setDurationToClose(200); ptrFrameLayout.setDurationToCloseHeader(1000);// default is false ptrFrameLayout.setPullToRefresh(false);// default is true ptrFrameLayout.setKeepHeaderWhenRefresh(true); 第三步：添加Header，Footer，并监听12345678910111213141516171819202122232425//第一种头部,StoreHouse风格的头部实现 /*StoreHouseHeader storeHouseHeader = new StoreHouseHeader(this); storeHouseHeader.setPadding(0,100,0,0); storeHouseHeader.setBackgroundColor(Color.BLACK); storeHouseHeader.setTextColor(Color.WHITE); storeHouseHeader.initWithString(&quot;haichenyi&quot;);//只可英文，中文不可运行(添加时间) ptrFrameLayout.setHeaderView(storeHouseHeader); ptrFrameLayout.addPtrUIHandler(storeHouseHeader);*/ //第二种头部,Material Design风格的头部实现,类似SwipeRefreshLayout /*MaterialHeader materialHeader = new MaterialHeader(this); materialHeader.setColorSchemeColors(new int[]&#123;Color.RED, Color.GREEN, Color.BLUE&#125;); ptrFrameLayout.setHeaderView(materialHeader); ptrFrameLayout.addPtrUIHandler(materialHeader);*/ //第三种头部,经典 风格的头部实现，下拉箭头+时间 PtrClassicDefaultHeader ptrClassicDefaultHeader = new PtrClassicDefaultHeader(this); ptrFrameLayout.setHeaderView(ptrClassicDefaultHeader); PtrClassicDefaultFooter ptrClassicDefaultFooter = new PtrClassicDefaultFooter(this); ptrFrameLayout.setFooterView(ptrClassicDefaultFooter); ptrFrameLayout.addPtrUIHandler(ptrClassicDefaultHeader); ptrFrameLayout.addPtrUIHandler(ptrClassicDefaultFooter); 如上面代码所示，Header，Footer的种类是一样的，Header有三种，Footer也有三种，定义好之后，通过 setHeaderView(), setFooterView() 添加到 ptrFrameLayout 中，然后通过调用 addPtrUIHandler 监听两者的状态即可。不监听会显示空白，看不到具体内容 第四步：监听刷新过程123456789101112ptrFrameLayout.setPtrHandler(new PtrDefaultHandler2() &#123; @Override public void onLoadMoreBegin(PtrFrameLayout frame) &#123; frame.postDelayed(ptrFrameLayout::refreshComplete, 2000); &#125; @Override public void onRefreshBegin(PtrFrameLayout frame) &#123; frame.postDelayed(ptrFrameLayout::refreshComplete, 2000); &#125; &#125;); ptrFrameLayout.setMode(PtrFrameLayout.Mode.LOAD_MORE); 通过设置 setPtrHandler() 方法监听刷新过程。默认的是 PtrDefaultHandler2(),它是后来加的，包括刷新和加载。PtrDefaultHandler() 只包含刷新功能。通过setMode()方法设置：只要下拉刷新，或者只要上拉加载，或者两者都要。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 加密算法（二）]]></title>
    <url>%2F2018%2F05%2F13%2FJava-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[补充知识点：密钥： 加密方用公钥，解密方用私钥 重要的事情强调六遍： 不用自己写加密算法 不用自己写加密算法 不用自己写加密算法 不用自己写加密算法 不用自己写加密算法 不用自己写加密算法 Cipher类&emsp;&emsp;Android有专门用来加密的工具类Cipher类，他里面封装了几种常用的加密算法，本篇介绍两种AES，RSA。 用法 12345678910111213141516171819202122232425262728293031分三步：以AES举例说明 /** * 加密方式：AES * 工作模式：ECB,CBC,CTR,OFB,CFB * 填充模式：PKCS5Padding，PKCS7Padding，ZEROPadding等等 */String CBC_PKCS5_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;//AES是加密方式 CBC是工作模式 PKCS5Padding是填充模式//第一步：获取对象Cipher cipher = Cipher.getInstance(String transformation);//传 CBC_PKCS5_PADDING//第二步：设置初始化参数 /** * 第一个参数：传类型，是加密Cipher.ENCRYPT_MODE，还是解密Cipher.DECRYPT_MODE * 第二个参数：传密钥key，我们这里传的是SecretKeySpec，它实现SecretKey，SecretKey实现Key接口。 * SecretKeySpec keySpec = new SecretKeySpec(raw, AES);//第一个参数传密钥byte数组，第二个参数传加密类型也就是&quot;AES&quot;字符串即可 * 第三个参数：传偏移量AlgorithmParameterSpec，我们这里传的IvParameterSpec，他实现AlgorithmParameterSpec接口，iv偏移量传默认的16个0的字节数组 * new IvParameterSpec(new byte[cipher.getBlockSize()])，这里是传的默认的16个0的byte数组，也是常用的方式 */cipher.init(int opmode, Key key, AlgorithmParameterSpec params)第三步：加密。传需要加密的字符串的byte数组cipher.doFinal(byte[] input)经过以上三步：AES加密就算完成了，加密之后就需要解密，辣么，怎么解密呢？ 草鸡简单，第二步初始化的时候，第一个参数传解密即可，其他都是一样的。 对称加密概念出自百度百科 &emsp;&emsp;需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。 &emsp;&emsp;所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。 &emsp;&emsp;因此，加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。 &emsp;&emsp;说了这么多废话，要我说，就一句话公钥，私钥 相同 的加密方式称之为对称加密 用法——AES&emsp;&emsp;申明：我这里并不是说对称加密就只有AES这一种方式，相反，对称加密有很多种，我这里只讲我用到的对称加密中的一种方式——AES 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 private static final String CBC_PKCS5_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;//AES是加密方式 CBC是工作模式 PKCS5Padding是填充模式 private static final String AES = &quot;AES&quot;;//AES 加密 private static final String SHA1PRNG = &quot;SHA1PRNG&quot;;// SHA1PRNG 强随机种子算法, 要区别4.2以上版本的调用方法/** * 随机生成密钥，传同一个字符串，每次都生成的不一样 * @param seed 一般传用户的密码 * @return 返回密钥的byte数组 * @throws Exception 异常 */ private static byte[] getRawKey(String seed) throws Exception &#123; SecureRandom sr = null; // 在4.2以上版本中，SecureRandom获取方式发生了改变 if (android.os.Build.VERSION.SDK_INT &gt;= 17) &#123; sr = SecureRandom.getInstance(SHA1PRNG, &quot;Crypto&quot;); &#125; else &#123; sr = SecureRandom.getInstance(&quot;SHA1PRNG&quot;); // 获得一个随机数，传入的参数为默认方式。 &#125; sr.setSeed(seed.getBytes()); // 设置一个种子，这个种子一般是用户设定的密码。也可以是其它某个固定的字符串 KeyGenerator keyGen = KeyGenerator.getInstance(&quot;AES&quot;); // 获得一个key生成器（AES加密模式） //AES中128位密钥版本有10个加密循环，192比特密钥版本有12个加密循环，256比特密钥版本则有14个加密循环。 keyGen.init(128, sr); // 设置密匙长度128位 SecretKey key = keyGen.generateKey(); // 获得密匙 return key.getEncoded(); &#125; /** * 加密过程 * @param raw 密钥的数组 * @param clear 需要加密的byte数组 * @return 加密后的byte数组 * @throws Exception 异常 */ private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception &#123; SecretKeySpec keySpec = new SecretKeySpec(raw, AES); Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING); //iv偏移量传默认的16个0的字节数组 cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); return cipher.doFinal(clear); &#125; /* * 解密 */ private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception &#123; SecretKeySpec keySpec = new SecretKeySpec(raw, AES); Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING); cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); return cipher.doFinal(encrypted); &#125; &emsp;&emsp;上面给的三个方法，一个获取密钥，一个加密，一个解密，注释写的很清楚，我就不用再讲了，转16进制的方法，我前一篇讲加密的时候就给出来了，不知道的可以去前一篇看一下，我下面给出调用方式和结果截图 1234567891011121314try &#123; byte[] rawKey = getRawKey(key); Log.v(&quot;wz&quot;, rawKey.length + &quot;&quot;); String s = bytesToHexFun1(rawKey); Log.v(&quot;wz&quot;,&quot;密钥16进制--&gt;&quot;+s); byte[] encrypt = encrypt(rawKey, data.getBytes()); String after = Base64.encodeToString(encrypt, Base64.NO_WRAP); Log.v(&quot;wz&quot;,&quot;加密后--&gt;&quot;+after); byte[] decode = Base64.decode(after, Base64.NO_WRAP); byte[] before = decrypt(rawKey, decode); Log.v(&quot;wz&quot;,&quot;解密后--&gt;&quot;+new String(before)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 结果： 非对称加密概念出自百度百科 &emsp;&emsp;1976年，美国学者Dime和Henman为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。 &emsp;&emsp;与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 &emsp;&emsp;说了这么多废话，要我说，就一句话公钥，私钥 不相同 的加密方式称之为对称加密 用法——RSA&emsp;&emsp;申明：我这里并不是说非对称加密就只有RSA这一种方式，相反，对非称加密有很多种，我这里只讲我用到的非对称加密中的一种方式——RSA &emsp;&emsp;辣么，成对公钥，私钥怎么来呢？难道我们自己去写吗？你要是会写，那你很棒棒哦，反正我不会(爱咋咋)，我是在线生成公钥，私钥对。用法跟上面讲的AES是类似的： 12345678910111213141516171819202122232425262728293031323334353637383940/** * 我们之前拿到的是公钥，我们还要把公钥转成Key * 因为cipher.init()初始化的时候，第二个参数需要传Key类型的，并不是String * 获取Key，我这里返回的是PublicKey，它实现的Key接口 * @param pubKey 生成的公钥 * @return 最后需要的key * @throws Exception 异常 */ public static PublicKey loadPublicKey(String pubKey) throws Exception &#123; byte[] buffer = Base64.decode(pubKey, Base64.DEFAULT); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer); return keyFactory.generatePublic(keySpec); &#125; /** * 加密 * @param data 需要加密的数据 * @param publicKey key * @return 返回加密后的byte，需要转成字符串 * @throws Exception 异常 */ private static byte[] encryptRSA(String data,PublicKey publicKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;); cipher.init(Cipher.ENCRYPT_MODE,publicKey); return cipher.doFinal(data.getBytes()); &#125; /** * 解密（我们需要注意的是，我们解密的是私钥加密的数据，不能解密公钥加密的数据） * @param data 需要解密的数据 * @param publicKey key * @return 返回解密后的数组 * @throws Exception 异常 */ private static byte[] decryptRSA(String data,PublicKey publicKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;); cipher.init(Cipher.DECRYPT_MODE,publicKey); return cipher.doFinal(data.getBytes()); &#125; &emsp;&emsp;这里，注释说的很清楚，看懂了前面的AES，辣么，这个RSA应该不是问题。]]></content>
      <categories>
        <category>Android -加密算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 加密算法（一）]]></title>
    <url>%2F2018%2F03%2F08%2FJava-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[补充知识点：字节：也就是 byte 是一种统计单位，表示数量的多少 字符：是指计算机中使用的文字和符号，比如：1、2、3、A、S、D、$、%等等符号 字节与字符的对应关系：它们完全不是一个概念，所以，没有什么有没有区别这个说法。不同的编码，两者的对应关系是不相同的，我这里就说常用的两种编码： ASCII码中，一个英文字母（不区分大小写）占一个字节，一个中文汉字占两个字节 UTF-8中，一个英文字母占一个字节，一个中文汉字占三个字节 &emsp;&emsp;我们加密最终常常操作的是bit，而我们加密首先得到的是byte数组的，byte的取值范围-128~127，中间包括0，刚好256个。也就是2^8=256。并且，1 byte = 8 bit（1kb = 1024 byte = 8^1024 bit等等） &emsp;&emsp;我们获得了byte之后，要把byte数组转成String字符串，String其实就是char数组，我们java有一个new String(char[] chars)，应该都用过。我们转成字符串的前提是转成char数组，由于，1 char = 2 byte，所以，我们byte转成char长度扩大了1倍。 四种分类 MD5加密 Base64加密 对称加密 非对称加密 MD5加密——不可逆概念&emsp;&emsp;MD5加密是我们常见的加密算法，是不可逆的，也就是说加密完成之后，无法解密转成原来的内容。MD5加密算法其实是一种散列函数，使用的是hash算法。MD5的原文是无线多个，但是MD5的值是有限的。所以一个MD5的值可能对应多个原文。SHA算法跟MD5是差不多的，只是MD5是128位，SHA是160位，多32位 &emsp;&emsp;为什么MD5的值是有限多个呢？主流的MD5使用的是将任意长度的字节串映射为一个128bit的大整数。也就是一共有2^128种可能，所以说这个数字是有限的，而，我们的原文则是无限多个。发现两段原文对应同一个MD5的值概率非常小，也就忽略不记了。 使用1234567891011121314String name1 = &quot;haichenyi&quot;; String name2 = &quot;海晨忆&quot;; try &#123; MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); byte[] digest1 = md5.digest(name1.getBytes(&quot;UTF-8&quot;)); Log.v(&quot;WZ&quot;,&quot;length1:&quot;+digest1.length); byte[] digest2 = md5.digest(name2.getBytes(&quot;UTF-8&quot;)); Log.v(&quot;WZ&quot;,&quot;length1:&quot;+digest2.length); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &emsp;&emsp;我们通过MD5，得到的是一个byte数组（这个byte数组的长度跟我们的1byte=8bit没有直接关系），我们需要做的就是对这个byte数组进行操作，我们习惯上就是把这个btye转成16进制数存进数据库，当然，你也可以转成其他的类型存到数据库。这里给出几个byte数组转16进制字符串的方法，亲测可用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private static final char[] HEX_CHAR = &#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;; /** * 方法一： * byte[] to hex string * * @param bytes * @return */ public String bytesToHexFun1(byte[] bytes) &#123; // 一个byte为8位，可用两个十六进制位标识 char[] buf = new char[bytes.length * 2]; int a = 0; int index = 0; for (byte b : bytes) &#123; // 使用除与取余进行转换 if (b &lt; 0) &#123; a = 256 + b; &#125; else &#123; a = b; &#125; buf[index++] = HEX_CHAR[a / 16]; buf[index++] = HEX_CHAR[a % 16]; &#125; return new String(buf); &#125; /** * 方法二： * byte[] to hex string * * @param bytes * @return */ public String bytesToHexFun2(byte[] bytes) &#123; char[] buf = new char[bytes.length * 2]; int index = 0; for(byte b : bytes) &#123; // 利用位运算进行转换，可以看作方法一的变种 buf[index++] = HEX_CHAR[b &gt;&gt;&gt; 4 &amp; 0xf]; buf[index++] = HEX_CHAR[b &amp; 0xf]; &#125; return new String(buf); &#125; /** * 方法三： * byte[] to hex string * * @param bytes * @return */ public String bytesToHexFun3(byte[] bytes) &#123; StringBuilder buf = new StringBuilder(bytes.length * 2); for(byte b : bytes) &#123; // 使用String的format方法进行转换 buf.append(String.format(&quot;%02x&quot;, new Integer(b &amp; 0xff))); &#125; return buf.toString(); &#125; /** * 将16进制字符串转换为byte[] * * @param str * @return */ public byte[] toBytes(String str) &#123; if(str == null || str.trim().equals(&quot;&quot;)) &#123; return new byte[0]; &#125; byte[] bytes = new byte[str.length() / 2]; for(int i = 0; i &lt; str.length() / 2; i++) &#123; String subStr = str.substring(i * 2, i * 2 + 2); bytes[i] = (byte) Integer.parseInt(subStr, 16); &#125; return bytes; &#125; Base64加密——可逆流程 要知道的是有一个64个数的表，也称Base64编码表。可以字节定义，不过都是用的一样的。 Base64是按照字符长度，以3个字符为一组 接着增对每组的每个字符，取ASCII编码 然后将获得的编码转换成8bit的二进制，就会得到3*8=24bit的字节 然后将这24bit的字节以6个bit为一组，分成4组 接着在每组前面填两个高位0，凑成每组8bit 最后将这每组8bit的二进制转成十进制，对应下面的Base64编码表 Base64 编码表 value char value char value char value char 0 A 16 Q 32 g 48 w 1 B 17 R 33 h 49 x 2 C 18 S 34 i 50 y 3 D 19 T 35 j 51 z 4 E 20 U 36 k 52 0 5 F 21 V 37 l 53 1 6 G 22 U 38 m 54 2 7 H 23 X 39 n 55 3 8 I 24 Y 40 o 56 4 9 J 25 Z 41 p 57 5 10 K 26 a 42 q 58 6 11 L 27 b 43 r 59 7 12 M 28 c 44 s 60 8 13 N 29 d 45 t 61 9 14 O 30 e 46 u 62 + 15 P 31 f 47 v 63 / 使用1234567891011String str = &quot;hai&quot;; byte[] encode = Base64.encode(str.getBytes(), Base64.NO_WRAP); try &#123; String a = new String(encode,&quot;UTF-8&quot;); String a1 = new String(encode,&quot;US-ASCII&quot;); Log.v(&quot;wz&quot;,a); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; String after = Base64.encodeToString(str.getBytes(), Base64.NO_WRAP); Log.v(&quot;wz&quot;,&quot;after--&gt;&quot;+after); 解析&emsp;&emsp;这里，我要使用Base64加密”hai”这个字符串，根据上面的流程： 待加密字符串 h a i ASCII编码 104 97 105 二进制 01101000 01100001 01101001 下面，上面的表不好表示，我再换一个表，下一步，该6位分一组了 现在的字符串：01101000 01100001 01101001 六位分一组 011010 000110 000101 101001 每组前面补0 00011010 00000110 00000101 00101001 转成10进制 26 6 5 41 Base64编码 a G F p 结果图： PS： Base64.encodeToString()方法直接转成加密后的字符串 Base64.encode()方法返回的byte数组是16进制的，不用手动在去转一遍16进制]]></content>
      <categories>
        <category>Android -加密算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EventBus源码解析(二)——注册]]></title>
    <url>%2F2018%2F03%2F07%2FEventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前我们讲过获取EventBus对象的源码，这一篇，我们来讲讲注册的源码。推荐EventBus 3.0进阶：源码及其设计模式 完全解析 简介12345678/** * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they * are no longer interested in receiving events. * &lt;p/&gt; * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;. * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link * ThreadMode&#125; and priority. */ &emsp;&emsp; 翻译： 注册给订阅方去接收事件，订阅者一旦对接收事件不感兴趣了，就要unregister，订阅者必须要有用Subscribe注解的方法，注解也可以设置线程和优先级 &emsp;&emsp; 白话文： 订阅者要是想接收消息，必须要先注册。当页面退出，或者不想接收消息的时候必须要反注册，不然他会一直处于接收消息的状态，页面退出会内存泄漏。订阅者的接收方法必须要用Subscribe注解，这个注解的后面可以设置接收这个消息的线程和优先级。如下： 1234@Subscribe(threadMode = ThreadMode.MAIN,priority = 100,sticky = true) public void handleMsg(DataBean dataBean)&#123; &#125; &emsp;&emsp;就像上面这样写，我一个一个来讲。我们先来说说这个ThreadMode类，点进去，我们可以看到如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 每个订阅的方法都有一个线程，决定那个线程的方法被叫做EventBus * EventBus的线程可以跟Post事件的那个线程不相同 */public enum ThreadMode &#123; /** *订阅者将在跟Post事件的那个线程的同一个线程中被调用，这是默认值， * 因为，他没有线程切换，所以开销最少，所以也是推荐模式。需要注意的是 * post事件的线程可能是UI线程，也可能是其他线程，所以，这里的操作要做判断， * 如果是UI操作，你必须要在UI线程中完成，如果是耗时操作，你必须要新开线程 */ POSTING, /** * 在Android上面，订阅者将会在UI线程中调用，如果post事件的线程是UI线程， * 辣么，这个订阅方法将直接被调用，如果不是UI线程，辣么，它将要排队交付， * 所以，这里可能阻塞线程，订阅者使用这个模式必须要快速返回，避免阻塞UI线程， * 就是不要在这里做耗时操作。谢谢。 */ MAIN, /** *这一个，跟上面的刚好对应，就是不管怎么样，都要排队交付， * 不论post事件是不是处于UI线程发送的 */ MAIN_ORDERED, /** * 在android上面，订阅方法将在子线程中调用。如果post事件处于子线程， * 辣么，订阅方法将直接被调用。如果post事件处于UI线程，辣么，eventBus * 就会新开线程，按照顺序处理事件，当然，也要注意，避免阻塞子线程 */ BACKGROUND, /** * 订阅方法将会在独立的线程中调用，这个线程总是独立语post事件 * 所处的线程和主线程。如果post事件是耗时操作：例如网络请求， * 订阅方法调用的时候，不会等待。我们不用考虑线程数量的问题， * EventBus已经限制了并发线程，并使用线程池高效的重用线程 */ ASYNC&#125; 他就是一个枚举类，几个值的意义，我说的很清楚了。 &emsp;&emsp;我们再来讲讲另外两个： sticky，默认值是false，如果设置成true，辣么，这个事件将会是粘性事件。发送事件的方式从post变成了postSticky，其他都没变。 &emsp;&emsp;再来讲讲 priority ，默认值是0，在同一个线程中值越大，优先级越高。优先级高的比优先级低的先收到消息。 好，终于准备工作做完了，我们来看看 register() 方法 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; &emsp;&emsp;注册方法。首先，他通过反射的方式获得当前类名，然后通过当前类名，找到订阅方法，存到list里面。我们来看看 findSubscriberMethods()方法 123456789101112131415161718192021List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;//首先从缓存中读取当前类的订阅方法，如果不等于null，就直接返回从缓存中读取到的list List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125;//ignoreGeneratedIndex的值，从Builder可知，一般为false。 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; //将获取的subscriberMeyhods放入缓存中 METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; &emsp;&emsp;上面的注释写的很清楚，ignoreGeneratedIndex为false，辣么就会走findUsingInfo() 方法 123456789101112131415161718192021222324private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;//首先新建了一个FindState，FindState是一个静态内部类，保存订阅者的信息 FindState findState = prepareFindState(); //初始化FindState findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findState.subscriberInfo = getSubscriberInfo(findState); //初始化的findState获得的订阅者信息，一般都是null if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; //就会跳到这里 findUsingReflectionInSingleClass(findState); &#125; //移动到父类继续查找 findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; 上面，我们提到了FindState类，我们来看看这个类的代码 1234567891011121314151617181920static class FindState &#123;//订阅方法的列表 final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;();//以class的名称为key，以方法为value final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;();//以方法名称为key，订阅者类为value final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;(); final StringBuilder methodKeyBuilder = new StringBuilder(128); Class&lt;?&gt; subscriberClass; Class&lt;?&gt; clazz; boolean skipSuperClasses; SubscriberInfo subscriberInfo;//初始化 void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; this.subscriberClass = clazz = subscriberClass; skipSuperClasses = false; subscriberInfo = null; &#125; &#125; &emsp;&emsp;不难看出，这里的几个map包括了，类名找方法，方法名找类，我们后面都用的到，然后就是初始化方法，前面我们注释里面写了，初始化之后一般信息都是null，这里我们也可以看到。所以，它会走 findUsingReflectionInSingleClass 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; /*------------------------------上面就是获取方法，重要的是在下面------------------------------------*/ //这里我强调的是我们前面的用法里面有说过注意点 //1.必须是public修饰 //2.必须是void类型 //3.必须是一个参数 //4.必须用Subscribe注解 for (Method method : methods) &#123; //获取方法的修饰符 int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; //获取方法参数类型 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //如果参数个数等于1 if (parameterTypes.length == 1) &#123; //获取方法注解名称 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; //参数类型 即为事件类型 Class&lt;?&gt; eventType = parameterTypes[0]; //调用checkAdd方法判断是否添加过 if (findState.checkAdd(method, eventType)) &#123; //从注解里面获取线程模式 ThreadMode threadMode = subscribeAnnotation.threadMode(); //新建一个SubscriberMethod对象，并添加到findState的subscriberMethods这个集合内 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; //如果开启了严格验证，同时当前方法又有@Subscribe注解，对不符合要求的方法会抛出异常 &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125; &#125; &emsp;&emsp;这个方法非常重要！！！在这个方法内部，利用反射的方式，对订阅者类进行扫描判断，是否满足条件从而找出订阅方法，并用上面的容器进行保存。辣么，上面提到的 checkAdd() 方法是怎么检查的呢？ 123456789101112131415161718boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123; // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required. // Usually a subscriber doesn&apos;t have methods listening to the same event type. Object existing = anyMethodByEventType.put(eventType, method); if (existing == null) &#123; return true; &#125; else &#123; if (existing instanceof Method) &#123; if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123; // Paranoia check throw new IllegalStateException(); &#125; // Put any non-Method object to &quot;consume&quot; the existing Method anyMethodByEventType.put(eventType, this); &#125; return checkAddWithMethodSignature(method, eventType); &#125; &#125; &emsp;&emsp;这个注释写的很清楚，两层检验，第一层是检测事件类型，第二次检验则是检验判断方法的完整，首先以eventType为键，方法为值，存到map中（这个map是在FindState类初始化的），put方法会有一个返回值，返回value，这个value是这个key对应的上一个值，所以说，如果是第一次存放，那么就会返回null。否则，之前存放过，辣么就会进入下一个判断 checkAddWithMethodSignature 1234567891011121314151617private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append(&apos;&gt;&apos;).append(eventType.getName()); String methodKey = methodKeyBuilder.toString(); Class&lt;?&gt; methodClass = method.getDeclaringClass(); Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy subscriberClassByMethodKey.put(methodKey, methodClassOld); return false; &#125; &#125; &emsp;&emsp;这个方法就是用来判断方法签名是否相同的，方法签名是什么呢？就是修饰符+返回类型+方法名+参数list是否相同。如果方法签名相同，辣么，就把旧值赋值给methodClassOld，判断这个值不是为null，第一次调用，没有旧值，就肯定为null，所以，if前面的一个条件是满足的，后面一个条件methodClassOld.isAssignableFrom(methodClass) 的意思是判断旧值是否是methodClass或者同一个类，如果两个条件都不满足，辣么当前方法就不会添加为订阅方法。 &emsp;&emsp;那么，说了一大堆关于checkAdd和checkAddWithMethodSignature方法的源码，那么这两个方法到底有什么作用呢？从这两个方法的逻辑来看，第一层判断根据eventType来判断是否有多个方法订阅该事件，而第二层判断根据完整的方法签名(包括方法名字以及参数名字)来判断。下面是笔者的理解： &emsp;&emsp;第一种情况：比如一个类有多个订阅方法，方法名不同，但它们的参数类型都是相同的(虽然一般不这样写，但不排除这样的可能)，那么遍历这些方法的时候，会多次调用到checkAdd方法，由于existing不为null，那么会进而调用checkAddWithMethodSignature方法，但是由于每个方法的名字都不同，因此methodClassOld会一直为null，因此都会返回true。也就是说，允许一个类有多个参数相同的订阅方法。 &emsp;&emsp;第二种情况：类B继承自类A，而每个类都是有相同订阅方法，换句话说，类B的订阅方法继承并重写自类A，它们都有着一样的方法签名。方法的遍历会从子类开始，即B类，在checkAddWithMethodSignature方法中，methodClassOld为null，那么B类的订阅方法会被添加到列表中。接着，向上找到类A的订阅方法，由于methodClassOld不为null而且显然类B不是类A的父类，methodClassOld.isAssignableFrom(methodClass)也会返回false，那么会返回false。也就是说，子类继承并重写了父类的订阅方法，那么只会把子类的订阅方法添加到订阅者列表，父类的方法会忽略。 &emsp;&emsp;让我们回到findUsingReflectionInSingleClass方法，当遍历完当前类的所有方法后，会回到findUsingInfo方法，接着会执行最后一行代码，即return getMethodsAndRelease(findState);那么我们继续 getMethodsAndRelease 123456789101112131415private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123; //从findState获取subscriberMethods，放进新的ArrayList List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); //把findState回收 findState.recycle(); synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; if (FIND_STATE_POOL[i] == null) &#123; FIND_STATE_POOL[i] = findState; break; &#125; &#125; &#125; return subscriberMethods; &#125; 通过该方法，把subscriberMethods不断逐层返回，直到返回EventBus#register()方法，最后开始遍历每一个订阅方法，并调用subscribe(subscriber, subscriberMethod)方法，那么，我们继续来看subscribe方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Must be called in synchronized block private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; //将subscriber和subscriberMethod封装成 Subscription Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //根据事件类型获取特定的 Subscription CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); //如果为null，说明该subscriber尚未注册该事件 if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; //如果不为null，并且包含了这个subscription 那么说明该subscriber已经注册了该事件，抛出异常 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125; //根据优先级来设置放进subscriptions的位置，优先级高的会先被通知 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; //根据subscriber(订阅者)来获取它的所有订阅事件 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); //下面是对粘性事件的处理 if (subscriberMethod.sticky) &#123; //从EventBusBuilder可知，eventInheritance默认为true if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; //根据eventType，从stickyEvents列表中获取特定的事件 Object stickyEvent = stickyEvents.get(eventType); //分发事件 checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; 到目前为止，注册流程基本分析完毕，丢一张流程图]]></content>
      <categories>
        <category>Android -源码解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（Design Patterns）（三）]]></title>
    <url>%2F2018%2F03%2F07%2FJava-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[十三、策略模式顾名思义:不同的策略，对应我们项目中用到的地方就是，同一个功能，不同的实现方法。就比方说登录功能：我们有帐号密码登录，QQ第三方登录，微信第三方登录等等。其实我个人认为最典型的就是：同一个接口方法，不同的实现方式。 12345678910111213141516171819interface LoginInterface&#123; void login();&#125;public class PhoneLogin implements LoginInterface&#123; @Override public void login()&#123; //具体的逻辑 Log.v(&quot;wz&quot;,&quot;帐号密码登录&quot;) &#125;&#125;public class QqLogin implements LoginInterface&#123; @Override public void login()&#123; //具体的逻辑 Log.v(&quot;wz&quot;,&quot;QQ第三方登录&quot;) &#125;&#125; 就像上面这样，同一个登录功能，不同的实现。 十四、责任链模式责任链模式，我项目里面用的比较少，但是我知道一个android里面绝对常用的东西用的是责任连模式，那就是——andoid事件分发 十五、状态模式状态模式，我项目里面用的比较少，但是我知道的是游戏里面用的很多。就是那种存档功能，遇到自己感觉过不去的地方，把当前进度存起来，过不去了之后，死了，游戏结束了，再读当前的存档。 PS：其他的设计模式等用到了再补充]]></content>
      <categories>
        <category>Android -设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（Design Patterns）（二）]]></title>
    <url>%2F2018%2F03%2F07%2FJava-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[六、适配器模式分类有三种：类的适配器模式，对象的适配器模式，接口的适配器模式，我印象最深刻的是接口适配器模式 接口适配器模式 &emsp;&emsp;有的时候，我们写的一个接口，会有很多种方法。而，我们的实现类只需要实现某一种，或者某几种，所以，我们这里会借助一个抽象类，去实现接口的所有方法。我们的具体实现类跟这个抽象类去打交道，而不是跟原始的接口去打交道。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123; private BaseView baseView; private boolean showLoading; public MySubscriber(BaseView baseView) &#123; this.baseView = baseView; &#125; public MySubscriber(BaseView baseView, boolean showLoading) &#123; this.baseView = baseView; this.showLoading = showLoading; &#125; @Override protected void onStart() &#123; super.onStart(); if (null != baseView &amp;&amp; showLoading) &#123; baseView.showLoading(); &#125; &#125; @Override public void onError(Throwable t) &#123; if (null == baseView) &#123; return; &#125; baseView.hideLoading(); if (t instanceof ApiException) &#123; ApiException apiException = (ApiException) t; switch (apiException.getCode()) &#123; case HttpCode.NO_PARAMETER: baseView.showTipMsg(&quot;参数为空&quot;); break; case HttpCode.SERVER_ERR: baseView.showTipMsg(&quot;服务器错误&quot;); break; default: break; &#125; &#125; &#125; @Override public void onComplete() &#123; if (null != baseView) &#123; baseView.hideLoading(); &#125; &#125;&#125;addSubscribe(helper.selectBrandList() .compose(RxUtil.handleHttp()) .subscribeWith(new MySubscriber&lt;List&lt;String&gt;&gt;(baseView, true) &#123; @Override public void onNext(List&lt;String&gt; dataList) &#123; Log.v(&quot;wz&quot;,&quot;111&quot;) &#125; &#125;)); &emsp;&emsp;上面这个代码，就是我之前写的从零开始搭建一个主流项目框架系列里面的网络请求，处理返回结果的回调方法，我的返回结果，不可能每个去实现onStart，onError，onNext，onCompleted方法。我的实现类只用去继承这个类，实现某一个，或者某几个方法。更直接的就是，我之前写的框架，BaseActivity，实现BaseView接口，然后，我其他的Activity去继承BaseActivity，选择实现BaseView的方法。 如果上面这样，你还无法认同，那我们看看下面这个： 12345678910//success动画结束监听 successAnim.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); if (null != myAnimotionInterface) &#123; myAnimotionInterface.AnimationEnd(); &#125; &#125; &#125;); 动画监听，我这里只想监听动画结束，在动画结束的时候，我做我的逻辑处理，但是，他的接口有开始，结束，暂停，重复等等监听，我不要这么，你们可以点 AnimatorListenerAdapter() 这个类，去看一下他是什么，他就是一个抽象类，实现了动画监听的那个接口，这个是官方封装好的一个类。 七、装饰器模式这个模式就是我之前写从零开始搭建一个主流项目框架系列里面网络请求，SP的操作，Socket的操作，关于他们的封装都是用的装饰者模式。说的官方一点：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。项目中的应用就是： 12345678910111213141516/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public interface HttpHelper &#123; Flowable&lt;WeatherBean&gt; getWeather(String city); /** * 登录时获取验证码. * * @param phone 手机号 * @return &#123;&quot;code&quot;:0&#125; */ Flowable&lt;HttpNoResult&gt; loginCode(String phone); &#125; &emsp;&emsp;这个就是装饰对象和被装饰对象实现的同一个接口，他们一开始就只有一个功能，那就是获取天气，后来他们又新加了一个功能，必须登录之后才能获取天气，那就多了一个登录功能 12345678910111213141516171819202122232425262728293031323334/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public class DataHelper implements HttpHelper, PreferencesHelper, SqlHelper &#123; private SqlHelper sqlHelper; private HttpHelper httpHelper; private PreferencesHelper preferencesHelper; /** * 初始化数据帮助类. * * @param sqlHelper &#123;@link SqlHelper&#125; * @param httpHelper &#123;@link HttpHelper&#125; * @param preferencesHelper &#123;@link PreferencesHelper&#125; */ public DataHelper(SqlHelper sqlHelper, HttpHelper httpHelper, PreferencesHelper preferencesHelper) &#123; this.sqlHelper = sqlHelper; this.httpHelper = httpHelper; this.preferencesHelper = preferencesHelper; &#125; @Override public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123; return httpHelper.getWeather(city); &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return httpHelper.loginCode(phone); &#125;&#125; &emsp;&emsp;这个就是装饰类，负责调用接口的方法 12345678910111213141516171819202122232425/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public class RetrofitHttp implements HttpHelper &#123; private WardrobeApi wardrobeApi; private WeatherApi weatherApi; @Inject RetrofitHttp(WardrobeApi wardrobeApi, WeatherApi weatherApi) &#123; this.wardrobeApi = wardrobeApi; this.weatherApi = weatherApi; &#125; @Override public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123; return weatherApi.getWeather(city, &quot;c41d9ca568d449e2802244d8eeb3d3c6&quot;); &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return wardrobeApi.loginCode(phone); &#125;&#125; &emsp;&emsp;这个就是被装饰类，负责具体的实现，这里是retrofit网络请求。以上都是伪代码。具体就是为了说明这个装饰者模式的中心思想，以及我在项目中的运用，不保证一定完全正确，都是按照自己的理解写的。 PS：其他的设计模式等用到了再补充]]></content>
      <categories>
        <category>Android -设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（Design Patterns）（一）]]></title>
    <url>%2F2018%2F03%2F06%2FJava-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[设计模式的分类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 我只讲我用的多的，用的多的印象深刻，知道怎么讲，用的少的，不知道怎么讲。只讲我熟练的。 一、单例模式单例模式，我想应该做过开发的人都用过。 懒汉式（用的时候初始化，延迟加载）12345678910public class MySocket&#123; private static MySocket instance; private MySocket()&#123;&#125; public static synchronized MySocket getInstance()&#123; if(null == instance)&#123; instance = new MySocket(); &#125; return instance; &#125;&#125; &emsp;&emsp;这里在懒汉式的单例模式中加上了同步锁synchronized，所以，这是线程安全的，但是，也是因为锁，所以造成的效率低，可以根据不同实际情况判断是否需要加同步锁。 饿汉式（加载类的时候直接初始化）1234567public class MySocket&#123; private static MySocket instance = new MySocket(); private MySocket()&#123;&#125; public static MySocket getInstance()&#123; return instance; &#125;&#125; 双重校验锁1234567891011121314public class MySocket&#123; private static MySocket instance; private MySocket()&#123;&#125; public static MySocket getInstance()&#123; if(null == instance)&#123; synchronized(MySocket.class)&#123; if(null == instance)&#123; instance = new MySocket(); &#125; &#125; &#125; return instance; &#125;&#125; &emsp;&emsp;这里的双重校验锁，其实就是我这里的线程安全懒汉式的升级版本，双重校验锁很多开源框架都是用的这种单例，比方说：EventBus。关于单例模式的其他变种我就不说了。单例模式的最终目的，就是全局单例，一个项目不论哪里调用这个类都是引用的同一个对象。 二、工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public class FragmentFactory &#123; public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz) &#123; return createFragment(clz, null); &#125; public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz, Bundle bundle) &#123; if (HomeFragment.class == clz) &#123; return new HomeFragment(); &#125; else if (MyClothesFragment.class == clz) &#123; return new MyClothesFragment(); &#125; else if (WardrobeStructureFragment.class == clz) &#123; return new WardrobeStructureFragment(); &#125; else if (WifiFragment.class == clz) &#123; return new WifiFragment(); &#125; else if (WardrobeConfigFragment.class == clz) &#123; return new WardrobeConfigFragment(); &#125; else if (ShowFragment.class == clz) &#123; return new ShowFragment(); &#125; else &#123; throw new NullPointerException(&quot;not found fragment&quot;); &#125; &#125; public static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz) &#123; return createDialogFragment(clz, null); &#125; @SuppressWarnings(&quot;unchecked&quot;) private static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz, Bundle bundle) &#123; if (clz == IconDialogFragment.class) &#123; return (T) new IconDialogFragment(); &#125; else if (clz == PasswordDialogFragment.class) &#123; return (T) PasswordDialogFragment.newInstance(); &#125; else &#123; throw new NullPointerException(&quot;not found fragment&quot;); &#125; &#125;&#125; &emsp;&emsp;这个fragment工厂类，就是我项目里面用到的。常用的工厂模式就是静态工厂，利用static方法，我这里的工厂就是静态工厂。我们常说的工厂方法对应的这里是什么呢？其实，工厂方法也是一个普通的方法，对应的这里就是createFragment(Class&lt;? extends BaseFragment&gt; clz)。工厂模式什么时候用呢？在需要大量类似的数据的时候（个人观点），Android里面，工厂方法用的最多的就是创建Fragment。 三、抽象工厂模式1234567891011121314151617public interface IFragmentFactory&#123; BaseFragment createFragment();&#125;public class HomeFactory implements IFragmentFactory&#123; @Override public BaseFragment createFragment()&#123; return new HomeFragment(); &#125;&#125;public class WifiFragment implements IFragmentFactory&#123; @Override public BaseFragment createFragment()&#123; return new WifiFragment(); &#125;&#125; &emsp;&emsp;我把上面的静态工厂类，改成了抽象工厂类，就是上面的代码。就是有一个工厂接口或者抽象的工厂类，然后创建不同的工厂类去实现这个接口，实现对应的类，返回你需要的东西 四、建造者模式我之前写Luban源码解析的时候就讲过建造者模式，可以去看一下，就在源码解析的一开始 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.haichenyi.mytakephoto;/** * Author: 海晨忆 * Date: 2018/3/6 * Desc: */public class DataBean &#123; private String name; private int age; private String sex; public DataBean(Builder builder) &#123; this.name = builder.name; this.age = builder.age; this.sex = builder.sex; &#125; public static class Builder &#123; private String name; private int age = 20; private String sex = &quot;男&quot;; public Builder setName(String name) &#123; this.name = name; return this; &#125; public Builder setAge(int age) &#123; this.age = age; return this; &#125; public Builder setSex(String sex) &#123; this.sex = sex; return this; &#125; public DataBean build() &#123; return new DataBean(this); &#125; &#125;&#125; &emsp;&emsp;上面的代码就是一个DataBean类，用建造者模式创建。要是还是不懂，你可以理解成，我们常常在写bean类的时候，往往要写set方法，你可以理解成，把set方法写在Builder里面，在Builder里面赋好值之后，在我们bean类的构造方法里面传递过来就可以了。 五、原型模式这个模式，我没用到过，网上搜的是，类似于拷贝功能。可以自行搜索。]]></content>
      <categories>
        <category>Android -设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2F2018%2F03%2F06%2FJava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;在运行过程中，对任意一个类，都能知道这个类的所有属性和方法。对于任一个对象，都能调用他的任意一个方法和属性。这种动态获取信息以及动态调用对象的方法称为java语言的反射机制 用法我这里就列出我常用的两个方法私有类和变量 方法Methods 方法 用途 getDeclaredMethods() 获取当前类的所有方法，包括public/private/protected/default修饰的方法 getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取当前类的某一个方法,包括public/private/protected/default修饰的方法 getMethods() 获取当前类和所继承父类的public标识的所有方法，仅仅包括public getMethod(String name, Class&lt;?&gt;… parameterTypes) 获取当前类和所继承父类的public标识的某一个方法，仅仅包括public &emsp;&emsp;上面就是两个类型的方法，一个是只获取当前类的方法，获取当前类的方法，包括所有类型的方法：public/private/protected/default。还有一个是获取当前类和所继承的父类的方法，仅仅包括public修饰的方法。 调用方式1234567//在TakePhotoActivity.class类中有两个重载方法，一个无参，一个有一个String类型的参数private void myTest()&#123; Log.v(&quot;WZ&quot;,&quot;myTest无参&quot;); &#125;private void myTest(String msg)&#123; Log.v(&quot;WZ&quot;,&quot;myTest有参&quot;); &#125; 调用无参的方法1234567891011TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象try &#123;Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象Method myTest = aClass1.getDeclaredMethod(&quot;myTest&quot;);myTest.setAccessible(true);//参数值为true，禁止访问控制检查myTest.invoke(takePhotoActivity);//执行私有方法&#125; catch (Exception e) &#123; e.printStackTrace(); Log.v(&quot;WZ&quot;, e.getMessage()); &#125; 调用有参的方法123456789101112TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象Class[] arr = new Class[]&#123;String.class&#125;;try &#123;Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象Method myTest = aClass1.getDeclaredMethod(&quot;myTest&quot;,arr);myTest.setAccessible(true);//参数值为true，禁止访问控制检查myTest.invoke(takePhotoActivity,&quot;s&quot;);//执行私有方法&#125; catch (Exception e) &#123; e.printStackTrace(); Log.v(&quot;WZ&quot;, e.getMessage()); &#125; 有参的方法，在获取方法的时候，传一个Class[]数组，里面的值就是参数类型的类。或者还有另一种传的方法，前面获取方法的时候： 获取方法的时候，无参的传一个空的Class[]，有参就传有值的Class[]数组 执行方法的时候，无参的传一个空的Object[]，有参就传有值的Object[]数组,至于传的值随便写，类型一样就行 变量Field 方法 用途 getDeclaredFields() 获取当前类的所有类型的全局变量,包括public/private/protected/default修饰的变量 getDeclaredField(String name) 获取当前类的某一个类型的全局变量,包括public/private/protected/default修饰的变量 getFields() 获取当前类和继承父类的所有用public修饰的变量 getField(String name) 获取当前类和继承父类的某一个用public修饰的变量 调用方式12//在TakePhotoActivity里面定义private int flag; 获取变量123456789101112TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象try &#123;Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象Field flag = aClass.getDeclaredField(&quot;flag&quot;);flag.setAccessible(true);Object o = flag.get(takePhotoActivity);//这里就获取到了对象...//做你自己的逻辑处理&#125; catch (Exception e) &#123; e.printStackTrace(); Log.v(&quot;WZ&quot;, e.getMessage()); &#125; 设置变量的值12//获取变量的值跟上面一样flag.set(takePhotoActivity,10);//这样写会改变TakePhotoActivity中flag的值 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * Author: 海晨忆. * Date: 2018/3/6 * Desc: 反射工具类 */public class ReflectionUtil &#123; /*** * 获取私有成员变量的值 * */ public static Object getValue(Object instance, String fieldName) throws IllegalAccessException, NoSuchFieldException &#123; Field field = instance.getClass().getDeclaredField(fieldName); field.setAccessible(true); // 参数值为true，禁止访问控制检查 return field.get(instance); &#125; /*** * 设置私有成员变量的值 * */ public static void setValue(Object instance, String fileName, Object value) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123; Field field = instance.getClass().getDeclaredField(fileName); field.setAccessible(true); field.set(instance, value); &#125; /*** * 访问私有方法 * */ public static Object callMethod(Object instance, String methodName, Class[] classes, Object[] objects) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; Method method = instance.getClass().getDeclaredMethod(methodName, classes); method.setAccessible(true); return method.invoke(instance, objects); &#125;&#125;]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EventBus源码解析(一)——获取EventBus对象]]></title>
    <url>%2F2018%2F03%2F06%2FEventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96EventBus%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[简介我们先来看一下他的类注释 12345678910/** * EventBus is a central publish/subscribe event system for Android. Events are posted (&#123;@link #post(Object)&#125;) to the * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events, * subscribers must register themselves to the bus using &#123;@link #register(Object)&#125;. Once registered, subscribers * receive events until &#123;@link #unregister(Object)&#125; is called. Event handling methods must be annotated by * &#123;@link Subscribe&#125;, must be public, return nothing (void), and have exactly one parameter * (the event). * * @author Markus Junginger, greenrobot */ &emsp;&emsp;英语不是很好，大致讲一下这段话是什么意思：EventBus是重要的发布/订阅的Android事件系统。事件被发布给总线，这个总线将这个事件传递给跟他匹配类型的订阅者。接收事件必须在总线使用的时候注册他们。一旦注册，订阅者就会一直接收事件，直到他们被取消注册。这个接收方法必须增加注解Subscribe标识，必须是public，返回类型是void，并且只有一个参数。 简单的来说，就是用之前必须先注册，然后接收方法必须有Subscribe注解，必须是public，返回类型是void并且只有一个参数 简单用法第一步：依赖1implementation &apos;org.greenrobot:eventbus:3.1.1&apos; 第二步：注册与反注册1234//注册，在onCrate里面EventBus.getDefault().register(this)//反注册，在onDestory里面EventBus.getDefault().unregister(this) 第三步：接收方法1234@Subscribepublic void handle(MyClothes myClothes)&#123; //你的具体逻辑&#125; 第四步：发送1EventBus.getDefault().post(new MyClothes()) &emsp;&emsp;经过上面三步，你就可以正常使用EventBus了，前面两步要在一个类里面，因为接收之前，必须要注册，可以在任意的地方post 源码解析—getDefault()12345678910public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; &emsp;&emsp;可以看到这里使用的是双重校验锁的单例模式，保证不同的线程调用该方法得到的都是同一个EventBus实例。 EventBus()看到上面的单例模式之后，我们再来瞅瞅单例模式里面调用的构造方法 123public EventBus() &#123; this(DEFAULT_BUILDER); &#125; 这里他的空参数的构造方法里面调用的是一个参数的构造方法，我们来看看这个参数是什么？ 1private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder(); EventBusBuilder()12EventBusBuilder() &#123; &#125; 这个builder的构造方法里面什么都没有，也就是说没有初始化任何变量，那我们看一看他的变量，这里我就说一个： 123private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE; Executors.newCachedThreadPool() 创建的是一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空线程池，若无回收，可新建线程。 接下来，我们再来看看只有EventBusBuilder参数的构造方法 EventBus(EventBusBuilder builder)123456789EventBus(EventBusBuilder builder) &#123; subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null; backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); ... &#125; &emsp;&emsp;讲到这里，很明显，他这里用的是建造者模式，跟我们之前讲的Luban的模式是一样的，这个建造者模式，我就不讲了。讲Luban的时候讲过的 &emsp;&emsp;这里我列出来的6个变量，其他变量并没有列出来，因为，其他变量都是builder里面的赋值，没有啥好讲的。我们来看看这6个成员变量的类型 123456private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;private final Poster mainThreadPoster;private final BackgroundPoster backgroundPoster;private final AsyncPoster asyncPoster; 意义： subscriptionsByEventType：可以看到这是一个是以event的class为key，以subscribe的list为value的map，有的人可能不知道CopyOnWriteArrayList，这是ArrayList的一个线程安全变种。（这里，有人会点到Subscription里面去看一下，可以看到就是一个类，封装了订阅者和订阅方法，重写了hashcode和equal方法） typesBySubscriber：这是以订阅者类为key，以event的list为value的map，在注册和反注册的时候用的到 stickyEvents：粘性事件，以event的class为key，订阅者为value的map 后面这三个Poster都是用来处理粘性事件的 &emsp;&emsp;我们说了这么多成员变量。我们知道这里的EventBusBuilder就是给EventBus初始化成员变量的，辣么，我们可不可以不用getDefault，获取eventBus对象呢？ 123EventBus build1 = EventBus.getDefault();EventBus build2 = EventBus.builder().build(); 这两个build的区别是什么呢？我们可以点到build()方法里面去看一下： 123public EventBus build() &#123; return new EventBus(this); &#125; 他这里是直接new出来的，并没有单例，所以每次使用的都是new一个新的对象，而通过getDefault，获得是同一个对象]]></content>
      <categories>
        <category>Android -源码解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android二维码扫描——BGAQRCode-Android]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E2%80%94%E2%80%94BGAQRCode-Android%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;做过二维码扫描的童鞋都知道，要用Zxing，可是google官方推的Zxing，我们集成扫描的时候很慢，有时候就直接扫不出来，体验太差了。因为他适配了太多东西，我们只要一个扫描功能，然后就去网上搜索，怎么使zxing扫描变的很快，zxing的优化，然后跟着网上的博客，一步一步走，即使最终做完了，感觉体验还是不够好。我这里推荐一个二维码扫描的开源框架——BGAQRCode-Android &emsp;&emsp;QRCode 扫描二维码、扫描条形码、相册获取图片后识别、生成带 Logo 二维码、支持微博微信、QQ 二维码扫描样式。他把Zbar和Zxing，都做了优化，扫描速度非常快，用户体验很好，用起来也非常方便 依赖123implementation &apos;cn.bingoogolapple:bga-qrcode-zbar:1.2.1&apos;或者implementation &apos;cn.bingoogolapple:bga-qrcode-zxing:1.2.1&apos; 用法以Zbar为例（Zxing类似） 第一步：XML文件1234567891011121314&lt;cn.bingoogolapple.qrcode.zbar.ZBarView android:id=&quot;@+id/zbarview&quot; style=&quot;@style/MatchMatch&quot; app:qrcv_animTime=&quot;1000&quot; app:qrcv_borderColor=&quot;@android:color/white&quot; app:qrcv_borderSize=&quot;1dp&quot; app:qrcv_cornerColor=&quot;@color/colorPrimaryDark&quot; app:qrcv_cornerLength=&quot;20dp&quot; app:qrcv_cornerSize=&quot;3dp&quot; app:qrcv_isShowDefaultScanLineDrawable=&quot;true&quot; app:qrcv_maskColor=&quot;#33FFFFFF&quot; app:qrcv_rectWidth=&quot;200dp&quot; app:qrcv_scanLineColor=&quot;@color/colorPrimaryDark&quot; app:qrcv_topOffset=&quot;90dp&quot; /&gt; 自定义属性说明 属性名 说明 默认值 qrcv_topOffset 扫描框距离 toolbar 底部的距离 90dp qrcv_cornerSize 扫描框边角线的宽度 3dp qrcv_cornerLength 扫描框边角线的长度 20dp qrcv_cornerColor 扫描框边角线的颜色 @android:color/white qrcv_rectWidth 扫描框的宽度 200dp qrcv_barcodeRectHeight 条码扫样式描框的高度 140dp qrcv_maskColor 除去扫描框，其余部分阴影颜色 #33FFFFFF qrcv_scanLineSize 扫描线的宽度 1dp qrcv_scanLineColor 扫描线的颜色「扫描线和默认的扫描线图片的颜色」 @android:color/white qrcv_scanLineMargin 扫描线距离上下或者左右边框的间距 0dp qrcv_isShowDefaultScanLineDrawable 是否显示默认的图片扫描线「设置该属性后 qrcv_scanLineSize 将失效，可以通过 qrcv_scanLineColor 设置扫描线的颜色，避免让你公司的UI单独给你出特定颜色的扫描线图片」 false qrcv_customScanLineDrawable 扫描线的图片资源「默认的扫描线图片样式不能满足你的需求时使用，设置该属性后 qrcv_isShowDefaultScanLineDrawable、qrcv_scanLineSize、qrcv_scanLineColor 将失效」 null qrcv_borderSize 扫描边框的宽度 1dp qrcv_borderColor 扫描边框的颜色 @android:color/white qrcv_animTime 扫描线从顶部移动到底部的动画时间「单位为毫秒」 1000 qrcv_isCenterVertical 扫描框是否垂直居中，该属性为true时会忽略 qrcv_topOffset 属性 false qrcv_toolbarHeight Toolbar 的高度，通过该属性来修正由 Toolbar 导致扫描框在垂直方向上的偏差 0dp qrcv_isBarcode 是否是扫条形码 false qrcv_tipText 提示文案 null qrcv_tipTextSize 提示文案字体大小 14sp qrcv_tipTextColor 提示文案颜色 @android:color/white qrcv_isTipTextBelowRect 提示文案是否在扫描框的底部 false qrcv_tipTextMargin 提示文案与扫描框之间的间距 20dp qrcv_isShowTipTextAsSingleLine 是否把提示文案作为单行显示 false qrcv_isShowTipBackground 是否显示提示文案的背景 false qrcv_tipBackgroundColor 提示文案的背景色 #22000000 qrcv_isScanLineReverse 扫描线是否来回移动 true qrcv_isShowDefaultGridScanLineDrawable 是否显示默认的网格图片扫描线 false qrcv_customGridScanLineDrawable 扫描线的网格图片资源 null qrcv_isOnlyDecodeScanBoxArea 是否只识别扫描框区域的二维码 false 第二步：获取控件，并实现QRCodeView.Delegate接口123456789101112131415QRCodeView mQRCodeView = (ZBarView) findViewById(R.id.zbarview);mQRCodeView.setDelegate(this);@Override public void onScanQRCodeSuccess(String result) &#123; vibrate(); Toast.makeText(this,result,Toast.LENGTH_SHORT).show(); mQRCodeView.startSpot(); &#125; @Override public void onScanQRCodeOpenCameraError() &#123; Toast.makeText(this,&quot;错误&quot;,Toast.LENGTH_SHORT).show(); &#125; 第四步：实现onStart，onStop，onDestroy方法1234567891011121314151617181920212223242526@Override protected void onStart() &#123; super.onStart(); mQRCodeView.startCamera();//打开相机 mQRCodeView.showScanRect();//显示扫描框 mQRCodeView.startSpot();//开始识别二维码 //mQRCodeView.openFlashlight();//开灯 //mQRCodeView.closeFlashlight();//关灯 &#125; @Override protected void onStop() &#123; mQRCodeView.stopCamera(); super.onStop(); &#125; @Override protected void onDestroy() &#123; mQRCodeView.onDestroy(); super.onDestroy(); &#125; private void vibrate() &#123; Vibrator vibrator = (Vibrator) getSystemService(VIBRATOR_SERVICE); vibrator.vibrate(200); &#125; 第五步：添加权限12&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt; 经过上面5步，扫描功能就已经出来了，Zbar扫描比Zxing快，Zbar是基于C实现的，Zxing是基于C++。有个问题就是Zbar无法生成二维码，如果你是集成的BGA的Zxing可以生成二维码。Zxing生成二维码的方式如下： 耗时操作，新开线程 123456//中文Bitmap bitmap = QRCodeEncoder.syncEncodeQRCode(&quot;海晨忆&quot;, BGAQRCodeUtil.dp2px(this, 150));//带logoBitmap logoBitmap = BitmapFactory.decodeResource(TestGeneratectivity.this.getResources(), R.mipmap.logo);QRCodeEncoder.syncEncodeQRCode(&quot;海晨忆&quot;, BGAQRCodeUtil.dp2px(TestGeneratectivity.this, 150), Color.parseColor(&quot;#ff0000&quot;), logoBitmap); 解析图片二维码 1234567//mEnglishLogoIv：显示二维码的控件mEnglishLogoIv.setDrawingCacheEnabled(true);Bitmap bitmap = mEnglishLogoIv.getDrawingCache();//返回二维码图片里的内容 或 nullString result = QRCodeDecoder.syncDecodeQRCode(bitmap);String result = QRCodeDecoder.syncDecodeQRCode(picturePath);]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android WIFI功能——WifiManager]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid-WIFI%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94WifiManager%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前做了关于Android wifi的相关功能，这里做一个记录 第一步：获取WifiManager1WifiManager wifiMgr = (WifiManager)Context.getSystemService(Context.WIFI_SERVICE); 第二步：获取周围热点信息和已连接wifi信息12List&lt;ScanResult&gt; scanResults = wifiMgr.getScanResults();//扫描到的周围热点信息WifiInfo info = wifiMgr.getConnectionInfo();//已连接wifi信息 这里我说一下几个字段的意思： 1234public String name;//ssid对应的wifi名字public String capabilities;//用来判断是否有密码public int level;//信号等级，这里是负数public String BSSID;//macid 这里我需要强调的就是level，是负数，负数越大，信号越好 第三步：检测wifi信息，这里我给出几个工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 连接有密码的wifi. * * @param SSID ssid * @param Password Password * @return apConfig */ private WifiConfiguration setWifiParamsPassword(String SSID, String Password) &#123; WifiConfiguration apConfig = new WifiConfiguration(); apConfig.SSID = &quot;\&quot;&quot; + SSID + &quot;\&quot;&quot;; apConfig.preSharedKey = &quot;\&quot;&quot; + Password + &quot;\&quot;&quot;; //不广播其SSID的网络 apConfig.hiddenSSID = true; apConfig.status = WifiConfiguration.Status.ENABLED; //公认的IEEE 802.11验证算法。 apConfig.allowedAuthAlgorithms.clear(); apConfig.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN); //公认的的公共组密码 apConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP); apConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP); //公认的密钥管理方案 apConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK); //密码为WPA。 apConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP); apConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP); //公认的安全协议。 apConfig.allowedProtocols.set(WifiConfiguration.Protocol.RSN); return apConfig; &#125; /** * 连接没有密码wifi. * * @param ssid ssid * @return configuration */ private WifiConfiguration setWifiParamsNoPassword(String ssid) &#123; WifiConfiguration configuration = new WifiConfiguration(); configuration.SSID = &quot;\&quot;&quot; + ssid + &quot;\&quot;&quot;; configuration.status = WifiConfiguration.Status.ENABLED; configuration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP); configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK); configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE); configuration.allowedPairwiseCiphers .set(WifiConfiguration.PairwiseCipher.TKIP); configuration.allowedPairwiseCiphers .set(WifiConfiguration.PairwiseCipher.CCMP); configuration.allowedProtocols.set(WifiConfiguration.Protocol.RSN); return configuration; &#125; public static final int WIFI_NO_PASS = 0; private static final int WIFI_WEP = 1; private static final int WIFI_PSK = 2; private static final int WIFI_EAP = 3; /** * 判断是否有密码. * * @param result ScanResult * @return 0 */ public static int getSecurity(MyScanResult result) &#123; if (null != result &amp;&amp; null != result.capabilities) &#123; if (result.capabilities.contains(&quot;WEP&quot;)) &#123; return WIFI_WEP; &#125; else if (result.capabilities.contains(&quot;PSK&quot;)) &#123; return WIFI_PSK; &#125; else if (result.capabilities.contains(&quot;EAP&quot;)) &#123; return WIFI_EAP; &#125; &#125; return WIFI_NO_PASS; &#125; 上面三个工具类，一个用来判断是否需要密码，另外两个用来连接wifi 连接wifi123456//需要密码wifiMgr.enableNetwork(wifiMgr.addNetwork( setWifiParamsPassword(mClickResult.name, password)), true);//不需要密码wifiMgr.enableNetwork(wifiMgr.addNetwork(setWifiParamsNoPassword(mClickResult.name)), true); wifi监听PS：关于wifi状态的监听，就是监听你当前的网络状态即可。 12345678&lt;receiver android:name=&quot;.receiver.NetworkReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.net.wifi.WIFI_STATE_CHANGED&quot;/&gt; &lt;action android:name=&quot;android.net.wifi.STATE_CHANGE&quot;/&gt; &lt;action android:name=&quot;android.net.wifi.supplicant.STATE_CHANGE&quot;/&gt; &lt;action android:name=&quot;android.net.wifi.NETWORK_IDS_CHANGED&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 首先在你的清单文件注册这四种action的广播，这里给出我的网络监听广播 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * Author: 海晨忆. * Date: 2018/1/10 * Desc: 网络广播监听 */public class NetworkReceiver extends BroadcastReceiver &#123; public static final int STATE1 = 1;//密码错误 public static final int STATE2 = 2;//连接成功 public static final int STATE3 = 3;//连接失败 public static final int STATE4 = 4;//正在获取ip地址 public static final int STATE5 = 5;//正在连接 @Override public void onReceive(Context context, Intent intent) &#123; if (WifiManager.SUPPLICANT_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123; //密码错误广播,是不是正在获得IP地址 int linkWifiResult = intent.getIntExtra(WifiManager.EXTRA_SUPPLICANT_ERROR, -1); if (linkWifiResult == WifiManager.ERROR_AUTHENTICATING) &#123; //密码错误 ToastUtils.showTipMsg(R.string.password_wrong); sendNetworkStateChange(new NetWorkInfo().setState(STATE1)); &#125; SupplicantState supplicantState = intent.getParcelableExtra(WifiManager.EXTRA_NEW_STATE); NetworkInfo.DetailedState state = WifiInfo.getDetailedStateOf(supplicantState); Log.v(Constants.HTTP_WZ, state.name()); if (state == NetworkInfo.DetailedState.CONNECTING) &#123; //正在连接 ToastUtils.showTipMsg(R.string.linking); sendNetworkStateChange(new NetWorkInfo().setState(STATE5)); &#125; else if (state == NetworkInfo.DetailedState.FAILED || state == NetworkInfo.DetailedState.DISCONNECTING) &#123; //连接失败 sendNetworkStateChange(new NetWorkInfo().setState(STATE3)); ToastUtils.showTipMsg(R.string.linked_failed); &#125; else if (state == NetworkInfo.DetailedState.CONNECTED) &#123; //连接成功 ToastUtils.showTipMsg(R.string.linked_success); &#125; else if (state == NetworkInfo.DetailedState.OBTAINING_IPADDR) &#123; //正在获取ip地址 sendNetworkStateChange(new NetWorkInfo().setState(STATE4)); &#125; else if (state == NetworkInfo.DetailedState.IDLE) &#123; //闲置的 ConnectivityManager connectManager = (ConnectivityManager) BaseApplication.getInstance() .getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo activeNetworkInfo = null; if (connectManager != null) &#123; activeNetworkInfo = connectManager.getActiveNetworkInfo(); &#125; if (activeNetworkInfo == null) &#123; sendNetworkStateChange(new NetWorkInfo().setState(STATE3)); ToastUtils.showTipMsg(R.string.linked_failed); &#125; &#125; &#125; else if (WifiManager.WIFI_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123; // 监听wifi的打开与关闭，与wifi的连接无关 int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, 0); Log.v(Constants.HTTP_WZ, &quot;wifiState:&quot; + wifiState); switch (wifiState) &#123; case WifiManager.WIFI_STATE_DISABLING://正在停止0 ToastUtils.showTipMsg(R.string.close_wifi); break; case WifiManager.WIFI_STATE_DISABLED://已停止1 break; case WifiManager.WIFI_STATE_UNKNOWN://未知4 break; case WifiManager.WIFI_STATE_ENABLING://正在打开2 ToastUtils.showTipMsg(R.string.opening_wifi); break; case WifiManager.WIFI_STATE_ENABLED://已开启3 break; default: break; &#125; &#125; else if (WifiManager.NETWORK_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123; // 监听wifi的连接状态即是否连上了一个有效无线路由 Parcelable parcelableExtra = intent .getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO); if (null != parcelableExtra) &#123; // 获取联网状态的NetWorkInfo对象 NetworkInfo networkInfo = (NetworkInfo) parcelableExtra; //获取的State对象则代表着连接成功与否等状态 NetworkInfo.State state = networkInfo.getState(); //判断网络是否已经连接 boolean isConnected = state == NetworkInfo.State.CONNECTED; Log.v(Constants.HTTP_WZ, &quot;isConnected:&quot; + isConnected); if (isConnected) &#123; ToastUtils.showTipMsg(R.string.linked_success); sendNetworkStateChange(new NetWorkInfo().setState(STATE2)); &#125; &#125; &#125; &#125; /** * 发送网络状态eventBus. * * @param info info */ private void sendNetworkStateChange(NetWorkInfo info) &#123; EventBus.getDefault().post(info); &#125; @SuppressWarnings(&quot;unused&quot;) private String getConnectionType(int type) &#123; String connType = &quot;&quot;; if (type == ConnectivityManager.TYPE_MOBILE) &#123; connType = &quot;移动网络&quot;; &#125; else if (type == ConnectivityManager.TYPE_WIFI) &#123; connType = &quot;WIFI网络&quot;; &#125; return connType; &#125; public static class NetWorkInfo &#123; public int state;//1密码错误，2:连接成功，3:连接失败 private NetWorkInfo setState(int state) &#123; this.state = state; return this; &#125; &#125;&#125; 注释应该写的很清楚，我就不做过多的解释了。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单的蓝牙通信]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%AE%80%E5%8D%95%E7%9A%84%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前公司做智能家居类型，其中做了一个智能衣柜项目，与衣柜通信就是用的蓝牙通信。一些操作一些简单的开关指令，蓝牙通信与socket是类似的。 步骤 清单文件注册权限 启动蓝牙服务（记得在清单文件中静态注册服务） 注册蓝牙广播（在蓝牙服务中动态注册蓝牙广播） 搜索，绑定，完成 退出app，停止服务，并在蓝牙服务的onDestory方法中取消注册蓝牙广播 不想写说明，只想贴代码 第一步：注册权限123&lt;!--获取蓝牙信息状态权限--&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 第二步、第三步、第五步：启动蓝牙服务，注册蓝牙广播，停止服务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Author: 海晨忆. * Date: 2018/1/4 * Desc: */public class BluetoothService extends Service &#123; //得到蓝牙适配器 private BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); private BluetoothReceiver mReceiver; @Override public void onCreate() &#123; super.onCreate(); EventBus.getDefault().register(this); if (mBluetoothAdapter != null) &#123; mReceiver = new BluetoothReceiver().setBluetoothAdapter(mBluetoothAdapter); //注册设备被发现时的广播 IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); registerReceiver(mReceiver, filter); //注册一个搜索结束时的广播 IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); registerReceiver(mReceiver, filter2); startLinkBluetooth(); &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; /** * 开始连接蓝牙设备. */ private void startLinkBluetooth() &#123; if (null != mBluetoothAdapter) &#123; //判断蓝牙是否打开 if (!mBluetoothAdapter.isEnabled()) &#123; //若没打开则打开蓝牙 mBluetoothAdapter.enable(); &#125; mBluetoothAdapter.startDiscovery(); Log.v(Constants.HTTP_WZ, &quot;正在扫描&quot;); &#125; &#125; @Subscribe @SuppressWarnings(&quot;unused&quot;) public void handleMsg(BluetoothInfo bluetoothInfo) &#123; if (bluetoothInfo.isLink) &#123; startLinkBluetooth(); &#125; &#125; public static class BluetoothInfo &#123; private boolean isLink = false; public BluetoothInfo setLink(boolean link) &#123; this.isLink = link; return this; &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); if (mReceiver != null) &#123; mReceiver.unRegister(); unregisterReceiver(mReceiver); &#125; &#125;&#125; 这个就是我的蓝牙服务类，这个类的逻辑怎么走的呢？ EventBus的东西我就不说了 首先获取蓝牙适配器 1BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); 初始化蓝牙广播，注册蓝牙广播 12345678910if (mBluetoothAdapter != null) &#123; mReceiver = new BluetoothReceiver().setBluetoothAdapter(mBluetoothAdapter); //注册设备被发现时的广播 IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); registerReceiver(mReceiver, filter); //注册一个搜索结束时的广播 IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); registerReceiver(mReceiver, filter2); startLinkBluetooth(); &#125; 开始准备连接蓝牙设备 1234567891011121314/** * 开始连接蓝牙设备. */ private void startLinkBluetooth() &#123; if (null != mBluetoothAdapter) &#123; //判断蓝牙是否打开 if (!mBluetoothAdapter.isEnabled()) &#123; //若没打开则打开蓝牙 mBluetoothAdapter.enable(); &#125; mBluetoothAdapter.startDiscovery(); Log.v(Constants.HTTP_WZ, &quot;正在扫描&quot;); &#125; &#125; 上面4步蓝牙扫描就完成了，这里我还要说的是，在服务的onDestory方法里面，记得停止服务 123456789@Override public void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); if (mReceiver != null) &#123; mReceiver.unRegister(); unregisterReceiver(mReceiver); &#125; &#125; 再就是在清单文件里面静态注册蓝牙服务 1&lt;service android:name=&quot;.service.BluetoothService&quot;/&gt; 启动服务的方式，我用的是非绑定的方式，同样，记得停止服务。 12Intent bluetoothService = new Intent(this, BluetoothService.class);startService(bluetoothService);//启动蓝牙服务 1stopService(bluetoothService); 123456@Nullable @Override public IBinder onBind(Intent intent) &#123; //非绑定方式，返回值为null return null; &#125; 第四步：搜索，绑定，完成搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * Author: 海晨忆. * Date: 2018/1/4 * Desc: 蓝牙广播监听 */public class BluetoothReceiver extends BroadcastReceiver &#123; //衣柜的蓝牙名称 private static final String WARDROBE_NAME = &quot;WARDROBE&quot;; // 固定的UUID private static final String SPP_UUID = &quot;00001101-0000-1000-8000-00805F9B34FB&quot;; private BluetoothSocket bluetoothSocket; private BluetoothAdapter bluetoothAdapter; private InputStream mInputStream; private OutputStream outputStream; private boolean isRunning = false; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (action != null) &#123; if (action.equals(BluetoothDevice.ACTION_FOUND)) &#123; BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); Log.v(Constants.HTTP_WZ, device.getName() + device.getAddress()); if (device.getBondState() == BluetoothDevice.BOND_BONDED &amp;&amp; device.getName().equals(WARDROBE_NAME)) &#123; UUID uuid = UUID.fromString(SPP_UUID); try &#123; bluetoothSocket = device.createRfcommSocketToServiceRecord(uuid); Log.v(Constants.HTTP_WZ, &quot;准备连接&quot;); connect(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; else if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) &#123; if (!EventBus.getDefault().isRegistered(this)) EventBus.getDefault().register(this); Observable.timer(2, TimeUnit.SECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(aLong -&gt; &#123; if (null == bluetoothSocket || !bluetoothSocket.isConnected()) ToastUtils.showTipMsg(R.string.no_wardrobe); &#125;); &#125; &#125; &#125; private void connect() &#123; new Thread(() -&gt; &#123; if (bluetoothSocket != null) &#123; bluetoothAdapter.cancelDiscovery(); try &#123; bluetoothSocket.connect(); Observable.just(1) .observeOn(AndroidSchedulers.mainThread()) .subscribe(integer -&gt; ToastUtils.showTipMsg(R.string.link_wardrobe)); Log.v(Constants.HTTP_WZ, &quot;连接成功&quot;); mInputStream = bluetoothSocket.getInputStream(); Log.v(Constants.HTTP_WZ, &quot;mInputSream:&quot; + mInputStream.toString()); isRunning = true; outputStream = bluetoothSocket.getOutputStream(); Log.v(Constants.HTTP_WZ, &quot;outputStream:&quot; + outputStream.toString()); BufferedReader br; while (isRunning) &#123; br = new BufferedReader(new InputStreamReader(mInputStream, &quot;utf-8&quot;)); String s = br.readLine(); //acceptReply(s); Log.v(Constants.HTTP_WZ, &quot;收到的数据:&quot; + s); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); try &#123; if (mInputStream != null) &#123; mInputStream.close(); Log.v(Constants.HTTP_WZ, &quot;mInputSream.close()&quot;); &#125; if (outputStream != null) &#123; outputStream.close(); Log.v(Constants.HTTP_WZ, &quot;outputStream.close()&quot;); &#125; if (bluetoothSocket != null) &#123; bluetoothSocket.close(); Log.v(Constants.HTTP_WZ, &quot;socket.close()&quot;); bluetoothSocket = null; &#125; isRunning = false; &#125; catch (Exception e2) &#123; // TODO: handle exception &#125; &#125; &#125; &#125;).start(); &#125; public BluetoothReceiver setBluetoothAdapter(BluetoothAdapter adapter) &#123; this.bluetoothAdapter = adapter; return this; &#125; /** * 反注册eventBus. */ public void unRegister() &#123; EventBus.getDefault().unregister(this); &#125;&#125; 这个就是我的蓝牙广播类，这个逻辑又是怎么走的呢？ 前面服务里面注册的两个action，一个BluetoothDevice.ACTION_FOUND，还有一个BluetoothAdapter.ACTION_DISCOVERY_FINISHED，做了一个if判断，是发现了设备还是已经完成了扫描设备 发现设备之后，获取蓝牙信息，他这里是获取到一个蓝牙信息就会走一遍这个方法，并不是说一次获取一个列表。 找到了蓝牙设备之后就是连接了，伪代码讲解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 固定的UUID连接的时候需要uuid private static final String SPP_UUID = &quot;00001101-0000-1000-8000-00805F9B34FB&quot;; //获取socketBluetoothSocket bluetoothSocket =device.createRfcommSocketToServiceRecord(uuid);//连接之前取消扫描，注意非空判断。adapter是在服务里面申明的，通过setBluetoothAdapter方法传过来的bluetoothAdapter.cancelDiscovery();//连接，这里是阻塞的方式，注意要新开线程连接bluetoothSocket.connect();//获取输入流对象和输出流对象InputStream mInputStream = bluetoothSocket.getInputStream();OutputStream outputStream = bluetoothSocket.getOutputStream();//发送消息private void sendInstruct(String msg) &#123; try &#123; if (null == bluetoothSocket || !bluetoothSocket.isConnected()) &#123; SocketUtils.reLinkBluetooth(); return; &#125; Log.v(Constants.HTTP_WZ, &quot;发送的数据--&gt;&quot; + msg + BluetoothInstruct.FINISH); outputStream.write(msg.getBytes()); outputStream.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;//接收消息，一次读一行，简单的蓝牙通信换行符作为结束标记BufferedReader br;while (isRunning) &#123; br = new BufferedReader(new InputStreamReader(mInputStream, &quot;utf-8&quot;)); String s = br.readLine(); acceptReply(s); Log.v(Constants.HTTP_WZ, &quot;收到的数据:&quot; + s); &#125; //异常的时候释放资源try &#123; if (mInputStream != null) &#123; mInputStream.close(); Log.v(Constants.HTTP_WZ, &quot;mInputSream.close()&quot;); &#125; if (outputStream != null) &#123; outputStream.close(); Log.v(Constants.HTTP_WZ, &quot;outputStream.close()&quot;); &#125; if (bluetoothSocket != null) &#123; bluetoothSocket.close(); Log.v(Constants.HTTP_WZ, &quot;socket.close()&quot;); bluetoothSocket = null; &#125; isRunning = false; &#125; catch (Exception e2) &#123; // TODO: handle exception &#125;]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android拍照功能——TakePhoto]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E6%8B%8D%E7%85%A7%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94TakePhoto%2F</url>
    <content type="text"><![CDATA[之前在写项目框架Andoroid 6.0，动态获取权限的时候就提到过TakePhoto开源框架 简介一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库 依赖1implementation &apos;com.jph.takephoto:takephoto_library:4.0.3&apos; 用法我这里就说拍照，选择相册的功能。其他功能请移步TakePhoto开源框架看说明文档，写的很清楚。最后会给出一个工具类，拷贝过去就可以直接用。 定义两个变量 12private TakePhoto takePhoto;private InvokeParam invokeParam; 添加如下代码获取TakePhoto实例 12345678public TakePhoto getTakePhoto()&#123; if (takePhoto==null)&#123; takePhoto= (TakePhoto) TakePhotoInvocationHandler.of(this).bind(new TakePhotoImpl(this,this)); &#125; //设置压缩规则，最大500kb takePhoto.onEnableCompress(new CompressConfig.Builder().setMaxSize(500 * 1024).create(), true); return takePhoto; &#125; 实现两个接口：TakePhoto.TakeResultListener,InvokeListener 在 onCreate,onActivityResult,onSaveInstanceState方法中调用TakePhoto对用的方法 1234567891011121314151617@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; getTakePhoto().onCreate(savedInstanceState); super.onCreate(savedInstanceState); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; getTakePhoto().onActivityResult(requestCode, resultCode, data); super.onActivityResult(requestCode, resultCode, data); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; getTakePhoto().onSaveInstanceState(outState); super.onSaveInstanceState(outState); &#125; 重写TPermissionType invoke(InvokeParam invokeParam)方法，添加如下代码：12345678910111213141516@Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); //以下代码为处理Android6.0、7.0动态权限所需 PermissionManager.TPermissionType type=PermissionManager.onRequestPermissionsResult(requestCode,permissions,grantResults); PermissionManager.handlePermissionsResult(this,type,invokeParam,this); &#125; @Override public PermissionManager.TPermissionType invoke(InvokeParam invokeParam) &#123; PermissionManager.TPermissionType type=PermissionManager.checkPermission(TContextWrap.of(this),invokeParam.getMethod()); if(PermissionManager.TPermissionType.WAIT.equals(type))&#123; this.invokeParam=invokeParam; &#125; return type; &#125; &emsp;&emsp;到这里，根据他官方的介绍就已经全部写完了，然后怎么分调用相机，相册还是文件夹呢？ 调用不同的方法，常用的：相机，相册，多选 123456789101112131415161718192021 flag = getIntent().getIntExtra(&quot;flag&quot;, 0); File file = new File(getExternalCacheDir(), System.currentTimeMillis() + &quot;.png&quot;); Uri uri = Uri.fromFile(file); int size = Math.min(getResources().getDisplayMetrics().widthPixels, getResources().getDisplayMetrics().heightPixels); CropOptions cropOptions = new CropOptions.Builder().setOutputX(size).setOutputX(size).setWithOwnCrop(false).create(); if (flag == 1) &#123; //相机获取照片并剪裁 takePhoto.onPickFromCaptureWithCrop(uri, cropOptions); //相机获取不剪裁 //takePhoto.onPickFromCapture(uri); &#125; else if (flag == 2) &#123; //相册获取照片并剪裁 takePhoto.onPickFromGalleryWithCrop(uri, cropOptions); //相册获取不剪裁// takePhoto.onPickFromGallery(); &#125; else if (flag == 3) &#123; //多选，并剪裁 takePhoto.onPickMultipleWithCrop(9, cropOptions); //多选，不剪裁// takePhoto.onPickMultiple(9); &#125; &emsp;&emsp;前面一个页面调用startActivityForResult，传一个标记过来，用来判断调用不同的方式。 &emsp;&emsp;我这里还想多说的是，一般我们这个拍照功能，都有三个选项，拍照，相册，取消，从底部弹出。这个我估计还是大部分人写的动画实现的。我想说的是BottomSheetDialog，这个是MD推出的一个控件，现在微信用的就是这个，用起来也非常方便，简单。 &emsp;&emsp;至于，工具类，直接下载项目，把对应的TakePhotoActivity文件拷贝过去就可以了。 资源链接]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android图片压缩——Luban鲁班压缩]]></title>
    <url>%2F2018%2F03%2F02%2FAndroid%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E2%80%94%E2%80%94Luban%E9%B2%81%E7%8F%AD%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Android让人头疼的OOM，造成OOM的原因之一就是图片，现在的手机像素越来越高，随便一张图片都是好几M，甚至几十M，这样的照片加载到app，可想而知，随便加载几张图片，手机内存就不够用了，自然而然就造成了OOM，所以，Android的图片压缩异常重要。这里，我推荐一款开源框架——Luban 效果与对比&emsp;&emsp;这里就不放效果图了，我拷贝了鲁班github上面的介绍——Android图片压缩工具，仿微信朋友圈压缩策略，因为是逆向推算，效果还没法跟微信一模一样，但是已经很接近微信朋友圈压缩后的效果，具体看以下对比！ 内容 原图 Luban Wechat 截屏 720P 720*1280,390k 720*1280,87k 720*1280,56k 截屏 1080P 1080*1920,2.21M 1080*1920,104k 1080*1920,112k 拍照 13M(4:3) 3096*4128,3.12M 1548*2064,141k 1548*2064,147k 拍照 9.6M(16:9) 4128*2322,4.64M 1032*581,97k 1032*581,74k 滚动截屏 1080*6433,1.56M 1080*6433,351k 1080*6433,482k 从这里就能看出，效果还是非常不错的 依赖1implementation &apos;top.zibin:Luban:1.1.3&apos; 调用方式异步调用&emsp;&emsp;Luban内部采用IO线程进行图片压缩，外部调用只需设置好结果监听即可： 1234567891011121314151617181920Luban.with(this) .load(photos) // 传人要压缩的图片列表 .ignoreBy(100) // 忽略不压缩图片的大小 .setTargetDir(getPath()) // 设置压缩后文件存储位置 .setCompressListener(new OnCompressListener() &#123; //设置回调 @Override public void onStart() &#123; // TODO 压缩开始前调用，可以在方法内启动 loading UI &#125; @Override public void onSuccess(File file) &#123; // TODO 压缩成功后调用，返回压缩后的图片文件 &#125; @Override public void onError(Throwable e) &#123; // TODO 当压缩过程出现问题时调用 &#125; &#125;).launch(); //启动压缩 同步调用&emsp;&emsp;同步方法请尽量避免在主线程调用以免阻塞主线程，下面以rxJava调用为例 12345678910Flowable.just(photos) .observeOn(Schedulers.io()) .map(new Function&lt;List&lt;String&gt;, List&lt;File&gt;&gt;() &#123; @Override public List&lt;File&gt; apply(@NonNull List&lt;String&gt; list) throws Exception &#123; // 同步方法直接返回压缩后的文件 return Luban.with(MainActivity.this).load(list).get(); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(); &emsp;&emsp;以上，均是它github上面说明都有的，我这里就是copy过来了而已。重点要说的是，他是怎么实现的，源码分析。 源码分析第一步：Luban.with()点击去看到源码为： 123public static Builder with(Context context) &#123; return new Builder(context); &#125; &emsp;&emsp;这里是一个静态的with方法，返回值是Builder，一般对设计模式比较熟悉的人，看到这里就应该懂了，他这里使用的是建造者模式。什么是建造者模式呢？建造者模式和工厂模式很相似，比工厂模式多了一个控制类，其实说白了，就是在创建对象的时候，减少初始化数据的代码，怎么理解呢？我们接着往下看。我们点到Builder里面看到如下代码： 12345678910111213141516public static class Builder &#123; private Context context;//上下文对象 private String mTargetDir;//压缩后图片存放位置 private List&lt;String&gt; mPaths;//多个文件的list private int mLeastCompressSize = 100;//忽略100kb以下的图片，不压缩 private OnCompressListener mCompressListener;//回调方法 Builder(Context context) &#123; this.context = context; this.mPaths = new ArrayList&lt;&gt;(); &#125; private Luban build() &#123; return new Luban(this); &#125;&#125; &emsp;&emsp;我们看到了是一个静态的内部类Builder，我们这里看到了有5个变量，上面我们说道了，为了减少初始化数据的代码，就拿这个举例子说明，我如果有4个地方调用这个鲁班压缩，其中这4个地方，mTargetDir，mLeastCompressSize这2个变量的值都是一样的，其他3个不一样，按照我们以往的写法都得一个一个的赋值，要写4遍，那如果使用建造者模式了，这里就只用写一遍赋值，这2个变量。其他3个不一样，就得写多遍。当然，这是我个人对于建造者模式的理解。 &emsp;&emsp;我上面多粘贴了一个build()方法，为什么会多粘贴一个呢？就是为了更好的说明建造者模式，我们可以看到他这个方法，返回的是Luban对象，调用的是需要传Builder的构造方法，我们点进去看 1234567private Luban(Builder builder) &#123; this.mPaths = builder.mPaths; this.mTargetDir = builder.mTargetDir; this.mCompressListener = builder.mCompressListener; this.mLeastCompressSize = builder.mLeastCompressSize; mHandler = new Handler(Looper.getMainLooper(), this); &#125; &emsp;&emsp;他这里就是赋值，他这个值就是Builder里面默认的，我们不论在哪里调用这个方法，都不用去一个一个赋值，因为，他已经处理好了。 第二步：load()点击去看到源码为 1234567891011121314public Builder load(File file) &#123; this.mPaths.add(file.getAbsolutePath()); return this; &#125; public Builder load(String string) &#123; this.mPaths.add(string); return this; &#125; public Builder load(List&lt;String&gt; list) &#123; this.mPaths.addAll(list); return this; &#125; &emsp;&emsp;这里，我们会看到三个重载方法，一个传文件，他会获取到文件的绝对路径存进去，实际上还是存的字符串，中间那个存的是字符串，最后面那个传String类型的list，它调用的addAll方法，最后还是存的String在mPaths里面。我们点击mPaths，他就是一个String类型的list，在Builder的构造方法里面初始化的。他就是存放你的图片路径的集合 第三步：ignoreBy() 和 setTargetDir()点击去看到源码为 123456789101112131415/** * do not compress when the origin image file size less than one value * * @param size * the value of file size, unit KB, default 100K */public Builder ignoreBy(int size) &#123; this.mLeastCompressSize = size; return this;&#125;public Builder setTargetDir(String targetDir) &#123; this.mTargetDir = targetDir; return this;&#125; &emsp;&emsp;这两个我为啥要放在一起讲呢？因为这两个没啥好说的，都是设置值，跟我们平时写的set方法的作用是一样的。没啥好说的 第四步：setCompressListener(OnCompressListener listener)点击去看到源码为 1234public Builder setCompressListener(OnCompressListener listener) &#123; this.mCompressListener = listener; return this; &#125; &emsp;&emsp;这个就是我们平时写自定义view的时候，要写回调方法，是一样的道理，他这里就是压缩方法的回调 第五步：launch()点击去看到源码为 123456/** * begin compress image with asynchronous */public void launch() &#123; build().launch(context);&#125; &emsp;&emsp;这里，我们看到他先调用了build(),我们前面讲了，他这个方法就是赋值，然后调用了launch(context)方法，我们点进去看： 123456789101112131415161718192021222324252627282930313233/** * start asynchronous compress thread */ @UiThread private void launch(final Context context) &#123; if (mPaths == null || mPaths.size() == 0 &amp;&amp; mCompressListener != null) &#123; mCompressListener.onError(new NullPointerException(&quot;image file cannot be null&quot;)); &#125; Iterator&lt;String&gt; iterator = mPaths.iterator(); while (iterator.hasNext()) &#123; final String path = iterator.next(); if (Checker.isImage(path)) &#123; AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_START)); File result = Checker.isNeedCompress(mLeastCompressSize, path) ? new Engine(path, getImageCacheFile(context, Checker.checkSuffix(path))).compress() : new File(path); mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_SUCCESS, result)); &#125; catch (IOException e) &#123; mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_ERROR, e)); &#125; &#125; &#125;); &#125; else &#123; Log.e(TAG, &quot;can not read the path : &quot; + path); &#125; iterator.remove(); &#125; &#125; &emsp;&emsp;这个方法就是最后，执行压缩的方法，前面都是初始化，我们可以看到，他这个方法是在主线程调用的，所以，我们不用考虑切换线程的问题，直接可以操作UI变化。我一步一步的讲： 首先，他这个是用的迭代器，循环遍历，遍历一个就移除一个 然后就是通过handler发消息调用 具体压缩代码。最重要的就是第三点，我把第三点，提到下面讲 接着上面的第三点，具体压缩 123File result = Checker.isNeedCompress(mLeastCompressSize, path) ? new Engine(path, getImageCacheFile(context, Checker.checkSuffix(path))).compress() : new File(path); 首先，他整体是一个三目运算符，我们点isNeedCompress()方法看一下 12345678910111213static boolean isNeedCompress(int leastCompressSize, String path) &#123; if (leastCompressSize &gt; 0) &#123; File source = new File(path); if (!source.exists()) &#123; return false; &#125; if (source.length() &lt;= (leastCompressSize &lt;&lt; 10)) &#123; return false; &#125; &#125; return true; &#125; &emsp;&emsp;这个方法就是用来判断，你给定路径的图片大小和你规定的忽略文件大小比较，他这里先做了你给定的最小值判断，要大于0，不大于0就返回ture。然后做了文件是否存在的判断，如果文件不存在，就返回fals。最后，给定文件大小是不是小于等于最小值左移10位的值，小于就返回false。 然后，如果返回的是true，就去压缩，如果，返回的是false，就直接返回file文件。压缩的方法点进去： 123456789101112131415Engine(String srcImg, File tagImg) throws IOException &#123; if (Checker.isJPG(srcImg)) &#123; this.srcExif = new ExifInterface(srcImg); &#125; this.tagImg = tagImg; this.srcImg = srcImg; BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; options.inSampleSize = 1; BitmapFactory.decodeFile(srcImg, options); this.srcWidth = options.outWidth; this.srcHeight = options.outHeight; &#125; &emsp;&emsp;这就又要说道另一个类了Engine类，它的类注释就是：用于操作，开始压缩，管理活动，缓存资源的类。他这里传原文件，也就是你需要压缩的图片，还有一个就是目标文件，也就是你压缩之后，要保存的文件。 &emsp;&emsp;我们先看第二个参数是什么怎么传的，有的人看不懂 123456789101112131415161718/** * Returns a mFile with a cache audio name in the private cache directory. * * @param context * A context. */ private File getImageCacheFile(Context context, String suffix) &#123; if (TextUtils.isEmpty(mTargetDir)) &#123; mTargetDir = getImageCacheDir(context).getAbsolutePath(); &#125; String cacheBuilder = mTargetDir + &quot;/&quot; + System.currentTimeMillis() + (int) (Math.random() * 1000) + (TextUtils.isEmpty(suffix) ? &quot;.jpg&quot; : suffix); return new File(cacheBuilder); &#125; &emsp;&emsp;他这里就是新建一个文件，设置路径，设置名称，然后返回文件 &emsp;&emsp;再掉回去看Engine的构造方法，我们这里获取到了源文件和目标文件，我们只用把压缩后的流存到目标文件就行了。我之前写过一篇关于图片压缩的博客。它这里的option就是设置压缩的参数，不懂的可以看一下我之前的博客，或者用google百度一下就知道了。具体压缩就是用的bitmap的工厂类，调用的decodeFile方法。没错就是这一句 BitmapFactory.decodeFile(srcImg, options); 最后，辣么一切都准备就绪了，怎么样开始压缩呢？compress() 12345678910111213141516171819File compress() throws IOException &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = computeSize(); Bitmap tagBitmap = BitmapFactory.decodeFile(srcImg, options); ByteArrayOutputStream stream = new ByteArrayOutputStream(); tagBitmap = rotatingImage(tagBitmap); tagBitmap.compress(Bitmap.CompressFormat.JPEG, 60, stream); tagBitmap.recycle(); FileOutputStream fos = new FileOutputStream(tagImg); fos.write(stream.toByteArray()); fos.flush(); fos.close(); stream.close(); return tagImg; &#125; &emsp;&emsp;这里面就是常规的压缩，存储的逻辑了，最最重要的压缩算法呢？就是这里的computeSize()方法 123456789101112131415161718192021222324private int computeSize() &#123; srcWidth = srcWidth % 2 == 1 ? srcWidth + 1 : srcWidth; srcHeight = srcHeight % 2 == 1 ? srcHeight + 1 : srcHeight; int longSide = Math.max(srcWidth, srcHeight); int shortSide = Math.min(srcWidth, srcHeight); float scale = ((float) shortSide / longSide); if (scale &lt;= 1 &amp;&amp; scale &gt; 0.5625) &#123; if (longSide &lt; 1664) &#123; return 1; &#125; else if (longSide &gt;= 1664 &amp;&amp; longSide &lt; 4990) &#123; return 2; &#125; else if (longSide &gt; 4990 &amp;&amp; longSide &lt; 10240) &#123; return 4; &#125; else &#123; return longSide / 1280 == 0 ? 1 : longSide / 1280; &#125; &#125; else if (scale &lt;= 0.5625 &amp;&amp; scale &gt; 0.5) &#123; return longSide / 1280 == 0 ? 1 : longSide / 1280; &#125; else &#123; return (int) Math.ceil(longSide / (1280.0 / scale)); &#125; &#125; 12345678910111213141516171819202122private Bitmap rotatingImage(Bitmap bitmap) &#123; if (srcExif == null) return bitmap; Matrix matrix = new Matrix(); int angle = 0; int orientation = srcExif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); switch (orientation) &#123; case ExifInterface.ORIENTATION_ROTATE_90: angle = 90; break; case ExifInterface.ORIENTATION_ROTATE_180: angle = 180; break; case ExifInterface.ORIENTATION_ROTATE_270: angle = 270; break; &#125; matrix.postRotate(angle); return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true); &#125; &emsp;&emsp;你以为我会一步一步给你讲Luban算法逻辑吗？那是不可能的，我特么都不会，怎么给你讲。我直接把他github上算法逻辑的介绍拷贝过来了： 判断图片比例值，是否处于以下区间内； [1, 0.5625) 即图片处于 [1:1 ~ 9:16) 比例范围内 [0.5625, 0.5) 即图片处于 [9:16 ~ 1:2) 比例范围内 [0.5, 0) 即图片处于 [1:2 ~ 1:∞) 比例范围内 判断图片最长边是否过边界值； [1, 0.5625) 边界值为：1664 n（n=1）, 4990 n（n=2）, 1280 * pow(2, n-1)（n≥3） [0.5625, 0.5) 边界值为：1280 * pow(2, n-1)（n≥1） [0.5, 0) 边界值为：1280 * pow(2, n-1)（n≥1） 计算压缩图片实际边长值，以第2步计算结果为准，超过某个边界值则：width / pow(2, n-1)，height/pow(2, n-1) 计算压缩图片的实际文件大小，以第2、3步结果为准，图片比例越大则文件越大。size = (newW newH) / (width height) * m； [1, 0.5625) 则 width &amp; height 对应 1664，4990，1280 * n（n≥3），m 对应 150，300，300； [0.5625, 0.5) 则 width = 1440，height = 2560, m = 200； [0.5, 0) 则 width = 1280，height = 1280 / scale，m = 500；注：scale为比例值 判断第4步的size是否过小 [1, 0.5625) 则最小 size 对应 60，60，100 [0.5625, 0.5) 则最小 size 都为 100 [0.5, 0) 则最小 size 都为 100 将前面求到的值压缩图片 width, height, size 传入压缩流程，压缩图片直到满足以上数值]]></content>
      <categories>
        <category>Android -源码解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（八）—— 私有目录被限制访问(Android 7.0)]]></title>
    <url>%2F2018%2F03%2F01%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E7%A7%81%E6%9C%89%E7%9B%AE%E5%BD%95%E8%A2%AB%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE-Android7.0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我这里只说我关心的问题，并不是说Android 7.0只增加了一个“私有目录被限制访问”，当然还有其他的变化。android 7.0的新特性中，对程序员开发造成最直接的变化就是FileUriExposedException异常，这个异常的产生就是由私有目录被限制访问造成的 &emsp;&emsp;Andoird 7.0中为了提高文件的安全性，面向Android N或者更高版本的应用私有目录将会被禁止访问，常见最直接的bug就是：你的应用给其他应用传递file:// URI类型的Uri时，可能导致接受者无法访问该路径会造成我们前面说的文件uri异常。 调用系统相机最直接的就是我们常用的拍照功能,我们自己的应用启动手机相机，这里手机相机就是其他应用，按照我们以前的写法就是： 1234567File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);if (!file.getParentFile().exists())file.getParentFile().mkdirs();Uri imageUri = Uri.fromFile(file);Intent intent = new Intent();intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);//设置Action为拍照intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);//将拍取的照片保存到指定URIstartActivityForResult(intent,986); &emsp;&emsp;先创建一个存放我们拍照图片的存放file，参数就是路径+文件名称，当我们还是按之前的写法，跑在android N及以上的机型的时候，会报如下异常： FileUriExposedException.png &emsp;&emsp;这就是由于Android 7.0执行了“StrictMode API 政策禁”对我们广大程序员造成的最常见，最直接的结果。辣么，怎么解决呢？ 解决办法FileProvider使用FileProvider解决上面的问题，步骤如下： 第一步：在清单文件里面申请provider123456789&lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;com.haichenyi.myproject.fileprovider&quot; android:grantUriPermissions=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; /&gt;&lt;/provider&gt; &emsp;&emsp;FileProvider是V4包下面的类，这里exproted属性必须给false，不然也会报异常，grantUriPermissions的值给true，表示授予临时URI访问权限，下面meta-data就是指定共享目录，authorities属性后面讲 第二步：指定共享目录12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;path&gt; &lt;external-path name=&quot;camera_photos&quot; path=&quot;&quot;/&gt; &lt;/path&gt;&lt;/resources&gt; &emsp;&emsp;有点android开发基础的人就知道，这个@xml目录是位于res根目录，跟layout目录平级的。所以，你得先创建xml文件夹，然后新建file_paths文件，添加上面的代码在文件中。这里的path路径，我们先瞅瞅下面的表： 物理路径 写法 Context.getFilesDir() + /path/ Context.getCacheDir() + /path/ Environment.getExternalStorageDirectory() + /path/ Context.getExternalFilesDir(String) + /path/ Context.getExternalCacheDir() + /path/ &emsp;&emsp;辣么，我们代码中path=””，是有特殊意义的，它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为path=”pictures”， 那么它代表着根目录下的pictures目录(eg:/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的 第三步：使用FileProvider12345678910val file = File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot; + System.currentTimeMillis() + &quot;.jpg&quot;) if (!file.parentFile.exists()) file.parentFile.mkdirs() //变化 val imageUri = FileProvider.getUriForFile(this, &quot;com.haichenyi.myproject.fileprovider&quot;, file)//通过FileProvider创建一个content类型的Uri val intent = Intent() //变化 intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION) //添加这一句表示对目标应用临时授权该Uri所代表的文件 intent.action = MediaStore.ACTION_IMAGE_CAPTURE//设置Action为拍照 intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri)//将拍取的照片保存到指定URI startActivityForResult(intent, 986) &emsp;&emsp;我们调用系统相机的代码发生了变化，变化的位置，我都注明了获取imageUri的方式发生了变化，其中，第二个参数就是我们在前面说放在后面讲的authorities属性的内容，再就是增加了一个flag，表示临时授权。加上如上代码，我们就可以正常调用系统相机了。 &emsp;&emsp;经过如上步骤之后，我们就能拍照了，拍完照片之后的存放路径在哪里呢？我们前面说了，这里我打印出了路径， 123file!!.absolutePath:/storage/emulated/0/temp/1519896174785.jpgimageUri:content://com.haichenyi.myproject.fileprovider/camera_photos/temp/1519896174785.jpg 照片裁剪Android 7.0之前，我们裁剪照片 1234567891011121314File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);if (!file.getParentFile().exists())file.getParentFile().mkdirs();Uri outputUri = Uri.fromFile(file);Uri imageUri=Uri.fromFile(new File(&quot;/storage/emulated/0/temp/1519896174785.jpg&quot;));Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);intent.setDataAndType(imageUri, &quot;image/*&quot;);intent.putExtra(&quot;crop&quot;, &quot;true&quot;);intent.putExtra(&quot;aspectX&quot;, 1);intent.putExtra(&quot;aspectY&quot;, 1);intent.putExtra(&quot;scale&quot;, true);intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri);intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());intent.putExtra(&quot;noFaceDetection&quot;, true); // no face detectionstartActivityForResult(intent,987); Android 7.0之后，我们裁剪照片 123456789101112131415File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);if (!file.getParentFile().exists())file.getParentFile().mkdirs();Uri outputUri = FileProvider.getUriForFile(context, &quot;com.haichenyi.myproject.fileprovider&quot;,file);Uri imageUri=FileProvider.getUriForFile(context, &quot;com.haichenyi.myproject.fileprovider&quot;, new File(&quot;/storage/emulated/0/temp/1519896174785.jpg&quot;);//通过FileProvider创建一个content类型的UriIntent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);intent.setDataAndType(imageUri, &quot;image/*&quot;);intent.putExtra(&quot;crop&quot;, &quot;true&quot;);intent.putExtra(&quot;aspectX&quot;, 1);intent.putExtra(&quot;aspectY&quot;, 1);intent.putExtra(&quot;scale&quot;, true);intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri);intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());intent.putExtra(&quot;noFaceDetection&quot;, true); // no face detectionstartActivityForResult(intent,987); &emsp;&emsp;拍照裁剪这是一个很常用的功能，很早之前就写过一篇，封装的不是很好。最近，又做了一遍这个功能，发现了一个好用的框架——TakePhoto 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（七）—— 权限申请(Android 6.0)]]></title>
    <url>%2F2018%2F03%2F01%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7-Android6.0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;总所周知，Android 6.0以上的版本，google对权限做了更严格的限制，不能app自动给权限，必须要让用户选择是否给权限。如果，用户不给权限，辣么，用这个功能的时候，app会造成崩溃，所以，最简单的办法就是，用户不给权限，不让用户用这个功能，也就是页面不做跳转。 &emsp;&emsp;当时，刚出来这个权限问题的时候，本人用原生的写，写了封装，搞了好长时间，总感觉各种不爽，各种不舒服，后来好了，大牛封装了一个开源框架——RxPermission，一行代码解决动态申请权限问题。 依赖1implementation &apos;com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar&apos; 工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.haichenyi.myproject.utilsimport android.app.Activityimport android.content.Intentimport android.net.Uriimport android.os.Buildimport android.os.Environmentimport android.provider.Settingsimport android.support.v7.app.AlertDialogimport com.haichenyi.myproject.Rimport com.tbruyelle.rxpermissions2.RxPermissionsimport java.io.Fileimport java.io.FileInputStreamimport java.io.IOExceptionimport java.util.*/** * Author: 海晨忆 * Date: 2018/2/28 * Desc: */object RxPerUtils &#123; /** * 请求权限的获取方法 * activity：Activity对象 * permissions：需要获取的权限，可以传多个 * aloe: (b: Boolean)：一个参数的回调方法，b为true，表示用户给了权限，false，表示没有给权限 */ fun requestPermission(activity: Activity, vararg permissions: String, aloe: (b: Boolean) -&gt; Unit) &#123; RxPermissions(activity).request(*permissions) .subscribe &#123; aBoolean -&gt; aloe(aBoolean) &#125; &#125; /** * 当用户拒绝给权限的时候调用，跳转权限设置页面，让用户手动给权限 * activity：Activity对象 * permissionName：权限名称 * msg：提示信息 */ fun setupPermission(activity: Activity, permissionName: String, msg: String, aloe: () -&gt; Unit) &#123; AlertDialog.Builder(activity, R.style.Theme_AppCompat_Dialog).setTitle(&quot;权限申请&quot;) .setMessage(String.format(Locale.getDefault(), &quot;请在“权限”中开启“%1s权限”，以正常使用%2s&quot;, permissionName, msg)) .setCancelable(false) .setNegativeButton(android.R.string.cancel) &#123; dialog, which -&gt; aloe &#125;.setPositiveButton(&quot;去设置&quot;) &#123; dialog, which -&gt; if (isMiUi()) &#123; setMiUiPermissions(activity) &#125; else &#123; activity.startActivityForResult(Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS) .setData(Uri.fromParts(&quot;package&quot;, activity.packageName, null)), 1000) &#125; &#125;.create().show() &#125; private fun setMiUiPermissions(activity: Activity) &#123; if (isMiUi()) &#123; try &#123; // MIUI 8 activity.startActivityForResult(Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;) .setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;) .putExtra(&quot;extra_pkgname&quot;, activity.packageName), 1000) &#125; catch (e: Exception) &#123; try &#123; // MIUI 5/6/7 activity.startActivityForResult(Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;) .setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;) .putExtra(&quot;extra_pkgname&quot;, activity.packageName), 1000) &#125; catch (e1: Exception) &#123; // 否则跳转到应用详情 activity.startActivityForResult(Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS) .setData(Uri.fromParts(&quot;package&quot;, activity.packageName, null)), 1000) &#125; &#125; &#125; &#125; private fun isMiUi(): Boolean &#123; val device = Build.MANUFACTURER if (device == &quot;Xiaomi&quot;) &#123; try &#123; val prop = Properties() prop.load(FileInputStream(File(Environment.getRootDirectory(), &quot;build.prop&quot;))) return (prop.getProperty(&quot;ro.miui.ui.version.code&quot;, null) != null || prop.getProperty(&quot;ro.miui.ui.version.name&quot;, null) != null || prop.getProperty(&quot;ro.miui.internal.storage&quot;, null) != null) &#125; catch (e: IOException) &#123; e.printStackTrace() &#125; &#125; return false &#125;&#125; 调用12345678910RxPerUtils.requestPermission(this, Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE) &#123; if (it) &#123; //这里写你自己的逻辑，已经获得权限，做你自己的业务逻辑操作 ToastUtils.showTipMsg(&quot;已经获得权限&quot;) &#125; else &#123; RxPerUtils.setupPermission(this, &quot;相机和存储&quot;, &quot;相机功能&quot;) &#123; &#125; &#125; &#125; &emsp;&emsp;请求权限的整个过程就是： 用RxPermission去请求权限，需要传activity对象,然后就是你需要获取的权限（可以传多个），再就是回调方法 在回调方法里面做判断，用户是否给了权限，如果给了，就走你正常的逻辑。如果没有给，就弹对话框提示用户，去设置页面给权限。 &emsp;&emsp;就这么简单，方法都封装好了，如果，你嫌弃系统自带的对话框样式不好看，你也可以自己写一个样式。项目就不传了，如果你有之前的代码，就直接把我这几个方法拷贝过去用就可以了，没有之前的代码，就去瞅瞅之前的博客吧。]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（六）——Socket网络编程]]></title>
    <url>%2F2018%2F02%2F26%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Android中常用的网络编程方式：Http和Socket，Http通讯方式，我们在前面已经加到框架里面了，用的是现在主流的RxJava+Retrofit+OkHttp的方式，用起来也很方便。今天，我们来说说Socket网络编程。前面已经有一篇讲过IO和NIO的区别，还有一篇讲过Netty了，今天这篇的目的就是把Netty加到我们这个框架里面。 添加依赖1implementation &apos;io.netty:netty-all:5.0.0.Alpha2&apos; 添加依赖，老生常谈的问题了，我就不多说了。 TCP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.haichenyi.myproject.model.socketimport android.util.Logimport com.haichenyi.myproject.model.bean.SocketTcpBeanimport io.netty.bootstrap.Bootstrapimport io.netty.channel.Channelimport io.netty.channel.ChannelInitializerimport io.netty.channel.ChannelOptionimport io.netty.channel.EventLoopGroupimport io.netty.channel.nio.NioEventLoopGroupimport io.netty.channel.socket.SocketChannelimport io.netty.channel.socket.nio.NioSocketChannelimport io.netty.handler.codec.LineBasedFrameDecoderimport io.netty.handler.codec.string.StringDecoderimport io.netty.handler.codec.string.StringEncoderimport io.netty.util.CharsetUtilimport org.greenrobot.eventbus.EventBusimport org.greenrobot.eventbus.Subscribe/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class SocketTcp &#123; companion object &#123; private val socket = SocketTcp() fun getInstance(): SocketTcp = socket &#125; private var port: Int = 0 private var host: String = &quot;&quot; private var channel: Channel? = null private var group: EventLoopGroup? = null fun setPort(port: Int): SocketTcp &#123; this.port = port return this &#125; fun setHost(host: String): SocketTcp &#123; this.host = host return this &#125; fun connect() &#123; if (null != channel) return if (null == group) &#123; if (!EventBus.getDefault().isRegistered(this)) EventBus.getDefault().register(this) group = NioEventLoopGroup() &#125; val bootstrap = Bootstrap() try &#123; bootstrap.group(group) .channel(NioSocketChannel::class.java) .option(ChannelOption.TCP_NODELAY, true) .handler(object : ChannelInitializer&lt;SocketChannel&gt;() &#123; override fun initChannel(ch: SocketChannel?) &#123; //以换行符为结束标记 val pipeline = ch!!.pipeline() pipeline.addLast(&quot;encoder&quot;, StringEncoder(CharsetUtil.UTF_8)) pipeline.addLast(LineBasedFrameDecoder(Integer.MAX_VALUE)) pipeline.addLast(StringDecoder()) pipeline.addLast(HeartTcp()) //以&quot;#_&quot;作为分隔符 /*val pipeline = ch!!.pipeline() pipeline.addLast(&quot;encoder&quot;, StringEncoder(CharsetUtil.UTF_8)) val s = &quot;#_&quot; val byteBuf = Unpooled.copiedBuffer(s.toByteArray()) pipeline.addLast(DelimiterBasedFrameDecoder(Integer.MAX_VALUE, byteBuf)) pipeline.addLast(StringDecoder())*/ &#125; &#125;) //发起异步连接操作 val channelFuture = bootstrap.connect(host, port).sync() channel = channelFuture.channel() //等待服务端监听端口关闭 channel!!.closeFuture().sync() &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; finally &#123; disConnect() &#125; &#125; //连接成功后，通过Channel提供的接口进行IO操作 fun sendMessage(msg: String) &#123; try &#123; if (channel != null &amp;&amp; channel!!.isOpen) &#123; channel!!.writeAndFlush(msg).sync() Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg) &#125; else &#123; throw Exception(&quot;channel is null | closed&quot;) &#125; &#125; catch (e: Exception) &#123; reConnect() e.printStackTrace() &#125; &#125; /** * 断开tcp连接. */ private fun disConnect() &#123; if (null != group) &#123; group!!.shutdownGracefully() &#125;// EventBus.getDefault().unregister(this) group = null channel = null Log.v(&quot;WZ&quot;, &quot;disConnect&quot;) &#125; @Subscribe fun handle(socketTcpBean: SocketTcpBean) &#123; sendMessage(socketTcpBean.msg) &#125; /** * 重连. */ private fun reConnect() &#123; Thread(Runnable &#123; this.connect() &#125;).start() &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.haichenyi.myproject.model.socketimport android.os.SystemClockimport android.util.Logimport io.netty.buffer.Unpooledimport io.netty.channel.ChannelHandlerContextimport io.netty.channel.SimpleChannelInboundHandlerimport java.util.concurrent.TimeUnitclass HeartTcp : SimpleChannelInboundHandler&lt;Any&gt;() &#123; private var ctx: ChannelHandlerContext? = null private var isConnect = false @Throws(Exception::class) override fun channelActive(ctx: ChannelHandlerContext) &#123; super.channelActive(ctx) Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;) isConnect = true if (this.ctx == null) &#123; synchronized(HeartTcp::class.java) &#123; if (this.ctx == null) &#123; this.ctx = ctx myAppHeart() &#125; &#125; &#125; &#125; private fun myAppHeart() &#123; Thread &#123; while (ctx != null &amp;&amp; isConnect) &#123; val data = &quot;123&quot; val bytes = data.toByteArray() if (isConnect) &#123; ctx!!.writeAndFlush(Unpooled.buffer(bytes.size).writeBytes(bytes)) SystemClock.sleep(3000) &#125; &#125; &#125;.start() &#125; @Throws(Exception::class) override fun channelInactive(ctx: ChannelHandlerContext) &#123; val loop = ctx.channel().eventLoop() loop.schedule(&#123; SocketTcp.getInstance().connect() &#125;, 5, TimeUnit.SECONDS) super.channelInactive(ctx) Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;) isConnect = false &#125; @Throws(Exception::class) override fun userEventTriggered(ctx: ChannelHandlerContext, evt: Any) &#123; super.userEventTriggered(ctx, evt) Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;) &#125; @Throws(Exception::class) override fun exceptionCaught(ctx: ChannelHandlerContext, cause: Throwable) &#123; super.exceptionCaught(ctx, cause) Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;) this.ctx = null &#125; @Throws(Exception::class) override fun messageReceived(ctx: ChannelHandlerContext, msg: Any) &#123; Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;) /*val msg1 = msg val bytes = ByteArray(msg1.readableBytes()) msg1.readBytes(bytes) val s = String(bytes*//*, &quot;UTF-8&quot;*//*)*/ val s = msg.toString() Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s) &#125;&#125; &emsp;&emsp;我这里就是把我前面那个讲Netty创建Socket连接的代码拷贝过来转成了kotlin代码，这里我就不做过多的解释了。 &emsp;&emsp;一般，我们都是后台新开一个服务去启动socket，所以，我们还要创建一个Service，去处理socket。我这里就是非绑定启动这个服务。在oncreate方法里面去连接服务器即可 123456789101112131415161718192021package com.haichenyi.myproject.model.socketimport android.app.Serviceimport android.content.Intentimport android.os.IBinder/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class SocketService : Service() &#123; override fun onBind(intent: Intent?): IBinder? &#123; return null &#125; override fun onCreate() &#123; super.onCreate() Thread(Runnable &#123; SocketTcp.getInstance().setPort(8080).setHost(&quot;192.168.0.235&quot;).connect() &#125;).start() &#125;&#125; &emsp;&emsp;之所以要新建一个服务，就是可能你在连接socket的时候，可能要做一些其他信息的初始化，而这些信息初始化也是只有在连接socket服务器之前才需要的，写在这里方便一起管理，要是写在activity里面不便于管理。上面都是扯淡，最主要的是我们在最初学Android的时候，教你们的老师应该讲过，什么时候需要用到服务，就是不需要页面，用户并不关心它长什么样子，需要长连接的任务，都放在服务里面。正好，socket连接正好满足这些条件。 &emsp;&emsp;细心的同学可能注意了，我在Tcp类里面有一个EventBus，我这里是把发TCP消息给拿出来了，便于管理。我这边还新建了一个SocketUtils类，就是处理Socket请求的方法，我们发消息之类的方法，都是调用SocketUtils类里面的方法，不用去改Tcp类。这样做就只有一个目的，就是便于统一管理，代码如下 12345678910111213141516171819package com.haichenyi.myproject.model.socketimport com.haichenyi.myproject.model.bean.SocketTcpBeanimport org.greenrobot.eventbus.EventBus/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */object SocketUtils &#123; fun sendTcpMsg(msg: String) &#123; sendTcpMsg(SocketTcpBean(msg)) &#125; private fun sendTcpMsg(socketTcpBean: SocketTcpBean) &#123; EventBus.getDefault().post(socketTcpBean) &#125;&#125; &emsp;&emsp;至于这个SocketTcpBean类，就是一个普通的java bean类，里面就只有一个参数msg，你需要发的消息 UDP我先给出来代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.haichenyi.myproject.model.socketimport android.util.Logimport com.haichenyi.myproject.model.bean.SocketUdpBeanimport io.netty.bootstrap.Bootstrapimport io.netty.buffer.Unpooledimport io.netty.channel.Channelimport io.netty.channel.ChannelOptionimport io.netty.channel.EventLoopGroupimport io.netty.channel.nio.NioEventLoopGroupimport io.netty.channel.socket.DatagramPacketimport io.netty.channel.socket.nio.NioDatagramChannelimport org.greenrobot.eventbus.EventBusimport org.greenrobot.eventbus.Subscribeimport java.net.InetSocketAddressimport java.nio.charset.Charset/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class SocketUdp &#123; companion object &#123; private val socket = SocketUdp() fun getInstance(): SocketUdp = socket &#125; private var port: Int = 0 private var channel: Channel? = null private var group: EventLoopGroup? = null fun setPort(port: Int): SocketUdp &#123; this.port = port return this &#125; fun connect() &#123; if (null != channel) return if (null == group) &#123; if (!EventBus.getDefault().isRegistered(this)) EventBus.getDefault().register(this) group = NioEventLoopGroup() &#125; val bootstrap = Bootstrap() bootstrap.group(group) .channel(NioDatagramChannel::class.java) .option(ChannelOption.SO_BROADCAST, true) .handler(UdpHandler()) try &#123; channel = bootstrap.bind(port).sync().channel() channel!!.closeFuture().sync() &#125; catch (e: InterruptedException) &#123; e.printStackTrace() &#125; finally &#123; disConnect() &#125; &#125; /** * 断开tcp连接. */ private fun disConnect() &#123; if (null != group) &#123; group!!.shutdownGracefully() &#125;// EventBus.getDefault().unregister(this) group = null channel = null Log.v(&quot;WZ&quot;, &quot;disConnect&quot;) &#125; //连接成功后，通过Channel提供的接口进行IO操作 private fun sendMessage(host: String, port: Int, data: ByteArray) &#123; val packet = DatagramPacket(Unpooled.copiedBuffer(data), InetSocketAddress(host, port)) channel?.let &#123; try &#123; it.writeAndFlush(packet).sync() Log.d(&quot;wz&quot;, &quot;send succeed &quot; + String(data, Charset.forName(&quot;UTF-8&quot;))) &#125; catch (e: Exception) &#123; reConnect() e.printStackTrace() &#125; &#125; &#125; @Subscribe fun handle(socketUdpBean: SocketUdpBean) &#123; sendMessage(socketUdpBean.host,socketUdpBean.port,socketUdpBean.data) &#125; /** * 重连. */ private fun reConnect() &#123; Thread(Runnable &#123; this.connect() &#125;).start() &#125;&#125; 123456789101112131415161718192021222324package com.haichenyi.myproject.model.socketimport android.util.Logimport io.netty.channel.ChannelHandlerContextimport io.netty.channel.SimpleChannelInboundHandlerimport io.netty.channel.socket.DatagramPacketimport java.nio.charset.Charset/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class UdpHandler : SimpleChannelInboundHandler&lt;DatagramPacket&gt;() &#123; override fun messageReceived(ctx: ChannelHandlerContext?, msg: DatagramPacket?) &#123; val byteBuf = msg!!.content() val bytes = ByteArray(byteBuf.readableBytes()) byteBuf.readBytes(bytes) val s = String(bytes, Charset.forName(&quot;UTF-8&quot;)) Log.v(&quot;WZ&quot;, &quot;UDP收到的消息是--&gt;$s&quot;) &#125;&#125; &emsp;&emsp;这里的代码跟TCP类似，我想说的就只有三点： 首先你客户端开启UDP的时候，需要bind一个端口号，这个端口号是服务器给你发消息的时候，需要的端口号。 它的管道里面的handle类型DatagramPacket 再有就是给目标主机发消息，UDP需要传目标地址，端口号，还有消息。这里的目标地址就是服务器的地址，端口号就是服务器跟你通信的端口号，消息就是你需要发送给服务器的信息 &emsp;&emsp;其实，这里的区别就是TCP与UDP的区别，TCP和UDP什么区别呢？ 类型 TCP UDP 是否连接 面向连接 面向非连接 传输效率 慢 快 数据是否有序 有序 无序 安全性 安全 不安全 模式 流模式 报文模式 系统资源 多 少 区别的总结：最典型的对比就是打电话（TCP）和发短信（UDP）的区别 是否连接方面，TCP是1对1，UDP可以1对N 传输效率：TCP必须等到一个消息全部传完了才能传下一个，UDP可以一直发 数据是否有序：TCP是按顺序一条一条的发，当然是有序的。UDP则是无序的 安全性方面：TCP有3次握手机制，采用的全双工的可靠信道，保证了数据的安全，UDP则没有3次握手机制，采用的是不可靠信道 模式方面：TCP是面向字节流，实际上TCP把数据看成了一连串无结构的字节流，UDP则是面向报文的 系统资源方面：TCP首部开销20个字节，UDP首部开销8个字节 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（五）—GreenDao的增删改查]]></title>
    <url>%2F2018%2F02%2F24%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94GreenDao%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇我们讲了GreenDao的数据库的依赖和创建，这一篇，我们来讲常用的增删改查四种方法。我们操作数据库都是Dao层，不同的表，有不懂的Dao层对象。我们上一篇的数据库接口的实现类里面，我们定义了UserDao，我们这一篇讲的就是操作我们昨天创建的user表。 &emsp;&emsp;在写下面几个方法之前，我还是先把MVP的用法先讲一遍吧，防止有人不知道，以增操作为例，另外三个就不再讲了： 点击页面的增按钮，我们要调用P层的方法去做增操作。效果图如下： P层的方法从哪来呢？P层实现的接口来撒，所以，我们只用在接口定义对应的方法，在P层去实现，效果图如下： 辣么，具体实现代码怎么写呢？既不记得，我们的装饰者模式，我们P层里面有一个DataHelper对象，通过它去调用对应的方法就可以了，效果图如下： 接下来，datahelper的方法又是从哪里来呢？我们的DataHelper是不是实现了SqlHelper接口，所以，直接在SqlHelper定义方法，在datahelper实现即可，效果图如下： 最后，前面只是调用了，具体实现在哪里呢？我之前有没有讲过装饰者模式，一个接口，两个实现方法，对，没错，就是在SqlImpl方法里面实现，效果图如下： &emsp;&emsp;通过以上5步，就完成我们的增操作。有同鞋就会问，那参数怎么传？我特么怎么知道需要传什么传输，你这个方法是干什么的，调用这个方法需要什么数据，你就丢在参数里面传过去，即可。 增方法12345//插入单个对象userDao.insert(user);//插入一个listuserDao.insertInTx(users); 调用12345//basePresenter.onAdd(User(&quot;小红&quot;, 1, 165, &quot;50KG&quot;, 18))val dataList = mutableListOf&lt;User&gt;()dataList.add(User(&quot;小刚&quot;, 2, 175, &quot;60KG&quot;, 28))dataList.add(User(&quot;小东&quot;, 2, 185, &quot;65KG&quot;, 25))basePresenter.onAddList(dataList) 效果图我就不贴出来了，如果，你的效果出不来，就肯定是你的代码写的有问题，我写这个博客都是边写代码，边写博客，我这边肯定是没问题的。 查方法1234//查询单个对象userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();//查询一个listuserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list(); 调用123456val user = basePresenter.onSelect(&quot;小红&quot;)println(user.name)val users = basePresenter.onSelectList(&quot;小东&quot;) users.forEach &#123; println(it.name) &#125; &emsp;&emsp;这里，我需要做一点说明，那就是手动能力强的宝宝，看见有两个查询方法，一个查询一个对象，一个查询list，这两个方法没问题，查询肯定是查询的一个，list里面也是只有一个对象，就有宝宝想着多插入几条数据，这个时候，项目就可能崩掉，因为，你插入的名字是相同的，我们这里名字是作为主键，表里面主键是不能相同的，所以就崩掉了，所以，你就得改表结构，正好测试我们之前说的版本更新问题，我这里亲测可用，数据也不会丢失。步骤如下： 修改数据库版本，把1改成2 User bean里面增加一个字段id Long类型，递增即可，clean，build项目 在你的Activity里面会报错，因为，你User的构造方法里面新增了一个参数，辣么这里你用的时候参数个数都不对，肯定报错，你把id字段对应的参数传null即可，他自己递增。这里也只有Long类型可以传null 重新运行项目，没有问题 删方法1234567891011121314151617181920/*//通过主键删除一个对象，删除满足条件的第一个对象 User user1 = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique(); //一定要记得做非空判断 if (user1 != null) &#123; userDao.deleteByKey(user1.getId()); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;); &#125;*/ //通过主键删除一个满足条件的List List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list(); if (list.size() &gt; 0) &#123; List&lt;Long&gt; keys = new ArrayList&lt;&gt;(); for (User user : list) &#123; keys.add(user.getId()); &#125; userDao.deleteByKeyInTx(keys); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;); &#125; 调用12//basePresenter.onDelete(&quot;小红&quot;)basePresenter.onDelete(&quot;小东&quot;) 改方法1234567891011List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(oldName)).build().list(); if (list.size() &gt; 0) &#123; for (User user : list) &#123; user.setName(newName); &#125;// userDao.update(user1); userDao.updateInTx(list); ToastUtils.Companion.showTipMsg(&quot;修改成功&quot;); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;未查询到相关数据&quot;); &#125; 调用1basePresenter.onUpdate(&quot;小刚&quot;, &quot;小贝&quot;) 完了，数据库的简单的增删改查 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（四）—Kotlin+GreenDao3.2]]></title>
    <url>%2F2018%2F02%2F24%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94Kotlin-GreenDao3-2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本篇介绍android常用的数据库之一GreenDao的简单用法，增删改查。基于前面搭的框架，当然，你也可以选择不用。看懂用法之后，用起来很方便。GreenDao数据库升级到3.0版本之后api用起来更加方便了，便于让开发人员专注于业务逻辑。我需要额外说明的是，我把之前的项目框架转成了kotlin，不会kotlin语法的同学，可以去研究一下。 添加依赖最终，我们要添加如下代码，效果图如下： 第一步&emsp;&emsp;打开的你根目录下面的build.gradle文件，也就是项目下面的，并不是app目录下面的build.gradle。 12345678910111213// In your root build.gradle file:buildscript &#123; repositories &#123; jcenter() ...//其他你自己的 mavenCentral() // add repository &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.0&apos; ...//其他你自己的 classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin &#125;&#125; 第二步&emsp;&emsp;打开你的项目下面的build.gradle文件，也就是你的app目录下面的，之前我们添加依赖的时候的那个文件 1234567// In your app projects build.gradle file:apply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin dependencies &#123; compile &apos;org.greenrobot:greendao:3.2.2&apos; // add library&#125; &emsp;&emsp;完成上面两步，辣么，关于greendao的依赖我们就添加完成了 初始化&emsp;&emsp;我们首先得有一个bean类，这个bean类对应的就是数据库表的表结构。我这里想说明的是（敲黑板了），看到了很多网上说的什么主键id必须用Long类型，这种说法是不准确的，准确的说，你的主键字段名称，如果是“id”，辣么，你这个字段“id”，必须用Long类型，如果你换一个名称，比方说“myId”，辣么，你就不必用Long类型，这个问题，说大不大，说小，又困扰了我有一会。我这里新建用户表，就需要一个User的java bean类。如下： 1234567891011121314151617181920212223242526package com.haichenyi.myproject.model.bean;import org.greenrobot.greendao.annotation.Entity;import org.greenrobot.greendao.annotation.Id;import org.greenrobot.greendao.annotation.NotNull;import org.greenrobot.greendao.annotation.Property;import org.greenrobot.greendao.annotation.Transient;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: 用户表的bean类 */@Entitypublic class User &#123; @Id private String name; private int sex; @Property(nameInDb = &quot;Height&quot;) private int height; private String weight; @NotNull private int age; @Transient private String character;&#125; &emsp;&emsp;这里我把几个常用的注解都写出来了，说一下这几个注解是什么意思 注解 意义 @Entity 用于标识这是一个需要Greendao帮我们生成代码的bean @Id 标明主键，括号里可以指定是否自增 @Property 用于设置属性在数据库中的列名（默认不写就是保持一致） @NotNull 非空 @Transient 标识这个字段是自定义的不会创建到数据库表里 简单的讲一下： @Entity：标识的bean类，我们在运行的时候，greendao会自动帮我们生成对应的表 @Id：标识的字段就是这个表对应的主键 @Property：标识的字段在表中对应的那一栏的名称是后面括号里面的，这个表height字段对应表中的Height，一般我们直接设置成默认就可以了 @NotNull：标识的字段，这个字段在表中不能为空，不然就出错，所以，在添加数据的时候设置默认值 @Transient：标识的字段，在生成表的时候不会生成对应的字段。这个什么时候用呢？这个，我一般用作标记flag，比方说，从数据库拿数据，又不想重新写一个bean类，就用这个bean类，RecyclerView，填充完数据，item点击的时候，状态发生变化，我们要有一个flag，就通过修改这个字段的值，页面做出相应的变化。 &emsp;&emsp;写到这里，我们的bean类也有了，要怎么生成数据库呢？在生成数据库之前，我们先把项目重新clean一遍，再build一遍，看到你刚写的需要生成表的bean类变成了如下样子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.haichenyi.myproject.model.bean;import org.greenrobot.greendao.annotation.Entity;import org.greenrobot.greendao.annotation.Id;import org.greenrobot.greendao.annotation.NotNull;import org.greenrobot.greendao.annotation.Property;import org.greenrobot.greendao.annotation.Transient;import org.greenrobot.greendao.annotation.Generated;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: 用户表的bean类 */@Entitypublic class User &#123; @Id private String name; private int sex; @Property(nameInDb = &quot;Height&quot;) private int height; private String weight; @NotNull private int age; @Transient private String character; @Generated(hash = 717717955) public User(String name, int sex, int height, String weight, int age) &#123; this.name = name; this.sex = sex; this.height = height; this.weight = weight; this.age = age; &#125; @Generated(hash = 586692638) public User() &#123; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getSex() &#123; return this.sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public int getHeight() &#123; return this.height; &#125; public void setHeight(int height) &#123; this.height = height; &#125; public String getWeight() &#123; return this.weight; &#125; public void setWeight(String weight) &#123; this.weight = weight; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; &emsp;&emsp;如上，greendao通过注解的方式帮我们自动生成了set/get方法，还有构造方法，这就对了，我们不用关，之后我们再执行如下代码生成数据库和表： 123DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(getApplicationContext(), &quot;haichenyi.db&quot;, null);DaoMaster daoMaster = new DaoMaster(devOpenHelper.getWritableDb());DaoSession daoSession = daoMaster.newSession(); &emsp;&emsp;通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。注意：默认的 DaoMaster.DevOpenHelper会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。升级的问题，我们在后面讲，这里我们先把数据库和表先创建了。 &emsp;&emsp;上面这个方式是java格式的，由于，我昨天写完框架之后，我把项目转成了kotlin代码，所以这里有点不一样，项目我后面会上传。这里我要说明的是（敲黑板）我用kotlin的时候，碰到了一个问题，当我使用greendao的时候，他提示我，无法引入用注解方式生成的类，dagger2也是一样的，我用java代码写就没有问题，我写这篇博客的时候，目前还没有找到解决的办法。 &emsp;&emsp;我用了另外一种方式，采用跟之前网络请求一样的设计模式——装饰者模式。我这里就不多做说明了。我贴出我的代码。 SqlHelper 12345678910111213141516package com.haichenyi.myproject.model.sql;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public interface SqlHelper &#123; void onAdd(); void onDelete(); void onUpdate(); void onSelect();&#125; &emsp;&emsp;这里定义增删改查4个方法，用于测试这4个功能 SqlImpl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.haichenyi.myproject.model.sql;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.model.bean.DaoMaster;import com.haichenyi.myproject.model.bean.DaoSession;import com.haichenyi.myproject.model.bean.UserDao;import com.haichenyi.myproject.utils.ToastUtils;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public class SqlImpl implements SqlHelper &#123; private final UserDao userDao; /** * 初始化Sql Dao. * * @param application &#123;@link MyApplication&#125; */ public SqlImpl(MyApplication application) &#123; SqlOpenHelper helper = new SqlOpenHelper(application, &quot;haichenyi.db&quot;); DaoSession daoSession = new DaoMaster(helper.getWritableDb()).newSession(); userDao = daoSession.getUserDao(); &#125; @Override public void onAdd() &#123; ToastUtils.Companion.showTipMsg(&quot;增加数据&quot;); &#125; @Override public void onDelete() &#123; ToastUtils.Companion.showTipMsg(&quot;删除数据&quot;); &#125; @Override public void onUpdate() &#123; ToastUtils.Companion.showTipMsg(&quot;更新数据&quot;); &#125; @Override public void onSelect() &#123; ToastUtils.Companion.showTipMsg(&quot;查询数据&quot;); &#125;&#125; &emsp;&emsp;功能实现类，看到他的构造方法里面，第二个参数就是我们的数据库名称，后面通过getWritableDb()获取的是可写的数据库，可写就肯定可读。然后就是接口的实现类了，这里就是具体的增删改查功能的实现类，我这里在对应的方法里面就写了Toast，增删改查具体怎么写后面再说 SqlOpenHelper 12345678910111213141516171819202122232425262728293031323334353637package com.haichenyi.myproject.model.sql;import android.content.Context;import com.haichenyi.myproject.model.bean.DaoMaster;import com.haichenyi.myproject.model.bean.UserDao;import org.greenrobot.greendao.database.Database;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public class SqlOpenHelper extends DaoMaster.OpenHelper &#123; public SqlOpenHelper(Context context, String name) &#123; super(context, name); &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123; super.onUpgrade(db, oldVersion, newVersion); MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() &#123; @Override public void onCreateAllTables(Database db, boolean ifNotExists) &#123; DaoMaster.createAllTables(db, ifNotExists); &#125; @Override public void onDropAllTables(Database db, boolean ifExists) &#123; DaoMaster.dropAllTables(db, ifExists); &#125; &#125;, UserDao.class); &#125;&#125; &emsp;&emsp;这个类用于管理数据库的表对应的字段发生变化的时候，数据库需要进行的版本更新，连上下面那个类，都是用于版本数据库版本更新的，防止数据丢失。怎么写呢？看到最后面的&emsp;UserDao.class&emsp;了吗？这个就是我们需要更新的表，你哪个表需要更新，直接写在后面就可以了，这个是可以一次传多个表的，并不是一次只能传一个 MigrationHelper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246package com.haichenyi.myproject.model.sql;import android.database.Cursor;import android.database.SQLException;import android.database.sqlite.SQLiteDatabase;import android.support.annotation.NonNull;import android.text.TextUtils;import android.util.Log;import org.greenrobot.greendao.AbstractDao;import org.greenrobot.greendao.database.Database;import org.greenrobot.greendao.database.StandardDatabase;import org.greenrobot.greendao.internal.DaoConfig;import java.lang.ref.WeakReference;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * Author: 海晨忆. * Date: 2018/2/24 * Desc: */public final class MigrationHelper &#123; public static boolean DEBUG = false; private static String TAG = &quot;MigrationHelper&quot;; private static final String SQLITE_MASTER = &quot;sqlite_master&quot;; private static final String SQLITE_TEMP_MASTER = &quot;sqlite_temp_master&quot;; private static WeakReference&lt;ReCreateAllTableListener&gt; weakListener; public interface ReCreateAllTableListener &#123; void onCreateAllTables(Database db, boolean ifNotExists); void onDropAllTables(Database db, boolean ifExists); &#125; public static void migrate(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; printLog(&quot;【The Old Database Version】&quot; + db.getVersion()); Database database = new StandardDatabase(db); migrate(database, daoClasses); &#125; public static void migrate(SQLiteDatabase db, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; weakListener = new WeakReference&lt;&gt;(listener); migrate(db, daoClasses); &#125; public static void migrate(Database database, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; weakListener = new WeakReference&lt;&gt;(listener); migrate(database, daoClasses); &#125; public static void migrate(Database database, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; printLog(&quot;【Generate temp table】start&quot;); generateTempTables(database, daoClasses); printLog(&quot;【Generate temp table】complete&quot;); ReCreateAllTableListener listener = null; if (weakListener != null) &#123; listener = weakListener.get(); &#125; if (listener != null) &#123; listener.onDropAllTables(database, true); printLog(&quot;【Drop all table by listener】&quot;); listener.onCreateAllTables(database, false); printLog(&quot;【Create all table by listener】&quot;); &#125; else &#123; dropAllTables(database, true, daoClasses); createAllTables(database, false, daoClasses); &#125; printLog(&quot;【Restore data】start&quot;); restoreData(database, daoClasses); printLog(&quot;【Restore data】complete&quot;); &#125; private static void generateTempTables(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; String tempTableName = null; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; if (!isTableExists(db, false, tableName)) &#123; printLog(&quot;【New Table】&quot; + tableName); continue; &#125; try &#123; tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;); StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append(&quot;DROP TABLE IF EXISTS &quot;).append(tempTableName).append(&quot;;&quot;); db.execSQL(dropTableStringBuilder.toString()); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append(&quot;CREATE TEMPORARY TABLE &quot;).append(tempTableName); insertTableStringBuilder.append(&quot; AS SELECT * FROM &quot;).append(tableName).append(&quot;;&quot;); db.execSQL(insertTableStringBuilder.toString()); printLog(&quot;【Table】&quot; + tableName + &quot;\n ---Columns--&gt;&quot; + getColumnsStr(daoConfig)); printLog(&quot;【Generate temp table】&quot; + tempTableName); &#125; catch (SQLException e) &#123; Log.e(TAG, &quot;【Failed to generate temp table】&quot; + tempTableName, e); &#125; &#125; &#125; private static boolean isTableExists(Database db, boolean isTemp, String tableName) &#123; if (db == null || TextUtils.isEmpty(tableName)) &#123; return false; &#125; String dbName = isTemp ? SQLITE_TEMP_MASTER : SQLITE_MASTER; String sql = &quot;SELECT COUNT(*) FROM &quot; + dbName + &quot; WHERE type = ? AND name = ?&quot;; Cursor cursor = null; int count = 0; try &#123; cursor = db.rawQuery(sql, new String[]&#123;&quot;table&quot;, tableName&#125;); if (cursor == null || !cursor.moveToFirst()) &#123; return false; &#125; count = cursor.getInt(0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); &#125; return count &gt; 0; &#125; private static String getColumnsStr(DaoConfig daoConfig) &#123; if (daoConfig == null) &#123; return &quot;no columns&quot;; &#125; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; daoConfig.allColumns.length; i++) &#123; builder.append(daoConfig.allColumns[i]); builder.append(&quot;,&quot;); &#125; if (builder.length() &gt; 0) &#123; builder.deleteCharAt(builder.length() - 1); &#125; return builder.toString(); &#125; private static void dropAllTables(Database db, boolean ifExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; reflectMethod(db, &quot;dropTable&quot;, ifExists, daoClasses); printLog(&quot;【Drop all table by reflect】&quot;); &#125; private static void createAllTables(Database db, boolean ifNotExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; reflectMethod(db, &quot;createTable&quot;, ifNotExists, daoClasses); printLog(&quot;【Create all table by reflect】&quot;); &#125; /** * dao class already define the sql exec method, so just invoke it */ private static void reflectMethod(Database db, String methodName, boolean isExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; if (daoClasses.length &lt; 1) &#123; return; &#125; try &#123; for (Class cls : daoClasses) &#123; Method method = cls.getDeclaredMethod(methodName, Database.class, boolean.class); method.invoke(null, db, isExists); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; private static void restoreData(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; String tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;); if (!isTableExists(db, true, tempTableName)) &#123; continue; &#125; try &#123; // get all columns from tempTable, take careful to use the columns list List&lt;String&gt; columns = getColumns(db, tempTableName); ArrayList&lt;String&gt; properties = new ArrayList&lt;&gt;(columns.size()); for (int j = 0; j &lt; daoConfig.properties.length; j++) &#123; String columnName = daoConfig.properties[j].columnName; if (columns.contains(columnName)) &#123; properties.add(&quot;`&quot; + columnName + &quot;`&quot;); &#125; &#125; if (properties.size() &gt; 0) &#123; final String columnSQL = TextUtils.join(&quot;,&quot;, properties); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append(&quot;REPLACE INTO &quot;).append(tableName).append(&quot; (&quot;); insertTableStringBuilder.append(columnSQL); insertTableStringBuilder.append(&quot;) SELECT &quot;); insertTableStringBuilder.append(columnSQL); insertTableStringBuilder.append(&quot; FROM &quot;).append(tempTableName).append(&quot;;&quot;); db.execSQL(insertTableStringBuilder.toString()); printLog(&quot;【Restore data】 to &quot; + tableName); &#125; StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append(&quot;DROP TABLE &quot;).append(tempTableName); db.execSQL(dropTableStringBuilder.toString()); printLog(&quot;【Drop temp table】&quot; + tempTableName); &#125; catch (SQLException e) &#123; Log.e(TAG, &quot;【Failed to restore data from temp table 】&quot; + tempTableName, e); &#125; &#125; &#125; private static List&lt;String&gt; getColumns(Database db, String tableName) &#123; List&lt;String&gt; columns = null; Cursor cursor = null; try &#123; cursor = db.rawQuery(&quot;SELECT * FROM &quot; + tableName + &quot; limit 0&quot;, null); if (null != cursor &amp;&amp; cursor.getColumnCount() &gt; 0) &#123; columns = Arrays.asList(cursor.getColumnNames()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); if (null == columns) columns = new ArrayList&lt;&gt;(); &#125; return columns; &#125; private static void printLog(String info) &#123; if (DEBUG) &#123; Log.d(TAG, info); &#125; &#125;&#125; &emsp;&emsp;这个类是工具类，拿过去用就好了，还有就是，应用怎么判断是否需要版本更新呢？打开你的app下面的build.grade，在根结点下面添加如下代码： 123greendao &#123; schemaVersion 1&#125; 每当你发布新版本的时候，把这个版本号+1即可。 &emsp;&emsp;当然，我门这里依然是用的dagger生成的全局单例，所以，你还需要在你的AppModule下面添加如下代码： 12345@Provides@SingletonSqlHelper provideSqlHelper() &#123; return new SqlImpl(application);&#125; &emsp;&emsp;记得把项目重新clean一遍，build一遍，重新跑项目的时候，找到你的数据库。data-data-你的应用包名-databases-haichenyi.db，这个就是我们的数据库。找个Sqlite可视化工具打开，你会看到如下结构。 &emsp;&emsp;太多了，不写了，下一篇写增删改查。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（三）—RxJava2.0+Retrofit2.0+OkHttp]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94RxJava2-0-Retrofit2-0-OkHttp%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇，我们把mvp+dagger加进去了，这一篇，我们把网络请求加上 &emsp;&emsp;我这里的网络请求是用的装饰者模式去写的，什么是装饰者模式呢？在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。我的理解就是一个接口，两个实现类，一个实现类负责调用接口的方法，另一个类负责功能的具体实现。本文中所提到的代码都是伪代码，最后会给出完整的，最初版本的项目框架。不包含任何业务逻辑 &emsp;&emsp;容我一个一个来说，首先，我们一般请求网络的时候，会有统一的返回数据格式，一个是需要判断返回code码的，就比方说登录功能，那登录成功，还是失败，我们只用判断code码即可，这种类型，我们统一是HttpNoResult。还有一个是返回数据的，就比方说查一个列表数据。这里我们统一的是HttpResult。我先给出这两个类的代码： 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.model.http;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:没有解析数据的返回 */public class HttpNoResult &#123; private int code; private String msg; public int getCode() &#123; return code; &#125; public HttpNoResult setCode(int code) &#123; this.code = code; return this; &#125; public String getMsg() &#123; return msg; &#125; public HttpNoResult setMsg(String msg) &#123; this.msg = msg; return this; &#125; @Override public String toString() &#123; return &quot;HttpNoResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.haichenyi.myproject.model.http;import com.google.gson.annotations.SerializedName;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:有解析数据的返回 */public class HttpResult&lt;T&gt; &#123; private int code; private String msg; @SerializedName(value = &quot;result&quot;) private T data; public int getCode() &#123; return code; &#125; public HttpResult setCode(int code) &#123; this.code = code; return this; &#125; public String getMsg() &#123; return msg; &#125; public HttpResult setMsg(String msg) &#123; this.msg = msg; return this; &#125; public T getData() &#123; return data; &#125; public HttpResult setData(T data) &#123; this.data = data; return this; &#125; @Override public String toString() &#123; return &quot;HttpResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &quot;, data=&quot; + data + &apos;&#125;&apos;; &#125;&#125; &emsp;&emsp;这里我就需要说一点，有数据返回的时候，每个数据类型都是不一样的，所以，这里我用的泛型传递，不同的数据类型，传不同的bean对象 &emsp;&emsp;言归正传，我们来说说网络请求的一个接口，两个实现类。 一个接口—HttpHelper 1234567891011121314151617181920package com.haichenyi.myproject.model.http;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络接口，接口参数Token统一处理，方法中不传Token */public interface HttpHelper &#123; /** * 登录时获取验证码. * * @param phone 手机号 * @return &#123;&quot;code&quot;:0&#125; */ Flowable&lt;HttpNoResult&gt; loginCode(String phone); /*Flowable&lt;HttpResult&lt;Login&gt;&gt; login(String phone, String code); Flowable&lt;HttpResult&lt;List&lt;DiyBean&gt;&gt;&gt; diyKeys(String allId);*/&#125; &emsp;&emsp;Flowable是RxJava2.0新增的，所以说RxJava完美兼容Retrofit，泛型就是我们需要解析的数据 loginCode方法是说返回数据，我们只用判断是否是成功还是失败， login方法是说返回数据是一个Login对象，至于对象是什么内容，那就是和你们后台确认了 diyKeys方法就是说，返回数据是一个list对象，每个list的item是DiyBean对象 123456789101112131415161718192021222324package com.haichenyi.myproject.model;import com.haichenyi.myproject.model.http.HttpHelper;import com.haichenyi.myproject.model.http.HttpNoResult;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求的实现类 */public class DataHelper implements HttpHelper &#123; private HttpHelper http; public DataHelper(HttpHelper http) &#123; this.http = http; &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return http.loginCode(phone); &#125;&#125; &emsp;&emsp;DataHelper是HttpHelper的实现类，他的唯一作用就是调用接口的方法即可，具体的功能实现是后面一个类，这里需要说明的是这个类的构造方法要public表示，因为他要dagger生成，用private或者protected表示无法生成。 123456789101112131415161718192021222324package com.haichenyi.myproject.model.http;import com.haichenyi.myproject.model.http.api.HttpApi;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: 网络接口Retrofit实现 */public class RetrofitHelper implements HttpHelper&#123; private HttpApi httpApi; @Inject RetrofitHelper(HttpApi httpApi) &#123; this.httpApi = httpApi; &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return httpApi.loginCode(phone); &#125;&#125; &emsp;&emsp;RetrofitHelper类作为HttpHelper接口的实现类，他是具体功能的实现类，为什么说他是具体功能的实现类呢？因为，他是调用HttpApi接口的方法。HttpApi接口是干什么用的呢？ 1234567891011121314151617181920212223242526package com.haichenyi.myproject.model.http.api;import com.haichenyi.myproject.model.http.HttpNoResult;import com.haichenyi.myproject.model.http.ProtocolHttp;import io.reactivex.Flowable;import retrofit2.http.Field;import retrofit2.http.FormUrlEncoded;import retrofit2.http.POST;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求接口api */public interface HttpApi &#123; /** * 登录时获取验证码. * * @param phone 手机号 * @return &#123;&quot;code&quot;:0&#125; */ @FormUrlEncoded @POST(ProtocolHttp.METHOD_LOGIN_CODE) Flowable&lt;HttpNoResult&gt; loginCode(@Field(&quot;phone&quot;) String phone);&#125; 这个就是Retrofit的网络请求的方式，看不懂？这个就是Retrofit的东西了方法注解，包含@GET、@POST、@PUT、@DELETE、@PATH、@HEAD、@OPTIONS、@HTTP。标记注解，包含@FormUrlEncoded、@Multipart、@Streaming。参数注解，包含@Query、@QueryMap、@Body、@Field，@FieldMap、@Part，@PartMap。其他注解，包含@Path、@Header、@Headers、@Url。 这里我们还差一个接口 123456789101112package com.haichenyi.myproject.model.http;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface ProtocolHttp &#123; String HTTP_HOST = &quot;http://xxx.xx.xxx.xxx:8080/app/con/&quot;; String HTTP_COMMON = &quot;common/&quot;; String METHOD_LOGIN_CODE = HTTP_COMMON + &quot;code&quot;;//登录发送验证码&#125; &emsp;&emsp;如上，这里需要注意的是不能以”\”结尾，然后就是，跟你们后台商量，格式不要错了，尽量就只有接口名字不同，接口名字前面部分都是一样的。 &emsp;&emsp;到此，这里基本上就说完了，那么有同鞋就会问了，接口定义方法的时候，我们知道该如何写返回数据类型呢？这个我就不知道了，你得问你们后台，根据后台返回的数据类型去写对应的bean类。推荐一个功能PostMan。 &emsp;&emsp;到目前为止，我们都还没有初始化网络请求的参数，这些网络请求的参数在哪里初始化呢？这些参数，我们就只用初始化一次，我们就想到了dagger的全局单例模式，没错，就是这个，我们上一篇写了很多没有用的东西，里面有一个HttpModule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.di.qualifier.ApiUrl;import com.haichenyi.myproject.model.http.ProtocolHttp;import com.haichenyi.myproject.model.http.api.HttpApi;import java.util.concurrent.TimeUnit;import javax.inject.Singleton;import dagger.Module;import dagger.Provides;import okhttp3.OkHttpClient;import retrofit2.Retrofit;import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;import retrofit2.converter.gson.GsonConverterFactory;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求的参数初始化 */@Modulepublic class HttpModule &#123; @Provides @Singleton OkHttpClient.Builder providesOkHttpHelper() &#123;//请求读写超时时间 return new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .readTimeout(10, TimeUnit.SECONDS) .writeTimeout(10, TimeUnit.SECONDS); &#125; @Provides @Singleton OkHttpClient provideClient(OkHttpClient.Builder builder) &#123; return builder// .addInterceptor(new MyHttpInterceptor()) .build(); &#125; @Provides @Singleton Retrofit.Builder providesRetrofitBuilder() &#123; return new Retrofit.Builder(); &#125; @Provides @Singleton HttpApi provideApi(@ApiUrl Retrofit retrofit) &#123; return retrofit.create(HttpApi.class); &#125; @Provides @Singleton @ApiUrl Retrofit providesApiRetrofit(Retrofit.Builder builder, OkHttpClient client) &#123; return createRetrofit(builder, client, ProtocolHttp.HTTP_HOST);//这里就是你的网络请求的url &#125; private Retrofit createRetrofit(Retrofit.Builder builder, OkHttpClient client, String host) &#123; return builder.client(client) .baseUrl(host) .addConverterFactory(GsonConverterFactory.create())//添加gson自动解析，我们不用关 .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); &#125;&#125; 如上代码，注释写的都有，考过去用就行了 在AppModule里面添加如下代码 12345678910111213141516171819202122232425262728293031323334353637package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.model.DataHelper;import com.haichenyi.myproject.model.http.HttpHelper;import com.haichenyi.myproject.model.http.RetrofitHelper;import javax.inject.Singleton;import dagger.Module;import dagger.Provides;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class AppModule &#123; private MyApplication application; public AppModule(MyApplication application) &#123; this.application = application; &#125; @Provides @Singleton DataHelper provideDataHelper(HttpHelper httpHelper) &#123; return new DataHelper(httpHelper); &#125; @Provides @Singleton HttpHelper provideHttpHelper(RetrofitHelper retrofitHelper) &#123; return retrofitHelper; &#125;&#125; 这里都是dagger了生成全局单例对象需要的东西 在AppComponent里面添加如下代码 1234567891011121314151617181920package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.di.module.AppModule;import com.haichenyi.myproject.di.module.HttpModule;import com.haichenyi.myproject.model.DataHelper;import javax.inject.Singleton;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Singleton@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)public interface AppComponent &#123; DataHelper getDataHelper();&#125; 在BaseMvpPresenter里面添加如下代码 123456789101112131415161718192021222324252627282930313233343536373839package com.haichenyi.myproject.base;import io.reactivex.disposables.CompositeDisposable;import io.reactivex.disposables.Disposable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123; protected T baseView; private CompositeDisposable disposables; @Override public void attachView(T baseView) &#123; this.baseView = baseView; &#125; protected void addSubscribe(Disposable disposable) &#123; if (null == disposables) &#123; disposables = new CompositeDisposable(); &#125; disposables.add(disposable); &#125; @Override public void detachView() &#123; this.baseView = null; unSubscribe(); &#125; private void unSubscribe() &#123; if (null != disposables) &#123; disposables.clear(); disposables = null; &#125; &#125;&#125; 至此，就全部写完了，关于网络请求的内容。调用方式如下： 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.model.DataHelper;import javax.inject.Inject;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; private DataHelper dataHelper; @Inject MainPresenter() &#123; dataHelper = MyApplication.getAppComponent().getDataHelper(); &#125; @Override public void loadData() &#123; addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe());// baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; 记得在清单文件里面，加上网络权限 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 网络请求，这样调用之后在哪处理呢？我给出我的几个处理的工具类。首先，按如下图设置1.8支持lambda表达式 然后添加如下几个类 HttpCode 123456789101112131415161718192021package com.haichenyi.myproject.model.http;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 网络请求状态码 */public interface HttpCode &#123; /** * 成功. */ int SUCCESS = 0; /** * 参数为空. */ int NO_PARAMETER = 1; /** * 服务器错误. */ int SERVER_ERR = 3;&#125; ApiException 1234567891011121314151617181920212223242526272829package com.haichenyi.myproject.model.http;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 接口异常判断处理 */public class ApiException extends Exception &#123; private int code; @SuppressWarnings(&quot;unused&quot;) public ApiException(int code) &#123; this.code = code; &#125; public ApiException(int code, String message) &#123; super(message); this.code = code; &#125; public int getCode() &#123; return code; &#125; public ApiException setCode(int code) &#123; this.code = code; return this; &#125;&#125; MyRxUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.haichenyi.myproject.model.http;import io.reactivex.BackpressureStrategy;import io.reactivex.Flowable;import io.reactivex.FlowableTransformer;import io.reactivex.Scheduler;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆. * Date: 2017/12/27 * Desc:切换线程的工具类 */public class MyRxUtils &#123; /** * 从其他线程转到主线程. * * @param scheduler Schedulers.io()等等 * @param &lt;T&gt; t * @return FlowableTransformer */ public static &lt;T&gt; FlowableTransformer&lt;T, T&gt; toMain(Scheduler scheduler) &#123; return upstream -&gt; upstream.subscribeOn(scheduler).observeOn(AndroidSchedulers.mainThread()); &#125; public static &lt;T&gt; FlowableTransformer&lt;HttpResult&lt;T&gt;, T&gt; handResult() &#123; return upstream -&gt; upstream.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .flatMap(tHttpResult -&gt; &#123; if (tHttpResult.getCode() == HttpCode.SUCCESS) &#123; return /*createData(tHttpResult.data)*/Flowable.just(tHttpResult.getData()); &#125; else &#123; return Flowable.error(new ApiException(tHttpResult.getCode(), tHttpResult.getMsg())); &#125; &#125;); &#125; private static &lt;T&gt; Flowable&lt;T&gt; createData(final T data) &#123; return Flowable.create(e -&gt; &#123; e.onNext(data); e.onComplete(); &#125;, BackpressureStrategy.ERROR); &#125;&#125; MySubscriber 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.haichenyi.myproject.model.http;import com.haichenyi.myproject.base.BaseView;import io.reactivex.subscribers.ResourceSubscriber;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123; private BaseView baseView; private boolean showLoading; public MySubscriber(BaseView baseView) &#123; this.baseView = baseView; &#125; public MySubscriber(BaseView baseView, boolean showLoading) &#123; this.baseView = baseView; this.showLoading = showLoading; &#125; @Override protected void onStart() &#123; super.onStart(); if (null != baseView &amp;&amp; showLoading) &#123; baseView.showLoading(); &#125; &#125; @Override public void onError(Throwable t) &#123; if (null == baseView) &#123; return; &#125; baseView.hideLoading(); if (t instanceof ApiException) &#123; ApiException apiException = (ApiException) t; switch (apiException.getCode()) &#123; case HttpCode.NO_PARAMETER: baseView.showTipMsg(&quot;参数为空&quot;); break; case HttpCode.SERVER_ERR: baseView.showTipMsg(&quot;服务器错误&quot;); break; default: break; &#125; &#125; &#125; @Override public void onComplete() &#123; if (null != baseView) &#123; baseView.hideLoading(); &#125; &#125;&#125; 这几个类不想多做解释，结合注释，仔细看几遍，就知道是干嘛用的了 加上这几个之后调用方式就变成了以下的方式： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.model.DataHelper;import com.haichenyi.myproject.model.http.HttpNoResult;import com.haichenyi.myproject.model.http.MyRxUtils;import com.haichenyi.myproject.model.http.MySubscriber;import javax.inject.Inject;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; private DataHelper dataHelper; @Inject MainPresenter() &#123; dataHelper = MyApplication.getAppComponent().getDataHelper(); &#125; @Override public void loadData() &#123; addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;) .compose(MyRxUtils.toMain(Schedulers.io())) .subscribeWith(new MySubscriber&lt;HttpNoResult&gt;(baseView, true) &#123; @Override public void onNext(HttpNoResult httpNoResult) &#123; &#125; &#125;));// baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; 完了，完了，终于写完了。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（二）—MVP+dagger2]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94MVP-dagger2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;接着上一篇简单的框架，没有看过的同鞋可以去喵一眼。上一篇我们搭好了简单的框架，初始化一次的内容丢在Application里面，所有的activity继承一个类BaseActivity，还有Fragment继承的一个类BaseFragment &emsp;&emsp;现在我们来加上MVP，不懂MVP的同鞋可以看一下，我前面写过的三种主流框架的对比。我们先导入dagger2的两个包，代码如下： 12implementation &apos;com.google.dagger:dagger:2.14.1&apos;annotationProcessor &quot;com.google.dagger:dagger-compiler:2.14.1&quot; 第一步&emsp;&emsp;新建BasePresenter接口，BaseMvpPresenter类去实现BasePresenter接口，代码如下 123456789101112package com.shfzwkeji.smartwardrobe.base;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 不带mvp的presenter的基类 */public interface BasePresenter&lt;T extends BaseView&gt; &#123; void attachView(T baseView); void detachView();&#125; 1234567891011121314151617181920package com.haichenyi.myproject.base;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:带mvp的presenter的基类 */public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123; protected T baseView; @Override public void attachView(T baseView) &#123; this.baseView = baseView; &#125; @Override public void detachView() &#123; this.baseView = null; &#125;&#125; &emsp;&emsp;这里就只有两个方法，一个是绑定view，还有一个是在ondestory方法里面解除绑定的方法，用来保证P层的生命周期和V层同步，避免了，当V层销毁的时候，P层仍然存在造成的内存泄漏。 第二步&emsp;&emsp;新建BaseMvpActivity 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.base;import javax.inject.Inject;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:带MVP的Activity */public abstract class BaseMvpActivity&lt;T extends BasePresenter&gt; extends BaseActivity&#123; @Inject protected T basePresenter; @Override @SuppressWarnings(&quot;unchecked&quot;) protected void initView() &#123; super.initView(); initInject(); if (null != basePresenter) &#123; basePresenter.attachView(this); &#125; &#125; protected abstract void initInject(); @Override protected void onDestroy() &#123; if (null != basePresenter) &#123; basePresenter.detachView(); basePresenter = null; &#125; super.onDestroy(); &#125;&#125; &emsp;&emsp;运用dagger2注解的方式，生成P层，这里我们在用P层之前得先生成P层，所以initject方法一定要在basePresenter用之前调用，因为他就是生成P层的代码。 &emsp;&emsp;怎么生成呢？dagger我们一般都命名成di层，所以，我们先创建di层的package，项目结构图如下： &emsp;&emsp;这里给出的是mvp+dagger加入之后的项目结构。我们重点看选中的di层，里面有4个package分别是component，module，qualifier，scope四个包，至于他们的作用分别是什么，请自行百度，google，dagger的用法。我这里先贴出这几个类，接口的代码： ActivityComponent 123456789101112131415161718package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.MainActivity;import com.haichenyi.myproject.di.module.ActivityModule;import com.haichenyi.myproject.di.scope.ActivityScope;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@ActivityScope@Component(dependencies = AppComponent.class, modules = ActivityModule.class)public interface ActivityComponent &#123; void inject(MainActivity mainActivity);&#125; AppComponent 123456789101112131415161718package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.di.module.AppModule;import com.haichenyi.myproject.di.module.HttpModule;import javax.inject.Singleton;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Singleton@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)public interface AppComponent &#123;&#125; ActivityModule 123456789101112package com.haichenyi.myproject.di.module;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class ActivityModule &#123;&#125; AppModule 12345678910111213141516171819package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.base.MyApplication;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class AppModule &#123; private MyApplication application; public AppModule(MyApplication application) &#123; this.application = application; &#125;&#125; HttpModule 123456789101112package com.haichenyi.myproject.di.module;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class HttpModule &#123;&#125; ActivityScope 12345678910111213141516package com.haichenyi.myproject.di.scope;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import javax.inject.Scope;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Scope@Retention(RetentionPolicy.RUNTIME)public @interface ActivityScope &#123;&#125; &emsp;&emsp;这几个类，接口里面基本上都没有内容，因为这几个类都是后面才会用的到的，这里我直接贴出来，说起来方便一些。还需要加两个方法，在MyApplication里面加如下方法: 1234567891011121314/** * 获取AppComponent. * * @return AppComponent */ public static synchronized AppComponent getAppComponent() &#123; if (null == appComponent) &#123; appComponent = DaggerAppComponent.builder() .appModule(new AppModule(getInstance())) .httpModule(new HttpModule()) .build(); &#125; return appComponent; &#125; 在BaseActivity里面加如下方法： 123456protected ActivityComponent getActivityComponent() &#123; return DaggerActivityComponent.builder() .appComponent(MyApplication.getAppComponent()) .activityModule(new ActivityModule()) .build(); &#125; &emsp;&emsp;加完这两个方法之后，肯定会有错误提示，重新编译一遍项目就可以了，如果重新编译一遍，还是不行，请重新对比一下，哪里不一样。 第三步&emsp;&emsp;就是关于mvp的了，从上面图应该看到了，有一个presenter包，和contract包，我们之前有一篇博客讲过，MVP就是多了很多个接口，这些接口写在哪呢？就在contract层 MainContract 代码如下： 123456789101112131415161718package com.haichenyi.myproject.contract;import com.haichenyi.myproject.base.BasePresenter;import com.haichenyi.myproject.base.BaseView;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface MainContract &#123; interface IView extends BaseView&#123; &#125; interface Presenter extends BasePresenter&lt;IView&gt;&#123; void loadData(); &#125;&#125; &emsp;&emsp;这里我需要说明的就是Presenter接口继承的是IVew，不是BaseView，页面变化的方法都是在IView接口里面定义，逻辑处理，网络请求方法都是在Presenter接口里面定义 MainPresenter 代码如下 1234567891011121314151617181920212223package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.contract.MainContract;import javax.inject.Inject;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; @Inject MainPresenter() &#123; &#125; @Override public void loadData() &#123; baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; &emsp;&emsp;这里我需要说明的是注意继承BaseMvpPresenter传的是MainContract.IView，不是BaseView，实现MainContract.Presenter接口，还有一点就是注意构造方法，上面有注解，这里的loadData里面应该是我们的网络请求逻辑，这里我放到后面一篇在说，这里我先就直接Toast，表示走了这个方法 第四步&emsp;&emsp;就是MainActivity，这里我贴出代码 123456789101112131415161718192021222324252627package com.haichenyi.myproject;import android.os.Bundle;import com.haichenyi.myproject.base.BaseMvpActivity;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.presenter.MainPresenter;public class MainActivity extends BaseMvpActivity&lt;MainPresenter&gt; implements MainContract.IView &#123; @Override protected int getLayoutId(Bundle savedInstanceState) &#123; return R.layout.activity_main; &#125; @Override protected void initData() &#123; super.initData(); initToolbar(true, false, true).setMyTitle(&quot;主页&quot;).setMoreTitle(&quot;更多&quot;); basePresenter.loadData(); &#125; @Override protected void initInject() &#123; getActivityComponent().inject(this); &#125;&#125; &emsp;&emsp;这里我需要说明的是继承BaseMvpActivity，泛型直接传MainPresenter，然后，实现MainContract.IView接口，直接用basePresenter调用方法，需要实现initInject方法，只要是是继承BaseMvpActivity的activity，都需要在ActivityComponent()里面注册一边。比方说，LoginActivity也是继承的BaseMvpActivity，辣么，在di层的component包下面的ActivityComponent接口里面定义一个方法 1void inject(LoginActivity loginActivity); 在LoginActivity的initInject方法里面写同样的代码 1getActivityComponent().inject(this); 就像这样写就可以了。 总结&emsp;&emsp;写到这里，mvp+dagger2基本上完成了，MVP的目的就是解藕，把业务逻辑，网络请求丢在P层，页面不发生变化，就只用改P层逻辑，从而达到了解藕的目的。dagger2简化了代码，并且，它有着全局单例模式，和局部单例模式，优化了我们的内存，减少了内存浪费。不用每次都去new一个P层对象出来。下一篇，我们就把网络请求加上 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（一）—简单的框架]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[目的&emsp;&emsp;首先先说出，最终的目的是现在主流的MVP+RxJava+Retrofit+OkHttp框架。让大家心里有底 &emsp;&emsp;开发工具Android Studio3.0，还在用eclipse的同鞋，强烈推荐你跨出这一步，你会发现一个新的世界。android studio都出来这么久了，你还在远古时代做开发，说句不好听的，你完全与时代脱轨，你不适合做开发（纯属个人观点） &emsp;&emsp;本篇就只有三部分，第一部分就是新建一个Application，第二部分就是BaseActivity，第三部分就是BaseFragment Application&emsp;&emsp;首先你得有application类，去初始化应用只用初始化一次的内容，继承Application，然后在清单文件里面注册。 123456789101112131415161718192021222324252627282930313233343536373839package com.haichenyi.myproject;import android.app.Application;import com.squareup.leakcanary.LeakCanary;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MyApplication extends Application &#123; private static MyApplication instance; public MyApplication getInstance() &#123; return instance; &#125; private void setInstance(MyApplication instance) &#123; MyApplication.instance = instance; &#125; @Override public void onCreate() &#123; super.onCreate(); setInstance(this); initLeakCanary(); &#125; /** * 初始化内存检测工具 */ private void initLeakCanary() &#123; if (LeakCanary.isInAnalyzerProcess(this)) &#123; return; &#125; LeakCanary.install(this); &#125;&#125; &emsp;&emsp;如上代码，我这里就初始化了一个全局application单例对象，还初始化square公司出品的一个内存检测工具，用于检测你项目中内存泄漏情况。便于你优化项目。 &emsp;&emsp;如上图所示，这个就是清单文件，在application结点下面，添加name标签，内容就是你创建的application的名字。这里你还需要添加两个内存检测的依赖。 &emsp;&emsp;如上图所示，首先把你的项目结构视图切换到Project，打开你的app目录下的build.gradle文件，在dependencies结点下面（只要是添加开源库都是在该结点下面，后面就不说了），添加如下两行代码： 12releaseImplementation &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos; &emsp;&emsp;最后的1.5.4是版本号，你可以在github上面搜索leakcanary，找最新的版本 BaseActivity&emsp;&emsp;创建基类BaseActivity，也就是所有Activity的父类。还有一个基类的接口BaseView，BaseActivity继承刚才添加的依赖的SupportActivity类，实现BaseView接口，并且实现点击事件的接口（选择实现，你要是不乐意在基类里面写，你可以在你自己的子类里面重新实现一遍也是可以的）。代码如下：每个方法注释写的很清楚，就不用一一解释了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.haichenyi.myproject.base;import android.app.AlertDialog;import android.graphics.Color;import android.graphics.drawable.ColorDrawable;import android.os.Bundle;import android.support.annotation.Nullable;import android.view.Window;import android.widget.ProgressBar;import com.haichenyi.myproject.utils.ToastUtils;import me.yokeyword.fragmentation.SupportActivity;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public abstract class BaseActivity extends SupportActivity implements BaseView &#123; private AlertDialog loadingDialog; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; /** * Toast 提示用户 * @param msg 提示内容String */ @Override public void showTipMsg(String msg) &#123; ToastUtils.showTipMsg(msg); &#125; /** * Toast 提示用户 * @param msg 提示内容res目录下面的String的int值 */ @Override public void showTipMsg(int msg) &#123; ToastUtils.showTipMsg(msg); &#125; /** * 网络请求的时候显示正在加载的对话框 */ @Override public void showLoading() &#123; if (null == loadingDialog) &#123; loadingDialog = new AlertDialog.Builder(this).setView(new ProgressBar(this)).create(); loadingDialog.setCanceledOnTouchOutside(false); Window window = loadingDialog.getWindow(); if (null != window) &#123; window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); &#125; &#125; if (!loadingDialog.isShowing()) &#123; loadingDialog.show(); &#125; &#125; /** * 网络请求完成时隐藏加载对话框 */ @Override public void hideLoading() &#123; if (null != loadingDialog) &#123; if (loadingDialog.isShowing()) &#123; loadingDialog.dismiss(); &#125; loadingDialog = null; &#125; &#125; @Override public void invalidToken() &#123; //用于检测你当前用户的token是否有效，无效就返回登录界面，具体的业务逻辑你自己实现 //如果需要做到实时检测，推荐用socket长连接，每隔10秒发送一个验证当前登录用户token是否过期的请求 &#125; /** * Finish当前页面，最好实现onBackPressedSupport()，这个方法会有一个退栈操作， * 开源框架实现的，我们不用管 */ @Override public void myFinish() &#123; onBackPressedSupport(); &#125; @Override public void onBackPressedSupport() &#123; super.onBackPressedSupport(); &#125;&#125; &emsp;&emsp;上面是目前BaseActivity代码，注释写的很清楚，你会发现BaseView你并没有，下面我给出BaseView的代码 12345678910111213141516171819202122package com.haichenyi.myproject.base;import android.support.annotation.StringRes;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface BaseView &#123; void showTipMsg(String msg); void showTipMsg(@StringRes int msg); void showLoading(); void hideLoading(); void invalidToken(); void myFinish();&#125; &emsp;&emsp;BaseView就是一个接口，是所有V层的基类，代码很简单，Toast方法，显示隐藏加载的对话框方法，检验token是否过期的方法，finish当前页面的方法。什么？Toast方法你没有，下面我贴出来我的Toast的工具类 1234567891011121314151617181920212223242526272829303132333435/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 实时更新的Toast工具类 */public final class ToastUtils &#123; private static Toast toast; private ToastUtils() &#123; throw new RuntimeException(&quot;工具类不允许创建对象&quot;); &#125; @SuppressWarnings(&quot;all&quot;) private static void init() &#123; if (toast == null) &#123; toast = Toast.makeText(MyApplication.getInstance(), &quot;&quot;, Toast.LENGTH_SHORT); &#125; &#125; public static void showTipMsg(String msg) &#123; if (null == toast) &#123; init(); &#125; toast.setText(msg); toast.show(); &#125; public static void showTipMsg(@StringRes int msg) &#123; if (null == toast) &#123; init(); &#125; toast.setText(msg); toast.show(); &#125;&#125; &emsp;&emsp;上面我贴出了三个类，这里我要说明的是，我又创建了两个package，一个是base，一个是utils，我把BaseActivity,BaseView,MyApplication放在base包下面，Toast的工具类放在utils包下面 &emsp;&emsp;再就是添加一些常用的东西了，这里我没有用黄油刀，用过一段时间之后，感觉他的每个控件都是全局的，有点占内存，就放弃了。我下面贴出BaseActivity新增的伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 保存当前activity对象，在OnCreate里面添加，记得在OnDestroy里面移除 * 有什么用呢？ * 比方说有一个需求，让你在任意位置弹出对话框，弹对话框又需要一个context对象，这个时候， * 你就只用传当前list的最上层的activity对象就可以了 * 当然还有其他需求 */ public static List&lt;BaseActivity&gt; activities = new ArrayList&lt;&gt;(); private Toolbar toolbar; private TextView tvToolbarTitle; private TextView tvToolbarRight; private TextView tvBack; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); activities.add(this); //强制竖屏(不强制加) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); int layoutId = getLayoutId(savedInstanceState); View inflate = getLayoutInflater().inflate(R.layout.activity_base, toolbar, false); LinearLayout rootLinearLayout = inflate.findViewById(R.id.ll_layout_base_activity); //没有布局的时候传0 if (0 == layoutId) &#123; setContentView(rootLinearLayout); &#125; else &#123; View rootView = getLayoutInflater().inflate(layoutId, rootLinearLayout, true); setContentView(rootView); &#125; stateBar(); initView(); initData(); setOnClick(R.id.tv_back_base_activity); &#125; /** * 设置点击事件. * * @param ids 被点击View的ID * @return &#123;@link BaseActivity&#125; */ public BaseActivity setOnClick(@IdRes int... ids) &#123; View view; for (int id : ids) &#123; view = findViewById(id); if (null != view) &#123; view.setOnClickListener(this); &#125; &#125; return this; &#125; /** * 设置点击事件. * * @param views 被点击View * @return &#123;@link BaseActivity&#125; */ public BaseActivity setOnClick(View... views) &#123; for (View view : views) &#123; view.setOnClickListener(this); &#125; return this; &#125; /** * 获取当前布局对象 * * @param savedInstanceState 这个是当前activity保存的数据，最常见的就是横竖屏切换的时候， * 数据丢失问题 * @return 当前布局的int值 */ protected abstract int getLayoutId(Bundle savedInstanceState); @Override protected void onDestroy() &#123; activities.remove(this); super.onDestroy(); &#125; protected void initData() &#123; &#125; protected void initView() &#123; toolbar = findViewById(R.id.toolbar_base_activity); tvToolbarTitle = findViewById(R.id.tv_title_base_activity); tvToolbarRight = findViewById(R.id.tv_right_base_activity); &#125; /** * 设置状态栏背景颜色，不能改变状态栏内容的颜色 */ private void stateBar() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; SystemBarTintManager tintManager = new SystemBarTintManager(this); tintManager.setStatusBarTintEnabled(true); tintManager.setNavigationBarTintEnabled(true); tintManager.setTintColor(Color.parseColor(&quot;#000000&quot;)); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.tv_back_base_activity: onBackPressedSupport(); break; default: break; &#125; &#125; &emsp;&emsp;这里我需要说明的是，新增了一个开源框架，就是设置状态栏背景颜色的systembartint。 1implementation &apos;com.readystatesoftware.systembartint:systembartint:1.0.3&apos; &emsp;&emsp;再就是设置activity标题内容，左边，右边的内容，左边右边可能是文字，也可能是图片。所以，我在用的时候，都是用的TextView，ImageView，不能设置文字。方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public BaseActivity setTitles(CharSequence title) &#123; tvToolbarTitle.setText(title); return this; &#125; /** * 初始化toolbar的内容 * @param isShowToolbar 是否显示toolbar * @param isShowBack 是否显示左边的TextView * @param isShowMore 是否显示右边的TextView * @return 当前activity对象，可以连点 */ protected BaseActivity initToolbar(boolean isShowToolbar, boolean isShowBack, boolean isShowMore) &#123; setSupportActionBar(toolbar); ActionBar actionBar = getSupportActionBar(); if (null != actionBar) &#123; if (isShowToolbar) &#123; actionBar.show(); tvBack = findViewById(R.id.tv_back_base_activity); TextView textView = findViewById(R.id.tv_right_base_activity); if (null != tvBack &amp;&amp; null != textView) &#123; tvBack.setVisibility(isShowBack ? View.VISIBLE : View.INVISIBLE); textView.setVisibility(isShowMore ? View.VISIBLE : View.INVISIBLE); &#125; &#125; else &#123; actionBar.hide(); &#125; &#125; return this; &#125; public BaseActivity setToolbarBack(int colorId) &#123; toolbar.setBackgroundColor(getResources().getColor(colorId)); return this; &#125; @SuppressWarnings(&quot;unused&quot;) public BaseActivity setMyTitle(String title) &#123; tvToolbarTitle.setText(title); return this; &#125; public BaseActivity setMyTitle(@StringRes int stringId) &#123; tvToolbarTitle.setText(stringId); return this; &#125; public void setMoreTitle(String moreTitle) &#123; tvToolbarRight.setText(moreTitle); &#125; public BaseActivity setMoreTitle(@StringRes int stringId) &#123; tvToolbarRight.setText(stringId); return this; &#125; /** * 设置左边内容. * * @param leftTitle 内容 * @return &#123;@link BaseActivity&#125; */ public BaseActivity setLeftTitle(String leftTitle) &#123; if (tvBack != null) &#123; tvBack.setBackground(null); tvBack.setText(leftTitle); &#125; return this; &#125; /** * 设置左边内容. * * @param leftTitle 内容 */ public void setLeftTitle(@StringRes int leftTitle) &#123; if (tvBack != null) &#123; tvBack.setBackground(null); tvBack.setText(leftTitle); &#125; &#125; @SuppressWarnings(&quot;unused&quot;) protected BaseActivity setMoreBackground(int resId) &#123; tvToolbarRight.setBackgroundResource(resId); return this; &#125; &emsp;&emsp;可以看到上面的方法返回值都是BaseActivity，这样做的目的就只有一个，可以连点，写一个方法之后，可以接着点写下一个方法，不用写一个方法就要加分号，就换一行写下一个方法。 &emsp;&emsp;还要加一句，在你的app主题里面添加两个item，也就是你的res目录下面的style： 12&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &emsp;&emsp;我这里贴出我目前的style的图片 &emsp;&emsp;下面有一个LineHorizontal样式，就是你toolbar下面的那个横线 BaseFragment&emsp;&emsp;BaseFragment跟BaseActivity的逻辑是差不多的，我这里就贴出代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package com.haichenyi.myproject.base;import android.os.Bundle;import android.support.annotation.IdRes;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.haichenyi.myproject.utils.ToastUtils;import me.yokeyword.fragmentation.SupportFragment;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public abstract class BaseFragment extends SupportFragment implements BaseView, View.OnClickListener &#123; protected boolean isInit; private View rootView; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; int layoutRes = layoutRes(); if (0 != layoutRes) &#123; return inflater.inflate(layoutRes, null); &#125; else &#123; return super.onCreateView(inflater, container, savedInstanceState); &#125; &#125; @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); rootView = view; &#125; @Override public void onLazyInitView(@Nullable Bundle savedInstanceState) &#123; super.onLazyInitView(savedInstanceState); isInit = true; init(); &#125; protected &lt;T extends View&gt; T findViewById(@IdRes int id) &#123; return rootView.findViewById(id); &#125; /** * 设置点击事件. * * @param ids 被点击View的ID * @return &#123;@link BaseFragment&#125; */ public BaseFragment setOnClick(@IdRes int... ids) &#123; for (int id : ids) &#123; rootView.findViewById(id).setOnClickListener(this); &#125; return this; &#125; /** * 设置点击事件. * * @param views 被点击View的ID * @return &#123;@link BaseFragment&#125; */ public BaseFragment setOnClick(View... views) &#123; for (View view : views) &#123; view.setOnClickListener(this); &#125; return this; &#125; protected abstract void init(); @Override public void onDestroy() &#123; rootView = null; super.onDestroy(); &#125; protected abstract int layoutRes(); @Override public void showTipMsg(String msg) &#123; ToastUtils.showTipMsg(msg); &#125; @Override public void showTipMsg(int msg) &#123; ToastUtils.showTipMsg(msg); &#125; @Override public void showLoading() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.showLoading(); &#125;*/ &#125; @Override public void hideLoading() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.hideLoading(); &#125;*/ &#125; @Override public void invalidToken() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.invalidToken(); &#125;*/ &#125; @Override public void onClick(View v) &#123; &#125; @Override public void myFinish() &#123; onBackPressedSupport(); &#125;&#125; &emsp;&emsp;两者在布局抽象方法里面有一点区别，Activity的传了Boundle参数，Fragment没有传，因为Fragment可以通过getArguments()方法获取到这个对象，而Activity不能获取到。 总结&emsp;&emsp;到此，一个简单的项目框架就出来了，目前还是框架的第一步，是一个雏形，还不包括MVP，dagger等等，下一篇就加上MVP，我这个人有个好习惯，就是喜欢写注释，我注释写的很清楚，是干什么用的，我也衷心的希望，你能写好注释。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVC、MVP、MVVM比较]]></title>
    <url>%2F2018%2F02%2F22%2FMVC%E3%80%81MVP%E3%80%81MVVM%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[Android框架的最终目的，也是体现一个项目好坏的唯一标准——高类聚，低耦合 MVC&emsp;&emsp;我们刚接触android写代码的时候基本上都是MVC架构。什么是MVC架构呢？ &emsp;&emsp;MVC：Model View Controller的简称。流程图如下： &emsp;&emsp;当用户发出事件的时候，首先通过V层，通知C层，然后C层通知Model层数据发生了变化，更新数据，M层直接显示数据到V层。 &emsp;&emsp;通俗的讲，xml可以理解层View层，你封装的网络请求的帮助类理解成model层，activity，fragment理解成Controller层。这么理解是可以的，但是，你不能说xml就是view层，这样说是不对的 &emsp;&emsp;举个例子，比方说一个登录的网络请求，首先，你需要点击按钮去触发网络请求的方法，你点击的这个button就是写在xml布局里面的，这就是V层。然后触发的网络请求帮助类去发送对应的登录请求方法，这就是model层。两者是怎么联系在一起的呢？就是我们在activity，fragment层里面写的onclick方法。activity，fragment就是Controller层。 MVP&emsp;&emsp;所有的UI变化，网络请求等等业务逻辑之类的都写在Activity里面，Activity既要处理业务逻辑，又要处理UI变化，代码就显得非常臃肿。 &emsp;&emsp;这个时候，MVP就顺势而生，什么是MVP架构呢？ &emsp;&emsp;MVP：Model View Presenter的简称 &emsp;&emsp;MVP作为MVC的演化版本，解决了MVC不少的缺点，对于Android来说，MVP的M层，相对于MVC来说是一样的，而不一样的就是activity不再是controller，而是纯粹的V层，所有关于用户事件的转发，全都由P层去处理 &emsp;&emsp;MVP和MVC最明显的差别就是，M层和V层完全解藕，两者的通信是通过P层，P层作为桥梁，用于操作View层发送的事件到P层，P层去操作M层，并且，讲数据返回给V层。整个过层M层和V层两者完全没有联系。辣么，就有好奇的宝宝就问了，这样做解决不了更本问题，你这样做P层和V层不一样耦合在一起了吗？我们并不能完全不耦合，只是尽可能减少耦合度。我们写程序最终目的就是高类聚，低耦合，不是说完全不耦合。并且，我们这里P层和V层是通过接口通信的，如果网络请求逻辑发生变化，直接修改P层里面的代码，就可以了。V层完全不用改。如果业务逻辑发生变化，我们直接重新定义接口也非常方便 MVVM&emsp;&emsp;由微软提出来的—MVVM。什么是MVVM架构呢？ &emsp;&emsp;MVVM：Model View ViewModel &emsp;&emsp;一眼看上去更MVP差不多，只是把P层换成了ViewModel层。还有一点就是View层和ViewModel层是相互绑定的关系，当你更新ViewMdel层数据的时候，View层的UI就要相应的发生变化。 &emsp;&emsp;不管怎么说，三种模式的出现，或者说所有的开发模式，或者说是架构的出现，他们都有一个最终的目的，那就体现是一个项目架构好坏的：高类聚，低耦合 &emsp;&emsp;学习成本，MVC最简单，弊端也是最多的，学起来也是最快的。MVP和MVVM两者都是MVC的演化版本，两者没法评论优缺点，各有千秋。MVP是目前最火的架构（-.-）。 总结&emsp;&emsp;吹了这么多，MVP有没有什么缺点呢？答案是肯定的：有。本人认为，MVP是目前已知框架最好的 缺点 P层比较臃肿，所有的逻辑代码，网络请求都丢在P层 接口很多，一个功能，相对于MVC来讲，需要多写很多代码 V层P层耦合度过于高，一旦视图需要变更，P层就要相应的发生变化 优点 解藕，这个不用说了 结构清晰明了，不会过了一个月就变成别人的代码 提高了维护性，功能出了问题，直接定位到接口，修改接口就行了 容易进行单元测试，虽然会用单元测试的人比较少]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制原理]]></title>
    <url>%2F2018%2F02%2F22%2FAndroid%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[推荐：非著名程序员的安卓自定义View教程目录，我的自定义view就是看他的这个系列学会的 &emsp;&emsp;首先，我们需要确认的是android的事件传递机制是责任链模式，如果自己能处理就拦截下来自己处理，如果自己处理不了或者不确定就传递给下一个对象 事件的拦截、分发、消费&emsp;&emsp;我们要知道三个方法，控制事件反而拦截，分发与消费。如下表： 类型 相关方法 Activity ViewGroup View 事件分发 dispatchTouchEvent 有 有 无 事件拦截 onInterceptTouchEvent 无 有 无 事件处理 onTouchEvent 有 有 有 以上三个方法，均有boolean类型的返回值，通过设置true，false来控制事件传递的流程 Activity和View均没有事件拦截方法，是因为 Activity作为事件响应起点，如果，Activity把事件拦截了，辣么将为导致整个屏幕都无法点击 View作为事件响应的最末端，要么消费事件，要么不处理回传，没必要拦截事件 事件分发流程&emsp;&emsp;先给出一张图 &emsp;&emsp;这里，我们看到多了两个东西，一个是PhoneWindow，一个是DecorView，我们平时写的布局，最外层的父布局就是这里的RootView，有过几个app开发经验的程序员都应该知道，app的状态栏颜色的修改，还有那个主题的内容修改，修改后显示在哪呢？没错，就是DecorView里面。 &emsp;&emsp;再有就是phoneWindow，其实，知不知道没什么用，phonewindow是Window的唯一实现类，Window是干嘛的呢？Window是一个抽象类，所有的视图，事件传递都归它管理，所以，phonewindow管理视图，上面说的DecorView就是phonewindow的一个内部实现类，除了自己的功能外，还负责消息传递。 &emsp;&emsp;说了这么多，该来讲讲事件传递的流程了。android的view是树形结构的，基于这样的结构，我们的事件可以有序的分发。事件收集之后，起点是Activity，然后有序的向下传递，大致如下： Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View 如果这个事件没有对象处理，辣么，它会依次往回传递，如果还是没有人处理，辣么就会被Activity抛弃掉 Activity &lt;－ PhoneWindow &lt;－ DecorView &lt;－ ViewGroup &lt;－ ... &lt;－ View 这就是文章开头我们提到的，责任链模式 下面我给出ViewGroup的事件分发机制的伪代码： 12345678910111213public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean result = false; // 默认状态为没有消费过 if (!onInterceptTouchEvent(ev)) &#123; // 如果没有拦截交给子View result = child.dispatchTouchEvent(ev); &#125; if (!result) &#123; // 如果事件没有被消费,询问自身onTouchEvent result = onTouchEvent(ev); &#125; return result;&#125; &emsp;&emsp;情景：老板: 我看公司最近业务不咋地，准备发展一下电商业务，下周之前做个淘宝出来试试怎么样。&emsp;&emsp;事件顺序，老板(MainActivity)要做淘宝，这个事件通过各个部门(ViewGroup)一层一层的往下传，传到最底层的时候，码农小王(View1)发现做不了，于是消息又一层一层的回传到老板那里。&emsp;&emsp;可以看到整个事件传递路线非常有序。从Activity开始，最后回传给Activity结束(由于我们无法操作Phone Window和DecorView，所以没有它们的信息)。 1234567891011MainActivity [老板]: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.RootView [经理]: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.RootView [经理]: onInterceptTouchEvent (老板可能疯了,但又不是我做.)ViewGroupA [组长]: dispatchTouchEvent 老板要做淘宝,下周上线?ViewGroupA [组长]: onInterceptTouchEvent (看着不太靠谱,先问问小王怎么看)View1 [码农]: dispatchTouchEvent 做淘宝???View1 [码农]: onTouchEvent 这个真心做不了啊.ViewGroupA [组长]: onTouchEvent 小王说做不了.RootView [经理]: onTouchEvent 报告老板, 技术部说做不了.MainActivity [老板]: onTouchEvent 这么简单都做不了,你们都是干啥的(愤怒). 总结事件分发机制设计到到情形非常多，这里就不一一列举了，记住以下几条原则就行了。 如果事件被消费，就意味着事件信息传递终止。 如果事件一直没有被消费，最后会传给Activity，如果Activity也不需要就被抛弃。 判断事件是否被消费是根据返回值，而不是根据你是否使用了事件。]]></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View]]></title>
    <url>%2F2018%2F02%2F08%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Netty的简单使用，实现socket通讯]]></title>
    <url>%2F2018%2F02%2F08%2FNetty%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[自从用了netty框架，妈妈再也不用担心我的socket通讯了 &emsp;&emsp;题外话，很多人都把JDK1.4提供的NIO称之为异步非阻塞I/O；其实，并不然，从严格意义上面讲，它只能称为非阻塞I/O。在JDK1.7提供的NIO 2.0，新增了异步的套接字通道Channel，它才是真正的异步非阻塞I/O。下表是不同I/O模型的对比： 表1-1 几种I/O模型和同能对比 同步阻塞I/O(BIO) 伪异步I/O 非阻塞I/O(NIO) 异步I/O(AIO) 客户端个数：I/O线程 1:1 M:N(M可以大于N) M:1(1个I/O线程处理多个客户端连接) M:0(不需要启动额外的I/O线程，被动回调) I/O类型(阻塞) 阻塞I/O 阻塞I/O 非阻塞I/O 非阻塞I/O I/O类型(同步) 同步I/O 同步I/O 同步I/O(I/O多路复用) 异步I/O API使用难度 简单 简单 非常复杂 复杂 调试难度 简单 简单 复杂 复杂 可靠性 非常差 差 高 高 吞吐量 低 中 高 高 简介&emsp;&emsp;Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 &emsp;&emsp;也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。 &emsp;&emsp;“快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。——百度百科 优点 API使用简单，开发门槛低 功能强大，预置了多种编解码功能，支持多种主流协议 性能高，通过与业界其他主流NIO框架相比，netty的综合性能最高 成熟，稳定，Netty已经修复了已经发现的所有的JDK NIO BUG，业务开发人员不用再为NIO的bug而烦恼 社区活跃，版本迭代周期短，发现bug可以及时被修复，同时有更多的新功能加入 经历了大规模的商界业务考验，只能得到了验证 粘包、拆包概念&emsp;&emsp;TCP是一个流协议，所谓的流，就是没有界限的一串数据。可以考虑河里的流水，他们并没有界限。tcp底层并不了解业务层数据的具体含义，他会根据tcp缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被tcp拆分成多个包进行发送，也可能把多个小包封装成一个大数据一起发送，这就是所谓的tcp粘包，拆包问题 产生原因 应用程序write写入的字节大小大于套接口发送缓冲区的大小 进行MSS大小的tcp分段 以太网帧的payload大于MTU进行IP分片 解决办法 消息定长，每个报文大小固定长度，不够的补0 包尾增加回车换行符进行分割。例如：FTP协议 将消息分为消息头和消息体。消息头中包含消息的总长度字段 更复杂的应用层协议 Netty框架的解决办法&emsp;&emsp;LineBasedFrameDecoder和StringDecoder两个类 LineBasedFrameDecoder&emsp;&emsp;LineBasedFrameDecoder的工作原理是依次遍历ByteBuf中的可读字节，判断看是否有”\r”或者”\r\n”，如果有就以此为结束位置，从可读索引位置到结束区间的字节就组成了一行。他是以换行符为结束标志的解码器，支持携带结束符和不带结束符两种解码方式。同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读取的异常流 StringDecoder&emsp;&emsp;StringDecoder的功能就非常简单，就是将接收到的对象换成字符串，然后继续调用后面的handler，LineBasedFrameDecoder+StringDecoder组合就是按换行符切换文本解码器，他被设计用来支持TCP粘包和拆包。Netty支持其他其他符号的解码器(DelimiterBasedFrameDecode) &emsp;&emsp;说了这么多，代码来了，就是用Netty实现的心跳。对于懒癌晚期，已经风装好，可以直接拿过去用，注释也写的很清楚 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import android.util.Log;import io.netty.bootstrap.Bootstrap;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import io.netty.util.CharsetUtil;/** * @author 海晨忆 * @date 2018/2/6 * @desc */public class SocketTcp &#123; private static SocketTcp socketTcp = new SocketTcp(); private Channel channel = null; private EventLoopGroup group; private int port; private String host; public static SocketTcp getInstance() &#123; return socketTcp; &#125; public SocketTcp setPort(int port) &#123; this.port = port; return this; &#125; public SocketTcp setHost(String host) &#123; this.host = host; return this; &#125; public void connect() &#123; if (channel != null) return; if (group == null) &#123; //NIO线程组 group = new NioEventLoopGroup(); &#125; try &#123;//配置Bootstrap Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; //以换行符为结束标记 ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); pipeline.addLast(new LineBasedFrameDecoder(Integer.MAX_VALUE)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket()); //以&quot;$_&quot;作为分隔符 /*ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); String s = &quot;$_&quot;; ByteBuf byteBuf = Unpooled.copiedBuffer(s.getBytes()); pipeline.addLast(new DelimiterBasedFrameDecoder(Integer.MAX_VALUE,byteBuf)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket());*/ &#125; &#125;); //发起异步连接操作 ChannelFuture channelFuture = bootstrap.connect(host, port).sync(); channel = channelFuture.channel(); //等待服务端监听端口关闭 channel.closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; disConnect(); &#125; &#125; /** * 断开tcp连接. */ private void disConnect() &#123; if (null != group) &#123; group.shutdownGracefully(); &#125; group = null; channel = null; &#125; public void sendMessage(String msg) &#123;//连接成功后，通过Channel提供的接口进行IO操作 try &#123; if (channel != null &amp;&amp; channel.isOpen()) &#123; channel.writeAndFlush(msg).sync(); Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg); &#125; else &#123; reConnect(); throw new Exception(&quot;channel is null | closed&quot;); &#125; &#125; catch (Exception e) &#123; reConnect(); e.printStackTrace(); &#125; &#125; /** * 重连. */ private void reConnect() &#123; new Thread(this::connect); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.example.zwang.myapplication.socket;import android.os.SystemClock;import android.util.Log;import java.util.concurrent.TimeUnit;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.EventLoop;import io.netty.channel.SimpleChannelInboundHandler;public class MyHeartSocket extends SimpleChannelInboundHandler&lt;Object&gt; &#123; private ChannelHandlerContext ctx; private boolean isConnect = false; @Override protected void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception &#123; Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;); ByteBuf msg1 = (ByteBuf) msg; byte[] bytes = new byte[msg1.readableBytes()]; msg1.readBytes(bytes); String s = new String(bytes, &quot;UTF-8&quot;); Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;); isConnect = true; if (this.ctx == null) &#123; synchronized (MyHeartSocket.class) &#123; if (this.ctx == null) &#123; this.ctx = ctx; MyAppHeart(); &#125; &#125; &#125; &#125; private void MyAppHeart() &#123; new Thread(() -&gt; &#123; while (ctx != null &amp;&amp; isConnect) &#123; String data = &quot;123&quot;; byte[] bytes = data.getBytes(); if (isConnect) &#123; ctx.writeAndFlush(Unpooled.buffer(bytes.length).writeBytes(bytes)); SystemClock.sleep(3000); &#125; &#125; &#125;).start(); &#125; @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; EventLoop loop = ctx.channel().eventLoop(); loop.schedule(() -&gt; SocketTcp.getInstance().connect(), 5, TimeUnit.SECONDS); super.channelInactive(ctx); Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;); isConnect = false; &#125; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; super.userEventTriggered(ctx, evt); Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.exceptionCaught(ctx, cause); Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;); this.ctx.close(); this.ctx = null; &#125;&#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO编程和NIO编程简介]]></title>
    <url>%2F2018%2F02%2F07%2FIO%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;传统的同步阻塞I/O通讯模型，导致的结果就是只要有一方处理数据缓慢，都会影响另外一方的处理性能。按照故障设计原则，一方的处理出现问题，不应该影响到另外一方才对。但是，在同步阻塞的模式下面，这样的情况是无法避免的，很难通过业务层去解决。既然同步无法避免，为了避免就产生了异步。Netty框架就一个完全异步非阻塞的I/O通讯方式 同步阻塞式I/O编程&emsp;&emsp;简单的来说，传统同步阻塞的I/O通讯模式，服务器端处理的方式是，每当有一个新用户接入的时候，就new一个新的线程，一个线程只能处理一个客户端的连接，在高性能方面，并发高的情景下无法满足。伪代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; public void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); while (true) &#123; socket = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; new TimerServerHandler(socket).run(); &#125; &#125;).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //释放资源 if (server != null) &#123; try &#123; server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; server = null; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimerServerHandler implements Runnable &#123; private Socket socket; public TimerServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; BufferedReader in = null; PrintWriter out = null; try &#123; in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); out = new PrintWriter(this.socket.getOutputStream(), true); String currentTime = null; String body = null; while (true) &#123; body = in.readLine(); if (body == null) break; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); //释放in，out，socket资源 &#125; &#125;&#125; &emsp;&emsp;上面这个就是最原始的服务端IO的代码，这里我就给出的是最简化的，当有新的客户端接入的时候，服务端是怎么处理线程的，可以看出，每当有新的客户端接入的时候，总是回新创建一个线程去服务这个新的客户端 伪异步式编程&emsp;&emsp;后来慢慢演化出一个版本“伪异步”模型，新增加一个线程池或者消息队列，满足一个线程或者多个线程满足N个客户端，通过线程池可以灵活的调用线程资源。通过设置线程池的最大值，防止海量并发接入造成的线程耗尽，它的底层实现依然是同步阻塞模型，伪代码如下：1234567891011121314151617181920212223242526272829303132333435import com.example.zwang.mysocket.server.TimerServerHandler;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; private void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); TimeServerHandlerExecutePool executePool = new TimeServerHandlerExecutePool(50, 1000); while (true) &#123; socket = server.accept(); executePool.execute(new TimerServerHandler(socket)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //释放资源 &#125; &#125;&#125; 12345678910111213141516171819202122import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimeServerHandlerExecutePool &#123; private ExecutorService executor; public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123; executor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize, 120L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize)); &#125; public void execute(Runnable task) &#123; executor.execute(task); &#125;&#125; &emsp;&emsp;“伪异步”的代码和传统同步的唯一区别就是在于，首先先创建了一个时间服务处理类的线程池，当有新的客户端接入的时候，先将socket请求封装成task，然后调用线程池的execute方法执行，从而避免了每一个新请求创建一个新线程。由于线程池和消息队列都是有限的，因此，无论客户端的并发量多大，它都不会导致线程个数过于大，而造成的内存溢出。相对于传统的同步阻塞，是一种改良。 &emsp;&emsp;但是他没有从更本上解决同步的问题，伪异步的问题在于，他还是有一方处理出现问题还是会影响到另一方。因为： &emsp;&emsp;当对socket的输入流进行读取操作的时候，它会一直阻塞直到一下三种方式发生： 有数据可读 可读数据已经读取完 发生空指针或者I/O异常。 这意味者，当读取inputstream方处理速度缓慢(不管是什么原因造成的速度缓慢)，另一方会一直同步阻塞，直到这一方把数据处理完. &emsp;&emsp;当调用outputstream的write方法写输出流的时候，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。学过TCP/IP相关知识的人都直到，当消息的接收方处理消息缓慢，不能及时的从TCP缓冲区读取数据，这将会导致发送方的TCP缓冲区的size一直减少，直到0.缓冲区为0，那么发消息的一方将无法将消息写入缓冲区，直到缓冲区的size大于0 &emsp;&emsp;通过以上。我们了解到读和写的操作都是同步阻塞的，阻塞的时间取决于对方的I/O线程的处理速度和网络I/O的传送速度。从本质上面看，我们无法保证对方的处理速度和网络传送速度。如果，我们的程序依靠与对方的处理速度，那么，他的可靠性将会非常差。 NIO编程&emsp;&emsp;官方叫法new I/O，也就是新的IO编程，更多的人喜欢称它为：Non-block IO即非阻塞IO。 &emsp;&emsp;与Socket和serverSocket类对应，NIO提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现，这两种都支持阻塞式编程和非阻塞式编程。开发人员可以根据自己的需求选择合适的编程模式。一般低负载，低并发的应用程序选择同步阻塞的方式以降低编程的复杂度。高负载，高并发的不用想了，非阻塞就是为了解决这个问题的 缓冲区Buffer &emsp;&emsp;Buffer是一个对象，它包含一些写入或者读出的数据。再NIO中加入buffer对象，体现了新库和旧库的一个重要区别。在面向流的io中，可以直接把数据读取或者写入到stream对象中。在NIO库中，所有数据操作都是通过缓冲区处理的。 &emsp;&emsp;缓冲区实质上是一个数组，通常是一个字节数组（ByteBuffer），基本数据类型除了boolean没有，其他都有，如ShortBuffer,CharBuffer等等 通道Channel &emsp;&emsp;Channel是一个通道，双向通道，网络数据都是通过Channel读取，写入的。是的，没错，Channel它既可以进行读操作，也可以进行写操作。而流只能是一个方向。只能读操作或者只能写操作，而channel是全双工，读写可以同时进行。channel可以分为两大类：网络读写的SelectableChannel和文件操作的FileChannel。我们前面提到的SocketChannel和ServerSocketChannel都是SelectableChannel的子类。 多路复用器Selector &emsp;&emsp;selector多路复用器，他是java NIO编程的基础，熟练的掌握selector对于NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单的讲就是他会不断的轮询注册的channel，如果一个Channel发生了读写操作，这个Chnnel就会处于就绪状态，会被selector轮询出来，通过SelectorKey获取就绪Channel集合，进行后续的IO操作。一个selector对应多个Channel &emsp;&emsp;由于原生NIO编码比较麻烦和复杂，我这里就给出了思路的伪代码。下一篇我们将用NIO中的Netty框架实现Socket通信，编码简单，一行代码解决烦人粘包、拆包问题。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 服务端nio过程的伪代码 * * @param port 端口号 * @throws IOException IOException */ private void init(int port) throws IOException &#123; //第一步：打开ServerSocketChannel，用于监听客户端连接，它是所有客户端连接的父管道 ServerSocketChannel socketChannel = ServerSocketChannel.open(); //第二步：监听绑定端口，设置连接模式为非阻塞模式， socketChannel.socket().bind(new InetSocketAddress(InetAddress.getByName(&quot;IP&quot;), port)); socketChannel.configureBlocking(false); //第三步：创建Reactor线程，创建多路复用器，并启动线程。 Selector selector = Selector.open(); new Thread().start(); //第四步：将ServerSocketChannel注册到Reactor线程的多路复用器上，监听accept事件 SelectionKey key = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第五步：多路复用器在线程run方法的无线循环体内轮询准备就绪的key int num = selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator(); while (it.hasNext()) &#123; SelectionKey next = it.next(); //deal with io event... &#125; //第六步：多路复用器检测到有新客户端接入，处理新的接入请求，完成TCP三次握手，建立物理链路 SocketChannel channel = socketChannel.accept(); //第七步：设置客户端为非阻塞模式 channel.configureBlocking(false); channel.socket().setReuseAddress(true); //第八步：将新接入的客户端注册到reactor线程的多路复用器上，监听读操作，读取客户端发送的消息 SelectionKey key1 = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第九步：异步读取客户端消息到缓冲区， /*int readNumber = channel.read(&quot;receivebuff&quot;);*/ //第十步：对byteBuffer进行编解码，如果有半包信息指针reset，继续读取到后续的报文，将解码成功消息封装成task，投递到业务线程池，进行业务逻辑编排 Object massage = null; while (buff.hasRemain()) &#123; buff.mark(); Object massage1 = decode(btyeBuffer); if (massage1 == null) &#123; byteBuffer.reset(); break; &#125; massageList.add(massage1); &#125; if (!byteBuffer.hasRemain()) &#123; byteBuffer.clean(); &#125; else &#123; byteBuffer.compact(); &#125; if (massageList != null &amp;&amp; !massageList.isEmpty()) &#123; for (Object massage3 : massageList)&#123; handlerTask(massage3); &#125; &#125; //第十一步：将POJO对象encode成ByteBuff，调用SocketChannel的异步write接口，将异步消息发送到客户端 socketChannel.write(buffer); &#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
</search>
