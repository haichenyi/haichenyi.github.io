<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 加密算法（一）]]></title>
    <url>%2F2018%2F03%2F08%2FJava-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[补充知识点：字节：也就是 byte 是一种统计单位，表示数量的多少 字符：是指计算机中使用的文字和符号，比如：1、2、3、A、S、D、$、%等等符号 字节与字符的对应关系：它们完全不是一个概念，所以，没有什么有没有区别这个说法。不同的编码，两者的对应关系是不相同的，我这里就说常用的两种编码： ASCII码中，一个英文字母（不区分大小写）占一个字节，一个中文汉字占两个字节 UTF-8中，一个英文字母占一个字节，一个中文汉字占三个字节 &emsp;&emsp;我们加密最终常常操作的是bit，而我们加密首先得到的是byte数组的，byte的取值范围-128~127，中间包括0，刚好256个。也就是2^8=256。并且，1 byte = 8 bit（1kb = 1024 byte = 8^1024 bit等等） &emsp;&emsp;我们获得了byte之后，要把byte数组转成String字符串，String其实就是char数组，我们java有一个new String(char[] chars)，应该都用过。我们转成字符串的前提是转成char数组，由于，1 char = 2 byte，所以，我们byte转成char长度扩大了1倍。 四种分类 MD5加密 Base64加密 对称加密 非对称加密 MD5加密——不可逆概念&emsp;&emsp;MD5加密是我们常见的加密算法，是不可逆的，也就是说加密完成之后，无法解密转成原来的内容。MD5加密算法其实是一种散列函数，使用的是hash算法。MD5的原文是无线多个，但是MD5的值是有限的。所以一个MD5的值可能对应多个原文。SHA算法跟MD5是差不多的，只是MD5是128位，SHA是160位，多32位 &emsp;&emsp;为什么MD5的值是有限多个呢？主流的MD5使用的是将任意长度的字节串映射为一个128bit的大整数。也就是一共有2^128种可能，所以说这个数字是有限的，而，我们的原文则是无限多个。发现两段原文对应同一个MD5的值概率非常小，也就忽略不记了。 使用1234567891011121314String name1 = &quot;haichenyi&quot;; String name2 = &quot;海晨忆&quot;; try &#123; MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); byte[] digest1 = md5.digest(name1.getBytes(&quot;UTF-8&quot;)); Log.v(&quot;WZ&quot;,&quot;length1:&quot;+digest1.length); byte[] digest2 = md5.digest(name2.getBytes(&quot;UTF-8&quot;)); Log.v(&quot;WZ&quot;,&quot;length1:&quot;+digest2.length); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &emsp;&emsp;我们通过MD5，得到的是一个byte数组（这个byte数组的长度跟我们的1byte=8bit没有直接关系），我们需要做的就是对这个byte数组进行操作，我们习惯上就是把这个btye转成16进制数存进数据库，当然，你也可以转成其他的类型存到数据库。这里给出几个byte数组转16进制字符串的方法，亲测可用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private static final char[] HEX_CHAR = &#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;; /** * 方法一： * byte[] to hex string * * @param bytes * @return */ public String bytesToHexFun1(byte[] bytes) &#123; // 一个byte为8位，可用两个十六进制位标识 char[] buf = new char[bytes.length * 2]; int a = 0; int index = 0; for (byte b : bytes) &#123; // 使用除与取余进行转换 if (b &lt; 0) &#123; a = 256 + b; &#125; else &#123; a = b; &#125; buf[index++] = HEX_CHAR[a / 16]; buf[index++] = HEX_CHAR[a % 16]; &#125; return new String(buf); &#125; /** * 方法二： * byte[] to hex string * * @param bytes * @return */ public String bytesToHexFun2(byte[] bytes) &#123; char[] buf = new char[bytes.length * 2]; int index = 0; for(byte b : bytes) &#123; // 利用位运算进行转换，可以看作方法一的变种 buf[index++] = HEX_CHAR[b &gt;&gt;&gt; 4 &amp; 0xf]; buf[index++] = HEX_CHAR[b &amp; 0xf]; &#125; return new String(buf); &#125; /** * 方法三： * byte[] to hex string * * @param bytes * @return */ public String bytesToHexFun3(byte[] bytes) &#123; StringBuilder buf = new StringBuilder(bytes.length * 2); for(byte b : bytes) &#123; // 使用String的format方法进行转换 buf.append(String.format(&quot;%02x&quot;, new Integer(b &amp; 0xff))); &#125; return buf.toString(); &#125; /** * 将16进制字符串转换为byte[] * * @param str * @return */ public byte[] toBytes(String str) &#123; if(str == null || str.trim().equals(&quot;&quot;)) &#123; return new byte[0]; &#125; byte[] bytes = new byte[str.length() / 2]; for(int i = 0; i &lt; str.length() / 2; i++) &#123; String subStr = str.substring(i * 2, i * 2 + 2); bytes[i] = (byte) Integer.parseInt(subStr, 16); &#125; return bytes; &#125; Base64加密——可逆流程 要知道的是有一个64个数的表，也称Base64编码表。可以字节定义，不过都是用的一样的。 Base64是按照字符长度，以3个字符为一组 接着增对每组的每个字符，取ASCII编码 然后将获得的编码转换成8bit的二进制，就会得到3*8=24bit的字节 然后将这24bit的字节以6个bit为一组，分成4组 接着在每组前面填两个高位0，凑成每组8bit 最后将这每组8bit的二进制转成十进制，对应下面的Base64编码表 Base64 编码表 value char value char value char value char 0 A 16 Q 32 g 48 w 1 B 17 R 33 h 49 x 2 C 18 S 34 i 50 y 3 D 19 T 35 j 51 z 4 E 20 U 36 k 52 0 5 F 21 V 37 l 53 1 6 G 22 U 38 m 54 2 7 H 23 X 39 n 55 3 8 I 24 Y 40 o 56 4 9 J 25 Z 41 p 57 5 10 K 26 a 42 q 58 6 11 L 27 b 43 r 59 7 12 M 28 c 44 s 60 8 13 N 29 d 45 t 61 9 14 O 30 e 46 u 62 + 15 P 31 f 47 v 63 / 使用1234567891011String str = &quot;hai&quot;; byte[] encode = Base64.encode(str.getBytes(), Base64.NO_WRAP); try &#123; String a = new String(encode,&quot;UTF-8&quot;); String a1 = new String(encode,&quot;US-ASCII&quot;); Log.v(&quot;wz&quot;,a); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; String after = Base64.encodeToString(str.getBytes(), Base64.NO_WRAP); Log.v(&quot;wz&quot;,&quot;after--&gt;&quot;+after); 解析&emsp;&emsp;这里，我要使用Base64加密”hai”这个字符串，根据上面的流程： 待加密字符串 h a i ASCII编码 104 97 105 二进制 01101000 01100001 01101001 下面，上面的表不好表示，我再换一个表，下一步，该6位分一组了 现在的字符串：01101000 01100001 01101001 六位分一组 011010 000110 000101 101001 每组前面补0 00011010 00000110 00000101 00101001 转成10进制 26 6 5 41 Base64编码 a G F p 结果图： PS： Base64.encodeToString()方法直接转成加密后的字符串 Base64.encode()方法返回的byte数组是16进制的，不用手动在去转一遍16进制]]></content>
      <categories>
        <category>Android -加密算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EventBus源码解析(二)——注册]]></title>
    <url>%2F2018%2F03%2F07%2FEventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前我们讲过获取EventBus对象的源码，这一篇，我们来讲讲注册的源码。推荐EventBus 3.0进阶：源码及其设计模式 完全解析 简介12345678/** * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they * are no longer interested in receiving events. * &lt;p/&gt; * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;. * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link * ThreadMode&#125; and priority. */ &emsp;&emsp; 翻译： 注册给订阅方去接收事件，订阅者一旦对接收事件不感兴趣了，就要unregister，订阅者必须要有用Subscribe注解的方法，注解也可以设置线程和优先级 &emsp;&emsp; 白话文： 订阅者要是想接收消息，必须要先注册。当页面退出，或者不想接收消息的时候必须要反注册，不然他会一直处于接收消息的状态，页面退出会内存泄漏。订阅者的接收方法必须要用Subscribe注解，这个注解的后面可以设置接收这个消息的线程和优先级。如下： 1234@Subscribe(threadMode = ThreadMode.MAIN,priority = 100,sticky = true) public void handleMsg(DataBean dataBean)&#123; &#125; &emsp;&emsp;就像上面这样写，我一个一个来讲。我们先来说说这个ThreadMode类，点进去，我们可以看到如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 每个订阅的方法都有一个线程，决定那个线程的方法被叫做EventBus * EventBus的线程可以跟Post事件的那个线程不相同 */public enum ThreadMode &#123; /** *订阅者将在跟Post事件的那个线程的同一个线程中被调用，这是默认值， * 因为，他没有线程切换，所以开销最少，所以也是推荐模式。需要注意的是 * post事件的线程可能是UI线程，也可能是其他线程，所以，这里的操作要做判断， * 如果是UI操作，你必须要在UI线程中完成，如果是耗时操作，你必须要新开线程 */ POSTING, /** * 在Android上面，订阅者将会在UI线程中调用，如果post事件的线程是UI线程， * 辣么，这个订阅方法将直接被调用，如果不是UI线程，辣么，它将要排队交付， * 所以，这里可能阻塞线程，订阅者使用这个模式必须要快速返回，避免阻塞UI线程， * 就是不要在这里做耗时操作。谢谢。 */ MAIN, /** *这一个，跟上面的刚好对应，就是不管怎么样，都要排队交付， * 不论post事件是不是处于UI线程发送的 */ MAIN_ORDERED, /** * 在android上面，订阅方法将在子线程中调用。如果post事件处于子线程， * 辣么，订阅方法将直接被调用。如果post事件处于UI线程，辣么，eventBus * 就会新开线程，按照顺序处理事件，当然，也要注意，避免阻塞子线程 */ BACKGROUND, /** * 订阅方法将会在独立的线程中调用，这个线程总是独立语post事件 * 所处的线程和主线程。如果post事件是耗时操作：例如网络请求， * 订阅方法调用的时候，不会等待。我们不用考虑线程数量的问题， * EventBus已经限制了并发线程，并使用线程池高效的重用线程 */ ASYNC&#125; 他就是一个枚举类，几个值的意义，我说的很清楚了。 &emsp;&emsp;我们再来讲讲另外两个： sticky，默认值是false，如果设置成true，辣么，这个事件将会是粘性事件。发送事件的方式从post变成了postSticky，其他都没变。 &emsp;&emsp;再来讲讲 priority ，默认值是0，在同一个线程中值越大，优先级越高。优先级高的比优先级低的先收到消息。 好，终于准备工作做完了，我们来看看 register() 方法 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; &emsp;&emsp;注册方法。首先，他通过反射的方式获得当前类名，然后通过当前类名，找到订阅方法，存到list里面。我们来看看 findSubscriberMethods()方法 123456789101112131415161718192021List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;//首先从缓存中读取当前类的订阅方法，如果不等于null，就直接返回从缓存中读取到的list List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125;//ignoreGeneratedIndex的值，从Builder可知，一般为false。 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; //将获取的subscriberMeyhods放入缓存中 METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; &emsp;&emsp;上面的注释写的很清楚，ignoreGeneratedIndex为false，辣么就会走findUsingInfo() 方法 123456789101112131415161718192021222324private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;//首先新建了一个FindState，FindState是一个静态内部类，保存订阅者的信息 FindState findState = prepareFindState(); //初始化FindState findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findState.subscriberInfo = getSubscriberInfo(findState); //初始化的findState获得的订阅者信息，一般都是null if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; //就会跳到这里 findUsingReflectionInSingleClass(findState); &#125; //移动到父类继续查找 findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; 上面，我们提到了FindState类，我们来看看这个类的代码 1234567891011121314151617181920static class FindState &#123;//订阅方法的列表 final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;();//以class的名称为key，以方法为value final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;();//以方法名称为key，订阅者类为value final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;(); final StringBuilder methodKeyBuilder = new StringBuilder(128); Class&lt;?&gt; subscriberClass; Class&lt;?&gt; clazz; boolean skipSuperClasses; SubscriberInfo subscriberInfo;//初始化 void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; this.subscriberClass = clazz = subscriberClass; skipSuperClasses = false; subscriberInfo = null; &#125; &#125; &emsp;&emsp;不难看出，这里的几个map包括了，类名找方法，方法名找类，我们后面都用的到，然后就是初始化方法，前面我们注释里面写了，初始化之后一般信息都是null，这里我们也可以看到。所以，它会走 findUsingReflectionInSingleClass 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; /*------------------------------上面就是获取方法，重要的是在下面------------------------------------*/ //这里我强调的是我们前面的用法里面有说过注意点 //1.必须是public修饰 //2.必须是void类型 //3.必须是一个参数 //4.必须用Subscribe注解 for (Method method : methods) &#123; //获取方法的修饰符 int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; //获取方法参数类型 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //如果参数个数等于1 if (parameterTypes.length == 1) &#123; //获取方法注解名称 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; //参数类型 即为事件类型 Class&lt;?&gt; eventType = parameterTypes[0]; //调用checkAdd方法判断是否添加过 if (findState.checkAdd(method, eventType)) &#123; //从注解里面获取线程模式 ThreadMode threadMode = subscribeAnnotation.threadMode(); //新建一个SubscriberMethod对象，并添加到findState的subscriberMethods这个集合内 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; //如果开启了严格验证，同时当前方法又有@Subscribe注解，对不符合要求的方法会抛出异常 &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125; &#125; &emsp;&emsp;这个方法非常重要！！！在这个方法内部，利用反射的方式，对订阅者类进行扫描判断，是否满足条件从而找出订阅方法，并用上面的容器进行保存。辣么，上面提到的 checkAdd() 方法是怎么检查的呢？ 123456789101112131415161718boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123; // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required. // Usually a subscriber doesn&apos;t have methods listening to the same event type. Object existing = anyMethodByEventType.put(eventType, method); if (existing == null) &#123; return true; &#125; else &#123; if (existing instanceof Method) &#123; if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123; // Paranoia check throw new IllegalStateException(); &#125; // Put any non-Method object to &quot;consume&quot; the existing Method anyMethodByEventType.put(eventType, this); &#125; return checkAddWithMethodSignature(method, eventType); &#125; &#125; &emsp;&emsp;这个注释写的很清楚，两层检验，第一层是检测事件类型，第二次检验则是检验判断方法的完整，首先以eventType为键，方法为值，存到map中（这个map是在FindState类初始化的），put方法会有一个返回值，返回value，这个value是这个key对应的上一个值，所以说，如果是第一次存放，那么就会返回null。否则，之前存放过，辣么就会进入下一个判断 checkAddWithMethodSignature 1234567891011121314151617private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append(&apos;&gt;&apos;).append(eventType.getName()); String methodKey = methodKeyBuilder.toString(); Class&lt;?&gt; methodClass = method.getDeclaringClass(); Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy subscriberClassByMethodKey.put(methodKey, methodClassOld); return false; &#125; &#125; &emsp;&emsp;这个方法就是用来判断方法签名是否相同的，方法签名是什么呢？就是修饰符+返回类型+方法名+参数list是否相同。如果方法签名相同，辣么，就把旧值赋值给methodClassOld，判断这个值不是为null，第一次调用，没有旧值，就肯定为null，所以，if前面的一个条件是满足的，后面一个条件methodClassOld.isAssignableFrom(methodClass) 的意思是判断旧值是否是methodClass或者同一个类，如果两个条件都不满足，辣么当前方法就不会添加为订阅方法。 &emsp;&emsp;那么，说了一大堆关于checkAdd和checkAddWithMethodSignature方法的源码，那么这两个方法到底有什么作用呢？从这两个方法的逻辑来看，第一层判断根据eventType来判断是否有多个方法订阅该事件，而第二层判断根据完整的方法签名(包括方法名字以及参数名字)来判断。下面是笔者的理解： &emsp;&emsp;第一种情况：比如一个类有多个订阅方法，方法名不同，但它们的参数类型都是相同的(虽然一般不这样写，但不排除这样的可能)，那么遍历这些方法的时候，会多次调用到checkAdd方法，由于existing不为null，那么会进而调用checkAddWithMethodSignature方法，但是由于每个方法的名字都不同，因此methodClassOld会一直为null，因此都会返回true。也就是说，允许一个类有多个参数相同的订阅方法。 &emsp;&emsp;第二种情况：类B继承自类A，而每个类都是有相同订阅方法，换句话说，类B的订阅方法继承并重写自类A，它们都有着一样的方法签名。方法的遍历会从子类开始，即B类，在checkAddWithMethodSignature方法中，methodClassOld为null，那么B类的订阅方法会被添加到列表中。接着，向上找到类A的订阅方法，由于methodClassOld不为null而且显然类B不是类A的父类，methodClassOld.isAssignableFrom(methodClass)也会返回false，那么会返回false。也就是说，子类继承并重写了父类的订阅方法，那么只会把子类的订阅方法添加到订阅者列表，父类的方法会忽略。 &emsp;&emsp;让我们回到findUsingReflectionInSingleClass方法，当遍历完当前类的所有方法后，会回到findUsingInfo方法，接着会执行最后一行代码，即return getMethodsAndRelease(findState);那么我们继续 getMethodsAndRelease 123456789101112131415private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123; //从findState获取subscriberMethods，放进新的ArrayList List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); //把findState回收 findState.recycle(); synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; if (FIND_STATE_POOL[i] == null) &#123; FIND_STATE_POOL[i] = findState; break; &#125; &#125; &#125; return subscriberMethods; &#125; 通过该方法，把subscriberMethods不断逐层返回，直到返回EventBus#register()方法，最后开始遍历每一个订阅方法，并调用subscribe(subscriber, subscriberMethod)方法，那么，我们继续来看subscribe方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Must be called in synchronized block private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; //将subscriber和subscriberMethod封装成 Subscription Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //根据事件类型获取特定的 Subscription CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); //如果为null，说明该subscriber尚未注册该事件 if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; //如果不为null，并且包含了这个subscription 那么说明该subscriber已经注册了该事件，抛出异常 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125; //根据优先级来设置放进subscriptions的位置，优先级高的会先被通知 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; //根据subscriber(订阅者)来获取它的所有订阅事件 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); //下面是对粘性事件的处理 if (subscriberMethod.sticky) &#123; //从EventBusBuilder可知，eventInheritance默认为true if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; //根据eventType，从stickyEvents列表中获取特定的事件 Object stickyEvent = stickyEvents.get(eventType); //分发事件 checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; 到目前为止，注册流程基本分析完毕，丢一张流程图]]></content>
      <categories>
        <category>Android -源码解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（Design Patterns）（三）]]></title>
    <url>%2F2018%2F03%2F07%2FJava-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[十三、策略模式顾名思义:不同的策略，对应我们项目中用到的地方就是，同一个功能，不同的实现方法。就比方说登录功能：我们有帐号密码登录，QQ第三方登录，微信第三方登录等等。其实我个人认为最典型的就是：同一个接口方法，不同的实现方式。 12345678910111213141516171819interface LoginInterface&#123; void login();&#125;public class PhoneLogin implements LoginInterface&#123; @Override public void login()&#123; //具体的逻辑 Log.v(&quot;wz&quot;,&quot;帐号密码登录&quot;) &#125;&#125;public class QqLogin implements LoginInterface&#123; @Override public void login()&#123; //具体的逻辑 Log.v(&quot;wz&quot;,&quot;QQ第三方登录&quot;) &#125;&#125; 就像上面这样，同一个登录功能，不同的实现。 十四、责任链模式责任链模式，我项目里面用的比较少，但是我知道一个android里面绝对常用的东西用的是责任连模式，那就是——andoid事件分发 十五、状态模式状态模式，我项目里面用的比较少，但是我知道的是游戏里面用的很多。就是那种存档功能，遇到自己感觉过不去的地方，把当前进度存起来，过不去了之后，死了，游戏结束了，再读当前的存档。 PS：其他的设计模式等用到了再补充]]></content>
      <categories>
        <category>Android -设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（Design Patterns）（二）]]></title>
    <url>%2F2018%2F03%2F07%2FJava-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[六、适配器模式分类有三种：类的适配器模式，对象的适配器模式，接口的适配器模式，我印象最深刻的是接口适配器模式 接口适配器模式 &emsp;&emsp;有的时候，我们写的一个接口，会有很多种方法。而，我们的实现类只需要实现某一种，或者某几种，所以，我们这里会借助一个抽象类，去实现接口的所有方法。我们的具体实现类跟这个抽象类去打交道，而不是跟原始的接口去打交道。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123; private BaseView baseView; private boolean showLoading; public MySubscriber(BaseView baseView) &#123; this.baseView = baseView; &#125; public MySubscriber(BaseView baseView, boolean showLoading) &#123; this.baseView = baseView; this.showLoading = showLoading; &#125; @Override protected void onStart() &#123; super.onStart(); if (null != baseView &amp;&amp; showLoading) &#123; baseView.showLoading(); &#125; &#125; @Override public void onError(Throwable t) &#123; if (null == baseView) &#123; return; &#125; baseView.hideLoading(); if (t instanceof ApiException) &#123; ApiException apiException = (ApiException) t; switch (apiException.getCode()) &#123; case HttpCode.NO_PARAMETER: baseView.showTipMsg(&quot;参数为空&quot;); break; case HttpCode.SERVER_ERR: baseView.showTipMsg(&quot;服务器错误&quot;); break; default: break; &#125; &#125; &#125; @Override public void onComplete() &#123; if (null != baseView) &#123; baseView.hideLoading(); &#125; &#125;&#125;addSubscribe(helper.selectBrandList() .compose(RxUtil.handleHttp()) .subscribeWith(new MySubscriber&lt;List&lt;String&gt;&gt;(baseView, true) &#123; @Override public void onNext(List&lt;String&gt; dataList) &#123; Log.v(&quot;wz&quot;,&quot;111&quot;) &#125; &#125;)); &emsp;&emsp;上面这个代码，就是我之前写的从零开始搭建一个主流项目框架系列里面的网络请求，处理返回结果的回调方法，我的返回结果，不可能每个去实现onStart，onError，onNext，onCompleted方法。我的实现类只用去继承这个类，实现某一个，或者某几个方法。更直接的就是，我之前写的框架，BaseActivity，实现BaseView接口，然后，我其他的Activity去继承BaseActivity，选择实现BaseView的方法。 如果上面这样，你还无法认同，那我们看看下面这个： 12345678910//success动画结束监听 successAnim.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); if (null != myAnimotionInterface) &#123; myAnimotionInterface.AnimationEnd(); &#125; &#125; &#125;); 动画监听，我这里只想监听动画结束，在动画结束的时候，我做我的逻辑处理，但是，他的接口有开始，结束，暂停，重复等等监听，我不要这么，你们可以点 AnimatorListenerAdapter() 这个类，去看一下他是什么，他就是一个抽象类，实现了动画监听的那个接口，这个是官方封装好的一个类。 七、装饰器模式这个模式就是我之前写从零开始搭建一个主流项目框架系列里面网络请求，SP的操作，Socket的操作，关于他们的封装都是用的装饰者模式。说的官方一点：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。项目中的应用就是： 12345678910111213141516/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public interface HttpHelper &#123; Flowable&lt;WeatherBean&gt; getWeather(String city); /** * 登录时获取验证码. * * @param phone 手机号 * @return &#123;&quot;code&quot;:0&#125; */ Flowable&lt;HttpNoResult&gt; loginCode(String phone); &#125; &emsp;&emsp;这个就是装饰对象和被装饰对象实现的同一个接口，他们一开始就只有一个功能，那就是获取天气，后来他们又新加了一个功能，必须登录之后才能获取天气，那就多了一个登录功能 12345678910111213141516171819202122232425262728293031323334/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public class DataHelper implements HttpHelper, PreferencesHelper, SqlHelper &#123; private SqlHelper sqlHelper; private HttpHelper httpHelper; private PreferencesHelper preferencesHelper; /** * 初始化数据帮助类. * * @param sqlHelper &#123;@link SqlHelper&#125; * @param httpHelper &#123;@link HttpHelper&#125; * @param preferencesHelper &#123;@link PreferencesHelper&#125; */ public DataHelper(SqlHelper sqlHelper, HttpHelper httpHelper, PreferencesHelper preferencesHelper) &#123; this.sqlHelper = sqlHelper; this.httpHelper = httpHelper; this.preferencesHelper = preferencesHelper; &#125; @Override public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123; return httpHelper.getWeather(city); &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return httpHelper.loginCode(phone); &#125;&#125; &emsp;&emsp;这个就是装饰类，负责调用接口的方法 12345678910111213141516171819202122232425/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public class RetrofitHttp implements HttpHelper &#123; private WardrobeApi wardrobeApi; private WeatherApi weatherApi; @Inject RetrofitHttp(WardrobeApi wardrobeApi, WeatherApi weatherApi) &#123; this.wardrobeApi = wardrobeApi; this.weatherApi = weatherApi; &#125; @Override public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123; return weatherApi.getWeather(city, &quot;c41d9ca568d449e2802244d8eeb3d3c6&quot;); &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return wardrobeApi.loginCode(phone); &#125;&#125; &emsp;&emsp;这个就是被装饰类，负责具体的实现，这里是retrofit网络请求。以上都是伪代码。具体就是为了说明这个装饰者模式的中心思想，以及我在项目中的运用，不保证一定完全正确，都是按照自己的理解写的。 PS：其他的设计模式等用到了再补充]]></content>
      <categories>
        <category>Android -设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（Design Patterns）（一）]]></title>
    <url>%2F2018%2F03%2F06%2FJava-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[设计模式的分类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 我只讲我用的多的，用的多的印象深刻，知道怎么讲，用的少的，不知道怎么讲。只讲我熟练的。 一、单例模式单例模式，我想应该做过开发的人都用过。 懒汉式（用的时候初始化，延迟加载）12345678910public class MySocket&#123; private static MySocket instance; private MySocket()&#123;&#125; public static synchronized MySocket getInstance()&#123; if(null == instance)&#123; instance = new MySocket(); &#125; return instance; &#125;&#125; &emsp;&emsp;这里在懒汉式的单例模式中加上了同步锁synchronized，所以，这是线程安全的，但是，也是因为锁，所以造成的效率低，可以根据不同实际情况判断是否需要加同步锁。 饿汉式（加载类的时候直接初始化）1234567public class MySocket&#123; private static MySocket instance = new MySocket(); private MySocket()&#123;&#125; public static MySocket getInstance()&#123; return instance; &#125;&#125; 双重校验锁1234567891011121314public class MySocket&#123; private static MySocket instance; private MySocket()&#123;&#125; public static MySocket getInstance()&#123; if(null == instance)&#123; synchronized(MySocket.class)&#123; if(null == instance)&#123; instance = new MySocket(); &#125; &#125; &#125; return instance; &#125;&#125; &emsp;&emsp;这里的双重校验锁，其实就是我这里的线程安全懒汉式的升级版本，双重校验锁很多开源框架都是用的这种单例，比方说：EventBus。关于单例模式的其他变种我就不说了。单例模式的最终目的，就是全局单例，一个项目不论哪里调用这个类都是引用的同一个对象。 二、工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public class FragmentFactory &#123; public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz) &#123; return createFragment(clz, null); &#125; public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz, Bundle bundle) &#123; if (HomeFragment.class == clz) &#123; return new HomeFragment(); &#125; else if (MyClothesFragment.class == clz) &#123; return new MyClothesFragment(); &#125; else if (WardrobeStructureFragment.class == clz) &#123; return new WardrobeStructureFragment(); &#125; else if (WifiFragment.class == clz) &#123; return new WifiFragment(); &#125; else if (WardrobeConfigFragment.class == clz) &#123; return new WardrobeConfigFragment(); &#125; else if (ShowFragment.class == clz) &#123; return new ShowFragment(); &#125; else &#123; throw new NullPointerException(&quot;not found fragment&quot;); &#125; &#125; public static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz) &#123; return createDialogFragment(clz, null); &#125; @SuppressWarnings(&quot;unchecked&quot;) private static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz, Bundle bundle) &#123; if (clz == IconDialogFragment.class) &#123; return (T) new IconDialogFragment(); &#125; else if (clz == PasswordDialogFragment.class) &#123; return (T) PasswordDialogFragment.newInstance(); &#125; else &#123; throw new NullPointerException(&quot;not found fragment&quot;); &#125; &#125;&#125; &emsp;&emsp;这个fragment工厂类，就是我项目里面用到的。常用的工厂模式就是静态工厂，利用static方法，我这里的工厂就是静态工厂。我们常说的工厂方法对应的这里是什么呢？其实，工厂方法也是一个普通的方法，对应的这里就是createFragment(Class&lt;? extends BaseFragment&gt; clz)。工厂模式什么时候用呢？在需要大量类似的数据的时候（个人观点），Android里面，工厂方法用的最多的就是创建Fragment。 三、抽象工厂模式1234567891011121314151617public interface IFragmentFactory&#123; BaseFragment createFragment();&#125;public class HomeFactory implements IFragmentFactory&#123; @Override public BaseFragment createFragment()&#123; return new HomeFragment(); &#125;&#125;public class WifiFragment implements IFragmentFactory&#123; @Override public BaseFragment createFragment()&#123; return new WifiFragment(); &#125;&#125; &emsp;&emsp;我把上面的静态工厂类，改成了抽象工厂类，就是上面的代码。就是有一个工厂接口或者抽象的工厂类，然后创建不同的工厂类去实现这个接口，实现对应的类，返回你需要的东西 四、建造者模式我之前写Luban源码解析的时候就讲过建造者模式，可以去看一下，就在源码解析的一开始 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.haichenyi.mytakephoto;/** * Author: 海晨忆 * Date: 2018/3/6 * Desc: */public class DataBean &#123; private String name; private int age; private String sex; public DataBean(Builder builder) &#123; this.name = builder.name; this.age = builder.age; this.sex = builder.sex; &#125; public static class Builder &#123; private String name; private int age = 20; private String sex = &quot;男&quot;; public Builder setName(String name) &#123; this.name = name; return this; &#125; public Builder setAge(int age) &#123; this.age = age; return this; &#125; public Builder setSex(String sex) &#123; this.sex = sex; return this; &#125; public DataBean build() &#123; return new DataBean(this); &#125; &#125;&#125; &emsp;&emsp;上面的代码就是一个DataBean类，用建造者模式创建。要是还是不懂，你可以理解成，我们常常在写bean类的时候，往往要写set方法，你可以理解成，把set方法写在Builder里面，在Builder里面赋好值之后，在我们bean类的构造方法里面传递过来就可以了。 五、原型模式这个模式，我没用到过，网上搜的是，类似于拷贝功能。可以自行搜索。]]></content>
      <categories>
        <category>Android -设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2F2018%2F03%2F06%2FJava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;在运行过程中，对任意一个类，都能知道这个类的所有属性和方法。对于任一个对象，都能调用他的任意一个方法和属性。这种动态获取信息以及动态调用对象的方法称为java语言的反射机制 用法我这里就列出我常用的两个方法私有类和变量 方法Methods 方法 用途 getDeclaredMethods() 获取当前类的所有方法，包括public/private/protected/default修饰的方法 getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取当前类的某一个方法,包括public/private/protected/default修饰的方法 getMethods() 获取当前类和所继承父类的public标识的所有方法，仅仅包括public getMethod(String name, Class&lt;?&gt;… parameterTypes) 获取当前类和所继承父类的public标识的某一个方法，仅仅包括public &emsp;&emsp;上面就是两个类型的方法，一个是只获取当前类的方法，获取当前类的方法，包括所有类型的方法：public/private/protected/default。还有一个是获取当前类和所继承的父类的方法，仅仅包括public修饰的方法。 调用方式1234567//在TakePhotoActivity.class类中有两个重载方法，一个无参，一个有一个String类型的参数private void myTest()&#123; Log.v(&quot;WZ&quot;,&quot;myTest无参&quot;); &#125;private void myTest(String msg)&#123; Log.v(&quot;WZ&quot;,&quot;myTest有参&quot;); &#125; 调用无参的方法1234567891011TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象try &#123;Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象Method myTest = aClass1.getDeclaredMethod(&quot;myTest&quot;);myTest.setAccessible(true);//参数值为true，禁止访问控制检查myTest.invoke(takePhotoActivity);//执行私有方法&#125; catch (Exception e) &#123; e.printStackTrace(); Log.v(&quot;WZ&quot;, e.getMessage()); &#125; 调用有参的方法123456789101112TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象Class[] arr = new Class[]&#123;String.class&#125;;try &#123;Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象Method myTest = aClass1.getDeclaredMethod(&quot;myTest&quot;,arr);myTest.setAccessible(true);//参数值为true，禁止访问控制检查myTest.invoke(takePhotoActivity,&quot;s&quot;);//执行私有方法&#125; catch (Exception e) &#123; e.printStackTrace(); Log.v(&quot;WZ&quot;, e.getMessage()); &#125; 有参的方法，在获取方法的时候，传一个Class[]数组，里面的值就是参数类型的类。或者还有另一种传的方法，前面获取方法的时候： 获取方法的时候，无参的传一个空的Class[]，有参就传有值的Class[]数组 执行方法的时候，无参的传一个空的Object[]，有参就传有值的Object[]数组,至于传的值随便写，类型一样就行 变量Field 方法 用途 getDeclaredFields() 获取当前类的所有类型的全局变量,包括public/private/protected/default修饰的变量 getDeclaredField(String name) 获取当前类的某一个类型的全局变量,包括public/private/protected/default修饰的变量 getFields() 获取当前类和继承父类的所有用public修饰的变量 getField(String name) 获取当前类和继承父类的某一个用public修饰的变量 调用方式12//在TakePhotoActivity里面定义private int flag; 获取变量123456789101112TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象try &#123;Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象Field flag = aClass.getDeclaredField(&quot;flag&quot;);flag.setAccessible(true);Object o = flag.get(takePhotoActivity);//这里就获取到了对象...//做你自己的逻辑处理&#125; catch (Exception e) &#123; e.printStackTrace(); Log.v(&quot;WZ&quot;, e.getMessage()); &#125; 设置变量的值12//获取变量的值跟上面一样flag.set(takePhotoActivity,10);//这样写会改变TakePhotoActivity中flag的值 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * Author: 海晨忆. * Date: 2018/3/6 * Desc: 反射工具类 */public class ReflectionUtil &#123; /*** * 获取私有成员变量的值 * */ public static Object getValue(Object instance, String fieldName) throws IllegalAccessException, NoSuchFieldException &#123; Field field = instance.getClass().getDeclaredField(fieldName); field.setAccessible(true); // 参数值为true，禁止访问控制检查 return field.get(instance); &#125; /*** * 设置私有成员变量的值 * */ public static void setValue(Object instance, String fileName, Object value) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123; Field field = instance.getClass().getDeclaredField(fileName); field.setAccessible(true); field.set(instance, value); &#125; /*** * 访问私有方法 * */ public static Object callMethod(Object instance, String methodName, Class[] classes, Object[] objects) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; Method method = instance.getClass().getDeclaredMethod(methodName, classes); method.setAccessible(true); return method.invoke(instance, objects); &#125;&#125;]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EventBus源码解析(一)——获取EventBus对象]]></title>
    <url>%2F2018%2F03%2F06%2FEventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96EventBus%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[简介我们先来看一下他的类注释 12345678910/** * EventBus is a central publish/subscribe event system for Android. Events are posted (&#123;@link #post(Object)&#125;) to the * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events, * subscribers must register themselves to the bus using &#123;@link #register(Object)&#125;. Once registered, subscribers * receive events until &#123;@link #unregister(Object)&#125; is called. Event handling methods must be annotated by * &#123;@link Subscribe&#125;, must be public, return nothing (void), and have exactly one parameter * (the event). * * @author Markus Junginger, greenrobot */ &emsp;&emsp;英语不是很好，大致讲一下这段话是什么意思：EventBus是重要的发布/订阅的Android事件系统。事件被发布给总线，这个总线将这个事件传递给跟他匹配类型的订阅者。接收事件必须在总线使用的时候注册他们。一旦注册，订阅者就会一直接收事件，直到他们被取消注册。这个接收方法必须增加注解Subscribe标识，必须是public，返回类型是void，并且只有一个参数。 简单的来说，就是用之前必须先注册，然后接收方法必须有Subscribe注解，必须是public，返回类型是void并且只有一个参数 简单用法第一步：依赖1implementation &apos;org.greenrobot:eventbus:3.1.1&apos; 第二步：注册与反注册1234//注册，在onCrate里面EventBus.getDefault().register(this)//反注册，在onDestory里面EventBus.getDefault().unregister(this) 第三步：接收方法1234@Subscribepublic void handle(MyClothes myClothes)&#123; //你的具体逻辑&#125; 第四步：发送1EventBus.getDefault().post(new MyClothes()) &emsp;&emsp;经过上面三步，你就可以正常使用EventBus了，前面两步要在一个类里面，因为接收之前，必须要注册，可以在任意的地方post 源码解析—getDefault()12345678910public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; &emsp;&emsp;可以看到这里使用的是双重校验锁的单例模式，保证不同的线程调用该方法得到的都是同一个EventBus实例。 EventBus()看到上面的单例模式之后，我们再来瞅瞅单例模式里面调用的构造方法 123public EventBus() &#123; this(DEFAULT_BUILDER); &#125; 这里他的空参数的构造方法里面调用的是一个参数的构造方法，我们来看看这个参数是什么？ 1private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder(); EventBusBuilder()12EventBusBuilder() &#123; &#125; 这个builder的构造方法里面什么都没有，也就是说没有初始化任何变量，那我们看一看他的变量，这里我就说一个： 123private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE; Executors.newCachedThreadPool() 创建的是一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空线程池，若无回收，可新建线程。 接下来，我们再来看看只有EventBusBuilder参数的构造方法 EventBus(EventBusBuilder builder)123456789EventBus(EventBusBuilder builder) &#123; subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null; backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); ... &#125; &emsp;&emsp;讲到这里，很明显，他这里用的是建造者模式，跟我们之前讲的Luban的模式是一样的，这个建造者模式，我就不讲了。讲Luban的时候讲过的 &emsp;&emsp;这里我列出来的6个变量，其他变量并没有列出来，因为，其他变量都是builder里面的赋值，没有啥好讲的。我们来看看这6个成员变量的类型 123456private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;private final Poster mainThreadPoster;private final BackgroundPoster backgroundPoster;private final AsyncPoster asyncPoster; 意义： subscriptionsByEventType：可以看到这是一个是以event的class为key，以subscribe的list为value的map，有的人可能不知道CopyOnWriteArrayList，这是ArrayList的一个线程安全变种。（这里，有人会点到Subscription里面去看一下，可以看到就是一个类，封装了订阅者和订阅方法，重写了hashcode和equal方法） typesBySubscriber：这是以订阅者类为key，以event的list为value的map，在注册和反注册的时候用的到 stickyEvents：粘性事件，以event的class为key，订阅者为value的map 后面这三个Poster都是用来处理粘性事件的 &emsp;&emsp;我们说了这么多成员变量。我们知道这里的EventBusBuilder就是给EventBus初始化成员变量的，辣么，我们可不可以不用getDefault，获取eventBus对象呢？ 123EventBus build1 = EventBus.getDefault();EventBus build2 = EventBus.builder().build(); 这两个build的区别是什么呢？我们可以点到build()方法里面去看一下： 123public EventBus build() &#123; return new EventBus(this); &#125; 他这里是直接new出来的，并没有单例，所以每次使用的都是new一个新的对象，而通过getDefault，获得是同一个对象]]></content>
      <categories>
        <category>Android -源码解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android二维码扫描——BGAQRCode-Android]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E2%80%94%E2%80%94BGAQRCode-Android%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;做过二维码扫描的童鞋都知道，要用Zxing，可是google官方推的Zxing，我们集成扫描的时候很慢，有时候就直接扫不出来，体验太差了。因为他适配了太多东西，我们只要一个扫描功能，然后就去网上搜索，怎么使zxing扫描变的很快，zxing的优化，然后跟着网上的博客，一步一步走，即使最终做完了，感觉体验还是不够好。我这里推荐一个二维码扫描的开源框架——BGAQRCode-Android &emsp;&emsp;QRCode 扫描二维码、扫描条形码、相册获取图片后识别、生成带 Logo 二维码、支持微博微信、QQ 二维码扫描样式。他把Zbar和Zxing，都做了优化，扫描速度非常快，用户体验很好，用起来也非常方便 依赖123implementation &apos;cn.bingoogolapple:bga-qrcode-zbar:1.2.1&apos;或者implementation &apos;cn.bingoogolapple:bga-qrcode-zxing:1.2.1&apos; 用法以Zbar为例（Zxing类似） 第一步：XML文件1234567891011121314&lt;cn.bingoogolapple.qrcode.zbar.ZBarView android:id=&quot;@+id/zbarview&quot; style=&quot;@style/MatchMatch&quot; app:qrcv_animTime=&quot;1000&quot; app:qrcv_borderColor=&quot;@android:color/white&quot; app:qrcv_borderSize=&quot;1dp&quot; app:qrcv_cornerColor=&quot;@color/colorPrimaryDark&quot; app:qrcv_cornerLength=&quot;20dp&quot; app:qrcv_cornerSize=&quot;3dp&quot; app:qrcv_isShowDefaultScanLineDrawable=&quot;true&quot; app:qrcv_maskColor=&quot;#33FFFFFF&quot; app:qrcv_rectWidth=&quot;200dp&quot; app:qrcv_scanLineColor=&quot;@color/colorPrimaryDark&quot; app:qrcv_topOffset=&quot;90dp&quot; /&gt; 自定义属性说明 属性名 说明 默认值 qrcv_topOffset 扫描框距离 toolbar 底部的距离 90dp qrcv_cornerSize 扫描框边角线的宽度 3dp qrcv_cornerLength 扫描框边角线的长度 20dp qrcv_cornerColor 扫描框边角线的颜色 @android:color/white qrcv_rectWidth 扫描框的宽度 200dp qrcv_barcodeRectHeight 条码扫样式描框的高度 140dp qrcv_maskColor 除去扫描框，其余部分阴影颜色 #33FFFFFF qrcv_scanLineSize 扫描线的宽度 1dp qrcv_scanLineColor 扫描线的颜色「扫描线和默认的扫描线图片的颜色」 @android:color/white qrcv_scanLineMargin 扫描线距离上下或者左右边框的间距 0dp qrcv_isShowDefaultScanLineDrawable 是否显示默认的图片扫描线「设置该属性后 qrcv_scanLineSize 将失效，可以通过 qrcv_scanLineColor 设置扫描线的颜色，避免让你公司的UI单独给你出特定颜色的扫描线图片」 false qrcv_customScanLineDrawable 扫描线的图片资源「默认的扫描线图片样式不能满足你的需求时使用，设置该属性后 qrcv_isShowDefaultScanLineDrawable、qrcv_scanLineSize、qrcv_scanLineColor 将失效」 null qrcv_borderSize 扫描边框的宽度 1dp qrcv_borderColor 扫描边框的颜色 @android:color/white qrcv_animTime 扫描线从顶部移动到底部的动画时间「单位为毫秒」 1000 qrcv_isCenterVertical 扫描框是否垂直居中，该属性为true时会忽略 qrcv_topOffset 属性 false qrcv_toolbarHeight Toolbar 的高度，通过该属性来修正由 Toolbar 导致扫描框在垂直方向上的偏差 0dp qrcv_isBarcode 是否是扫条形码 false qrcv_tipText 提示文案 null qrcv_tipTextSize 提示文案字体大小 14sp qrcv_tipTextColor 提示文案颜色 @android:color/white qrcv_isTipTextBelowRect 提示文案是否在扫描框的底部 false qrcv_tipTextMargin 提示文案与扫描框之间的间距 20dp qrcv_isShowTipTextAsSingleLine 是否把提示文案作为单行显示 false qrcv_isShowTipBackground 是否显示提示文案的背景 false qrcv_tipBackgroundColor 提示文案的背景色 #22000000 qrcv_isScanLineReverse 扫描线是否来回移动 true qrcv_isShowDefaultGridScanLineDrawable 是否显示默认的网格图片扫描线 false qrcv_customGridScanLineDrawable 扫描线的网格图片资源 null qrcv_isOnlyDecodeScanBoxArea 是否只识别扫描框区域的二维码 false 第二步：获取控件，并实现QRCodeView.Delegate接口123456789101112131415QRCodeView mQRCodeView = (ZBarView) findViewById(R.id.zbarview);mQRCodeView.setDelegate(this);@Override public void onScanQRCodeSuccess(String result) &#123; vibrate(); Toast.makeText(this,result,Toast.LENGTH_SHORT).show(); mQRCodeView.startSpot(); &#125; @Override public void onScanQRCodeOpenCameraError() &#123; Toast.makeText(this,&quot;错误&quot;,Toast.LENGTH_SHORT).show(); &#125; 第四步：实现onStart，onStop，onDestroy方法1234567891011121314151617181920212223242526@Override protected void onStart() &#123; super.onStart(); mQRCodeView.startCamera();//打开相机 mQRCodeView.showScanRect();//显示扫描框 mQRCodeView.startSpot();//开始识别二维码 //mQRCodeView.openFlashlight();//开灯 //mQRCodeView.closeFlashlight();//关灯 &#125; @Override protected void onStop() &#123; mQRCodeView.stopCamera(); super.onStop(); &#125; @Override protected void onDestroy() &#123; mQRCodeView.onDestroy(); super.onDestroy(); &#125; private void vibrate() &#123; Vibrator vibrator = (Vibrator) getSystemService(VIBRATOR_SERVICE); vibrator.vibrate(200); &#125; 第五步：添加权限12&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt; 经过上面5步，扫描功能就已经出来了，Zbar扫描比Zxing快，Zbar是基于C实现的，Zxing是基于C++。有个问题就是Zbar无法生成二维码，如果你是集成的BGA的Zxing可以生成二维码。Zxing生成二维码的方式如下： 耗时操作，新开线程 123456//中文Bitmap bitmap = QRCodeEncoder.syncEncodeQRCode(&quot;海晨忆&quot;, BGAQRCodeUtil.dp2px(this, 150));//带logoBitmap logoBitmap = BitmapFactory.decodeResource(TestGeneratectivity.this.getResources(), R.mipmap.logo);QRCodeEncoder.syncEncodeQRCode(&quot;海晨忆&quot;, BGAQRCodeUtil.dp2px(TestGeneratectivity.this, 150), Color.parseColor(&quot;#ff0000&quot;), logoBitmap); 解析图片二维码 1234567//mEnglishLogoIv：显示二维码的控件mEnglishLogoIv.setDrawingCacheEnabled(true);Bitmap bitmap = mEnglishLogoIv.getDrawingCache();//返回二维码图片里的内容 或 nullString result = QRCodeDecoder.syncDecodeQRCode(bitmap);String result = QRCodeDecoder.syncDecodeQRCode(picturePath);]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android WIFI功能——WifiManager]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid-WIFI%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94WifiManager%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前做了关于Android wifi的相关功能，这里做一个记录 第一步：获取WifiManager1WifiManager wifiMgr = (WifiManager)Context.getSystemService(Context.WIFI_SERVICE); 第二步：获取周围热点信息和已连接wifi信息12List&lt;ScanResult&gt; scanResults = wifiMgr.getScanResults();//扫描到的周围热点信息WifiInfo info = wifiMgr.getConnectionInfo();//已连接wifi信息 这里我说一下几个字段的意思： 1234public String name;//ssid对应的wifi名字public String capabilities;//用来判断是否有密码public int level;//信号等级，这里是负数public String BSSID;//macid 这里我需要强调的就是level，是负数，负数越大，信号越好 第三步：检测wifi信息，这里我给出几个工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 连接有密码的wifi. * * @param SSID ssid * @param Password Password * @return apConfig */ private WifiConfiguration setWifiParamsPassword(String SSID, String Password) &#123; WifiConfiguration apConfig = new WifiConfiguration(); apConfig.SSID = &quot;\&quot;&quot; + SSID + &quot;\&quot;&quot;; apConfig.preSharedKey = &quot;\&quot;&quot; + Password + &quot;\&quot;&quot;; //不广播其SSID的网络 apConfig.hiddenSSID = true; apConfig.status = WifiConfiguration.Status.ENABLED; //公认的IEEE 802.11验证算法。 apConfig.allowedAuthAlgorithms.clear(); apConfig.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN); //公认的的公共组密码 apConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP); apConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP); //公认的密钥管理方案 apConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK); //密码为WPA。 apConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP); apConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP); //公认的安全协议。 apConfig.allowedProtocols.set(WifiConfiguration.Protocol.RSN); return apConfig; &#125; /** * 连接没有密码wifi. * * @param ssid ssid * @return configuration */ private WifiConfiguration setWifiParamsNoPassword(String ssid) &#123; WifiConfiguration configuration = new WifiConfiguration(); configuration.SSID = &quot;\&quot;&quot; + ssid + &quot;\&quot;&quot;; configuration.status = WifiConfiguration.Status.ENABLED; configuration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP); configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK); configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE); configuration.allowedPairwiseCiphers .set(WifiConfiguration.PairwiseCipher.TKIP); configuration.allowedPairwiseCiphers .set(WifiConfiguration.PairwiseCipher.CCMP); configuration.allowedProtocols.set(WifiConfiguration.Protocol.RSN); return configuration; &#125; public static final int WIFI_NO_PASS = 0; private static final int WIFI_WEP = 1; private static final int WIFI_PSK = 2; private static final int WIFI_EAP = 3; /** * 判断是否有密码. * * @param result ScanResult * @return 0 */ public static int getSecurity(MyScanResult result) &#123; if (null != result &amp;&amp; null != result.capabilities) &#123; if (result.capabilities.contains(&quot;WEP&quot;)) &#123; return WIFI_WEP; &#125; else if (result.capabilities.contains(&quot;PSK&quot;)) &#123; return WIFI_PSK; &#125; else if (result.capabilities.contains(&quot;EAP&quot;)) &#123; return WIFI_EAP; &#125; &#125; return WIFI_NO_PASS; &#125; 上面三个工具类，一个用来判断是否需要密码，另外两个用来连接wifi 连接wifi123456//需要密码wifiMgr.enableNetwork(wifiMgr.addNetwork( setWifiParamsPassword(mClickResult.name, password)), true);//不需要密码wifiMgr.enableNetwork(wifiMgr.addNetwork(setWifiParamsNoPassword(mClickResult.name)), true); wifi监听PS：关于wifi状态的监听，就是监听你当前的网络状态即可。 12345678&lt;receiver android:name=&quot;.receiver.NetworkReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.net.wifi.WIFI_STATE_CHANGED&quot;/&gt; &lt;action android:name=&quot;android.net.wifi.STATE_CHANGE&quot;/&gt; &lt;action android:name=&quot;android.net.wifi.supplicant.STATE_CHANGE&quot;/&gt; &lt;action android:name=&quot;android.net.wifi.NETWORK_IDS_CHANGED&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 首先在你的清单文件注册这四种action的广播，这里给出我的网络监听广播 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * Author: 海晨忆. * Date: 2018/1/10 * Desc: 网络广播监听 */public class NetworkReceiver extends BroadcastReceiver &#123; public static final int STATE1 = 1;//密码错误 public static final int STATE2 = 2;//连接成功 public static final int STATE3 = 3;//连接失败 public static final int STATE4 = 4;//正在获取ip地址 public static final int STATE5 = 5;//正在连接 @Override public void onReceive(Context context, Intent intent) &#123; if (WifiManager.SUPPLICANT_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123; //密码错误广播,是不是正在获得IP地址 int linkWifiResult = intent.getIntExtra(WifiManager.EXTRA_SUPPLICANT_ERROR, -1); if (linkWifiResult == WifiManager.ERROR_AUTHENTICATING) &#123; //密码错误 ToastUtils.showTipMsg(R.string.password_wrong); sendNetworkStateChange(new NetWorkInfo().setState(STATE1)); &#125; SupplicantState supplicantState = intent.getParcelableExtra(WifiManager.EXTRA_NEW_STATE); NetworkInfo.DetailedState state = WifiInfo.getDetailedStateOf(supplicantState); Log.v(Constants.HTTP_WZ, state.name()); if (state == NetworkInfo.DetailedState.CONNECTING) &#123; //正在连接 ToastUtils.showTipMsg(R.string.linking); sendNetworkStateChange(new NetWorkInfo().setState(STATE5)); &#125; else if (state == NetworkInfo.DetailedState.FAILED || state == NetworkInfo.DetailedState.DISCONNECTING) &#123; //连接失败 sendNetworkStateChange(new NetWorkInfo().setState(STATE3)); ToastUtils.showTipMsg(R.string.linked_failed); &#125; else if (state == NetworkInfo.DetailedState.CONNECTED) &#123; //连接成功 ToastUtils.showTipMsg(R.string.linked_success); &#125; else if (state == NetworkInfo.DetailedState.OBTAINING_IPADDR) &#123; //正在获取ip地址 sendNetworkStateChange(new NetWorkInfo().setState(STATE4)); &#125; else if (state == NetworkInfo.DetailedState.IDLE) &#123; //闲置的 ConnectivityManager connectManager = (ConnectivityManager) BaseApplication.getInstance() .getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo activeNetworkInfo = null; if (connectManager != null) &#123; activeNetworkInfo = connectManager.getActiveNetworkInfo(); &#125; if (activeNetworkInfo == null) &#123; sendNetworkStateChange(new NetWorkInfo().setState(STATE3)); ToastUtils.showTipMsg(R.string.linked_failed); &#125; &#125; &#125; else if (WifiManager.WIFI_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123; // 监听wifi的打开与关闭，与wifi的连接无关 int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, 0); Log.v(Constants.HTTP_WZ, &quot;wifiState:&quot; + wifiState); switch (wifiState) &#123; case WifiManager.WIFI_STATE_DISABLING://正在停止0 ToastUtils.showTipMsg(R.string.close_wifi); break; case WifiManager.WIFI_STATE_DISABLED://已停止1 break; case WifiManager.WIFI_STATE_UNKNOWN://未知4 break; case WifiManager.WIFI_STATE_ENABLING://正在打开2 ToastUtils.showTipMsg(R.string.opening_wifi); break; case WifiManager.WIFI_STATE_ENABLED://已开启3 break; default: break; &#125; &#125; else if (WifiManager.NETWORK_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123; // 监听wifi的连接状态即是否连上了一个有效无线路由 Parcelable parcelableExtra = intent .getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO); if (null != parcelableExtra) &#123; // 获取联网状态的NetWorkInfo对象 NetworkInfo networkInfo = (NetworkInfo) parcelableExtra; //获取的State对象则代表着连接成功与否等状态 NetworkInfo.State state = networkInfo.getState(); //判断网络是否已经连接 boolean isConnected = state == NetworkInfo.State.CONNECTED; Log.v(Constants.HTTP_WZ, &quot;isConnected:&quot; + isConnected); if (isConnected) &#123; ToastUtils.showTipMsg(R.string.linked_success); sendNetworkStateChange(new NetWorkInfo().setState(STATE2)); &#125; &#125; &#125; &#125; /** * 发送网络状态eventBus. * * @param info info */ private void sendNetworkStateChange(NetWorkInfo info) &#123; EventBus.getDefault().post(info); &#125; @SuppressWarnings(&quot;unused&quot;) private String getConnectionType(int type) &#123; String connType = &quot;&quot;; if (type == ConnectivityManager.TYPE_MOBILE) &#123; connType = &quot;移动网络&quot;; &#125; else if (type == ConnectivityManager.TYPE_WIFI) &#123; connType = &quot;WIFI网络&quot;; &#125; return connType; &#125; public static class NetWorkInfo &#123; public int state;//1密码错误，2:连接成功，3:连接失败 private NetWorkInfo setState(int state) &#123; this.state = state; return this; &#125; &#125;&#125; 注释应该写的很清楚，我就不做过多的解释了。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单的蓝牙通信]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%AE%80%E5%8D%95%E7%9A%84%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前公司做智能家居类型，其中做了一个智能衣柜项目，与衣柜通信就是用的蓝牙通信。一些操作一些简单的开关指令，蓝牙通信与socket是类似的。 步骤 清单文件注册权限 启动蓝牙服务（记得在清单文件中静态注册服务） 注册蓝牙广播（在蓝牙服务中动态注册蓝牙广播） 搜索，绑定，完成 退出app，停止服务，并在蓝牙服务的onDestory方法中取消注册蓝牙广播 不想写说明，只想贴代码 第一步：注册权限123&lt;!--获取蓝牙信息状态权限--&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 第二步、第三步、第五步：启动蓝牙服务，注册蓝牙广播，停止服务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Author: 海晨忆. * Date: 2018/1/4 * Desc: */public class BluetoothService extends Service &#123; //得到蓝牙适配器 private BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); private BluetoothReceiver mReceiver; @Override public void onCreate() &#123; super.onCreate(); EventBus.getDefault().register(this); if (mBluetoothAdapter != null) &#123; mReceiver = new BluetoothReceiver().setBluetoothAdapter(mBluetoothAdapter); //注册设备被发现时的广播 IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); registerReceiver(mReceiver, filter); //注册一个搜索结束时的广播 IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); registerReceiver(mReceiver, filter2); startLinkBluetooth(); &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; /** * 开始连接蓝牙设备. */ private void startLinkBluetooth() &#123; if (null != mBluetoothAdapter) &#123; //判断蓝牙是否打开 if (!mBluetoothAdapter.isEnabled()) &#123; //若没打开则打开蓝牙 mBluetoothAdapter.enable(); &#125; mBluetoothAdapter.startDiscovery(); Log.v(Constants.HTTP_WZ, &quot;正在扫描&quot;); &#125; &#125; @Subscribe @SuppressWarnings(&quot;unused&quot;) public void handleMsg(BluetoothInfo bluetoothInfo) &#123; if (bluetoothInfo.isLink) &#123; startLinkBluetooth(); &#125; &#125; public static class BluetoothInfo &#123; private boolean isLink = false; public BluetoothInfo setLink(boolean link) &#123; this.isLink = link; return this; &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); if (mReceiver != null) &#123; mReceiver.unRegister(); unregisterReceiver(mReceiver); &#125; &#125;&#125; 这个就是我的蓝牙服务类，这个类的逻辑怎么走的呢？ EventBus的东西我就不说了 首先获取蓝牙适配器 1BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); 初始化蓝牙广播，注册蓝牙广播 12345678910if (mBluetoothAdapter != null) &#123; mReceiver = new BluetoothReceiver().setBluetoothAdapter(mBluetoothAdapter); //注册设备被发现时的广播 IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); registerReceiver(mReceiver, filter); //注册一个搜索结束时的广播 IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); registerReceiver(mReceiver, filter2); startLinkBluetooth(); &#125; 开始准备连接蓝牙设备 1234567891011121314/** * 开始连接蓝牙设备. */ private void startLinkBluetooth() &#123; if (null != mBluetoothAdapter) &#123; //判断蓝牙是否打开 if (!mBluetoothAdapter.isEnabled()) &#123; //若没打开则打开蓝牙 mBluetoothAdapter.enable(); &#125; mBluetoothAdapter.startDiscovery(); Log.v(Constants.HTTP_WZ, &quot;正在扫描&quot;); &#125; &#125; 上面4步蓝牙扫描就完成了，这里我还要说的是，在服务的onDestory方法里面，记得停止服务 123456789@Override public void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); if (mReceiver != null) &#123; mReceiver.unRegister(); unregisterReceiver(mReceiver); &#125; &#125; 再就是在清单文件里面静态注册蓝牙服务 1&lt;service android:name=&quot;.service.BluetoothService&quot;/&gt; 启动服务的方式，我用的是非绑定的方式，同样，记得停止服务。 12Intent bluetoothService = new Intent(this, BluetoothService.class);startService(bluetoothService);//启动蓝牙服务 1stopService(bluetoothService); 123456@Nullable @Override public IBinder onBind(Intent intent) &#123; //非绑定方式，返回值为null return null; &#125; 第四步：搜索，绑定，完成搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * Author: 海晨忆. * Date: 2018/1/4 * Desc: 蓝牙广播监听 */public class BluetoothReceiver extends BroadcastReceiver &#123; //衣柜的蓝牙名称 private static final String WARDROBE_NAME = &quot;WARDROBE&quot;; // 固定的UUID private static final String SPP_UUID = &quot;00001101-0000-1000-8000-00805F9B34FB&quot;; private BluetoothSocket bluetoothSocket; private BluetoothAdapter bluetoothAdapter; private InputStream mInputStream; private OutputStream outputStream; private boolean isRunning = false; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (action != null) &#123; if (action.equals(BluetoothDevice.ACTION_FOUND)) &#123; BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); Log.v(Constants.HTTP_WZ, device.getName() + device.getAddress()); if (device.getBondState() == BluetoothDevice.BOND_BONDED &amp;&amp; device.getName().equals(WARDROBE_NAME)) &#123; UUID uuid = UUID.fromString(SPP_UUID); try &#123; bluetoothSocket = device.createRfcommSocketToServiceRecord(uuid); Log.v(Constants.HTTP_WZ, &quot;准备连接&quot;); connect(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; else if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) &#123; if (!EventBus.getDefault().isRegistered(this)) EventBus.getDefault().register(this); Observable.timer(2, TimeUnit.SECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(aLong -&gt; &#123; if (null == bluetoothSocket || !bluetoothSocket.isConnected()) ToastUtils.showTipMsg(R.string.no_wardrobe); &#125;); &#125; &#125; &#125; private void connect() &#123; new Thread(() -&gt; &#123; if (bluetoothSocket != null) &#123; bluetoothAdapter.cancelDiscovery(); try &#123; bluetoothSocket.connect(); Observable.just(1) .observeOn(AndroidSchedulers.mainThread()) .subscribe(integer -&gt; ToastUtils.showTipMsg(R.string.link_wardrobe)); Log.v(Constants.HTTP_WZ, &quot;连接成功&quot;); mInputStream = bluetoothSocket.getInputStream(); Log.v(Constants.HTTP_WZ, &quot;mInputSream:&quot; + mInputStream.toString()); isRunning = true; outputStream = bluetoothSocket.getOutputStream(); Log.v(Constants.HTTP_WZ, &quot;outputStream:&quot; + outputStream.toString()); BufferedReader br; while (isRunning) &#123; br = new BufferedReader(new InputStreamReader(mInputStream, &quot;utf-8&quot;)); String s = br.readLine(); //acceptReply(s); Log.v(Constants.HTTP_WZ, &quot;收到的数据:&quot; + s); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); try &#123; if (mInputStream != null) &#123; mInputStream.close(); Log.v(Constants.HTTP_WZ, &quot;mInputSream.close()&quot;); &#125; if (outputStream != null) &#123; outputStream.close(); Log.v(Constants.HTTP_WZ, &quot;outputStream.close()&quot;); &#125; if (bluetoothSocket != null) &#123; bluetoothSocket.close(); Log.v(Constants.HTTP_WZ, &quot;socket.close()&quot;); bluetoothSocket = null; &#125; isRunning = false; &#125; catch (Exception e2) &#123; // TODO: handle exception &#125; &#125; &#125; &#125;).start(); &#125; public BluetoothReceiver setBluetoothAdapter(BluetoothAdapter adapter) &#123; this.bluetoothAdapter = adapter; return this; &#125; /** * 反注册eventBus. */ public void unRegister() &#123; EventBus.getDefault().unregister(this); &#125;&#125; 这个就是我的蓝牙广播类，这个逻辑又是怎么走的呢？ 前面服务里面注册的两个action，一个BluetoothDevice.ACTION_FOUND，还有一个BluetoothAdapter.ACTION_DISCOVERY_FINISHED，做了一个if判断，是发现了设备还是已经完成了扫描设备 发现设备之后，获取蓝牙信息，他这里是获取到一个蓝牙信息就会走一遍这个方法，并不是说一次获取一个列表。 找到了蓝牙设备之后就是连接了，伪代码讲解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 固定的UUID连接的时候需要uuid private static final String SPP_UUID = &quot;00001101-0000-1000-8000-00805F9B34FB&quot;; //获取socketBluetoothSocket bluetoothSocket =device.createRfcommSocketToServiceRecord(uuid);//连接之前取消扫描，注意非空判断。adapter是在服务里面申明的，通过setBluetoothAdapter方法传过来的bluetoothAdapter.cancelDiscovery();//连接，这里是阻塞的方式，注意要新开线程连接bluetoothSocket.connect();//获取输入流对象和输出流对象InputStream mInputStream = bluetoothSocket.getInputStream();OutputStream outputStream = bluetoothSocket.getOutputStream();//发送消息private void sendInstruct(String msg) &#123; try &#123; if (null == bluetoothSocket || !bluetoothSocket.isConnected()) &#123; SocketUtils.reLinkBluetooth(); return; &#125; Log.v(Constants.HTTP_WZ, &quot;发送的数据--&gt;&quot; + msg + BluetoothInstruct.FINISH); outputStream.write(msg.getBytes()); outputStream.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;//接收消息，一次读一行，简单的蓝牙通信换行符作为结束标记BufferedReader br;while (isRunning) &#123; br = new BufferedReader(new InputStreamReader(mInputStream, &quot;utf-8&quot;)); String s = br.readLine(); acceptReply(s); Log.v(Constants.HTTP_WZ, &quot;收到的数据:&quot; + s); &#125; //异常的时候释放资源try &#123; if (mInputStream != null) &#123; mInputStream.close(); Log.v(Constants.HTTP_WZ, &quot;mInputSream.close()&quot;); &#125; if (outputStream != null) &#123; outputStream.close(); Log.v(Constants.HTTP_WZ, &quot;outputStream.close()&quot;); &#125; if (bluetoothSocket != null) &#123; bluetoothSocket.close(); Log.v(Constants.HTTP_WZ, &quot;socket.close()&quot;); bluetoothSocket = null; &#125; isRunning = false; &#125; catch (Exception e2) &#123; // TODO: handle exception &#125;]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android拍照功能——TakePhoto]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E6%8B%8D%E7%85%A7%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94TakePhoto%2F</url>
    <content type="text"><![CDATA[之前在写项目框架Andoroid 6.0，动态获取权限的时候就提到过TakePhoto开源框架 简介一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库 依赖1implementation &apos;com.jph.takephoto:takephoto_library:4.0.3&apos; 用法我这里就说拍照，选择相册的功能。其他功能请移步TakePhoto开源框架看说明文档，写的很清楚。最后会给出一个工具类，拷贝过去就可以直接用。 定义两个变量 12private TakePhoto takePhoto;private InvokeParam invokeParam; 添加如下代码获取TakePhoto实例 12345678public TakePhoto getTakePhoto()&#123; if (takePhoto==null)&#123; takePhoto= (TakePhoto) TakePhotoInvocationHandler.of(this).bind(new TakePhotoImpl(this,this)); &#125; //设置压缩规则，最大500kb takePhoto.onEnableCompress(new CompressConfig.Builder().setMaxSize(500 * 1024).create(), true); return takePhoto; &#125; 实现两个接口：TakePhoto.TakeResultListener,InvokeListener 在 onCreate,onActivityResult,onSaveInstanceState方法中调用TakePhoto对用的方法 1234567891011121314151617@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; getTakePhoto().onCreate(savedInstanceState); super.onCreate(savedInstanceState); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; getTakePhoto().onActivityResult(requestCode, resultCode, data); super.onActivityResult(requestCode, resultCode, data); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; getTakePhoto().onSaveInstanceState(outState); super.onSaveInstanceState(outState); &#125; 重写TPermissionType invoke(InvokeParam invokeParam)方法，添加如下代码：12345678910111213141516@Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); //以下代码为处理Android6.0、7.0动态权限所需 PermissionManager.TPermissionType type=PermissionManager.onRequestPermissionsResult(requestCode,permissions,grantResults); PermissionManager.handlePermissionsResult(this,type,invokeParam,this); &#125; @Override public PermissionManager.TPermissionType invoke(InvokeParam invokeParam) &#123; PermissionManager.TPermissionType type=PermissionManager.checkPermission(TContextWrap.of(this),invokeParam.getMethod()); if(PermissionManager.TPermissionType.WAIT.equals(type))&#123; this.invokeParam=invokeParam; &#125; return type; &#125; &emsp;&emsp;到这里，根据他官方的介绍就已经全部写完了，然后怎么分调用相机，相册还是文件夹呢？ 调用不同的方法，常用的：相机，相册，多选 123456789101112131415161718192021 flag = getIntent().getIntExtra(&quot;flag&quot;, 0); File file = new File(getExternalCacheDir(), System.currentTimeMillis() + &quot;.png&quot;); Uri uri = Uri.fromFile(file); int size = Math.min(getResources().getDisplayMetrics().widthPixels, getResources().getDisplayMetrics().heightPixels); CropOptions cropOptions = new CropOptions.Builder().setOutputX(size).setOutputX(size).setWithOwnCrop(false).create(); if (flag == 1) &#123; //相机获取照片并剪裁 takePhoto.onPickFromCaptureWithCrop(uri, cropOptions); //相机获取不剪裁 //takePhoto.onPickFromCapture(uri); &#125; else if (flag == 2) &#123; //相册获取照片并剪裁 takePhoto.onPickFromGalleryWithCrop(uri, cropOptions); //相册获取不剪裁// takePhoto.onPickFromGallery(); &#125; else if (flag == 3) &#123; //多选，并剪裁 takePhoto.onPickMultipleWithCrop(9, cropOptions); //多选，不剪裁// takePhoto.onPickMultiple(9); &#125; &emsp;&emsp;前面一个页面调用startActivityForResult，传一个标记过来，用来判断调用不同的方式。 &emsp;&emsp;我这里还想多说的是，一般我们这个拍照功能，都有三个选项，拍照，相册，取消，从底部弹出。这个我估计还是大部分人写的动画实现的。我想说的是BottomSheetDialog，这个是MD推出的一个控件，现在微信用的就是这个，用起来也非常方便，简单。 &emsp;&emsp;至于，工具类，直接下载项目，把对应的TakePhotoActivity文件拷贝过去就可以了。 资源链接]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android图片压缩——Luban鲁班压缩]]></title>
    <url>%2F2018%2F03%2F02%2FAndroid%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E2%80%94%E2%80%94Luban%E9%B2%81%E7%8F%AD%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Android让人头疼的OOM，造成OOM的原因之一就是图片，现在的手机像素越来越高，随便一张图片都是好几M，甚至几十M，这样的照片加载到app，可想而知，随便加载几张图片，手机内存就不够用了，自然而然就造成了OOM，所以，Android的图片压缩异常重要。这里，我推荐一款开源框架——Luban 效果与对比&emsp;&emsp;这里就不放效果图了，我拷贝了鲁班github上面的介绍——Android图片压缩工具，仿微信朋友圈压缩策略，因为是逆向推算，效果还没法跟微信一模一样，但是已经很接近微信朋友圈压缩后的效果，具体看以下对比！ 内容 原图 Luban Wechat 截屏 720P 720*1280,390k 720*1280,87k 720*1280,56k 截屏 1080P 1080*1920,2.21M 1080*1920,104k 1080*1920,112k 拍照 13M(4:3) 3096*4128,3.12M 1548*2064,141k 1548*2064,147k 拍照 9.6M(16:9) 4128*2322,4.64M 1032*581,97k 1032*581,74k 滚动截屏 1080*6433,1.56M 1080*6433,351k 1080*6433,482k 从这里就能看出，效果还是非常不错的 依赖1implementation &apos;top.zibin:Luban:1.1.3&apos; 调用方式异步调用&emsp;&emsp;Luban内部采用IO线程进行图片压缩，外部调用只需设置好结果监听即可： 1234567891011121314151617181920Luban.with(this) .load(photos) // 传人要压缩的图片列表 .ignoreBy(100) // 忽略不压缩图片的大小 .setTargetDir(getPath()) // 设置压缩后文件存储位置 .setCompressListener(new OnCompressListener() &#123; //设置回调 @Override public void onStart() &#123; // TODO 压缩开始前调用，可以在方法内启动 loading UI &#125; @Override public void onSuccess(File file) &#123; // TODO 压缩成功后调用，返回压缩后的图片文件 &#125; @Override public void onError(Throwable e) &#123; // TODO 当压缩过程出现问题时调用 &#125; &#125;).launch(); //启动压缩 同步调用&emsp;&emsp;同步方法请尽量避免在主线程调用以免阻塞主线程，下面以rxJava调用为例 12345678910Flowable.just(photos) .observeOn(Schedulers.io()) .map(new Function&lt;List&lt;String&gt;, List&lt;File&gt;&gt;() &#123; @Override public List&lt;File&gt; apply(@NonNull List&lt;String&gt; list) throws Exception &#123; // 同步方法直接返回压缩后的文件 return Luban.with(MainActivity.this).load(list).get(); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(); &emsp;&emsp;以上，均是它github上面说明都有的，我这里就是copy过来了而已。重点要说的是，他是怎么实现的，源码分析。 源码分析第一步：Luban.with()点击去看到源码为： 123public static Builder with(Context context) &#123; return new Builder(context); &#125; &emsp;&emsp;这里是一个静态的with方法，返回值是Builder，一般对设计模式比较熟悉的人，看到这里就应该懂了，他这里使用的是建造者模式。什么是建造者模式呢？建造者模式和工厂模式很相似，比工厂模式多了一个控制类，其实说白了，就是在创建对象的时候，减少初始化数据的代码，怎么理解呢？我们接着往下看。我们点到Builder里面看到如下代码： 12345678910111213141516public static class Builder &#123; private Context context;//上下文对象 private String mTargetDir;//压缩后图片存放位置 private List&lt;String&gt; mPaths;//多个文件的list private int mLeastCompressSize = 100;//忽略100kb以下的图片，不压缩 private OnCompressListener mCompressListener;//回调方法 Builder(Context context) &#123; this.context = context; this.mPaths = new ArrayList&lt;&gt;(); &#125; private Luban build() &#123; return new Luban(this); &#125;&#125; &emsp;&emsp;我们看到了是一个静态的内部类Builder，我们这里看到了有5个变量，上面我们说道了，为了减少初始化数据的代码，就拿这个举例子说明，我如果有4个地方调用这个鲁班压缩，其中这4个地方，mTargetDir，mLeastCompressSize这2个变量的值都是一样的，其他3个不一样，按照我们以往的写法都得一个一个的赋值，要写4遍，那如果使用建造者模式了，这里就只用写一遍赋值，这2个变量。其他3个不一样，就得写多遍。当然，这是我个人对于建造者模式的理解。 &emsp;&emsp;我上面多粘贴了一个build()方法，为什么会多粘贴一个呢？就是为了更好的说明建造者模式，我们可以看到他这个方法，返回的是Luban对象，调用的是需要传Builder的构造方法，我们点进去看 1234567private Luban(Builder builder) &#123; this.mPaths = builder.mPaths; this.mTargetDir = builder.mTargetDir; this.mCompressListener = builder.mCompressListener; this.mLeastCompressSize = builder.mLeastCompressSize; mHandler = new Handler(Looper.getMainLooper(), this); &#125; &emsp;&emsp;他这里就是赋值，他这个值就是Builder里面默认的，我们不论在哪里调用这个方法，都不用去一个一个赋值，因为，他已经处理好了。 第二步：load()点击去看到源码为 1234567891011121314public Builder load(File file) &#123; this.mPaths.add(file.getAbsolutePath()); return this; &#125; public Builder load(String string) &#123; this.mPaths.add(string); return this; &#125; public Builder load(List&lt;String&gt; list) &#123; this.mPaths.addAll(list); return this; &#125; &emsp;&emsp;这里，我们会看到三个重载方法，一个传文件，他会获取到文件的绝对路径存进去，实际上还是存的字符串，中间那个存的是字符串，最后面那个传String类型的list，它调用的addAll方法，最后还是存的String在mPaths里面。我们点击mPaths，他就是一个String类型的list，在Builder的构造方法里面初始化的。他就是存放你的图片路径的集合 第三步：ignoreBy() 和 setTargetDir()点击去看到源码为 123456789101112131415/** * do not compress when the origin image file size less than one value * * @param size * the value of file size, unit KB, default 100K */public Builder ignoreBy(int size) &#123; this.mLeastCompressSize = size; return this;&#125;public Builder setTargetDir(String targetDir) &#123; this.mTargetDir = targetDir; return this;&#125; &emsp;&emsp;这两个我为啥要放在一起讲呢？因为这两个没啥好说的，都是设置值，跟我们平时写的set方法的作用是一样的。没啥好说的 第四步：setCompressListener(OnCompressListener listener)点击去看到源码为 1234public Builder setCompressListener(OnCompressListener listener) &#123; this.mCompressListener = listener; return this; &#125; &emsp;&emsp;这个就是我们平时写自定义view的时候，要写回调方法，是一样的道理，他这里就是压缩方法的回调 第五步：launch()点击去看到源码为 123456/** * begin compress image with asynchronous */public void launch() &#123; build().launch(context);&#125; &emsp;&emsp;这里，我们看到他先调用了build(),我们前面讲了，他这个方法就是赋值，然后调用了launch(context)方法，我们点进去看： 123456789101112131415161718192021222324252627282930313233/** * start asynchronous compress thread */ @UiThread private void launch(final Context context) &#123; if (mPaths == null || mPaths.size() == 0 &amp;&amp; mCompressListener != null) &#123; mCompressListener.onError(new NullPointerException(&quot;image file cannot be null&quot;)); &#125; Iterator&lt;String&gt; iterator = mPaths.iterator(); while (iterator.hasNext()) &#123; final String path = iterator.next(); if (Checker.isImage(path)) &#123; AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_START)); File result = Checker.isNeedCompress(mLeastCompressSize, path) ? new Engine(path, getImageCacheFile(context, Checker.checkSuffix(path))).compress() : new File(path); mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_SUCCESS, result)); &#125; catch (IOException e) &#123; mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_ERROR, e)); &#125; &#125; &#125;); &#125; else &#123; Log.e(TAG, &quot;can not read the path : &quot; + path); &#125; iterator.remove(); &#125; &#125; &emsp;&emsp;这个方法就是最后，执行压缩的方法，前面都是初始化，我们可以看到，他这个方法是在主线程调用的，所以，我们不用考虑切换线程的问题，直接可以操作UI变化。我一步一步的讲： 首先，他这个是用的迭代器，循环遍历，遍历一个就移除一个 然后就是通过handler发消息调用 具体压缩代码。最重要的就是第三点，我把第三点，提到下面讲 接着上面的第三点，具体压缩 123File result = Checker.isNeedCompress(mLeastCompressSize, path) ? new Engine(path, getImageCacheFile(context, Checker.checkSuffix(path))).compress() : new File(path); 首先，他整体是一个三目运算符，我们点isNeedCompress()方法看一下 12345678910111213static boolean isNeedCompress(int leastCompressSize, String path) &#123; if (leastCompressSize &gt; 0) &#123; File source = new File(path); if (!source.exists()) &#123; return false; &#125; if (source.length() &lt;= (leastCompressSize &lt;&lt; 10)) &#123; return false; &#125; &#125; return true; &#125; &emsp;&emsp;这个方法就是用来判断，你给定路径的图片大小和你规定的忽略文件大小比较，他这里先做了你给定的最小值判断，要大于0，不大于0就返回ture。然后做了文件是否存在的判断，如果文件不存在，就返回fals。最后，给定文件大小是不是小于等于最小值左移10位的值，小于就返回false。 然后，如果返回的是true，就去压缩，如果，返回的是false，就直接返回file文件。压缩的方法点进去： 123456789101112131415Engine(String srcImg, File tagImg) throws IOException &#123; if (Checker.isJPG(srcImg)) &#123; this.srcExif = new ExifInterface(srcImg); &#125; this.tagImg = tagImg; this.srcImg = srcImg; BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; options.inSampleSize = 1; BitmapFactory.decodeFile(srcImg, options); this.srcWidth = options.outWidth; this.srcHeight = options.outHeight; &#125; &emsp;&emsp;这就又要说道另一个类了Engine类，它的类注释就是：用于操作，开始压缩，管理活动，缓存资源的类。他这里传原文件，也就是你需要压缩的图片，还有一个就是目标文件，也就是你压缩之后，要保存的文件。 &emsp;&emsp;我们先看第二个参数是什么怎么传的，有的人看不懂 123456789101112131415161718/** * Returns a mFile with a cache audio name in the private cache directory. * * @param context * A context. */ private File getImageCacheFile(Context context, String suffix) &#123; if (TextUtils.isEmpty(mTargetDir)) &#123; mTargetDir = getImageCacheDir(context).getAbsolutePath(); &#125; String cacheBuilder = mTargetDir + &quot;/&quot; + System.currentTimeMillis() + (int) (Math.random() * 1000) + (TextUtils.isEmpty(suffix) ? &quot;.jpg&quot; : suffix); return new File(cacheBuilder); &#125; &emsp;&emsp;他这里就是新建一个文件，设置路径，设置名称，然后返回文件 &emsp;&emsp;再掉回去看Engine的构造方法，我们这里获取到了源文件和目标文件，我们只用把压缩后的流存到目标文件就行了。我之前写过一篇关于图片压缩的博客。它这里的option就是设置压缩的参数，不懂的可以看一下我之前的博客，或者用google百度一下就知道了。具体压缩就是用的bitmap的工厂类，调用的decodeFile方法。没错就是这一句 BitmapFactory.decodeFile(srcImg, options); 最后，辣么一切都准备就绪了，怎么样开始压缩呢？compress() 12345678910111213141516171819File compress() throws IOException &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = computeSize(); Bitmap tagBitmap = BitmapFactory.decodeFile(srcImg, options); ByteArrayOutputStream stream = new ByteArrayOutputStream(); tagBitmap = rotatingImage(tagBitmap); tagBitmap.compress(Bitmap.CompressFormat.JPEG, 60, stream); tagBitmap.recycle(); FileOutputStream fos = new FileOutputStream(tagImg); fos.write(stream.toByteArray()); fos.flush(); fos.close(); stream.close(); return tagImg; &#125; &emsp;&emsp;这里面就是常规的压缩，存储的逻辑了，最最重要的压缩算法呢？就是这里的computeSize()方法 123456789101112131415161718192021222324private int computeSize() &#123; srcWidth = srcWidth % 2 == 1 ? srcWidth + 1 : srcWidth; srcHeight = srcHeight % 2 == 1 ? srcHeight + 1 : srcHeight; int longSide = Math.max(srcWidth, srcHeight); int shortSide = Math.min(srcWidth, srcHeight); float scale = ((float) shortSide / longSide); if (scale &lt;= 1 &amp;&amp; scale &gt; 0.5625) &#123; if (longSide &lt; 1664) &#123; return 1; &#125; else if (longSide &gt;= 1664 &amp;&amp; longSide &lt; 4990) &#123; return 2; &#125; else if (longSide &gt; 4990 &amp;&amp; longSide &lt; 10240) &#123; return 4; &#125; else &#123; return longSide / 1280 == 0 ? 1 : longSide / 1280; &#125; &#125; else if (scale &lt;= 0.5625 &amp;&amp; scale &gt; 0.5) &#123; return longSide / 1280 == 0 ? 1 : longSide / 1280; &#125; else &#123; return (int) Math.ceil(longSide / (1280.0 / scale)); &#125; &#125; 12345678910111213141516171819202122private Bitmap rotatingImage(Bitmap bitmap) &#123; if (srcExif == null) return bitmap; Matrix matrix = new Matrix(); int angle = 0; int orientation = srcExif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); switch (orientation) &#123; case ExifInterface.ORIENTATION_ROTATE_90: angle = 90; break; case ExifInterface.ORIENTATION_ROTATE_180: angle = 180; break; case ExifInterface.ORIENTATION_ROTATE_270: angle = 270; break; &#125; matrix.postRotate(angle); return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true); &#125; &emsp;&emsp;你以为我会一步一步给你讲Luban算法逻辑吗？那是不可能的，我特么都不会，怎么给你讲。我直接把他github上算法逻辑的介绍拷贝过来了： 判断图片比例值，是否处于以下区间内； [1, 0.5625) 即图片处于 [1:1 ~ 9:16) 比例范围内 [0.5625, 0.5) 即图片处于 [9:16 ~ 1:2) 比例范围内 [0.5, 0) 即图片处于 [1:2 ~ 1:∞) 比例范围内 判断图片最长边是否过边界值； [1, 0.5625) 边界值为：1664 n（n=1）, 4990 n（n=2）, 1280 * pow(2, n-1)（n≥3） [0.5625, 0.5) 边界值为：1280 * pow(2, n-1)（n≥1） [0.5, 0) 边界值为：1280 * pow(2, n-1)（n≥1） 计算压缩图片实际边长值，以第2步计算结果为准，超过某个边界值则：width / pow(2, n-1)，height/pow(2, n-1) 计算压缩图片的实际文件大小，以第2、3步结果为准，图片比例越大则文件越大。size = (newW newH) / (width height) * m； [1, 0.5625) 则 width &amp; height 对应 1664，4990，1280 * n（n≥3），m 对应 150，300，300； [0.5625, 0.5) 则 width = 1440，height = 2560, m = 200； [0.5, 0) 则 width = 1280，height = 1280 / scale，m = 500；注：scale为比例值 判断第4步的size是否过小 [1, 0.5625) 则最小 size 对应 60，60，100 [0.5625, 0.5) 则最小 size 都为 100 [0.5, 0) 则最小 size 都为 100 将前面求到的值压缩图片 width, height, size 传入压缩流程，压缩图片直到满足以上数值]]></content>
      <categories>
        <category>Android -源码解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（八）—— 私有目录被限制访问(Android 7.0)]]></title>
    <url>%2F2018%2F03%2F01%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E7%A7%81%E6%9C%89%E7%9B%AE%E5%BD%95%E8%A2%AB%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE-Android7.0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我这里只说我关心的问题，并不是说Android 7.0只增加了一个“私有目录被限制访问”，当然还有其他的变化。android 7.0的新特性中，对程序员开发造成最直接的变化就是FileUriExposedException异常，这个异常的产生就是由私有目录被限制访问造成的 &emsp;&emsp;Andoird 7.0中为了提高文件的安全性，面向Android N或者更高版本的应用私有目录将会被禁止访问，常见最直接的bug就是：你的应用给其他应用传递file:// URI类型的Uri时，可能导致接受者无法访问该路径会造成我们前面说的文件uri异常。 调用系统相机最直接的就是我们常用的拍照功能,我们自己的应用启动手机相机，这里手机相机就是其他应用，按照我们以前的写法就是： 1234567File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);if (!file.getParentFile().exists())file.getParentFile().mkdirs();Uri imageUri = Uri.fromFile(file);Intent intent = new Intent();intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);//设置Action为拍照intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);//将拍取的照片保存到指定URIstartActivityForResult(intent,986); &emsp;&emsp;先创建一个存放我们拍照图片的存放file，参数就是路径+文件名称，当我们还是按之前的写法，跑在android N及以上的机型的时候，会报如下异常： FileUriExposedException.png &emsp;&emsp;这就是由于Android 7.0执行了“StrictMode API 政策禁”对我们广大程序员造成的最常见，最直接的结果。辣么，怎么解决呢？ 解决办法FileProvider使用FileProvider解决上面的问题，步骤如下： 第一步：在清单文件里面申请provider123456789&lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;com.haichenyi.myproject.fileprovider&quot; android:grantUriPermissions=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; /&gt;&lt;/provider&gt; &emsp;&emsp;FileProvider是V4包下面的类，这里exproted属性必须给false，不然也会报异常，grantUriPermissions的值给true，表示授予临时URI访问权限，下面meta-data就是指定共享目录，authorities属性后面讲 第二步：指定共享目录12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;path&gt; &lt;external-path name=&quot;camera_photos&quot; path=&quot;&quot;/&gt; &lt;/path&gt;&lt;/resources&gt; &emsp;&emsp;有点android开发基础的人就知道，这个@xml目录是位于res根目录，跟layout目录平级的。所以，你得先创建xml文件夹，然后新建file_paths文件，添加上面的代码在文件中。这里的path路径，我们先瞅瞅下面的表： 物理路径 写法 Context.getFilesDir() + /path/ Context.getCacheDir() + /path/ Environment.getExternalStorageDirectory() + /path/ Context.getExternalFilesDir(String) + /path/ Context.getExternalCacheDir() + /path/ &emsp;&emsp;辣么，我们代码中path=””，是有特殊意义的，它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为path=”pictures”， 那么它代表着根目录下的pictures目录(eg:/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的 第三步：使用FileProvider12345678910val file = File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot; + System.currentTimeMillis() + &quot;.jpg&quot;) if (!file.parentFile.exists()) file.parentFile.mkdirs() //变化 val imageUri = FileProvider.getUriForFile(this, &quot;com.haichenyi.myproject.fileprovider&quot;, file)//通过FileProvider创建一个content类型的Uri val intent = Intent() //变化 intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION) //添加这一句表示对目标应用临时授权该Uri所代表的文件 intent.action = MediaStore.ACTION_IMAGE_CAPTURE//设置Action为拍照 intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri)//将拍取的照片保存到指定URI startActivityForResult(intent, 986) &emsp;&emsp;我们调用系统相机的代码发生了变化，变化的位置，我都注明了获取imageUri的方式发生了变化，其中，第二个参数就是我们在前面说放在后面讲的authorities属性的内容，再就是增加了一个flag，表示临时授权。加上如上代码，我们就可以正常调用系统相机了。 &emsp;&emsp;经过如上步骤之后，我们就能拍照了，拍完照片之后的存放路径在哪里呢？我们前面说了，这里我打印出了路径， 123file!!.absolutePath:/storage/emulated/0/temp/1519896174785.jpgimageUri:content://com.haichenyi.myproject.fileprovider/camera_photos/temp/1519896174785.jpg 照片裁剪Android 7.0之前，我们裁剪照片 1234567891011121314File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);if (!file.getParentFile().exists())file.getParentFile().mkdirs();Uri outputUri = Uri.fromFile(file);Uri imageUri=Uri.fromFile(new File(&quot;/storage/emulated/0/temp/1519896174785.jpg&quot;));Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);intent.setDataAndType(imageUri, &quot;image/*&quot;);intent.putExtra(&quot;crop&quot;, &quot;true&quot;);intent.putExtra(&quot;aspectX&quot;, 1);intent.putExtra(&quot;aspectY&quot;, 1);intent.putExtra(&quot;scale&quot;, true);intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri);intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());intent.putExtra(&quot;noFaceDetection&quot;, true); // no face detectionstartActivityForResult(intent,987); Android 7.0之后，我们裁剪照片 123456789101112131415File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);if (!file.getParentFile().exists())file.getParentFile().mkdirs();Uri outputUri = FileProvider.getUriForFile(context, &quot;com.haichenyi.myproject.fileprovider&quot;,file);Uri imageUri=FileProvider.getUriForFile(context, &quot;com.haichenyi.myproject.fileprovider&quot;, new File(&quot;/storage/emulated/0/temp/1519896174785.jpg&quot;);//通过FileProvider创建一个content类型的UriIntent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);intent.setDataAndType(imageUri, &quot;image/*&quot;);intent.putExtra(&quot;crop&quot;, &quot;true&quot;);intent.putExtra(&quot;aspectX&quot;, 1);intent.putExtra(&quot;aspectY&quot;, 1);intent.putExtra(&quot;scale&quot;, true);intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri);intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());intent.putExtra(&quot;noFaceDetection&quot;, true); // no face detectionstartActivityForResult(intent,987); &emsp;&emsp;拍照裁剪这是一个很常用的功能，很早之前就写过一篇，封装的不是很好。最近，又做了一遍这个功能，发现了一个好用的框架——TakePhoto 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（七）—— 权限申请(Android 6.0)]]></title>
    <url>%2F2018%2F03%2F01%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7-Android6.0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;总所周知，Android 6.0以上的版本，google对权限做了更严格的限制，不能app自动给权限，必须要让用户选择是否给权限。如果，用户不给权限，辣么，用这个功能的时候，app会造成崩溃，所以，最简单的办法就是，用户不给权限，不让用户用这个功能，也就是页面不做跳转。 &emsp;&emsp;当时，刚出来这个权限问题的时候，本人用原生的写，写了封装，搞了好长时间，总感觉各种不爽，各种不舒服，后来好了，大牛封装了一个开源框架——RxPermission，一行代码解决动态申请权限问题。 依赖1implementation &apos;com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar&apos; 工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.haichenyi.myproject.utilsimport android.app.Activityimport android.content.Intentimport android.net.Uriimport android.os.Buildimport android.os.Environmentimport android.provider.Settingsimport android.support.v7.app.AlertDialogimport com.haichenyi.myproject.Rimport com.tbruyelle.rxpermissions2.RxPermissionsimport java.io.Fileimport java.io.FileInputStreamimport java.io.IOExceptionimport java.util.*/** * Author: 海晨忆 * Date: 2018/2/28 * Desc: */object RxPerUtils &#123; /** * 请求权限的获取方法 * activity：Activity对象 * permissions：需要获取的权限，可以传多个 * aloe: (b: Boolean)：一个参数的回调方法，b为true，表示用户给了权限，false，表示没有给权限 */ fun requestPermission(activity: Activity, vararg permissions: String, aloe: (b: Boolean) -&gt; Unit) &#123; RxPermissions(activity).request(*permissions) .subscribe &#123; aBoolean -&gt; aloe(aBoolean) &#125; &#125; /** * 当用户拒绝给权限的时候调用，跳转权限设置页面，让用户手动给权限 * activity：Activity对象 * permissionName：权限名称 * msg：提示信息 */ fun setupPermission(activity: Activity, permissionName: String, msg: String, aloe: () -&gt; Unit) &#123; AlertDialog.Builder(activity, R.style.Theme_AppCompat_Dialog).setTitle(&quot;权限申请&quot;) .setMessage(String.format(Locale.getDefault(), &quot;请在“权限”中开启“%1s权限”，以正常使用%2s&quot;, permissionName, msg)) .setCancelable(false) .setNegativeButton(android.R.string.cancel) &#123; dialog, which -&gt; aloe &#125;.setPositiveButton(&quot;去设置&quot;) &#123; dialog, which -&gt; if (isMiUi()) &#123; setMiUiPermissions(activity) &#125; else &#123; activity.startActivityForResult(Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS) .setData(Uri.fromParts(&quot;package&quot;, activity.packageName, null)), 1000) &#125; &#125;.create().show() &#125; private fun setMiUiPermissions(activity: Activity) &#123; if (isMiUi()) &#123; try &#123; // MIUI 8 activity.startActivityForResult(Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;) .setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;) .putExtra(&quot;extra_pkgname&quot;, activity.packageName), 1000) &#125; catch (e: Exception) &#123; try &#123; // MIUI 5/6/7 activity.startActivityForResult(Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;) .setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;) .putExtra(&quot;extra_pkgname&quot;, activity.packageName), 1000) &#125; catch (e1: Exception) &#123; // 否则跳转到应用详情 activity.startActivityForResult(Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS) .setData(Uri.fromParts(&quot;package&quot;, activity.packageName, null)), 1000) &#125; &#125; &#125; &#125; private fun isMiUi(): Boolean &#123; val device = Build.MANUFACTURER if (device == &quot;Xiaomi&quot;) &#123; try &#123; val prop = Properties() prop.load(FileInputStream(File(Environment.getRootDirectory(), &quot;build.prop&quot;))) return (prop.getProperty(&quot;ro.miui.ui.version.code&quot;, null) != null || prop.getProperty(&quot;ro.miui.ui.version.name&quot;, null) != null || prop.getProperty(&quot;ro.miui.internal.storage&quot;, null) != null) &#125; catch (e: IOException) &#123; e.printStackTrace() &#125; &#125; return false &#125;&#125; 调用12345678910RxPerUtils.requestPermission(this, Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE) &#123; if (it) &#123; //这里写你自己的逻辑，已经获得权限，做你自己的业务逻辑操作 ToastUtils.showTipMsg(&quot;已经获得权限&quot;) &#125; else &#123; RxPerUtils.setupPermission(this, &quot;相机和存储&quot;, &quot;相机功能&quot;) &#123; &#125; &#125; &#125; &emsp;&emsp;请求权限的整个过程就是： 用RxPermission去请求权限，需要传activity对象,然后就是你需要获取的权限（可以传多个），再就是回调方法 在回调方法里面做判断，用户是否给了权限，如果给了，就走你正常的逻辑。如果没有给，就弹对话框提示用户，去设置页面给权限。 &emsp;&emsp;就这么简单，方法都封装好了，如果，你嫌弃系统自带的对话框样式不好看，你也可以自己写一个样式。项目就不传了，如果你有之前的代码，就直接把我这几个方法拷贝过去用就可以了，没有之前的代码，就去瞅瞅之前的博客吧。]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（六）——Socket网络编程]]></title>
    <url>%2F2018%2F02%2F26%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Android中常用的网络编程方式：Http和Socket，Http通讯方式，我们在前面已经加到框架里面了，用的是现在主流的RxJava+Retrofit+OkHttp的方式，用起来也很方便。今天，我们来说说Socket网络编程。前面已经有一篇讲过IO和NIO的区别，还有一篇讲过Netty了，今天这篇的目的就是把Netty加到我们这个框架里面。 添加依赖1implementation &apos;io.netty:netty-all:5.0.0.Alpha2&apos; 添加依赖，老生常谈的问题了，我就不多说了。 TCP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.haichenyi.myproject.model.socketimport android.util.Logimport com.haichenyi.myproject.model.bean.SocketTcpBeanimport io.netty.bootstrap.Bootstrapimport io.netty.channel.Channelimport io.netty.channel.ChannelInitializerimport io.netty.channel.ChannelOptionimport io.netty.channel.EventLoopGroupimport io.netty.channel.nio.NioEventLoopGroupimport io.netty.channel.socket.SocketChannelimport io.netty.channel.socket.nio.NioSocketChannelimport io.netty.handler.codec.LineBasedFrameDecoderimport io.netty.handler.codec.string.StringDecoderimport io.netty.handler.codec.string.StringEncoderimport io.netty.util.CharsetUtilimport org.greenrobot.eventbus.EventBusimport org.greenrobot.eventbus.Subscribe/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class SocketTcp &#123; companion object &#123; private val socket = SocketTcp() fun getInstance(): SocketTcp = socket &#125; private var port: Int = 0 private var host: String = &quot;&quot; private var channel: Channel? = null private var group: EventLoopGroup? = null fun setPort(port: Int): SocketTcp &#123; this.port = port return this &#125; fun setHost(host: String): SocketTcp &#123; this.host = host return this &#125; fun connect() &#123; if (null != channel) return if (null == group) &#123; if (!EventBus.getDefault().isRegistered(this)) EventBus.getDefault().register(this) group = NioEventLoopGroup() &#125; val bootstrap = Bootstrap() try &#123; bootstrap.group(group) .channel(NioSocketChannel::class.java) .option(ChannelOption.TCP_NODELAY, true) .handler(object : ChannelInitializer&lt;SocketChannel&gt;() &#123; override fun initChannel(ch: SocketChannel?) &#123; //以换行符为结束标记 val pipeline = ch!!.pipeline() pipeline.addLast(&quot;encoder&quot;, StringEncoder(CharsetUtil.UTF_8)) pipeline.addLast(LineBasedFrameDecoder(Integer.MAX_VALUE)) pipeline.addLast(StringDecoder()) pipeline.addLast(HeartTcp()) //以&quot;#_&quot;作为分隔符 /*val pipeline = ch!!.pipeline() pipeline.addLast(&quot;encoder&quot;, StringEncoder(CharsetUtil.UTF_8)) val s = &quot;#_&quot; val byteBuf = Unpooled.copiedBuffer(s.toByteArray()) pipeline.addLast(DelimiterBasedFrameDecoder(Integer.MAX_VALUE, byteBuf)) pipeline.addLast(StringDecoder())*/ &#125; &#125;) //发起异步连接操作 val channelFuture = bootstrap.connect(host, port).sync() channel = channelFuture.channel() //等待服务端监听端口关闭 channel!!.closeFuture().sync() &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; finally &#123; disConnect() &#125; &#125; //连接成功后，通过Channel提供的接口进行IO操作 fun sendMessage(msg: String) &#123; try &#123; if (channel != null &amp;&amp; channel!!.isOpen) &#123; channel!!.writeAndFlush(msg).sync() Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg) &#125; else &#123; throw Exception(&quot;channel is null | closed&quot;) &#125; &#125; catch (e: Exception) &#123; reConnect() e.printStackTrace() &#125; &#125; /** * 断开tcp连接. */ private fun disConnect() &#123; if (null != group) &#123; group!!.shutdownGracefully() &#125;// EventBus.getDefault().unregister(this) group = null channel = null Log.v(&quot;WZ&quot;, &quot;disConnect&quot;) &#125; @Subscribe fun handle(socketTcpBean: SocketTcpBean) &#123; sendMessage(socketTcpBean.msg) &#125; /** * 重连. */ private fun reConnect() &#123; Thread(Runnable &#123; this.connect() &#125;).start() &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.haichenyi.myproject.model.socketimport android.os.SystemClockimport android.util.Logimport io.netty.buffer.Unpooledimport io.netty.channel.ChannelHandlerContextimport io.netty.channel.SimpleChannelInboundHandlerimport java.util.concurrent.TimeUnitclass HeartTcp : SimpleChannelInboundHandler&lt;Any&gt;() &#123; private var ctx: ChannelHandlerContext? = null private var isConnect = false @Throws(Exception::class) override fun channelActive(ctx: ChannelHandlerContext) &#123; super.channelActive(ctx) Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;) isConnect = true if (this.ctx == null) &#123; synchronized(HeartTcp::class.java) &#123; if (this.ctx == null) &#123; this.ctx = ctx myAppHeart() &#125; &#125; &#125; &#125; private fun myAppHeart() &#123; Thread &#123; while (ctx != null &amp;&amp; isConnect) &#123; val data = &quot;123&quot; val bytes = data.toByteArray() if (isConnect) &#123; ctx!!.writeAndFlush(Unpooled.buffer(bytes.size).writeBytes(bytes)) SystemClock.sleep(3000) &#125; &#125; &#125;.start() &#125; @Throws(Exception::class) override fun channelInactive(ctx: ChannelHandlerContext) &#123; val loop = ctx.channel().eventLoop() loop.schedule(&#123; SocketTcp.getInstance().connect() &#125;, 5, TimeUnit.SECONDS) super.channelInactive(ctx) Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;) isConnect = false &#125; @Throws(Exception::class) override fun userEventTriggered(ctx: ChannelHandlerContext, evt: Any) &#123; super.userEventTriggered(ctx, evt) Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;) &#125; @Throws(Exception::class) override fun exceptionCaught(ctx: ChannelHandlerContext, cause: Throwable) &#123; super.exceptionCaught(ctx, cause) Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;) this.ctx = null &#125; @Throws(Exception::class) override fun messageReceived(ctx: ChannelHandlerContext, msg: Any) &#123; Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;) /*val msg1 = msg val bytes = ByteArray(msg1.readableBytes()) msg1.readBytes(bytes) val s = String(bytes*//*, &quot;UTF-8&quot;*//*)*/ val s = msg.toString() Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s) &#125;&#125; &emsp;&emsp;我这里就是把我前面那个讲Netty创建Socket连接的代码拷贝过来转成了kotlin代码，这里我就不做过多的解释了。 &emsp;&emsp;一般，我们都是后台新开一个服务去启动socket，所以，我们还要创建一个Service，去处理socket。我这里就是非绑定启动这个服务。在oncreate方法里面去连接服务器即可 123456789101112131415161718192021package com.haichenyi.myproject.model.socketimport android.app.Serviceimport android.content.Intentimport android.os.IBinder/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class SocketService : Service() &#123; override fun onBind(intent: Intent?): IBinder? &#123; return null &#125; override fun onCreate() &#123; super.onCreate() Thread(Runnable &#123; SocketTcp.getInstance().setPort(8080).setHost(&quot;192.168.0.235&quot;).connect() &#125;).start() &#125;&#125; &emsp;&emsp;之所以要新建一个服务，就是可能你在连接socket的时候，可能要做一些其他信息的初始化，而这些信息初始化也是只有在连接socket服务器之前才需要的，写在这里方便一起管理，要是写在activity里面不便于管理。上面都是扯淡，最主要的是我们在最初学Android的时候，教你们的老师应该讲过，什么时候需要用到服务，就是不需要页面，用户并不关心它长什么样子，需要长连接的任务，都放在服务里面。正好，socket连接正好满足这些条件。 &emsp;&emsp;细心的同学可能注意了，我在Tcp类里面有一个EventBus，我这里是把发TCP消息给拿出来了，便于管理。我这边还新建了一个SocketUtils类，就是处理Socket请求的方法，我们发消息之类的方法，都是调用SocketUtils类里面的方法，不用去改Tcp类。这样做就只有一个目的，就是便于统一管理，代码如下 12345678910111213141516171819package com.haichenyi.myproject.model.socketimport com.haichenyi.myproject.model.bean.SocketTcpBeanimport org.greenrobot.eventbus.EventBus/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */object SocketUtils &#123; fun sendTcpMsg(msg: String) &#123; sendTcpMsg(SocketTcpBean(msg)) &#125; private fun sendTcpMsg(socketTcpBean: SocketTcpBean) &#123; EventBus.getDefault().post(socketTcpBean) &#125;&#125; &emsp;&emsp;至于这个SocketTcpBean类，就是一个普通的java bean类，里面就只有一个参数msg，你需要发的消息 UDP我先给出来代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.haichenyi.myproject.model.socketimport android.util.Logimport com.haichenyi.myproject.model.bean.SocketUdpBeanimport io.netty.bootstrap.Bootstrapimport io.netty.buffer.Unpooledimport io.netty.channel.Channelimport io.netty.channel.ChannelOptionimport io.netty.channel.EventLoopGroupimport io.netty.channel.nio.NioEventLoopGroupimport io.netty.channel.socket.DatagramPacketimport io.netty.channel.socket.nio.NioDatagramChannelimport org.greenrobot.eventbus.EventBusimport org.greenrobot.eventbus.Subscribeimport java.net.InetSocketAddressimport java.nio.charset.Charset/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class SocketUdp &#123; companion object &#123; private val socket = SocketUdp() fun getInstance(): SocketUdp = socket &#125; private var port: Int = 0 private var channel: Channel? = null private var group: EventLoopGroup? = null fun setPort(port: Int): SocketUdp &#123; this.port = port return this &#125; fun connect() &#123; if (null != channel) return if (null == group) &#123; if (!EventBus.getDefault().isRegistered(this)) EventBus.getDefault().register(this) group = NioEventLoopGroup() &#125; val bootstrap = Bootstrap() bootstrap.group(group) .channel(NioDatagramChannel::class.java) .option(ChannelOption.SO_BROADCAST, true) .handler(UdpHandler()) try &#123; channel = bootstrap.bind(port).sync().channel() channel!!.closeFuture().sync() &#125; catch (e: InterruptedException) &#123; e.printStackTrace() &#125; finally &#123; disConnect() &#125; &#125; /** * 断开tcp连接. */ private fun disConnect() &#123; if (null != group) &#123; group!!.shutdownGracefully() &#125;// EventBus.getDefault().unregister(this) group = null channel = null Log.v(&quot;WZ&quot;, &quot;disConnect&quot;) &#125; //连接成功后，通过Channel提供的接口进行IO操作 private fun sendMessage(host: String, port: Int, data: ByteArray) &#123; val packet = DatagramPacket(Unpooled.copiedBuffer(data), InetSocketAddress(host, port)) channel?.let &#123; try &#123; it.writeAndFlush(packet).sync() Log.d(&quot;wz&quot;, &quot;send succeed &quot; + String(data, Charset.forName(&quot;UTF-8&quot;))) &#125; catch (e: Exception) &#123; reConnect() e.printStackTrace() &#125; &#125; &#125; @Subscribe fun handle(socketUdpBean: SocketUdpBean) &#123; sendMessage(socketUdpBean.host,socketUdpBean.port,socketUdpBean.data) &#125; /** * 重连. */ private fun reConnect() &#123; Thread(Runnable &#123; this.connect() &#125;).start() &#125;&#125; 123456789101112131415161718192021222324package com.haichenyi.myproject.model.socketimport android.util.Logimport io.netty.channel.ChannelHandlerContextimport io.netty.channel.SimpleChannelInboundHandlerimport io.netty.channel.socket.DatagramPacketimport java.nio.charset.Charset/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class UdpHandler : SimpleChannelInboundHandler&lt;DatagramPacket&gt;() &#123; override fun messageReceived(ctx: ChannelHandlerContext?, msg: DatagramPacket?) &#123; val byteBuf = msg!!.content() val bytes = ByteArray(byteBuf.readableBytes()) byteBuf.readBytes(bytes) val s = String(bytes, Charset.forName(&quot;UTF-8&quot;)) Log.v(&quot;WZ&quot;, &quot;UDP收到的消息是--&gt;$s&quot;) &#125;&#125; &emsp;&emsp;这里的代码跟TCP类似，我想说的就只有三点： 首先你客户端开启UDP的时候，需要bind一个端口号，这个端口号是服务器给你发消息的时候，需要的端口号。 它的管道里面的handle类型DatagramPacket 再有就是给目标主机发消息，UDP需要传目标地址，端口号，还有消息。这里的目标地址就是服务器的地址，端口号就是服务器跟你通信的端口号，消息就是你需要发送给服务器的信息 &emsp;&emsp;其实，这里的区别就是TCP与UDP的区别，TCP和UDP什么区别呢？ 类型 TCP UDP 是否连接 面向连接 面向非连接 传输效率 慢 快 数据是否有序 有序 无序 安全性 安全 不安全 模式 流模式 报文模式 系统资源 多 少 区别的总结：最典型的对比就是打电话（TCP）和发短信（UDP）的区别 是否连接方面，TCP是1对1，UDP可以1对N 传输效率：TCP必须等到一个消息全部传完了才能传下一个，UDP可以一直发 数据是否有序：TCP是按顺序一条一条的发，当然是有序的。UDP则是无序的 安全性方面：TCP有3次握手机制，采用的全双工的可靠信道，保证了数据的安全，UDP则没有3次握手机制，采用的是不可靠信道 模式方面：TCP是面向字节流，实际上TCP把数据看成了一连串无结构的字节流，UDP则是面向报文的 系统资源方面：TCP首部开销20个字节，UDP首部开销8个字节 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（五）—GreenDao的增删改查]]></title>
    <url>%2F2018%2F02%2F24%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94GreenDao%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇我们讲了GreenDao的数据库的依赖和创建，这一篇，我们来讲常用的增删改查四种方法。我们操作数据库都是Dao层，不同的表，有不懂的Dao层对象。我们上一篇的数据库接口的实现类里面，我们定义了UserDao，我们这一篇讲的就是操作我们昨天创建的user表。 &emsp;&emsp;在写下面几个方法之前，我还是先把MVP的用法先讲一遍吧，防止有人不知道，以增操作为例，另外三个就不再讲了： 点击页面的增按钮，我们要调用P层的方法去做增操作。效果图如下： P层的方法从哪来呢？P层实现的接口来撒，所以，我们只用在接口定义对应的方法，在P层去实现，效果图如下： 辣么，具体实现代码怎么写呢？既不记得，我们的装饰者模式，我们P层里面有一个DataHelper对象，通过它去调用对应的方法就可以了，效果图如下： 接下来，datahelper的方法又是从哪里来呢？我们的DataHelper是不是实现了SqlHelper接口，所以，直接在SqlHelper定义方法，在datahelper实现即可，效果图如下： 最后，前面只是调用了，具体实现在哪里呢？我之前有没有讲过装饰者模式，一个接口，两个实现方法，对，没错，就是在SqlImpl方法里面实现，效果图如下： &emsp;&emsp;通过以上5步，就完成我们的增操作。有同鞋就会问，那参数怎么传？我特么怎么知道需要传什么传输，你这个方法是干什么的，调用这个方法需要什么数据，你就丢在参数里面传过去，即可。 增方法12345//插入单个对象userDao.insert(user);//插入一个listuserDao.insertInTx(users); 调用12345//basePresenter.onAdd(User(&quot;小红&quot;, 1, 165, &quot;50KG&quot;, 18))val dataList = mutableListOf&lt;User&gt;()dataList.add(User(&quot;小刚&quot;, 2, 175, &quot;60KG&quot;, 28))dataList.add(User(&quot;小东&quot;, 2, 185, &quot;65KG&quot;, 25))basePresenter.onAddList(dataList) 效果图我就不贴出来了，如果，你的效果出不来，就肯定是你的代码写的有问题，我写这个博客都是边写代码，边写博客，我这边肯定是没问题的。 查方法1234//查询单个对象userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();//查询一个listuserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list(); 调用123456val user = basePresenter.onSelect(&quot;小红&quot;)println(user.name)val users = basePresenter.onSelectList(&quot;小东&quot;) users.forEach &#123; println(it.name) &#125; &emsp;&emsp;这里，我需要做一点说明，那就是手动能力强的宝宝，看见有两个查询方法，一个查询一个对象，一个查询list，这两个方法没问题，查询肯定是查询的一个，list里面也是只有一个对象，就有宝宝想着多插入几条数据，这个时候，项目就可能崩掉，因为，你插入的名字是相同的，我们这里名字是作为主键，表里面主键是不能相同的，所以就崩掉了，所以，你就得改表结构，正好测试我们之前说的版本更新问题，我这里亲测可用，数据也不会丢失。步骤如下： 修改数据库版本，把1改成2 User bean里面增加一个字段id Long类型，递增即可，clean，build项目 在你的Activity里面会报错，因为，你User的构造方法里面新增了一个参数，辣么这里你用的时候参数个数都不对，肯定报错，你把id字段对应的参数传null即可，他自己递增。这里也只有Long类型可以传null 重新运行项目，没有问题 删方法1234567891011121314151617181920/*//通过主键删除一个对象，删除满足条件的第一个对象 User user1 = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique(); //一定要记得做非空判断 if (user1 != null) &#123; userDao.deleteByKey(user1.getId()); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;); &#125;*/ //通过主键删除一个满足条件的List List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list(); if (list.size() &gt; 0) &#123; List&lt;Long&gt; keys = new ArrayList&lt;&gt;(); for (User user : list) &#123; keys.add(user.getId()); &#125; userDao.deleteByKeyInTx(keys); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;); &#125; 调用12//basePresenter.onDelete(&quot;小红&quot;)basePresenter.onDelete(&quot;小东&quot;) 改方法1234567891011List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(oldName)).build().list(); if (list.size() &gt; 0) &#123; for (User user : list) &#123; user.setName(newName); &#125;// userDao.update(user1); userDao.updateInTx(list); ToastUtils.Companion.showTipMsg(&quot;修改成功&quot;); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;未查询到相关数据&quot;); &#125; 调用1basePresenter.onUpdate(&quot;小刚&quot;, &quot;小贝&quot;) 完了，数据库的简单的增删改查 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（四）—Kotlin+GreenDao3.2]]></title>
    <url>%2F2018%2F02%2F24%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94Kotlin-GreenDao3-2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本篇介绍android常用的数据库之一GreenDao的简单用法，增删改查。基于前面搭的框架，当然，你也可以选择不用。看懂用法之后，用起来很方便。GreenDao数据库升级到3.0版本之后api用起来更加方便了，便于让开发人员专注于业务逻辑。我需要额外说明的是，我把之前的项目框架转成了kotlin，不会kotlin语法的同学，可以去研究一下。 添加依赖最终，我们要添加如下代码，效果图如下： 第一步&emsp;&emsp;打开的你根目录下面的build.gradle文件，也就是项目下面的，并不是app目录下面的build.gradle。 12345678910111213// In your root build.gradle file:buildscript &#123; repositories &#123; jcenter() ...//其他你自己的 mavenCentral() // add repository &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.0&apos; ...//其他你自己的 classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin &#125;&#125; 第二步&emsp;&emsp;打开你的项目下面的build.gradle文件，也就是你的app目录下面的，之前我们添加依赖的时候的那个文件 1234567// In your app projects build.gradle file:apply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin dependencies &#123; compile &apos;org.greenrobot:greendao:3.2.2&apos; // add library&#125; &emsp;&emsp;完成上面两步，辣么，关于greendao的依赖我们就添加完成了 初始化&emsp;&emsp;我们首先得有一个bean类，这个bean类对应的就是数据库表的表结构。我这里想说明的是（敲黑板了），看到了很多网上说的什么主键id必须用Long类型，这种说法是不准确的，准确的说，你的主键字段名称，如果是“id”，辣么，你这个字段“id”，必须用Long类型，如果你换一个名称，比方说“myId”，辣么，你就不必用Long类型，这个问题，说大不大，说小，又困扰了我有一会。我这里新建用户表，就需要一个User的java bean类。如下： 1234567891011121314151617181920212223242526package com.haichenyi.myproject.model.bean;import org.greenrobot.greendao.annotation.Entity;import org.greenrobot.greendao.annotation.Id;import org.greenrobot.greendao.annotation.NotNull;import org.greenrobot.greendao.annotation.Property;import org.greenrobot.greendao.annotation.Transient;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: 用户表的bean类 */@Entitypublic class User &#123; @Id private String name; private int sex; @Property(nameInDb = &quot;Height&quot;) private int height; private String weight; @NotNull private int age; @Transient private String character;&#125; &emsp;&emsp;这里我把几个常用的注解都写出来了，说一下这几个注解是什么意思 注解 意义 @Entity 用于标识这是一个需要Greendao帮我们生成代码的bean @Id 标明主键，括号里可以指定是否自增 @Property 用于设置属性在数据库中的列名（默认不写就是保持一致） @NotNull 非空 @Transient 标识这个字段是自定义的不会创建到数据库表里 简单的讲一下： @Entity：标识的bean类，我们在运行的时候，greendao会自动帮我们生成对应的表 @Id：标识的字段就是这个表对应的主键 @Property：标识的字段在表中对应的那一栏的名称是后面括号里面的，这个表height字段对应表中的Height，一般我们直接设置成默认就可以了 @NotNull：标识的字段，这个字段在表中不能为空，不然就出错，所以，在添加数据的时候设置默认值 @Transient：标识的字段，在生成表的时候不会生成对应的字段。这个什么时候用呢？这个，我一般用作标记flag，比方说，从数据库拿数据，又不想重新写一个bean类，就用这个bean类，RecyclerView，填充完数据，item点击的时候，状态发生变化，我们要有一个flag，就通过修改这个字段的值，页面做出相应的变化。 &emsp;&emsp;写到这里，我们的bean类也有了，要怎么生成数据库呢？在生成数据库之前，我们先把项目重新clean一遍，再build一遍，看到你刚写的需要生成表的bean类变成了如下样子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.haichenyi.myproject.model.bean;import org.greenrobot.greendao.annotation.Entity;import org.greenrobot.greendao.annotation.Id;import org.greenrobot.greendao.annotation.NotNull;import org.greenrobot.greendao.annotation.Property;import org.greenrobot.greendao.annotation.Transient;import org.greenrobot.greendao.annotation.Generated;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: 用户表的bean类 */@Entitypublic class User &#123; @Id private String name; private int sex; @Property(nameInDb = &quot;Height&quot;) private int height; private String weight; @NotNull private int age; @Transient private String character; @Generated(hash = 717717955) public User(String name, int sex, int height, String weight, int age) &#123; this.name = name; this.sex = sex; this.height = height; this.weight = weight; this.age = age; &#125; @Generated(hash = 586692638) public User() &#123; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getSex() &#123; return this.sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public int getHeight() &#123; return this.height; &#125; public void setHeight(int height) &#123; this.height = height; &#125; public String getWeight() &#123; return this.weight; &#125; public void setWeight(String weight) &#123; this.weight = weight; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; &emsp;&emsp;如上，greendao通过注解的方式帮我们自动生成了set/get方法，还有构造方法，这就对了，我们不用关，之后我们再执行如下代码生成数据库和表： 123DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(getApplicationContext(), &quot;haichenyi.db&quot;, null);DaoMaster daoMaster = new DaoMaster(devOpenHelper.getWritableDb());DaoSession daoSession = daoMaster.newSession(); &emsp;&emsp;通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。注意：默认的 DaoMaster.DevOpenHelper会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。升级的问题，我们在后面讲，这里我们先把数据库和表先创建了。 &emsp;&emsp;上面这个方式是java格式的，由于，我昨天写完框架之后，我把项目转成了kotlin代码，所以这里有点不一样，项目我后面会上传。这里我要说明的是（敲黑板）我用kotlin的时候，碰到了一个问题，当我使用greendao的时候，他提示我，无法引入用注解方式生成的类，dagger2也是一样的，我用java代码写就没有问题，我写这篇博客的时候，目前还没有找到解决的办法。 &emsp;&emsp;我用了另外一种方式，采用跟之前网络请求一样的设计模式——装饰者模式。我这里就不多做说明了。我贴出我的代码。 SqlHelper 12345678910111213141516package com.haichenyi.myproject.model.sql;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public interface SqlHelper &#123; void onAdd(); void onDelete(); void onUpdate(); void onSelect();&#125; &emsp;&emsp;这里定义增删改查4个方法，用于测试这4个功能 SqlImpl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.haichenyi.myproject.model.sql;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.model.bean.DaoMaster;import com.haichenyi.myproject.model.bean.DaoSession;import com.haichenyi.myproject.model.bean.UserDao;import com.haichenyi.myproject.utils.ToastUtils;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public class SqlImpl implements SqlHelper &#123; private final UserDao userDao; /** * 初始化Sql Dao. * * @param application &#123;@link MyApplication&#125; */ public SqlImpl(MyApplication application) &#123; SqlOpenHelper helper = new SqlOpenHelper(application, &quot;haichenyi.db&quot;); DaoSession daoSession = new DaoMaster(helper.getWritableDb()).newSession(); userDao = daoSession.getUserDao(); &#125; @Override public void onAdd() &#123; ToastUtils.Companion.showTipMsg(&quot;增加数据&quot;); &#125; @Override public void onDelete() &#123; ToastUtils.Companion.showTipMsg(&quot;删除数据&quot;); &#125; @Override public void onUpdate() &#123; ToastUtils.Companion.showTipMsg(&quot;更新数据&quot;); &#125; @Override public void onSelect() &#123; ToastUtils.Companion.showTipMsg(&quot;查询数据&quot;); &#125;&#125; &emsp;&emsp;功能实现类，看到他的构造方法里面，第二个参数就是我们的数据库名称，后面通过getWritableDb()获取的是可写的数据库，可写就肯定可读。然后就是接口的实现类了，这里就是具体的增删改查功能的实现类，我这里在对应的方法里面就写了Toast，增删改查具体怎么写后面再说 SqlOpenHelper 12345678910111213141516171819202122232425262728293031323334353637package com.haichenyi.myproject.model.sql;import android.content.Context;import com.haichenyi.myproject.model.bean.DaoMaster;import com.haichenyi.myproject.model.bean.UserDao;import org.greenrobot.greendao.database.Database;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public class SqlOpenHelper extends DaoMaster.OpenHelper &#123; public SqlOpenHelper(Context context, String name) &#123; super(context, name); &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123; super.onUpgrade(db, oldVersion, newVersion); MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() &#123; @Override public void onCreateAllTables(Database db, boolean ifNotExists) &#123; DaoMaster.createAllTables(db, ifNotExists); &#125; @Override public void onDropAllTables(Database db, boolean ifExists) &#123; DaoMaster.dropAllTables(db, ifExists); &#125; &#125;, UserDao.class); &#125;&#125; &emsp;&emsp;这个类用于管理数据库的表对应的字段发生变化的时候，数据库需要进行的版本更新，连上下面那个类，都是用于版本数据库版本更新的，防止数据丢失。怎么写呢？看到最后面的&emsp;UserDao.class&emsp;了吗？这个就是我们需要更新的表，你哪个表需要更新，直接写在后面就可以了，这个是可以一次传多个表的，并不是一次只能传一个 MigrationHelper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246package com.haichenyi.myproject.model.sql;import android.database.Cursor;import android.database.SQLException;import android.database.sqlite.SQLiteDatabase;import android.support.annotation.NonNull;import android.text.TextUtils;import android.util.Log;import org.greenrobot.greendao.AbstractDao;import org.greenrobot.greendao.database.Database;import org.greenrobot.greendao.database.StandardDatabase;import org.greenrobot.greendao.internal.DaoConfig;import java.lang.ref.WeakReference;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * Author: 海晨忆. * Date: 2018/2/24 * Desc: */public final class MigrationHelper &#123; public static boolean DEBUG = false; private static String TAG = &quot;MigrationHelper&quot;; private static final String SQLITE_MASTER = &quot;sqlite_master&quot;; private static final String SQLITE_TEMP_MASTER = &quot;sqlite_temp_master&quot;; private static WeakReference&lt;ReCreateAllTableListener&gt; weakListener; public interface ReCreateAllTableListener &#123; void onCreateAllTables(Database db, boolean ifNotExists); void onDropAllTables(Database db, boolean ifExists); &#125; public static void migrate(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; printLog(&quot;【The Old Database Version】&quot; + db.getVersion()); Database database = new StandardDatabase(db); migrate(database, daoClasses); &#125; public static void migrate(SQLiteDatabase db, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; weakListener = new WeakReference&lt;&gt;(listener); migrate(db, daoClasses); &#125; public static void migrate(Database database, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; weakListener = new WeakReference&lt;&gt;(listener); migrate(database, daoClasses); &#125; public static void migrate(Database database, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; printLog(&quot;【Generate temp table】start&quot;); generateTempTables(database, daoClasses); printLog(&quot;【Generate temp table】complete&quot;); ReCreateAllTableListener listener = null; if (weakListener != null) &#123; listener = weakListener.get(); &#125; if (listener != null) &#123; listener.onDropAllTables(database, true); printLog(&quot;【Drop all table by listener】&quot;); listener.onCreateAllTables(database, false); printLog(&quot;【Create all table by listener】&quot;); &#125; else &#123; dropAllTables(database, true, daoClasses); createAllTables(database, false, daoClasses); &#125; printLog(&quot;【Restore data】start&quot;); restoreData(database, daoClasses); printLog(&quot;【Restore data】complete&quot;); &#125; private static void generateTempTables(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; String tempTableName = null; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; if (!isTableExists(db, false, tableName)) &#123; printLog(&quot;【New Table】&quot; + tableName); continue; &#125; try &#123; tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;); StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append(&quot;DROP TABLE IF EXISTS &quot;).append(tempTableName).append(&quot;;&quot;); db.execSQL(dropTableStringBuilder.toString()); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append(&quot;CREATE TEMPORARY TABLE &quot;).append(tempTableName); insertTableStringBuilder.append(&quot; AS SELECT * FROM &quot;).append(tableName).append(&quot;;&quot;); db.execSQL(insertTableStringBuilder.toString()); printLog(&quot;【Table】&quot; + tableName + &quot;\n ---Columns--&gt;&quot; + getColumnsStr(daoConfig)); printLog(&quot;【Generate temp table】&quot; + tempTableName); &#125; catch (SQLException e) &#123; Log.e(TAG, &quot;【Failed to generate temp table】&quot; + tempTableName, e); &#125; &#125; &#125; private static boolean isTableExists(Database db, boolean isTemp, String tableName) &#123; if (db == null || TextUtils.isEmpty(tableName)) &#123; return false; &#125; String dbName = isTemp ? SQLITE_TEMP_MASTER : SQLITE_MASTER; String sql = &quot;SELECT COUNT(*) FROM &quot; + dbName + &quot; WHERE type = ? AND name = ?&quot;; Cursor cursor = null; int count = 0; try &#123; cursor = db.rawQuery(sql, new String[]&#123;&quot;table&quot;, tableName&#125;); if (cursor == null || !cursor.moveToFirst()) &#123; return false; &#125; count = cursor.getInt(0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); &#125; return count &gt; 0; &#125; private static String getColumnsStr(DaoConfig daoConfig) &#123; if (daoConfig == null) &#123; return &quot;no columns&quot;; &#125; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; daoConfig.allColumns.length; i++) &#123; builder.append(daoConfig.allColumns[i]); builder.append(&quot;,&quot;); &#125; if (builder.length() &gt; 0) &#123; builder.deleteCharAt(builder.length() - 1); &#125; return builder.toString(); &#125; private static void dropAllTables(Database db, boolean ifExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; reflectMethod(db, &quot;dropTable&quot;, ifExists, daoClasses); printLog(&quot;【Drop all table by reflect】&quot;); &#125; private static void createAllTables(Database db, boolean ifNotExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; reflectMethod(db, &quot;createTable&quot;, ifNotExists, daoClasses); printLog(&quot;【Create all table by reflect】&quot;); &#125; /** * dao class already define the sql exec method, so just invoke it */ private static void reflectMethod(Database db, String methodName, boolean isExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; if (daoClasses.length &lt; 1) &#123; return; &#125; try &#123; for (Class cls : daoClasses) &#123; Method method = cls.getDeclaredMethod(methodName, Database.class, boolean.class); method.invoke(null, db, isExists); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; private static void restoreData(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; String tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;); if (!isTableExists(db, true, tempTableName)) &#123; continue; &#125; try &#123; // get all columns from tempTable, take careful to use the columns list List&lt;String&gt; columns = getColumns(db, tempTableName); ArrayList&lt;String&gt; properties = new ArrayList&lt;&gt;(columns.size()); for (int j = 0; j &lt; daoConfig.properties.length; j++) &#123; String columnName = daoConfig.properties[j].columnName; if (columns.contains(columnName)) &#123; properties.add(&quot;`&quot; + columnName + &quot;`&quot;); &#125; &#125; if (properties.size() &gt; 0) &#123; final String columnSQL = TextUtils.join(&quot;,&quot;, properties); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append(&quot;REPLACE INTO &quot;).append(tableName).append(&quot; (&quot;); insertTableStringBuilder.append(columnSQL); insertTableStringBuilder.append(&quot;) SELECT &quot;); insertTableStringBuilder.append(columnSQL); insertTableStringBuilder.append(&quot; FROM &quot;).append(tempTableName).append(&quot;;&quot;); db.execSQL(insertTableStringBuilder.toString()); printLog(&quot;【Restore data】 to &quot; + tableName); &#125; StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append(&quot;DROP TABLE &quot;).append(tempTableName); db.execSQL(dropTableStringBuilder.toString()); printLog(&quot;【Drop temp table】&quot; + tempTableName); &#125; catch (SQLException e) &#123; Log.e(TAG, &quot;【Failed to restore data from temp table 】&quot; + tempTableName, e); &#125; &#125; &#125; private static List&lt;String&gt; getColumns(Database db, String tableName) &#123; List&lt;String&gt; columns = null; Cursor cursor = null; try &#123; cursor = db.rawQuery(&quot;SELECT * FROM &quot; + tableName + &quot; limit 0&quot;, null); if (null != cursor &amp;&amp; cursor.getColumnCount() &gt; 0) &#123; columns = Arrays.asList(cursor.getColumnNames()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); if (null == columns) columns = new ArrayList&lt;&gt;(); &#125; return columns; &#125; private static void printLog(String info) &#123; if (DEBUG) &#123; Log.d(TAG, info); &#125; &#125;&#125; &emsp;&emsp;这个类是工具类，拿过去用就好了，还有就是，应用怎么判断是否需要版本更新呢？打开你的app下面的build.grade，在根结点下面添加如下代码： 123greendao &#123; schemaVersion 1&#125; 每当你发布新版本的时候，把这个版本号+1即可。 &emsp;&emsp;当然，我门这里依然是用的dagger生成的全局单例，所以，你还需要在你的AppModule下面添加如下代码： 12345@Provides@SingletonSqlHelper provideSqlHelper() &#123; return new SqlImpl(application);&#125; &emsp;&emsp;记得把项目重新clean一遍，build一遍，重新跑项目的时候，找到你的数据库。data-data-你的应用包名-databases-haichenyi.db，这个就是我们的数据库。找个Sqlite可视化工具打开，你会看到如下结构。 &emsp;&emsp;太多了，不写了，下一篇写增删改查。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（三）—RxJava2.0+Retrofit2.0+OkHttp]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94RxJava2-0-Retrofit2-0-OkHttp%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇，我们把mvp+dagger加进去了，这一篇，我们把网络请求加上 &emsp;&emsp;我这里的网络请求是用的装饰者模式去写的，什么是装饰者模式呢？在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。我的理解就是一个接口，两个实现类，一个实现类负责调用接口的方法，另一个类负责功能的具体实现。本文中所提到的代码都是伪代码，最后会给出完整的，最初版本的项目框架。不包含任何业务逻辑 &emsp;&emsp;容我一个一个来说，首先，我们一般请求网络的时候，会有统一的返回数据格式，一个是需要判断返回code码的，就比方说登录功能，那登录成功，还是失败，我们只用判断code码即可，这种类型，我们统一是HttpNoResult。还有一个是返回数据的，就比方说查一个列表数据。这里我们统一的是HttpResult。我先给出这两个类的代码： 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.model.http;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:没有解析数据的返回 */public class HttpNoResult &#123; private int code; private String msg; public int getCode() &#123; return code; &#125; public HttpNoResult setCode(int code) &#123; this.code = code; return this; &#125; public String getMsg() &#123; return msg; &#125; public HttpNoResult setMsg(String msg) &#123; this.msg = msg; return this; &#125; @Override public String toString() &#123; return &quot;HttpNoResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.haichenyi.myproject.model.http;import com.google.gson.annotations.SerializedName;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:有解析数据的返回 */public class HttpResult&lt;T&gt; &#123; private int code; private String msg; @SerializedName(value = &quot;result&quot;) private T data; public int getCode() &#123; return code; &#125; public HttpResult setCode(int code) &#123; this.code = code; return this; &#125; public String getMsg() &#123; return msg; &#125; public HttpResult setMsg(String msg) &#123; this.msg = msg; return this; &#125; public T getData() &#123; return data; &#125; public HttpResult setData(T data) &#123; this.data = data; return this; &#125; @Override public String toString() &#123; return &quot;HttpResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &quot;, data=&quot; + data + &apos;&#125;&apos;; &#125;&#125; &emsp;&emsp;这里我就需要说一点，有数据返回的时候，每个数据类型都是不一样的，所以，这里我用的泛型传递，不同的数据类型，传不同的bean对象 &emsp;&emsp;言归正传，我们来说说网络请求的一个接口，两个实现类。 一个接口—HttpHelper 1234567891011121314151617181920package com.haichenyi.myproject.model.http;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络接口，接口参数Token统一处理，方法中不传Token */public interface HttpHelper &#123; /** * 登录时获取验证码. * * @param phone 手机号 * @return &#123;&quot;code&quot;:0&#125; */ Flowable&lt;HttpNoResult&gt; loginCode(String phone); /*Flowable&lt;HttpResult&lt;Login&gt;&gt; login(String phone, String code); Flowable&lt;HttpResult&lt;List&lt;DiyBean&gt;&gt;&gt; diyKeys(String allId);*/&#125; &emsp;&emsp;Flowable是RxJava2.0新增的，所以说RxJava完美兼容Retrofit，泛型就是我们需要解析的数据 loginCode方法是说返回数据，我们只用判断是否是成功还是失败， login方法是说返回数据是一个Login对象，至于对象是什么内容，那就是和你们后台确认了 diyKeys方法就是说，返回数据是一个list对象，每个list的item是DiyBean对象 123456789101112131415161718192021222324package com.haichenyi.myproject.model;import com.haichenyi.myproject.model.http.HttpHelper;import com.haichenyi.myproject.model.http.HttpNoResult;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求的实现类 */public class DataHelper implements HttpHelper &#123; private HttpHelper http; public DataHelper(HttpHelper http) &#123; this.http = http; &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return http.loginCode(phone); &#125;&#125; &emsp;&emsp;DataHelper是HttpHelper的实现类，他的唯一作用就是调用接口的方法即可，具体的功能实现是后面一个类，这里需要说明的是这个类的构造方法要public表示，因为他要dagger生成，用private或者protected表示无法生成。 123456789101112131415161718192021222324package com.haichenyi.myproject.model.http;import com.haichenyi.myproject.model.http.api.HttpApi;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: 网络接口Retrofit实现 */public class RetrofitHelper implements HttpHelper&#123; private HttpApi httpApi; @Inject RetrofitHelper(HttpApi httpApi) &#123; this.httpApi = httpApi; &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return httpApi.loginCode(phone); &#125;&#125; &emsp;&emsp;RetrofitHelper类作为HttpHelper接口的实现类，他是具体功能的实现类，为什么说他是具体功能的实现类呢？因为，他是调用HttpApi接口的方法。HttpApi接口是干什么用的呢？ 1234567891011121314151617181920212223242526package com.haichenyi.myproject.model.http.api;import com.haichenyi.myproject.model.http.HttpNoResult;import com.haichenyi.myproject.model.http.ProtocolHttp;import io.reactivex.Flowable;import retrofit2.http.Field;import retrofit2.http.FormUrlEncoded;import retrofit2.http.POST;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求接口api */public interface HttpApi &#123; /** * 登录时获取验证码. * * @param phone 手机号 * @return &#123;&quot;code&quot;:0&#125; */ @FormUrlEncoded @POST(ProtocolHttp.METHOD_LOGIN_CODE) Flowable&lt;HttpNoResult&gt; loginCode(@Field(&quot;phone&quot;) String phone);&#125; 这个就是Retrofit的网络请求的方式，看不懂？这个就是Retrofit的东西了方法注解，包含@GET、@POST、@PUT、@DELETE、@PATH、@HEAD、@OPTIONS、@HTTP。标记注解，包含@FormUrlEncoded、@Multipart、@Streaming。参数注解，包含@Query、@QueryMap、@Body、@Field，@FieldMap、@Part，@PartMap。其他注解，包含@Path、@Header、@Headers、@Url。 这里我们还差一个接口 123456789101112package com.haichenyi.myproject.model.http;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface ProtocolHttp &#123; String HTTP_HOST = &quot;http://xxx.xx.xxx.xxx:8080/app/con/&quot;; String HTTP_COMMON = &quot;common/&quot;; String METHOD_LOGIN_CODE = HTTP_COMMON + &quot;code&quot;;//登录发送验证码&#125; &emsp;&emsp;如上，这里需要注意的是不能以”\”结尾，然后就是，跟你们后台商量，格式不要错了，尽量就只有接口名字不同，接口名字前面部分都是一样的。 &emsp;&emsp;到此，这里基本上就说完了，那么有同鞋就会问了，接口定义方法的时候，我们知道该如何写返回数据类型呢？这个我就不知道了，你得问你们后台，根据后台返回的数据类型去写对应的bean类。推荐一个功能PostMan。 &emsp;&emsp;到目前为止，我们都还没有初始化网络请求的参数，这些网络请求的参数在哪里初始化呢？这些参数，我们就只用初始化一次，我们就想到了dagger的全局单例模式，没错，就是这个，我们上一篇写了很多没有用的东西，里面有一个HttpModule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.di.qualifier.ApiUrl;import com.haichenyi.myproject.model.http.ProtocolHttp;import com.haichenyi.myproject.model.http.api.HttpApi;import java.util.concurrent.TimeUnit;import javax.inject.Singleton;import dagger.Module;import dagger.Provides;import okhttp3.OkHttpClient;import retrofit2.Retrofit;import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;import retrofit2.converter.gson.GsonConverterFactory;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求的参数初始化 */@Modulepublic class HttpModule &#123; @Provides @Singleton OkHttpClient.Builder providesOkHttpHelper() &#123;//请求读写超时时间 return new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .readTimeout(10, TimeUnit.SECONDS) .writeTimeout(10, TimeUnit.SECONDS); &#125; @Provides @Singleton OkHttpClient provideClient(OkHttpClient.Builder builder) &#123; return builder// .addInterceptor(new MyHttpInterceptor()) .build(); &#125; @Provides @Singleton Retrofit.Builder providesRetrofitBuilder() &#123; return new Retrofit.Builder(); &#125; @Provides @Singleton HttpApi provideApi(@ApiUrl Retrofit retrofit) &#123; return retrofit.create(HttpApi.class); &#125; @Provides @Singleton @ApiUrl Retrofit providesApiRetrofit(Retrofit.Builder builder, OkHttpClient client) &#123; return createRetrofit(builder, client, ProtocolHttp.HTTP_HOST);//这里就是你的网络请求的url &#125; private Retrofit createRetrofit(Retrofit.Builder builder, OkHttpClient client, String host) &#123; return builder.client(client) .baseUrl(host) .addConverterFactory(GsonConverterFactory.create())//添加gson自动解析，我们不用关 .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); &#125;&#125; 如上代码，注释写的都有，考过去用就行了 在AppModule里面添加如下代码 12345678910111213141516171819202122232425262728293031323334353637package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.model.DataHelper;import com.haichenyi.myproject.model.http.HttpHelper;import com.haichenyi.myproject.model.http.RetrofitHelper;import javax.inject.Singleton;import dagger.Module;import dagger.Provides;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class AppModule &#123; private MyApplication application; public AppModule(MyApplication application) &#123; this.application = application; &#125; @Provides @Singleton DataHelper provideDataHelper(HttpHelper httpHelper) &#123; return new DataHelper(httpHelper); &#125; @Provides @Singleton HttpHelper provideHttpHelper(RetrofitHelper retrofitHelper) &#123; return retrofitHelper; &#125;&#125; 这里都是dagger了生成全局单例对象需要的东西 在AppComponent里面添加如下代码 1234567891011121314151617181920package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.di.module.AppModule;import com.haichenyi.myproject.di.module.HttpModule;import com.haichenyi.myproject.model.DataHelper;import javax.inject.Singleton;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Singleton@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)public interface AppComponent &#123; DataHelper getDataHelper();&#125; 在BaseMvpPresenter里面添加如下代码 123456789101112131415161718192021222324252627282930313233343536373839package com.haichenyi.myproject.base;import io.reactivex.disposables.CompositeDisposable;import io.reactivex.disposables.Disposable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123; protected T baseView; private CompositeDisposable disposables; @Override public void attachView(T baseView) &#123; this.baseView = baseView; &#125; protected void addSubscribe(Disposable disposable) &#123; if (null == disposables) &#123; disposables = new CompositeDisposable(); &#125; disposables.add(disposable); &#125; @Override public void detachView() &#123; this.baseView = null; unSubscribe(); &#125; private void unSubscribe() &#123; if (null != disposables) &#123; disposables.clear(); disposables = null; &#125; &#125;&#125; 至此，就全部写完了，关于网络请求的内容。调用方式如下： 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.model.DataHelper;import javax.inject.Inject;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; private DataHelper dataHelper; @Inject MainPresenter() &#123; dataHelper = MyApplication.getAppComponent().getDataHelper(); &#125; @Override public void loadData() &#123; addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe());// baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; 记得在清单文件里面，加上网络权限 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 网络请求，这样调用之后在哪处理呢？我给出我的几个处理的工具类。首先，按如下图设置1.8支持lambda表达式 然后添加如下几个类 HttpCode 123456789101112131415161718192021package com.haichenyi.myproject.model.http;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 网络请求状态码 */public interface HttpCode &#123; /** * 成功. */ int SUCCESS = 0; /** * 参数为空. */ int NO_PARAMETER = 1; /** * 服务器错误. */ int SERVER_ERR = 3;&#125; ApiException 1234567891011121314151617181920212223242526272829package com.haichenyi.myproject.model.http;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 接口异常判断处理 */public class ApiException extends Exception &#123; private int code; @SuppressWarnings(&quot;unused&quot;) public ApiException(int code) &#123; this.code = code; &#125; public ApiException(int code, String message) &#123; super(message); this.code = code; &#125; public int getCode() &#123; return code; &#125; public ApiException setCode(int code) &#123; this.code = code; return this; &#125;&#125; MyRxUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.haichenyi.myproject.model.http;import io.reactivex.BackpressureStrategy;import io.reactivex.Flowable;import io.reactivex.FlowableTransformer;import io.reactivex.Scheduler;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆. * Date: 2017/12/27 * Desc:切换线程的工具类 */public class MyRxUtils &#123; /** * 从其他线程转到主线程. * * @param scheduler Schedulers.io()等等 * @param &lt;T&gt; t * @return FlowableTransformer */ public static &lt;T&gt; FlowableTransformer&lt;T, T&gt; toMain(Scheduler scheduler) &#123; return upstream -&gt; upstream.subscribeOn(scheduler).observeOn(AndroidSchedulers.mainThread()); &#125; public static &lt;T&gt; FlowableTransformer&lt;HttpResult&lt;T&gt;, T&gt; handResult() &#123; return upstream -&gt; upstream.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .flatMap(tHttpResult -&gt; &#123; if (tHttpResult.getCode() == HttpCode.SUCCESS) &#123; return /*createData(tHttpResult.data)*/Flowable.just(tHttpResult.getData()); &#125; else &#123; return Flowable.error(new ApiException(tHttpResult.getCode(), tHttpResult.getMsg())); &#125; &#125;); &#125; private static &lt;T&gt; Flowable&lt;T&gt; createData(final T data) &#123; return Flowable.create(e -&gt; &#123; e.onNext(data); e.onComplete(); &#125;, BackpressureStrategy.ERROR); &#125;&#125; MySubscriber 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.haichenyi.myproject.model.http;import com.haichenyi.myproject.base.BaseView;import io.reactivex.subscribers.ResourceSubscriber;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123; private BaseView baseView; private boolean showLoading; public MySubscriber(BaseView baseView) &#123; this.baseView = baseView; &#125; public MySubscriber(BaseView baseView, boolean showLoading) &#123; this.baseView = baseView; this.showLoading = showLoading; &#125; @Override protected void onStart() &#123; super.onStart(); if (null != baseView &amp;&amp; showLoading) &#123; baseView.showLoading(); &#125; &#125; @Override public void onError(Throwable t) &#123; if (null == baseView) &#123; return; &#125; baseView.hideLoading(); if (t instanceof ApiException) &#123; ApiException apiException = (ApiException) t; switch (apiException.getCode()) &#123; case HttpCode.NO_PARAMETER: baseView.showTipMsg(&quot;参数为空&quot;); break; case HttpCode.SERVER_ERR: baseView.showTipMsg(&quot;服务器错误&quot;); break; default: break; &#125; &#125; &#125; @Override public void onComplete() &#123; if (null != baseView) &#123; baseView.hideLoading(); &#125; &#125;&#125; 这几个类不想多做解释，结合注释，仔细看几遍，就知道是干嘛用的了 加上这几个之后调用方式就变成了以下的方式： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.model.DataHelper;import com.haichenyi.myproject.model.http.HttpNoResult;import com.haichenyi.myproject.model.http.MyRxUtils;import com.haichenyi.myproject.model.http.MySubscriber;import javax.inject.Inject;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; private DataHelper dataHelper; @Inject MainPresenter() &#123; dataHelper = MyApplication.getAppComponent().getDataHelper(); &#125; @Override public void loadData() &#123; addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;) .compose(MyRxUtils.toMain(Schedulers.io())) .subscribeWith(new MySubscriber&lt;HttpNoResult&gt;(baseView, true) &#123; @Override public void onNext(HttpNoResult httpNoResult) &#123; &#125; &#125;));// baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; 完了，完了，终于写完了。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（二）—MVP+dagger2]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94MVP-dagger2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;接着上一篇简单的框架，没有看过的同鞋可以去喵一眼。上一篇我们搭好了简单的框架，初始化一次的内容丢在Application里面，所有的activity继承一个类BaseActivity，还有Fragment继承的一个类BaseFragment &emsp;&emsp;现在我们来加上MVP，不懂MVP的同鞋可以看一下，我前面写过的三种主流框架的对比。我们先导入dagger2的两个包，代码如下： 12implementation &apos;com.google.dagger:dagger:2.14.1&apos;annotationProcessor &quot;com.google.dagger:dagger-compiler:2.14.1&quot; 第一步&emsp;&emsp;新建BasePresenter接口，BaseMvpPresenter类去实现BasePresenter接口，代码如下 123456789101112package com.shfzwkeji.smartwardrobe.base;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 不带mvp的presenter的基类 */public interface BasePresenter&lt;T extends BaseView&gt; &#123; void attachView(T baseView); void detachView();&#125; 1234567891011121314151617181920package com.haichenyi.myproject.base;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:带mvp的presenter的基类 */public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123; protected T baseView; @Override public void attachView(T baseView) &#123; this.baseView = baseView; &#125; @Override public void detachView() &#123; this.baseView = null; &#125;&#125; &emsp;&emsp;这里就只有两个方法，一个是绑定view，还有一个是在ondestory方法里面解除绑定的方法，用来保证P层的生命周期和V层同步，避免了，当V层销毁的时候，P层仍然存在造成的内存泄漏。 第二步&emsp;&emsp;新建BaseMvpActivity 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.base;import javax.inject.Inject;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:带MVP的Activity */public abstract class BaseMvpActivity&lt;T extends BasePresenter&gt; extends BaseActivity&#123; @Inject protected T basePresenter; @Override @SuppressWarnings(&quot;unchecked&quot;) protected void initView() &#123; super.initView(); initInject(); if (null != basePresenter) &#123; basePresenter.attachView(this); &#125; &#125; protected abstract void initInject(); @Override protected void onDestroy() &#123; if (null != basePresenter) &#123; basePresenter.detachView(); basePresenter = null; &#125; super.onDestroy(); &#125;&#125; &emsp;&emsp;运用dagger2注解的方式，生成P层，这里我们在用P层之前得先生成P层，所以initject方法一定要在basePresenter用之前调用，因为他就是生成P层的代码。 &emsp;&emsp;怎么生成呢？dagger我们一般都命名成di层，所以，我们先创建di层的package，项目结构图如下： &emsp;&emsp;这里给出的是mvp+dagger加入之后的项目结构。我们重点看选中的di层，里面有4个package分别是component，module，qualifier，scope四个包，至于他们的作用分别是什么，请自行百度，google，dagger的用法。我这里先贴出这几个类，接口的代码： ActivityComponent 123456789101112131415161718package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.MainActivity;import com.haichenyi.myproject.di.module.ActivityModule;import com.haichenyi.myproject.di.scope.ActivityScope;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@ActivityScope@Component(dependencies = AppComponent.class, modules = ActivityModule.class)public interface ActivityComponent &#123; void inject(MainActivity mainActivity);&#125; AppComponent 123456789101112131415161718package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.di.module.AppModule;import com.haichenyi.myproject.di.module.HttpModule;import javax.inject.Singleton;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Singleton@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)public interface AppComponent &#123;&#125; ActivityModule 123456789101112package com.haichenyi.myproject.di.module;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class ActivityModule &#123;&#125; AppModule 12345678910111213141516171819package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.base.MyApplication;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class AppModule &#123; private MyApplication application; public AppModule(MyApplication application) &#123; this.application = application; &#125;&#125; HttpModule 123456789101112package com.haichenyi.myproject.di.module;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class HttpModule &#123;&#125; ActivityScope 12345678910111213141516package com.haichenyi.myproject.di.scope;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import javax.inject.Scope;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Scope@Retention(RetentionPolicy.RUNTIME)public @interface ActivityScope &#123;&#125; &emsp;&emsp;这几个类，接口里面基本上都没有内容，因为这几个类都是后面才会用的到的，这里我直接贴出来，说起来方便一些。还需要加两个方法，在MyApplication里面加如下方法: 1234567891011121314/** * 获取AppComponent. * * @return AppComponent */ public static synchronized AppComponent getAppComponent() &#123; if (null == appComponent) &#123; appComponent = DaggerAppComponent.builder() .appModule(new AppModule(getInstance())) .httpModule(new HttpModule()) .build(); &#125; return appComponent; &#125; 在BaseActivity里面加如下方法： 123456protected ActivityComponent getActivityComponent() &#123; return DaggerActivityComponent.builder() .appComponent(MyApplication.getAppComponent()) .activityModule(new ActivityModule()) .build(); &#125; &emsp;&emsp;加完这两个方法之后，肯定会有错误提示，重新编译一遍项目就可以了，如果重新编译一遍，还是不行，请重新对比一下，哪里不一样。 第三步&emsp;&emsp;就是关于mvp的了，从上面图应该看到了，有一个presenter包，和contract包，我们之前有一篇博客讲过，MVP就是多了很多个接口，这些接口写在哪呢？就在contract层 MainContract 代码如下： 123456789101112131415161718package com.haichenyi.myproject.contract;import com.haichenyi.myproject.base.BasePresenter;import com.haichenyi.myproject.base.BaseView;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface MainContract &#123; interface IView extends BaseView&#123; &#125; interface Presenter extends BasePresenter&lt;IView&gt;&#123; void loadData(); &#125;&#125; &emsp;&emsp;这里我需要说明的就是Presenter接口继承的是IVew，不是BaseView，页面变化的方法都是在IView接口里面定义，逻辑处理，网络请求方法都是在Presenter接口里面定义 MainPresenter 代码如下 1234567891011121314151617181920212223package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.contract.MainContract;import javax.inject.Inject;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; @Inject MainPresenter() &#123; &#125; @Override public void loadData() &#123; baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; &emsp;&emsp;这里我需要说明的是注意继承BaseMvpPresenter传的是MainContract.IView，不是BaseView，实现MainContract.Presenter接口，还有一点就是注意构造方法，上面有注解，这里的loadData里面应该是我们的网络请求逻辑，这里我放到后面一篇在说，这里我先就直接Toast，表示走了这个方法 第四步&emsp;&emsp;就是MainActivity，这里我贴出代码 123456789101112131415161718192021222324252627package com.haichenyi.myproject;import android.os.Bundle;import com.haichenyi.myproject.base.BaseMvpActivity;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.presenter.MainPresenter;public class MainActivity extends BaseMvpActivity&lt;MainPresenter&gt; implements MainContract.IView &#123; @Override protected int getLayoutId(Bundle savedInstanceState) &#123; return R.layout.activity_main; &#125; @Override protected void initData() &#123; super.initData(); initToolbar(true, false, true).setMyTitle(&quot;主页&quot;).setMoreTitle(&quot;更多&quot;); basePresenter.loadData(); &#125; @Override protected void initInject() &#123; getActivityComponent().inject(this); &#125;&#125; &emsp;&emsp;这里我需要说明的是继承BaseMvpActivity，泛型直接传MainPresenter，然后，实现MainContract.IView接口，直接用basePresenter调用方法，需要实现initInject方法，只要是是继承BaseMvpActivity的activity，都需要在ActivityComponent()里面注册一边。比方说，LoginActivity也是继承的BaseMvpActivity，辣么，在di层的component包下面的ActivityComponent接口里面定义一个方法 1void inject(LoginActivity loginActivity); 在LoginActivity的initInject方法里面写同样的代码 1getActivityComponent().inject(this); 就像这样写就可以了。 总结&emsp;&emsp;写到这里，mvp+dagger2基本上完成了，MVP的目的就是解藕，把业务逻辑，网络请求丢在P层，页面不发生变化，就只用改P层逻辑，从而达到了解藕的目的。dagger2简化了代码，并且，它有着全局单例模式，和局部单例模式，优化了我们的内存，减少了内存浪费。不用每次都去new一个P层对象出来。下一篇，我们就把网络请求加上 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（一）—简单的框架]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[目的&emsp;&emsp;首先先说出，最终的目的是现在主流的MVP+RxJava+Retrofit+OkHttp框架。让大家心里有底 &emsp;&emsp;开发工具Android Studio3.0，还在用eclipse的同鞋，强烈推荐你跨出这一步，你会发现一个新的世界。android studio都出来这么久了，你还在远古时代做开发，说句不好听的，你完全与时代脱轨，你不适合做开发（纯属个人观点） &emsp;&emsp;本篇就只有三部分，第一部分就是新建一个Application，第二部分就是BaseActivity，第三部分就是BaseFragment Application&emsp;&emsp;首先你得有application类，去初始化应用只用初始化一次的内容，继承Application，然后在清单文件里面注册。 123456789101112131415161718192021222324252627282930313233343536373839package com.haichenyi.myproject;import android.app.Application;import com.squareup.leakcanary.LeakCanary;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MyApplication extends Application &#123; private static MyApplication instance; public MyApplication getInstance() &#123; return instance; &#125; private void setInstance(MyApplication instance) &#123; MyApplication.instance = instance; &#125; @Override public void onCreate() &#123; super.onCreate(); setInstance(this); initLeakCanary(); &#125; /** * 初始化内存检测工具 */ private void initLeakCanary() &#123; if (LeakCanary.isInAnalyzerProcess(this)) &#123; return; &#125; LeakCanary.install(this); &#125;&#125; &emsp;&emsp;如上代码，我这里就初始化了一个全局application单例对象，还初始化square公司出品的一个内存检测工具，用于检测你项目中内存泄漏情况。便于你优化项目。 &emsp;&emsp;如上图所示，这个就是清单文件，在application结点下面，添加name标签，内容就是你创建的application的名字。这里你还需要添加两个内存检测的依赖。 &emsp;&emsp;如上图所示，首先把你的项目结构视图切换到Project，打开你的app目录下的build.gradle文件，在dependencies结点下面（只要是添加开源库都是在该结点下面，后面就不说了），添加如下两行代码： 12releaseImplementation &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos; &emsp;&emsp;最后的1.5.4是版本号，你可以在github上面搜索leakcanary，找最新的版本 BaseActivity&emsp;&emsp;创建基类BaseActivity，也就是所有Activity的父类。还有一个基类的接口BaseView，BaseActivity继承刚才添加的依赖的SupportActivity类，实现BaseView接口，并且实现点击事件的接口（选择实现，你要是不乐意在基类里面写，你可以在你自己的子类里面重新实现一遍也是可以的）。代码如下：每个方法注释写的很清楚，就不用一一解释了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.haichenyi.myproject.base;import android.app.AlertDialog;import android.graphics.Color;import android.graphics.drawable.ColorDrawable;import android.os.Bundle;import android.support.annotation.Nullable;import android.view.Window;import android.widget.ProgressBar;import com.haichenyi.myproject.utils.ToastUtils;import me.yokeyword.fragmentation.SupportActivity;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public abstract class BaseActivity extends SupportActivity implements BaseView &#123; private AlertDialog loadingDialog; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; /** * Toast 提示用户 * @param msg 提示内容String */ @Override public void showTipMsg(String msg) &#123; ToastUtils.showTipMsg(msg); &#125; /** * Toast 提示用户 * @param msg 提示内容res目录下面的String的int值 */ @Override public void showTipMsg(int msg) &#123; ToastUtils.showTipMsg(msg); &#125; /** * 网络请求的时候显示正在加载的对话框 */ @Override public void showLoading() &#123; if (null == loadingDialog) &#123; loadingDialog = new AlertDialog.Builder(this).setView(new ProgressBar(this)).create(); loadingDialog.setCanceledOnTouchOutside(false); Window window = loadingDialog.getWindow(); if (null != window) &#123; window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); &#125; &#125; if (!loadingDialog.isShowing()) &#123; loadingDialog.show(); &#125; &#125; /** * 网络请求完成时隐藏加载对话框 */ @Override public void hideLoading() &#123; if (null != loadingDialog) &#123; if (loadingDialog.isShowing()) &#123; loadingDialog.dismiss(); &#125; loadingDialog = null; &#125; &#125; @Override public void invalidToken() &#123; //用于检测你当前用户的token是否有效，无效就返回登录界面，具体的业务逻辑你自己实现 //如果需要做到实时检测，推荐用socket长连接，每隔10秒发送一个验证当前登录用户token是否过期的请求 &#125; /** * Finish当前页面，最好实现onBackPressedSupport()，这个方法会有一个退栈操作， * 开源框架实现的，我们不用管 */ @Override public void myFinish() &#123; onBackPressedSupport(); &#125; @Override public void onBackPressedSupport() &#123; super.onBackPressedSupport(); &#125;&#125; &emsp;&emsp;上面是目前BaseActivity代码，注释写的很清楚，你会发现BaseView你并没有，下面我给出BaseView的代码 12345678910111213141516171819202122package com.haichenyi.myproject.base;import android.support.annotation.StringRes;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface BaseView &#123; void showTipMsg(String msg); void showTipMsg(@StringRes int msg); void showLoading(); void hideLoading(); void invalidToken(); void myFinish();&#125; &emsp;&emsp;BaseView就是一个接口，是所有V层的基类，代码很简单，Toast方法，显示隐藏加载的对话框方法，检验token是否过期的方法，finish当前页面的方法。什么？Toast方法你没有，下面我贴出来我的Toast的工具类 1234567891011121314151617181920212223242526272829303132333435/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 实时更新的Toast工具类 */public final class ToastUtils &#123; private static Toast toast; private ToastUtils() &#123; throw new RuntimeException(&quot;工具类不允许创建对象&quot;); &#125; @SuppressWarnings(&quot;all&quot;) private static void init() &#123; if (toast == null) &#123; toast = Toast.makeText(MyApplication.getInstance(), &quot;&quot;, Toast.LENGTH_SHORT); &#125; &#125; public static void showTipMsg(String msg) &#123; if (null == toast) &#123; init(); &#125; toast.setText(msg); toast.show(); &#125; public static void showTipMsg(@StringRes int msg) &#123; if (null == toast) &#123; init(); &#125; toast.setText(msg); toast.show(); &#125;&#125; &emsp;&emsp;上面我贴出了三个类，这里我要说明的是，我又创建了两个package，一个是base，一个是utils，我把BaseActivity,BaseView,MyApplication放在base包下面，Toast的工具类放在utils包下面 &emsp;&emsp;再就是添加一些常用的东西了，这里我没有用黄油刀，用过一段时间之后，感觉他的每个控件都是全局的，有点占内存，就放弃了。我下面贴出BaseActivity新增的伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 保存当前activity对象，在OnCreate里面添加，记得在OnDestroy里面移除 * 有什么用呢？ * 比方说有一个需求，让你在任意位置弹出对话框，弹对话框又需要一个context对象，这个时候， * 你就只用传当前list的最上层的activity对象就可以了 * 当然还有其他需求 */ public static List&lt;BaseActivity&gt; activities = new ArrayList&lt;&gt;(); private Toolbar toolbar; private TextView tvToolbarTitle; private TextView tvToolbarRight; private TextView tvBack; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); activities.add(this); //强制竖屏(不强制加) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); int layoutId = getLayoutId(savedInstanceState); View inflate = getLayoutInflater().inflate(R.layout.activity_base, toolbar, false); LinearLayout rootLinearLayout = inflate.findViewById(R.id.ll_layout_base_activity); //没有布局的时候传0 if (0 == layoutId) &#123; setContentView(rootLinearLayout); &#125; else &#123; View rootView = getLayoutInflater().inflate(layoutId, rootLinearLayout, true); setContentView(rootView); &#125; stateBar(); initView(); initData(); setOnClick(R.id.tv_back_base_activity); &#125; /** * 设置点击事件. * * @param ids 被点击View的ID * @return &#123;@link BaseActivity&#125; */ public BaseActivity setOnClick(@IdRes int... ids) &#123; View view; for (int id : ids) &#123; view = findViewById(id); if (null != view) &#123; view.setOnClickListener(this); &#125; &#125; return this; &#125; /** * 设置点击事件. * * @param views 被点击View * @return &#123;@link BaseActivity&#125; */ public BaseActivity setOnClick(View... views) &#123; for (View view : views) &#123; view.setOnClickListener(this); &#125; return this; &#125; /** * 获取当前布局对象 * * @param savedInstanceState 这个是当前activity保存的数据，最常见的就是横竖屏切换的时候， * 数据丢失问题 * @return 当前布局的int值 */ protected abstract int getLayoutId(Bundle savedInstanceState); @Override protected void onDestroy() &#123; activities.remove(this); super.onDestroy(); &#125; protected void initData() &#123; &#125; protected void initView() &#123; toolbar = findViewById(R.id.toolbar_base_activity); tvToolbarTitle = findViewById(R.id.tv_title_base_activity); tvToolbarRight = findViewById(R.id.tv_right_base_activity); &#125; /** * 设置状态栏背景颜色，不能改变状态栏内容的颜色 */ private void stateBar() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; SystemBarTintManager tintManager = new SystemBarTintManager(this); tintManager.setStatusBarTintEnabled(true); tintManager.setNavigationBarTintEnabled(true); tintManager.setTintColor(Color.parseColor(&quot;#000000&quot;)); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.tv_back_base_activity: onBackPressedSupport(); break; default: break; &#125; &#125; &emsp;&emsp;这里我需要说明的是，新增了一个开源框架，就是设置状态栏背景颜色的systembartint。 1implementation &apos;com.readystatesoftware.systembartint:systembartint:1.0.3&apos; &emsp;&emsp;再就是设置activity标题内容，左边，右边的内容，左边右边可能是文字，也可能是图片。所以，我在用的时候，都是用的TextView，ImageView，不能设置文字。方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public BaseActivity setTitles(CharSequence title) &#123; tvToolbarTitle.setText(title); return this; &#125; /** * 初始化toolbar的内容 * @param isShowToolbar 是否显示toolbar * @param isShowBack 是否显示左边的TextView * @param isShowMore 是否显示右边的TextView * @return 当前activity对象，可以连点 */ protected BaseActivity initToolbar(boolean isShowToolbar, boolean isShowBack, boolean isShowMore) &#123; setSupportActionBar(toolbar); ActionBar actionBar = getSupportActionBar(); if (null != actionBar) &#123; if (isShowToolbar) &#123; actionBar.show(); tvBack = findViewById(R.id.tv_back_base_activity); TextView textView = findViewById(R.id.tv_right_base_activity); if (null != tvBack &amp;&amp; null != textView) &#123; tvBack.setVisibility(isShowBack ? View.VISIBLE : View.INVISIBLE); textView.setVisibility(isShowMore ? View.VISIBLE : View.INVISIBLE); &#125; &#125; else &#123; actionBar.hide(); &#125; &#125; return this; &#125; public BaseActivity setToolbarBack(int colorId) &#123; toolbar.setBackgroundColor(getResources().getColor(colorId)); return this; &#125; @SuppressWarnings(&quot;unused&quot;) public BaseActivity setMyTitle(String title) &#123; tvToolbarTitle.setText(title); return this; &#125; public BaseActivity setMyTitle(@StringRes int stringId) &#123; tvToolbarTitle.setText(stringId); return this; &#125; public void setMoreTitle(String moreTitle) &#123; tvToolbarRight.setText(moreTitle); &#125; public BaseActivity setMoreTitle(@StringRes int stringId) &#123; tvToolbarRight.setText(stringId); return this; &#125; /** * 设置左边内容. * * @param leftTitle 内容 * @return &#123;@link BaseActivity&#125; */ public BaseActivity setLeftTitle(String leftTitle) &#123; if (tvBack != null) &#123; tvBack.setBackground(null); tvBack.setText(leftTitle); &#125; return this; &#125; /** * 设置左边内容. * * @param leftTitle 内容 */ public void setLeftTitle(@StringRes int leftTitle) &#123; if (tvBack != null) &#123; tvBack.setBackground(null); tvBack.setText(leftTitle); &#125; &#125; @SuppressWarnings(&quot;unused&quot;) protected BaseActivity setMoreBackground(int resId) &#123; tvToolbarRight.setBackgroundResource(resId); return this; &#125; &emsp;&emsp;可以看到上面的方法返回值都是BaseActivity，这样做的目的就只有一个，可以连点，写一个方法之后，可以接着点写下一个方法，不用写一个方法就要加分号，就换一行写下一个方法。 &emsp;&emsp;还要加一句，在你的app主题里面添加两个item，也就是你的res目录下面的style： 12&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &emsp;&emsp;我这里贴出我目前的style的图片 &emsp;&emsp;下面有一个LineHorizontal样式，就是你toolbar下面的那个横线 BaseFragment&emsp;&emsp;BaseFragment跟BaseActivity的逻辑是差不多的，我这里就贴出代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package com.haichenyi.myproject.base;import android.os.Bundle;import android.support.annotation.IdRes;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.haichenyi.myproject.utils.ToastUtils;import me.yokeyword.fragmentation.SupportFragment;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public abstract class BaseFragment extends SupportFragment implements BaseView, View.OnClickListener &#123; protected boolean isInit; private View rootView; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; int layoutRes = layoutRes(); if (0 != layoutRes) &#123; return inflater.inflate(layoutRes, null); &#125; else &#123; return super.onCreateView(inflater, container, savedInstanceState); &#125; &#125; @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); rootView = view; &#125; @Override public void onLazyInitView(@Nullable Bundle savedInstanceState) &#123; super.onLazyInitView(savedInstanceState); isInit = true; init(); &#125; protected &lt;T extends View&gt; T findViewById(@IdRes int id) &#123; return rootView.findViewById(id); &#125; /** * 设置点击事件. * * @param ids 被点击View的ID * @return &#123;@link BaseFragment&#125; */ public BaseFragment setOnClick(@IdRes int... ids) &#123; for (int id : ids) &#123; rootView.findViewById(id).setOnClickListener(this); &#125; return this; &#125; /** * 设置点击事件. * * @param views 被点击View的ID * @return &#123;@link BaseFragment&#125; */ public BaseFragment setOnClick(View... views) &#123; for (View view : views) &#123; view.setOnClickListener(this); &#125; return this; &#125; protected abstract void init(); @Override public void onDestroy() &#123; rootView = null; super.onDestroy(); &#125; protected abstract int layoutRes(); @Override public void showTipMsg(String msg) &#123; ToastUtils.showTipMsg(msg); &#125; @Override public void showTipMsg(int msg) &#123; ToastUtils.showTipMsg(msg); &#125; @Override public void showLoading() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.showLoading(); &#125;*/ &#125; @Override public void hideLoading() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.hideLoading(); &#125;*/ &#125; @Override public void invalidToken() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.invalidToken(); &#125;*/ &#125; @Override public void onClick(View v) &#123; &#125; @Override public void myFinish() &#123; onBackPressedSupport(); &#125;&#125; &emsp;&emsp;两者在布局抽象方法里面有一点区别，Activity的传了Boundle参数，Fragment没有传，因为Fragment可以通过getArguments()方法获取到这个对象，而Activity不能获取到。 总结&emsp;&emsp;到此，一个简单的项目框架就出来了，目前还是框架的第一步，是一个雏形，还不包括MVP，dagger等等，下一篇就加上MVP，我这个人有个好习惯，就是喜欢写注释，我注释写的很清楚，是干什么用的，我也衷心的希望，你能写好注释。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVC、MVP、MVVM比较]]></title>
    <url>%2F2018%2F02%2F22%2FMVC%E3%80%81MVP%E3%80%81MVVM%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[Android框架的最终目的，也是体现一个项目好坏的唯一标准——高类聚，低耦合 MVC&emsp;&emsp;我们刚接触android写代码的时候基本上都是MVC架构。什么是MVC架构呢？ &emsp;&emsp;MVC：Model View Controller的简称。流程图如下： &emsp;&emsp;当用户发出事件的时候，首先通过V层，通知C层，然后C层通知Model层数据发生了变化，更新数据，M层直接显示数据到V层。 &emsp;&emsp;通俗的讲，xml可以理解层View层，你封装的网络请求的帮助类理解成model层，activity，fragment理解成Controller层。这么理解是可以的，但是，你不能说xml就是view层，这样说是不对的 &emsp;&emsp;举个例子，比方说一个登录的网络请求，首先，你需要点击按钮去触发网络请求的方法，你点击的这个button就是写在xml布局里面的，这就是V层。然后触发的网络请求帮助类去发送对应的登录请求方法，这就是model层。两者是怎么联系在一起的呢？就是我们在activity，fragment层里面写的onclick方法。activity，fragment就是Controller层。 MVP&emsp;&emsp;所有的UI变化，网络请求等等业务逻辑之类的都写在Activity里面，Activity既要处理业务逻辑，又要处理UI变化，代码就显得非常臃肿。 &emsp;&emsp;这个时候，MVP就顺势而生，什么是MVP架构呢？ &emsp;&emsp;MVP：Model View Presenter的简称 &emsp;&emsp;MVP作为MVC的演化版本，解决了MVC不少的缺点，对于Android来说，MVP的M层，相对于MVC来说是一样的，而不一样的就是activity不再是controller，而是纯粹的V层，所有关于用户事件的转发，全都由P层去处理 &emsp;&emsp;MVP和MVC最明显的差别就是，M层和V层完全解藕，两者的通信是通过P层，P层作为桥梁，用于操作View层发送的事件到P层，P层去操作M层，并且，讲数据返回给V层。整个过层M层和V层两者完全没有联系。辣么，就有好奇的宝宝就问了，这样做解决不了更本问题，你这样做P层和V层不一样耦合在一起了吗？我们并不能完全不耦合，只是尽可能减少耦合度。我们写程序最终目的就是高类聚，低耦合，不是说完全不耦合。并且，我们这里P层和V层是通过接口通信的，如果网络请求逻辑发生变化，直接修改P层里面的代码，就可以了。V层完全不用改。如果业务逻辑发生变化，我们直接重新定义接口也非常方便 MVVM&emsp;&emsp;由微软提出来的—MVVM。什么是MVVM架构呢？ &emsp;&emsp;MVVM：Model View ViewModel &emsp;&emsp;一眼看上去更MVP差不多，只是把P层换成了ViewModel层。还有一点就是View层和ViewModel层是相互绑定的关系，当你更新ViewMdel层数据的时候，View层的UI就要相应的发生变化。 &emsp;&emsp;不管怎么说，三种模式的出现，或者说所有的开发模式，或者说是架构的出现，他们都有一个最终的目的，那就体现是一个项目架构好坏的：高类聚，低耦合 &emsp;&emsp;学习成本，MVC最简单，弊端也是最多的，学起来也是最快的。MVP和MVVM两者都是MVC的演化版本，两者没法评论优缺点，各有千秋。MVP是目前最火的架构（-.-）。 总结&emsp;&emsp;吹了这么多，MVP有没有什么缺点呢？答案是肯定的：有。本人认为，MVP是目前已知框架最好的 缺点 P层比较臃肿，所有的逻辑代码，网络请求都丢在P层 接口很多，一个功能，相对于MVC来讲，需要多写很多代码 V层P层耦合度过于高，一旦视图需要变更，P层就要相应的发生变化 优点 解藕，这个不用说了 结构清晰明了，不会过了一个月就变成别人的代码 提高了维护性，功能出了问题，直接定位到接口，修改接口就行了 容易进行单元测试，虽然会用单元测试的人比较少]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制原理]]></title>
    <url>%2F2018%2F02%2F22%2FAndroid%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[推荐：非著名程序员的安卓自定义View教程目录，我的自定义view就是看他的这个系列学会的 &emsp;&emsp;首先，我们需要确认的是android的事件传递机制是责任链模式，如果自己能处理就拦截下来自己处理，如果自己处理不了或者不确定就传递给下一个对象 事件的拦截、分发、消费&emsp;&emsp;我们要知道三个方法，控制事件反而拦截，分发与消费。如下表： 类型 相关方法 Activity ViewGroup View 事件分发 dispatchTouchEvent 有 有 无 事件拦截 onInterceptTouchEvent 无 有 无 事件处理 onTouchEvent 有 有 有 以上三个方法，均有boolean类型的返回值，通过设置true，false来控制事件传递的流程 Activity和View均没有事件拦截方法，是因为 Activity作为事件响应起点，如果，Activity把事件拦截了，辣么将为导致整个屏幕都无法点击 View作为事件响应的最末端，要么消费事件，要么不处理回传，没必要拦截事件 事件分发流程&emsp;&emsp;先给出一张图 &emsp;&emsp;这里，我们看到多了两个东西，一个是PhoneWindow，一个是DecorView，我们平时写的布局，最外层的父布局就是这里的RootView，有过几个app开发经验的程序员都应该知道，app的状态栏颜色的修改，还有那个主题的内容修改，修改后显示在哪呢？没错，就是DecorView里面。 &emsp;&emsp;再有就是phoneWindow，其实，知不知道没什么用，phonewindow是Window的唯一实现类，Window是干嘛的呢？Window是一个抽象类，所有的视图，事件传递都归它管理，所以，phonewindow管理视图，上面说的DecorView就是phonewindow的一个内部实现类，除了自己的功能外，还负责消息传递。 &emsp;&emsp;说了这么多，该来讲讲事件传递的流程了。android的view是树形结构的，基于这样的结构，我们的事件可以有序的分发。事件收集之后，起点是Activity，然后有序的向下传递，大致如下： Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View 如果这个事件没有对象处理，辣么，它会依次往回传递，如果还是没有人处理，辣么就会被Activity抛弃掉 Activity &lt;－ PhoneWindow &lt;－ DecorView &lt;－ ViewGroup &lt;－ ... &lt;－ View 这就是文章开头我们提到的，责任链模式 下面我给出ViewGroup的事件分发机制的伪代码： 12345678910111213public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean result = false; // 默认状态为没有消费过 if (!onInterceptTouchEvent(ev)) &#123; // 如果没有拦截交给子View result = child.dispatchTouchEvent(ev); &#125; if (!result) &#123; // 如果事件没有被消费,询问自身onTouchEvent result = onTouchEvent(ev); &#125; return result;&#125; &emsp;&emsp;情景：老板: 我看公司最近业务不咋地，准备发展一下电商业务，下周之前做个淘宝出来试试怎么样。&emsp;&emsp;事件顺序，老板(MainActivity)要做淘宝，这个事件通过各个部门(ViewGroup)一层一层的往下传，传到最底层的时候，码农小王(View1)发现做不了，于是消息又一层一层的回传到老板那里。&emsp;&emsp;可以看到整个事件传递路线非常有序。从Activity开始，最后回传给Activity结束(由于我们无法操作Phone Window和DecorView，所以没有它们的信息)。 1234567891011MainActivity [老板]: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.RootView [经理]: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.RootView [经理]: onInterceptTouchEvent (老板可能疯了,但又不是我做.)ViewGroupA [组长]: dispatchTouchEvent 老板要做淘宝,下周上线?ViewGroupA [组长]: onInterceptTouchEvent (看着不太靠谱,先问问小王怎么看)View1 [码农]: dispatchTouchEvent 做淘宝???View1 [码农]: onTouchEvent 这个真心做不了啊.ViewGroupA [组长]: onTouchEvent 小王说做不了.RootView [经理]: onTouchEvent 报告老板, 技术部说做不了.MainActivity [老板]: onTouchEvent 这么简单都做不了,你们都是干啥的(愤怒). 总结事件分发机制设计到到情形非常多，这里就不一一列举了，记住以下几条原则就行了。 如果事件被消费，就意味着事件信息传递终止。 如果事件一直没有被消费，最后会传给Activity，如果Activity也不需要就被抛弃。 判断事件是否被消费是根据返回值，而不是根据你是否使用了事件。]]></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View]]></title>
    <url>%2F2018%2F02%2F08%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Netty的简单使用，实现socket通讯]]></title>
    <url>%2F2018%2F02%2F08%2FNetty%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[自从用了netty框架，妈妈再也不用担心我的socket通讯了&emsp;&emsp;题外话，很多人都把JDK1.4提供的NIO称之为异步非阻塞I/O；其实，并不然，从严格意义上面讲，它只能称为非阻塞I/O。在JDK1.7提供的NIO 2.0，新增了异步的套接字通道Channel，它才是真正的异步非阻塞I/O。下表是不同I/O模型的对比： 表1-1 几种I/O模型和同能对比 同步阻塞I/O(BIO) 伪异步I/O 非阻塞I/O(NIO) 异步I/O(AIO) 客户端个数：I/O线程 1:1 M:N(M可以大于N) M:1(1个I/O线程处理多个客户端连接) M:0(不需要启动额外的I/O线程，被动回调) I/O类型(阻塞) 阻塞I/O 阻塞I/O 非阻塞I/O 非阻塞I/O I/O类型(同步) 同步I/O 同步I/O 同步I/O(I/O多路复用) 异步I/O API使用难度 简单 简单 非常复杂 复杂 调试难度 简单 简单 复杂 复杂 可靠性 非常差 差 高 高 吞吐量 低 中 高 高 简介&emsp;&emsp;Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 &emsp;&emsp;也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。 &emsp;&emsp;“快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。——百度百科 优点 API使用简单，开发门槛低 功能强大，预置了多种编解码功能，支持多种主流协议 性能高，通过与业界其他主流NIO框架相比，netty的综合性能最高 成熟，稳定，Netty已经修复了已经发现的所有的JDK NIO BUG，业务开发人员不用再为NIO的bug而烦恼 社区活跃，版本迭代周期短，发现bug可以及时被修复，同时有更多的新功能加入 经历了大规模的商界业务考验，只能得到了验证 粘包、拆包概念&emsp;&emsp;TCP是一个流协议，所谓的流，就是没有界限的一串数据。可以考虑河里的流水，他们并没有界限。tcp底层并不了解业务层数据的具体含义，他会根据tcp缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被tcp拆分成多个包进行发送，也可能把多个小包封装成一个大数据一起发送，这就是所谓的tcp粘包，拆包问题 产生原因 应用程序write写入的字节大小大于套接口发送缓冲区的大小 进行MSS大小的tcp分段 以太网帧的payload大于MTU进行IP分片 解决办法 消息定长，每个报文大小固定长度，不够的补0 包尾增加回车换行符进行分割。例如：FTP协议 将消息分为消息头和消息体。消息头中包含消息的总长度字段 更复杂的应用层协议 Netty框架的解决办法&emsp;&emsp;LineBasedFrameDecoder和StringDecoder两个类 LineBasedFrameDecoder&emsp;&emsp;LineBasedFrameDecoder的工作原理是依次遍历ByteBuf中的可读字节，判断看是否有”\r”或者”\r\n”，如果有就以此为结束位置，从可读索引位置到结束区间的字节就组成了一行。他是以换行符为结束标志的解码器，支持携带结束符和不带结束符两种解码方式。同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读取的异常流 StringDecoder&emsp;&emsp;StringDecoder的功能就非常简单，就是将接收到的对象换成字符串，然后继续调用后面的handler，LineBasedFrameDecoder+StringDecoder组合就是按换行符切换文本解码器，他被设计用来支持TCP粘包和拆包。Netty支持其他其他符号的解码器(DelimiterBasedFrameDecode) &emsp;&emsp;说了这么多，代码来了，就是用Netty实现的心跳。对于懒癌晚期，已经风装好，可以直接拿过去用，注释也写的很清楚 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import android.util.Log;import io.netty.bootstrap.Bootstrap;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import io.netty.util.CharsetUtil;/** * @author 海晨忆 * @date 2018/2/6 * @desc */public class SocketTcp &#123; private static SocketTcp socketTcp = new SocketTcp(); private Channel channel = null; private EventLoopGroup group; private int port; private String host; public static SocketTcp getInstance() &#123; return socketTcp; &#125; public SocketTcp setPort(int port) &#123; this.port = port; return this; &#125; public SocketTcp setHost(String host) &#123; this.host = host; return this; &#125; public void connect() &#123; if (channel != null) return; if (group == null) &#123; //NIO线程组 group = new NioEventLoopGroup(); &#125; try &#123;//配置Bootstrap Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; //以换行符为结束标记 ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); pipeline.addLast(new LineBasedFrameDecoder(Integer.MAX_VALUE)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket()); //以&quot;$_&quot;作为分隔符 /*ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); String s = &quot;$_&quot;; ByteBuf byteBuf = Unpooled.copiedBuffer(s.getBytes()); pipeline.addLast(new DelimiterBasedFrameDecoder(Integer.MAX_VALUE,byteBuf)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket());*/ &#125; &#125;); //发起异步连接操作 ChannelFuture channelFuture = bootstrap.connect(host, port).sync(); channel = channelFuture.channel(); //等待服务端监听端口关闭 channel.closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; disConnect(); &#125; &#125; /** * 断开tcp连接. */ private void disConnect() &#123; if (null != group) &#123; group.shutdownGracefully(); &#125; group = null; channel = null; &#125; public void sendMessage(String msg) &#123;//连接成功后，通过Channel提供的接口进行IO操作 try &#123; if (channel != null &amp;&amp; channel.isOpen()) &#123; channel.writeAndFlush(msg).sync(); Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg); &#125; else &#123; reConnect(); throw new Exception(&quot;channel is null | closed&quot;); &#125; &#125; catch (Exception e) &#123; reConnect(); e.printStackTrace(); &#125; &#125; /** * 重连. */ private void reConnect() &#123; new Thread(this::connect); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.example.zwang.myapplication.socket;import android.os.SystemClock;import android.util.Log;import java.util.concurrent.TimeUnit;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.EventLoop;import io.netty.channel.SimpleChannelInboundHandler;public class MyHeartSocket extends SimpleChannelInboundHandler&lt;Object&gt; &#123; private ChannelHandlerContext ctx; private boolean isConnect = false; @Override protected void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception &#123; Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;); ByteBuf msg1 = (ByteBuf) msg; byte[] bytes = new byte[msg1.readableBytes()]; msg1.readBytes(bytes); String s = new String(bytes, &quot;UTF-8&quot;); Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;); isConnect = true; if (this.ctx == null) &#123; synchronized (MyHeartSocket.class) &#123; if (this.ctx == null) &#123; this.ctx = ctx; MyAppHeart(); &#125; &#125; &#125; &#125; private void MyAppHeart() &#123; new Thread(() -&gt; &#123; while (ctx != null &amp;&amp; isConnect) &#123; String data = &quot;123&quot;; byte[] bytes = data.getBytes(); if (isConnect) &#123; ctx.writeAndFlush(Unpooled.buffer(bytes.length).writeBytes(bytes)); SystemClock.sleep(3000); &#125; &#125; &#125;).start(); &#125; @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; EventLoop loop = ctx.channel().eventLoop(); loop.schedule(() -&gt; SocketTcp.getInstance().connect(), 5, TimeUnit.SECONDS); super.channelInactive(ctx); Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;); isConnect = false; &#125; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; super.userEventTriggered(ctx, evt); Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.exceptionCaught(ctx, cause); Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;); this.ctx.close(); this.ctx = null; &#125;&#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO编程和NIO编程简介]]></title>
    <url>%2F2018%2F02%2F07%2FIO%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;传统的同步阻塞I/O通讯模型，导致的结果就是只要有一方处理数据缓慢，都会影响另外一方的处理性能。按照故障设计原则，一方的处理出现问题，不应该影响到另外一方才对。但是，在同步阻塞的模式下面，这样的情况是无法避免的，很难通过业务层去解决。既然同步无法避免，为了避免就产生了异步。Netty框架就一个完全异步非阻塞的I/O通讯方式 同步阻塞式I/O编程&emsp;&emsp;简单的来说，传统同步阻塞的I/O通讯模式，服务器端处理的方式是，每当有一个新用户接入的时候，就new一个新的线程，一个线程只能处理一个客户端的连接，在高性能方面，并发高的情景下无法满足。伪代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; public void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); while (true) &#123; socket = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; new TimerServerHandler(socket).run(); &#125; &#125;).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //释放资源 if (server != null) &#123; try &#123; server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; server = null; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimerServerHandler implements Runnable &#123; private Socket socket; public TimerServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; BufferedReader in = null; PrintWriter out = null; try &#123; in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); out = new PrintWriter(this.socket.getOutputStream(), true); String currentTime = null; String body = null; while (true) &#123; body = in.readLine(); if (body == null) break; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); //释放in，out，socket资源 &#125; &#125;&#125; &emsp;&emsp;上面这个就是最原始的服务端IO的代码，这里我就给出的是最简化的，当有新的客户端接入的时候，服务端是怎么处理线程的，可以看出，每当有新的客户端接入的时候，总是回新创建一个线程去服务这个新的客户端 伪异步式编程&emsp;&emsp;后来慢慢演化出一个版本“伪异步”模型，新增加一个线程池或者消息队列，满足一个线程或者多个线程满足N个客户端，通过线程池可以灵活的调用线程资源。通过设置线程池的最大值，防止海量并发接入造成的线程耗尽，它的底层实现依然是同步阻塞模型，伪代码如下：1234567891011121314151617181920212223242526272829303132333435import com.example.zwang.mysocket.server.TimerServerHandler;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; private void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); TimeServerHandlerExecutePool executePool = new TimeServerHandlerExecutePool(50, 1000); while (true) &#123; socket = server.accept(); executePool.execute(new TimerServerHandler(socket)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //释放资源 &#125; &#125;&#125; 12345678910111213141516171819202122import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimeServerHandlerExecutePool &#123; private ExecutorService executor; public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123; executor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize, 120L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize)); &#125; public void execute(Runnable task) &#123; executor.execute(task); &#125;&#125; &emsp;&emsp;“伪异步”的代码和传统同步的唯一区别就是在于，首先先创建了一个时间服务处理类的线程池，当有新的客户端接入的时候，先将socket请求封装成task，然后调用线程池的execute方法执行，从而避免了每一个新请求创建一个新线程。由于线程池和消息队列都是有限的，因此，无论客户端的并发量多大，它都不会导致线程个数过于大，而造成的内存溢出。相对于传统的同步阻塞，是一种改良。 &emsp;&emsp;但是他没有从更本上解决同步的问题，伪异步的问题在于，他还是有一方处理出现问题还是会影响到另一方。因为： &emsp;&emsp;当对socket的输入流进行读取操作的时候，它会一直阻塞直到一下三种方式发生： 有数据可读 可读数据已经读取完 发生空指针或者I/O异常。 这意味者，当读取inputstream方处理速度缓慢(不管是什么原因造成的速度缓慢)，另一方会一直同步阻塞，直到这一方把数据处理完. &emsp;&emsp;当调用outputstream的write方法写输出流的时候，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。学过TCP/IP相关知识的人都直到，当消息的接收方处理消息缓慢，不能及时的从TCP缓冲区读取数据，这将会导致发送方的TCP缓冲区的size一直减少，直到0.缓冲区为0，那么发消息的一方将无法将消息写入缓冲区，直到缓冲区的size大于0 &emsp;&emsp;通过以上。我们了解到读和写的操作都是同步阻塞的，阻塞的时间取决于对方的I/O线程的处理速度和网络I/O的传送速度。从本质上面看，我们无法保证对方的处理速度和网络传送速度。如果，我们的程序依靠与对方的处理速度，那么，他的可靠性将会非常差。 NIO编程&emsp;&emsp;官方叫法new I/O，也就是新的IO编程，更多的人喜欢称它为：Non-block IO即非阻塞IO。 &emsp;&emsp;与Socket和serverSocket类对应，NIO提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现，这两种都支持阻塞式编程和非阻塞式编程。开发人员可以根据自己的需求选择合适的编程模式。一般低负载，低并发的应用程序选择同步阻塞的方式以降低编程的复杂度。高负载，高并发的不用想了，非阻塞就是为了解决这个问题的 缓冲区Buffer &emsp;&emsp;Buffer是一个对象，它包含一些写入或者读出的数据。再NIO中加入buffer对象，体现了新库和旧库的一个重要区别。在面向流的io中，可以直接把数据读取或者写入到stream对象中。在NIO库中，所有数据操作都是通过缓冲区处理的。 &emsp;&emsp;缓冲区实质上是一个数组，通常是一个字节数组（ByteBuffer），基本数据类型除了boolean没有，其他都有，如ShortBuffer,CharBuffer等等 通道Channel &emsp;&emsp;Channel是一个通道，双向通道，网络数据都是通过Channel读取，写入的。是的，没错，Channel它既可以进行读操作，也可以进行写操作。而流只能是一个方向。只能读操作或者只能写操作，而channel是全双工，读写可以同时进行。channel可以分为两大类：网络读写的SelectableChannel和文件操作的FileChannel。我们前面提到的SocketChannel和ServerSocketChannel都是SelectableChannel的子类。 多路复用器Selector &emsp;&emsp;selector多路复用器，他是java NIO编程的基础，熟练的掌握selector对于NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单的讲就是他会不断的轮询注册的channel，如果一个Channel发生了读写操作，这个Chnnel就会处于就绪状态，会被selector轮询出来，通过SelectorKey获取就绪Channel集合，进行后续的IO操作。一个selector对应多个Channel &emsp;&emsp;由于原生NIO编码比较麻烦和复杂，我这里就给出了思路的伪代码。下一篇我们将用NIO中的Netty框架实现Socket通信，编码简单，一行代码解决烦人粘包、拆包问题。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 服务端nio过程的伪代码 * * @param port 端口号 * @throws IOException IOException */ private void init(int port) throws IOException &#123; //第一步：打开ServerSocketChannel，用于监听客户端连接，它是所有客户端连接的父管道 ServerSocketChannel socketChannel = ServerSocketChannel.open(); //第二步：监听绑定端口，设置连接模式为非阻塞模式， socketChannel.socket().bind(new InetSocketAddress(InetAddress.getByName(&quot;IP&quot;), port)); socketChannel.configureBlocking(false); //第三步：创建Reactor线程，创建多路复用器，并启动线程。 Selector selector = Selector.open(); new Thread().start(); //第四步：将ServerSocketChannel注册到Reactor线程的多路复用器上，监听accept事件 SelectionKey key = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第五步：多路复用器在线程run方法的无线循环体内轮询准备就绪的key int num = selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator(); while (it.hasNext()) &#123; SelectionKey next = it.next(); //deal with io event... &#125; //第六步：多路复用器检测到有新客户端接入，处理新的接入请求，完成TCP三次握手，建立物理链路 SocketChannel channel = socketChannel.accept(); //第七步：设置客户端为非阻塞模式 channel.configureBlocking(false); channel.socket().setReuseAddress(true); //第八步：将新接入的客户端注册到reactor线程的多路复用器上，监听读操作，读取客户端发送的消息 SelectionKey key1 = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第九步：异步读取客户端消息到缓冲区， /*int readNumber = channel.read(&quot;receivebuff&quot;);*/ //第十步：对byteBuffer进行编解码，如果有半包信息指针reset，继续读取到后续的报文，将解码成功消息封装成task，投递到业务线程池，进行业务逻辑编排 Object massage = null; while (buff.hasRemain()) &#123; buff.mark(); Object massage1 = decode(btyeBuffer); if (massage1 == null) &#123; byteBuffer.reset(); break; &#125; massageList.add(massage1); &#125; if (!byteBuffer.hasRemain()) &#123; byteBuffer.clean(); &#125; else &#123; byteBuffer.compact(); &#125; if (massageList != null &amp;&amp; !massageList.isEmpty()) &#123; for (Object massage3 : massageList)&#123; handlerTask(massage3); &#125; &#125; //第十一步：将POJO对象encode成ByteBuff，调用SocketChannel的异步write接口，将异步消息发送到客户端 socketChannel.write(buffer); &#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
</search>
