<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kotlin之协程（一）]]></title>
    <url>%2F2019%2F07%2F16%2Fkotlin%E4%B9%8B%E5%8D%8F%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;kotlin协程用于线程切换，kotlin里面不需要new Thread，并且，协程的开销小于new Thread。有三种写法：runBlocking，launch，async 既然协程的出现可以取代Thread，我们这里想要验证的是： 会不会阻塞主线程，能不能做耗时操作？ 协程里面的代码是怎么执行的？按顺序执行还是并行? 协程里面能不能更新页面？ 依赖&emsp;&emsp;协程需要额外依赖一个库协程用于android的库，它会自动依赖官方提供的那个协程的代码库。1implementation &apos;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.0-M2&apos; runBlocking用法：123456789101112131415override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) runBlocking &#123; Log.e(&quot;wz&quot;, &quot;for_start&quot;) for (i in 0..5) &#123; delay(500) Log.e(&quot;wz&quot;, i.toString()) &#125; Log.e(&quot;wz&quot;, &quot;for_end&quot;) tvName.text = &quot;for_end&quot; &#125; Log.e(&quot;wz&quot;, &quot;runBocking外&quot;) &#125; 结果： &emsp;&emsp;从打印顺序上看，runBlocking的执行顺序是从上往下执行的，并且能更新页面，所以，runBlocking可以理解成在主线程中执行。回答上面的三个问题： 会阻塞线程，可以做耗时操作 从上往下按顺序执行的 可以更新页面 &emsp;&emsp;java里面有Thread，所以线程休眠用Thread.sleep()。kotlin里面既然协程可以取代Thread，所以，kotlin也有自己的休眠方法，也就是上面的delay()，注意，这里delay只能用在协程里面，不能用在外面。 GlobalScope.launch用法： 123456789101112131415override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) GlobalScope.launch &#123; Log.e(&quot;wz&quot;, &quot;for_start&quot;) for (i in 0..5) &#123; delay(500) Log.e(&quot;wz&quot;, i.toString()) &#125; Log.e(&quot;wz&quot;, &quot;for_end&quot;) tvName.text = &quot;for_end&quot; &#125; Log.e(&quot;wz&quot;, &quot;runBocking外&quot;) &#125; 结果： &emsp;&emsp;从打印顺序上面看，launch是先执行外面的代码，然后执行协程里面的代码，最后在设置text的时候程序崩掉了。所以，launch可以理解成新开了一个线程执行，但是，协程的开销小于新开线程。回答上面的三个问题: 不会阻塞线程，可以做耗时操作 既然会阻塞线程，那就是并行的 不能更新页面 GlobalScope.async用法： 123456789101112131415override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) GlobalScope.async &#123; Log.e(&quot;wz&quot;, &quot;for_start&quot;) for (i in 0..5) &#123; delay(500) Log.e(&quot;wz&quot;, i.toString()) &#125; Log.e(&quot;wz&quot;, &quot;for_end&quot;) tvName.text = &quot;for_end&quot; &#125; Log.e(&quot;wz&quot;, &quot;runBocking外&quot;) &#125; 结果： &emsp;&emsp;从打印顺序上看，跟launch是一样的，只是async的程序没有崩溃，但是页面一样没有更新。所以结论更launch是一样的。 &emsp;&emsp;都一样的话，那么launch和async有什么区别呢？他们俩的返回值不一样。launch的返回值：Job，而async的返回值：Deferred 这也是我们用于线程切换，更新页面的原因。 &emsp;&emsp;那么，问题来了，既然可以代替Thread，怎么更新页面呢？我们实际项目里面很多时候，都是拿到数据之后，对数据做完操作就更新页面。协程要怎么做呢？async一般都是与await成对出现 12345678910111213141516override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) GlobalScope.launch(Dispatchers.Main) &#123; tvName.text = GlobalScope.async(Dispatchers.IO) &#123; var index = 0 for (index1 in 0..10) &#123; index++ delay(500) Log.e(&quot;wz&quot;, &quot;index的值为：$&#123;index&#125;&quot;) &#125; return@async &quot;index的值为：$&#123;index&#125;&quot; &#125;.await() &#125; Log.e(&quot;wz&quot;, &quot;runBocking外&quot;) &#125; 如上面的代码所示： launch(Dispatchers.Main)的意思就是在主线程中执行 async(Dispatchers.IO)的意思就是在IO线程中执行，并且用await方法获取到返回值，赋值给text &emsp;&emsp;所以，上面的意思就是launch里面套了一个async，launch的构造方法里面传的Main，意思就是在主线程中执行，async的构造方法里面传IO，意思就是在IO线程中执行。并且拿到返回值，赋值给text。]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin之内部类，匿名内部类与伴生对象]]></title>
    <url>%2F2019%2F06%2F14%2Fkotlin%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[内部类&emsp;&emsp;kotlin的内部类与java的内部类有点不同java的内部类可以直接访问外部类的成员，kotlin的内部类不能直接访问外部类的成员，必须用inner标记之后才能访问外部类的成员 123456789101112131415class AAA&#123; var a = 0 class BBB&#123; //此时，BBB类的内部是不能直接用a变量的 var b = a //编译无法通过 &#125;&#125;class AAA&#123; var a = 0 inner class BBB&#123; //此时，BBB类的内部是可以直接用a变量的 var b = a //编译可以通过 &#125;&#125; 匿名内部类&emsp;&emsp;匿名内部类主要是针对那些获取抽象类或者接口对象而来的。最常见的匿名内部类点击事件： 1234567//java,匿名内部类的写法btn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); &emsp;&emsp;上面这个是java匿名内部类的写法，kotlin没有new关键字，那么kotlin的匿名内部类该怎么写呢？ 123456btn1.setOnClickListener(object : View.OnClickListener&#123; override fun onClick(v: View?) &#123; print(&quot;1111&quot;) &#125; &#125;) &emsp;&emsp;方法的参数是一个匿名内部类，先写object:，然后写你的参数类型View.OnClickListener{}，然后编译器会出提示，让你补齐即可。 &emsp;&emsp;kotlin还有一个写法lambda 表达式，非常之方便，这个是java，jdk1.8里面包含的 1btn1.setOnClickListener &#123; print(&quot;1111&quot;) &#125; 单例模式(object)&emsp;&emsp;说道这个object就让我想到了kotlin里面的单例模式，kotlin里面用object标记的类，默认在初始化时候自己生成单例，这也是为什么我们再混合开发的时候，java里面调用会有INSTANCE这个东西。 123456object AAA&#123; var a = 10 fun getName() : String&#123; return &quot;海晨忆&quot; &#125;&#125; &emsp;&emsp;上面这个类AAA，默认就有单例，所以可以直接AAA.getName()，这样调用方法。AAA.a这样直接使用变量，混合模式的时候，我们的调用方式是”AAA.INSTANCE.getName()” &emsp;&emsp;我们java里面写的工具类都是用static表示，kotlin里面就不需要，直接把你的工具类的class表示换成object，然后在这个工具类里面正常写方法，就可以直接用类.方法调用，常量也是一样的 伴生对象(companion object)&emsp;&emsp;伴生对象对应的java里面的就是一个类中的静态变量，静态方法。但是，这里编译之后对应的java文件，并不是静态的，而是通过单例调用的。伴生对象的写法： 12345678910111213141516171819202122class SecondActivity : AppCompatActivity() &#123; companion object &#123; var c: Int = 10 fun getName(): String &#123; return c.toString() &#125; class CCC &#123; var d: Int = 11 &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_second) &#125;&#125;//在其他位置的调用方式：SecondActivity.cSecondActivity.getName()SecondActivity.Companion.CCC().d object，companion object，扩展方法的区别&emsp;&emsp;昨天写的扩展方法，我们说到，它编译之后对应的java文件生成的方法都加上了final static，所以，我们说它是静态的。 &emsp;&emsp;今天的这两个object和伴生对象，通过查看它编译之后的java文件，他的属性，方法都是加了final，并没有static，但是，object标识的类在初始化的时候生成了final static类型的INSTANCE变量 ，伴生对象在初始化的时候生成了final static类型的Companion变量 PS:最好写个demo看一下对应的java文件，印象深刻，查看方式：Tools –&gt; Kotlin –&gt; Show Kotlin ByteCodes]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin之扩展方法]]></title>
    <url>%2F2019%2F06%2F14%2Fkotlin%E4%B9%8B%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;kotlin的扩展方法类似于java工具类，但是又优于java的工具类。 扩展方法&emsp;&emsp;扩展方法的写法，新建一个File类型的kt文件，不是Class类型，不是Interface类型，不是枚举类型，不是Object类型，就是File类型 &emsp;&emsp;然后直接定义方法，跟kotlin定义方法相同，需要什么方法就定义什么方法，唯一的区别就是在方法名的前面可以加上”类型.”，格式如下 1234//类型可以省略，即任意类型fun 类型.方法名(参数...):返回值&#123; &#125; 举个例子： 123456789//两个数相加，任意类型都可以调用fun add(a: Int, b: Int): Int &#123; return a + b&#125;//加载图片，只有ImageView类型可以调用fun ImageView.loadUrl(imgUrl: String) &#123; Glide.with(this.context).load(imgUrl).into(this)&#125; 调用的例子： 12345678910111213141516171819package com.haichenyi.aloe.mykotlinimport android.os.Bundleimport android.support.v7.app.AppCompatActivityimport kotlinx.android.synthetic.main.activity_second.*class SecondActivity : AppCompatActivity()&#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_second) val a = 1 val b = 2 //调用两个数相加 add(a, b) //调用加载图片 img.loadUrl(&quot;&quot;) &#125;&#125; 这里需要注意的是： 如果方法没有加类型，就是随便什么类型都能调用，就是只要是项目在内的其他任意地方都可以调用这个方法 第二个是ImageView类型才能调用，要记得是变量调用，而不是类型调用，变量调用方法。就像我这里的img变量，就是ImageView类型的 写法我们都知道用Glide加载图片，最后into方法传递的是一个ImageView类型的view，我上面写的this，这里的this就是指的是当前方法前面类型的变量，也就是这里的ImageView类型的变量，也就是我们调用的时候的img变量 扩展方法，其实最后生成java文件的时候，就是在方法的前面加上了static final ，没什么神奇的，最后跟我们java里面工具类的原理是一样的。 Activity间的跳转1startActivity(Intent(this@MainActivity,SecondActivity::class.java)) 密封类sealed&emsp;&emsp;java中没有密封类的概念，这个是kotlin独有的，他能使我们的代码更加安全。 &emsp;&emsp;kotlin的类默认是final，不能被继承，sealed修饰的类可以被继承，因为它修饰的是open，这里只是把open隐藏了。 &emsp;&emsp;为什么说它能使我们的代码更加安全呐？举个例子： 12345678lateinit var obj : Anyvar b = when(obj)&#123; 1 -&gt; 2 is String -&gt; 3 3,4 -&gt; &quot;obj等于3或者等于4&quot; in 10..20 -&gt; &quot;obj在10到20之间&quot; else -&gt; true&#125; &emsp;&emsp;这个是我们之前说过的when的表达式，我们之前讲过when表达式最后必须要加else，不然编译通过不了。或者你能保证else前面的条件语句包括else条件的情况，那就不用加。一般情况下，我们都加else。我们看一下下面这个写法 123456789101112131415161718sealed class AAA &#123;&#125;class BBB : AAA() &#123;&#125;class CCC : AAA() &#123;&#125;fun QQQ(aaa: AAA): Int = when (aaa) &#123; is BBB -&gt; 10 is CCC -&gt; 11 &#125; &emsp;&emsp;我们这里类AAA是用sealed标识的，类BBB,CCC都继承AAA。我们方法QQQ需要传递一个AAA对象，里面用when做判断，这里就不需要加else，因为这里的条件只有两种，一种是类BBB,一种是类CCC，没有第三种。如果AAA，没有用sealed标识，这里还可以加其他条件，编译都可以通过，因为判断不出来，所以，代码就不安全。]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin之构造函数(constructor)]]></title>
    <url>%2F2019%2F06%2F12%2Fkotlin%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-constructor%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;java中的构造函数是与类名相同即可，kotlin里面的构造函数是用constructor关键字表示。 &emsp;&emsp;kotlin里面的构造函数分为主构造函数和次构造函数。主构造函数只能有一个，次构造函数个数不限制，可以有一个或者多个 constructor&emsp;&emsp;啥是主构造方法？啥是次构造方法呢？ 1234567891011121314151617181920212223242526272829//主构造方法如下，跟在类名后面class Person constructor(name:String)&#123; &#125;class Person constructor()&#123; &#125;//当主构造方法没有任何注解或者可见性修饰符时，可以省略，写成下面这样class Person &#123; &#125;//这种就是有注解标记的主构造方法，不能省略class Person @Inject internal constructor()&#123; &#125;//次构造方法，一个无参的次构造方法，一个有一个参数的次构造方法class Person &#123; constructor()&#123; &#125; constructor(name:String)&#123; &#125;&#125; &emsp;&emsp;我们可以看到主构造方法是没有方法体的，那么，我们需要初始化的数据应该放到哪呢？kotlin提供了init方法，给我们初始化数据。 123456789101112131415class Person constructor()&#123; init&#123; print(&quot;111&quot;) &#125; init&#123; println() print(&quot;222&quot;) &#125;&#125;var p = Person()//这里我们会看到打印台打印:111，换行打印222//这里构造方法是按顺序执行的//我都是自己写代码跑的结果，不想贴图了，自己写了跑一边，印象会更加深刻 &emsp;&emsp;那么，问题来了，次构造方法有方法体，会执行这个init模块吗？ 123456789101112class Person&#123; constructor()&#123; println() print(&quot;111&quot;) &#125; init&#123; print(&quot;222&quot;) &#125;&#125;//这里我们会看到打印台打印:222，换行打印111 结论：不管是什么构造方法，先执行init模块逻辑，后执行构造方法的逻辑 this，super&emsp;&emsp;简单的说一下继承,this和super两个关键字，跟java差不多； &emsp;&emsp;this是调用自己的，super是调用父类的 12345678910111213141516171819202122232425open class AAA &#123; constructor(name: String) &#123; Log.v(&quot;wz&quot;, &quot;$name A&quot;) &#125; constructor(name: String, age: Int) &#123; Log.v(&quot;wz&quot;, &quot;我是AAA的两个参数的构造方法&quot;) &#125; init &#123; Log.v(&quot;wz&quot;, &quot;222&quot;) &#125; &#125; class BBB : AAA &#123; constructor(name: String) : this(name, 0) &#123; Log.v(&quot;wz&quot;, &quot;我是BBB的一个参数的构造方法&quot;) &#125; constructor(name: String, age: Int) : super(name, age) &#123; Log.v(&quot;wz&quot;, &quot;我是BBB的两个参数的构造方法&quot;) &#125; &#125; var b = BBB(&quot;小王&quot;) &emsp;&emsp;类BBB继承类AAA，其中BBB分别有一个参数的构造方法和两个参数的构造方法；一个参数的构造方法用的this关键字调用自己的两个参数的构造；而两个参数的构造方法用的super关键字调用的父类两个参数的构造方法；这里控制台打印的数据： 1234222我是AAA的两个参数的构造方法我是BBB的两个参数的构造方法我是BBB的一个参数的构造方法 重写set/get方法说到了这个类，讲一下怎么重写属性的set/get方法 123456789101112131415161718open class Person &#123; var name: String = &quot;&quot; set(value) &#123; field = value + &quot;www&quot; &#125; get() &#123; return field + &quot;zzz&quot; &#125; var age: Int = 0 set(value) &#123; field = if (value &gt;= 20) 20 else value &#125; get() &#123; return field * 2 &#125; var address: String = &quot;&quot; &#125; &emsp;&emsp;这里一个person类，里面有三个属性：name，age，address；在name和age下面分别写了set，get方法，address没写。 重点： 你想重写哪个属性的set，get方法，就在哪个属性下方写set，get方法，不用成对出现，可以只重写set方法，也可以只重写get方法 用field表示你想要的值 &emsp;&emsp;这里，我就只重写了name和age的set，get方法，没有重写address的set，get方法 &emsp;&emsp;这里，我再存名字的时候在名字的后面加上了www，在获取的时候又加上了zzz，也就是说，如果你这里name传的是”小王”，那么你用get方法取到的name的值应该是”小王wwwzzz” &emsp;&emsp;存age的时候，自己分析一下吧，很简单。]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin之扩展函数let，run，also，apply]]></title>
    <url>%2F2019%2F06%2F11%2Fkotlin%E4%B9%8B%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0let%EF%BC%8Crun%EF%BC%8Calso%EF%BC%8Capply%2F</url>
    <content type="text"><![CDATA[举个例子 123456789open class Person &#123; var name: String = &quot;&quot; var age: Int = 0 var address: String = &quot;&quot; override fun toString(): String &#123; return &quot;Person($name)&quot; &#125;&#125; &emsp;&emsp;新建一个Person类，有三个属性，重写了toString方法。 &emsp;&emsp;这里有个关键字open，只有用open标识的类才能被继承。 12345678910111213141516171819202122232425262728293031var person1 = Person().let &#123; it.name = &quot;张三let&quot; it.age = 24 it.address = &quot;浦东新区&quot; 10&#125;Log.v(&quot;wz&quot;, person1.toString())//10var person2 = Person().run &#123; this.name = &quot;张思run&quot; this.age = 25 this.address = &quot;青浦区&quot; 20&#125;Log.v(&quot;wz&quot;, person2.toString())//20var person3 = Person().also &#123; it.name = &quot;张武also&quot; it.age = 26 it.address = &quot;黄浦区&quot; 30&#125;Log.v(&quot;wz&quot;,person3.toString())//Person(张武also)var person4 = Person().apply &#123; this.name = &quot;张柳apply&quot; this.age = 27 this.address = &quot;崇明区&quot; 40&#125;Log.v(&quot;wz&quot;,person4.toString())//Person(张柳apply) 上面打印的结果： person1——let——10 person2——run——20 person3——also——Person(张武also) person4——apply——Person(张柳apply) 总结： let,run以最后一行的结果为返回值；also,apply返回对象本身。 在他们的方法体中，let,also用it代指本身；run,apply用this代指本身。 PS:充分了解他们的用法，以及返回值的区别，可以实现链式调用实现功能模块，使代码清晰，一目了然。]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kotlin之基础]]></title>
    <url>%2F2019%2F06%2F11%2Fkotlin%E4%B9%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;自从18年上一家公司用kotlin做了项目之后，新公司就没有用过kotlin了，都快要忘完了，最近又想起来了，再捡了一下吧。 定义变量的方式&emsp;&emsp;java：类型+变量名+值+逗号1int a = 5; &emsp;&emsp;kotlin：var/val+变量名+(:类型)+值(ps:类型可省略) &emsp;&emsp;var：可变变量（可以重新分配值） &emsp;&emsp;val：只读变量（初始化的时候必须赋值，不能修改） 1234var c:int c = 5var c = 5 val b = 5 函数&emsp;&emsp;java：public/private/protected+返回类型+方法名+括号参数+大括号方法体 123456public void add(int a ,int b)&#123; &#125;public int add1(int a,int b)&#123; return a+b;&#125; &emsp;&emsp;kotlin：fun+方法名+括号参数+(:返回类型)+大括号方法体 &emsp;&emsp;返回类型Unit类型，对应java的void，即无返回值，可省略 1234567891011fun add(a:int,b:int):Unit&#123; &#125;fun add(a:int,b:int)&#123; &#125;fun add1(a:int,b:int):int&#123; return a+b &#125; if表达式(java中三目运算符)&emsp;&emsp;把a和b两个数中值大的赋值给c1234java：三目运算符int c = a &gt; b ? a : bkotlin：if表达式val c = if( a &gt; b) a else b for循环123456789101112131415161718192021222324252627282930//javaList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;c&quot;);list.add(&quot;d&quot;);for (int j = 0; j &lt;= list.size(); j++) &#123; Log.v(&quot;wz&quot;, list.get(j));&#125;//kotlinval list = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)for(item in list)&#123; Log.v(&quot;wz&quot;,item)&#125;//上面这个for循环等同于forEachlist.forEach&#123; Log.v(&quot;wz&quot;,it)&#125;//上面两种循环拿不到下标for(index in list.indices)&#123; //美元符号的用法见后面 Log.v(&quot;wz&quot;,&quot;第$index 个item的值是$&#123;list[index]&#125;&quot;)&#125;//上面这种就可以拿到for循环的下标//kotlin中String类型的变量也可以for循环遍历每一个char的值 美元符号($)&emsp;&emsp;把$符号放在变量前面，输出的就是变量的值123456val i = 3Log.v(&quot;wz&quot;,&quot;i的值是：$i&quot;)//输出的是：i的值是：3Log.v(&quot;wz&quot;,&quot;i的值是：$3&quot;)//输出的是：i的值是：$3 == 和 ===的区别&emsp;&emsp;类似于java中的==和equals的区别 &emsp;&emsp;java：==判断值是否相等，equals判断物理地址是否相等 &emsp;&emsp;kotlin：==判断物理地址是否相等，===判断值是否相等 数据类型的转换:toInt(),toBoolean()等等12345678//java中不同数据类型的相互转换是强转String s = &quot;1&quot;;int a = (int)s;//kotlin中没有强转提供了转换的方法var s = &quot;1&quot;var a = s.toInt()var a1 = s.toBoolean() is运算符&emsp;&emsp;个人觉得is运算符类似于java中的instanceof关键字12345678910111213141516//java：判断某个变量是否是某个类型的String s = &quot;1&quot;;if(s instanceof String)&#123; &#125;//kotlin：判断某个变量是否是某个类型var s = &quot;1&quot;if(s is String)&#123; &#125;//既然上面说了is是个运算符，运算符当然可以加非if(s !is String)&#123;&#125; 空指针和lateinit&emsp;&emsp;要明确一点：java中才会有空指针异常，kotlin中不存在空指针异常，因为它有非空判断机制 &emsp;&emsp;比方说，我们如果要在kotlin定义一个Bitmap变量，我们知道Bitmap是非常占内存的，用完之后我们要手动置空 &emsp;&emsp;在类型的后面加上问号，用的时候也要加问号才能用，表示不为空的时候才会往下走，如果为空就不会往下走了 12var bitmap:Bitmap? = nullvar w = bitmap?.width &emsp;&emsp;那么，我们如果要定义一个不可能为空的对象怎么定义呢？ 12lateinit var bitmap:Bitmapbitmap.width 黑科技：when表达式和Any(任意类型)&emsp;&emsp;when表达式取代java中的switch，when的返回值依据每一个条件的返回值来定，可以返回任意类型，从上往下按顺序执行，else不能少 12345678lateinit var obj : Anyvar b = when(obj)&#123; 1 -&gt; 2 is String -&gt; 3 3,4 -&gt; &quot;obj等于3或者等于4&quot; in 10..20 -&gt; &quot;obj在10到20之间&quot; else -&gt; true&#125; &emsp;&emsp;比方说这里，先定义个可以是任意类型变量的的obj，如果传进来的是Int类型的1，则返回int类型的2。如果传进来的是String类型的变量，则返回int类型的3。其他，则返回boolean类型的true &emsp;&emsp;when可以取代 if-else if链。如 1234567val x = 10when &#123; x &lt; 10 -&gt; &quot;x小于10&quot; x in 10..20 -&gt; &quot;x在10到20之间&quot; x in 21..40 -&gt; &quot;x在21到40之间&quot; else -&gt; &quot;x大于40&quot;&#125; 区间&emsp;&emsp;顾名思义：在某个范围内123456789101112131415161718//等同于 x &gt;= 1 &amp;&amp; x &lt;= 4(包括1，包括4)，从1到4x in 1..4 //1，2，3，4//等同于 x &gt;= 1 &amp;&amp; x &lt; 4(包括1，不包括4)，从1到4x in 1 until 4 //1，2，3//包括1，包括4 ，从4到1x in 4 downTo 1 //4，3，2，1//从1到8，每隔两个循环一次，也就是1，3，5，7i in 1..8 step 2//从8到1，每隔两个循环一次，也就是8，6，4，2i in 8 downTo 1 step 2//从8到1，每隔两个，并且要满足能整除3的，这里就是6i in (8 downTo 1 step 2).filter &#123; it % 3 == 0 &#125;//上面的关键字filter，还有map等，用过RxJava的应该很眼熟]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android——Tensorflow-Lite简单使用]]></title>
    <url>%2F2019%2F06%2F11%2FAndroid%E2%80%94%E2%80%94Tensorflow-Lite%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;项目里面用到了tflite，用于做简单的图片处理，不是判断图片是什么类型，就是传进去图片，生成新图片，类似于前面一篇讲的GPUImage的滤镜功能，但是比滤镜功能更加强大。 &emsp;&emsp;我这里要做的就是集成，拿人家训练好的模型直接来用，我不用去训练模型。 第一步 依赖1234567891011//依赖库implementation &apos;org.tensorflow:tensorflow-lite:0.0.0-nightly&apos;android &#123; ··· //set no compress models aaptOptions &#123; noCompress &quot;tflite&quot; &#125;&#125; 第二步 加载训练模型&emsp;&emsp;网上很多介绍资料都是把训练模型直接copy到项目main目录下的assets目录（不存在就创建）与java目录平级，自然，这样的加载方式就是 1234567891011121314151617181920212223242526// load infer model private void loadModel(String model) &#123; try &#123; tflite = new Interpreter(loadModelFile(model)); Log.d(TAG, model + &quot; model load success&quot;); tflite.setNumThreads(4); load_result = true; &#125; catch (IOException e) &#123; Log.d(TAG, model + &quot; model load fail&quot;); load_result = false; e.printStackTrace(); &#125; &#125; /** * Memory-map the model file in Assets. */ private MappedByteBuffer loadModelFile(String model) throws IOException &#123; AssetFileDescriptor fileDescriptor = getApplicationContext().getAssets().openFd(model + &quot;.tflite&quot;); FileInputStream inputStream = new FileInputStream(fileDescriptor.getFileDescriptor()); FileChannel fileChannel = inputStream.getChannel(); long startOffset = fileDescriptor.getStartOffset(); long declaredLength = fileDescriptor.getDeclaredLength(); return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength); &#125; &emsp;&emsp;一个tflite文件就好几M，甚至十几M，全部copy到项目里面不显示，所以，我们一般项目里面用都是先下载，然后再使用，那，这样的方式，我们要怎么加载训练模型呢？ &emsp;&emsp;我们先分析一下再assets目录下面怎么加载的？说白了就是新建一个Interpreter对象，就是加载模型。上面的方法都过时了，我们可以找到Interpreter类，里面你会看到如下的方法 123456789//第一个参数传tflite文件，第二个参数传一个Interpreter静态内部类对象public Interpreter(@NonNull File modelFile, Interpreter.Options options) &#123; this.wrapper = new NativeInterpreterWrapper(modelFile.getAbsolutePath(), options);&#125; //所以，我们自己项目里面加载模型，用如下方式即可Interpreter.Options options = new Interpreter.Options();options.setNumThreads(4);tflite = new Interpreter(new File(&quot;&quot;), options); 第三步 执行run方法1tflite.run(in, out); &emsp;&emsp;通过执行这个run方法，获取我们需要的东西，第一个参数，输入对象，第二个参数，输出参数。 重点，敲黑板 重点，敲黑板 重点，敲黑板 &emsp;&emsp;重点就在这里，这里的输入和输出参数要怎么传？我这里训练模型是用Python做的，它需要传入一个四维数组，所以，输出我们自然也要用一个四维数组接收。 &emsp;&emsp;这里的四维数组怎么传递呐？就要说到Android里面的bitmap知识了，它的每个像素点都是一个ARGB数组。即透明度，红色，绿色，蓝色。我们前面的灰色滤镜之类的东西，实际上就是改变RGB三原色的值，让颜色变成灰色，然后改变亮度之类的就是改变每个管道的透明度。网上有很多这样的知识。 &emsp;&emsp;再来说说这个四维数组，我项目里面用到的这个四维数组：1 X 256 X 256 X 3，这几个值怎么理解呢？ 123451：表示一张图片256X256：表示图片的宽高3：表示RGB色值 &emsp;&emsp;那我们怎么把bitmap对象，转换成我们需要的四维数组呐？ 1234567891011121314151617181920212223242526272829303132333435//定义了一个一维数组，里面就是我们需要的参数，便于修改private int[] ddims = &#123;1, 256, 256, 3&#125;; /** * 获取图片的四维数组 * @param bitmap bitmap对象 * @param ddims 参数数组 * @return 图片四维数组 */public float[][][][] getScaledMatrix(Bitmap bitmap, int[] ddims) &#123; //新建一个1*256*256*3的四维数组 float[][][][] inFloat = new float[ddims[0]][ddims[1]][ddims[2]][ddims[3]]; //新建一个一维数组，长度是图片像素点的数量 int[] pixels = new int[ddims[1] * ddims[2]]; //把原图缩放成我们需要的图片大小 Bitmap bm = Bitmap.createScaledBitmap(bitmap, ddims[1], ddims[2], false); //把图片的每个像素点的值放到我们前面新建的一维数组中 bm.getPixels(pixels, 0, bm.getWidth(), 0, 0, ddims[1], ddims[2]); int pixel = 0; //for循环，把每个像素点的值转换成RBG的值，存放到我们的目标数组中 for (int i = 0; i &lt; ddims[1]; ++i) &#123; for (int j = 0; j &lt; ddims[2]; ++j) &#123; final int val = pixels[pixel++]; float red = ((val &gt;&gt; 16) &amp; 0xFF); float green = ((val &gt;&gt; 8) &amp; 0xFF); float blue = (val &amp; 0xFF); float[] arr = &#123;red, green, blue&#125;; inFloat[0][i][j] = arr; &#125; &#125; if (bm.isRecycled()) &#123; bm.recycle(); &#125; return inFloat; &#125; &emsp;&emsp;上面代码注释写的很清楚了吧？每一行都有注释，for循环的作用也标的很清楚，通过这个方法，我们得到的就是我们想要的四维数组了，这里的四维数组的格式，图片的大小，都是tflite文件建模型的时候设置好的，看你们训练模型的工程师是怎么定义的，你就怎么传。 &emsp;&emsp;然后，新建一个一模一样格式的数组去接收输出值，也是一个四维数组，那么，我们怎么把这个四维数组转换成我们需要的bitmap呢？ 123//创建bitmap的方法，Bitmap.createBitmap(@NonNull @ColorInt int[] colors, int width, int height, Config config); &emsp;&emsp;就是这个方法，传一个一维颜色数组，图片的宽高，还有一个图片的格式，那我们这里就是要把这个四维数组转成一个一维的颜色数组了。 123456789101112131415161718192021222324252627/** * 四维数组转成bitmap对象 * @param outArr 数组 * @param ddims 格式 * @return bitmap */public Bitmap getBitmap(float[][][][] outArr, int[] ddims) &#123; //获取图片的三维数组 float[][][] temp = outArr[0]; int n = 0; //新建一个接收的颜色数组，长度就是图片的宽高之积，类似于上面的像素那个数组 int[] colorArr = new int[ddims[1] * ddims[2]]; //for循环遍历把图片的ARGB色值转成一个颜色值，放入颜色数组中 for (int i = 0; i &lt; ddims[1]; i++) &#123; for (int j = 0; j &lt; ddims[2]; j++) &#123; float[] arr = temp[i][j]; int alpha = 255; int red = (int) arr[0]; int green = (int) arr[1]; int blue = (int) arr[2]; int tempARGB = (alpha &lt;&lt; 24) | (red &lt;&lt; 16) | (green &lt;&lt; 8) | blue; colorArr[n++] = tempARGB; &#125; &#125; //创建bitmap对象 return Bitmap.createBitmap(colorArr, ddims[1], ddims[2], Bitmap.Config.ARGB_8888);&#125; &emsp;&emsp;至此，我们就拿到了，我们需要的bitmap对象了，然后再做后续的逻辑即可。 项目链接]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图片滤镜——GPUImage]]></title>
    <url>%2F2019%2F06%2F11%2F%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E2%80%94%E2%80%94GPUImage%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;GPUImage图片滤镜处理的第三方开源库，对照IOS版的GPUImage写的,部分功能尚未完善，目前也有很多种滤镜，常用的滤镜基本上都有，请先浏览一遍github上面的用法。 依赖的库123456789repositories &#123; jcenter()&#125;dependencies &#123;//这个版本号2.x.x，具体的数字看，github官方说明//README.md下方Download后面的版本号 implementation &apos;jp.co.cyberagent.android:gpuimage:2.x.x&apos;&#125; 注意事项一、图片变形&emsp;&emsp;Android版目前没有IOS那么多类，那么多用法，我们用的最多的就是GPUImageView这个自定义view，继承的FrameLayout，并不是继承的ImageView，所以，它这里显示图片的时候，会有图片变形的问题。我的处理方法： 先用Glide获取图片的宽高 然后获取GPUImageView的LayoutParams，动态设置控件的宽高 二、内存溢出 图片过大造成的内存溢出，压缩图片，推荐使用鲁班压缩 频繁使用GPUImage获取Bitmap的getBitmapWithFilterApplied()方法，造成Bitmap过多的内存泄漏，推荐用WeakReference(弱引用)标记Bitmap，GC自动回收 显示大图和缩略图，一般都是一个大图和多种添加滤镜后的效果图(这个是缩略图)，这里缩略图再通过getBitmapWithFilterApplied获取之前，最好吧原图按照规则缩小之后再获取显示，这样也能尽可能的减少内存的占用，点击缩略图显示大的效果图的时候，并不是改变bitmap，是给gpuIamgeView对象设置你点击目标图使用滤镜即可，这样也可以避免内存过多的消耗 三、滤镜添加 单一滤镜的添加 1234//这里以添加黑白滤镜为例GPUImageView gpuImageView = findViewById(R.id.img);gpuImageView.setImage(bitmap);gpuImageView.setFilter(new GPUImageGrayscaleFilter()); 组合滤镜的添加GPUImageFilterGroup 12345678910GPUImageView gpuImageView = findViewById(R.id.img);gpuImageView.setImage(bitmap);GPUImageFilterGroup filterGroup = new GPUImageFilterGroup();//把你需要添加的滤镜放到GPUImageFilterGroup容器里面，//这里我添加了灰色滤镜，曝光度滤镜和饱和度滤镜理论上可以添加无数个filterGroup.add(new GPUImageGrayscaleFilter());filterGroup.add(new GPUImageExposureFilter());filterGroup.add(new GPUImageSaturationFilter());//把这个容器添加到GPUImageViewgpuImageView.setFilter(filterGroup); 多张图片的滤镜 1234567891011121314//这里以GPUImageTwoInputFilter为例（可以加到组合滤镜里面）,它有多个子类//我们这里用GPUImageChromaKeyBlendFilter为例//实现的效果是一个过渡效果，从原图过渡到目标图GPUImageView gpuImageView = findViewById(R.id.img);//设置原图gpuImageView.setImage(bitmap);//新建滤镜对象，并且把目标图设置给滤镜GPUImageChromaKeyBlendFilter keyBlendFilter = new GPUImageChromaKeyBlendFilter();//设置目标图keyBlendFilter.setBitmap(bitmap1);//平滑的过渡方法，改变参数的值即可keyBlendFilter.setSmoothing(progressFloat);//把滤镜设置给GPUImageViewgpuImageView.setFilter(keyBlendFilter); 四、微调（敏感度问题）&emsp;&emsp;只要构造方法，方法带参数的，都可以微调，这里微调的取值范围，Filter源码的类注释上面都有。如果，我们把seekBar的取值范围设置成类注释上面的范围，你滑动很小距离的seekBar，图片变化就会很大，所以，我们一般都是缩小范围再使用。 12345678910111213141516171819//第一个参数seekBar是最大值，第二个参数是最小值，第三个参数是默认值，第四个参数是seekbar分几段//mapSeekBarBean.put(TYPE_SATURATION, new SeekBarBean(2, 0, 0.5f, 10));mapSeekBarBean.put(TYPE_SATURATION, new SeekBarBean(100, 0, 50f, 2));//mapSeekBarBean.put(TYPE_BRIGHTNESS, new SeekBarBean(1, -1, 0.5f, 10));mapSeekBarBean.put(TYPE_BRIGHTNESS, new SeekBarBean(100, 0, 50f, 2));//mapSeekBarBean.put(TYPE_EXPOSURE, new SeekBarBean(10, -10, 0.5f, 0));mapSeekBarBean.put(TYPE_EXPOSURE, new SeekBarBean(100, 0, 50f, 2));//mapSeekBarBean.put(TYPE_CONTRAST, new SeekBarBean(4, 0, 0.25f, 0));mapSeekBarBean.put(TYPE_CONTRAST, new SeekBarBean(100, 0, 25f, 2));mapSeekBarBean.put(TYPE_POSTERIZE, new SeekBarBean(256, 0, 100f, 3));//mapSeekBarBean.put(TYPE_HIGH_LIGHT_SHADOW, new SeekBarBean(1, 0, 0f, 0));mapSeekBarBean.put(TYPE_HIGH_LIGHT_SHADOW, new SeekBarBean(100, 0, 0f, 2));mapSeekBarBean.put(TYPE_SHARPEN, new SeekBarBean(100, 0, 50f, 3));//mapSeekBarBean.put(TYPE_GAMMA, new SeekBarBean(3, 0, 0.33f, 0));mapSeekBarBean.put(TYPE_GAMMA, new SeekBarBean(100, 0, 33f, 3));//mapSeekBarBean.put(TYPE_OPACITY, new SeekBarBean(1, 0, 1f, 0));mapSeekBarBean.put(TYPE_OPACITY, new SeekBarBean(100, 0, 100f, 2));//mapSeekBarBean.put(TYPE_VIBRANCE, new SeekBarBean(1, 0, 0f, 0));mapSeekBarBean.put(TYPE_VIBRANCE, new SeekBarBean(100, 0, 0f, 2)); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//这里是最终设置的值switch (entrySet.getKey()) &#123; case TYPE_SATURATION: //最后面*2是范围（0,2） float f1 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 2; filters.add(new GPUImageSaturationFilter(f1)); break; case TYPE_BRIGHTNESS: float f2 = entrySet.getValue().getProgress(); if (f2 == 50) &#123; f2 = 0f; &#125; else &#123; //后面的*0.7是范围（-1,1），以中间0为准，分成两部分（-1,0），（0,1） //负数为变暗，正数为变亮,本应该*1 f2 = (float) (((f2 - 50) / 50) * 0.4); &#125; filters.add(new GPUImageBrightnessFilter(f2)); break; case TYPE_EXPOSURE: float f3 = entrySet.getValue().getProgress(); if (f3 == 50) &#123; f3 = 0f; &#125; else &#123; //后面的*1是范围（-10,10），以中间0为准，分成两部分（-10,0），（0,10） //负数为变暗，正数为变亮，本应该*10 f3 = ((f3 - 50) / 50) * 1; &#125; filters.add(new GPUImageExposureFilter(f3)); break; case TYPE_CONTRAST: //最后面*4是范围（0,4） float f4 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 4; filters.add(new GPUImageContrastFilter(f4)); break; case TYPE_POSTERIZE: filters.add(new GPUImagePosterizeFilter((int) entrySet.getValue().getProgress())); break; case TYPE_HIGH_LIGHT_SHADOW: GPUImageHighlightShadowFilter highlightShadowFilter = new GPUImageHighlightShadowFilter(); float f9 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1; highlightShadowFilter.setHighlights(1 - f9); highlightShadowFilter.setShadows(f9); filters.add(highlightShadowFilter); break; case TYPE_SHARPEN: float f5 = entrySet.getValue().getProgress(); if (f5 == 50) &#123; f5 = 0f; &#125; else &#123; //后面的*4是范围（-4,4），以中间0为准，分成两部分（-4,0），（0,4） //负数为变暗，正数为变亮，本应该*4 f5 = ((f5 - 50) / 50) * 4; &#125; filters.add(new GPUImageSharpenFilter(f5)); break; case TYPE_GAMMA: //最后面*3是范围（0,3） float f6 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 3; filters.add(new GPUImageGammaFilter(f6)); break; case TYPE_OPACITY: float f7 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1; filters.add(new GPUImageOpacityFilter(f7)); break; case TYPE_VIBRANCE: float f8 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1; filters.add(new GPUImageVibranceFilter(f8)); break; default: &#125; 用法&emsp;&emsp;上面的注意事项里面已经说了简单的用法了，怎么获取滤镜后的图片呢？ 123456//这个方法是获取bitmap对象，至于怎么保存，那就是你自己做了gpuImageView.getGPUImage().getBitmapWithFilterApplied();//当然，库也提供了保存图片的方法：保存的文件夹名称，文件名字，回调方法gpuImageView.saveToPictures(folderName,fileName,OnPictureSavedListener)//其中回调方法里面返回的uri，不能直接传给File，会找不到路径，需要转换一下 12345678910111213141516171819202122/** * 根据Uri获取文件的路径 * * @param context context * @param contentURI uri * @return 文件路径 */ public static String getRealPathFromURI(Context context, Uri contentURI) &#123; String result; Cursor cursor = context.getContentResolver().query(contentURI, new String[]&#123;MediaStore.Images.ImageColumns.DATA&#125;, null, null, null); if (cursor == null) &#123; result = contentURI.getPath(); &#125; else &#123; cursor.moveToFirst(); int index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA); result = cursor.getString(index); cursor.close(); &#125; return result; &#125; 项目就不贴出来了。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JDBC的简单使用——MySQL]]></title>
    <url>%2F2018%2F10%2F11%2FJDBC%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94MySQL%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前面几篇学了基本的SQL语句和用工具操作数据库，今天讲一下用代码操作数据库。 连接MySQL&emsp;&emsp;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java &emsp;&emsp;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java &emsp;&emsp;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java 代码如下： 1234567891011//1、获取驱动类,路动类路径：com.mysql.jdbc.DriverClass.forName(&quot;com.mysql.jdbc.Driver&quot;);//获取url：jdbc:mysql://ip:端口号/数据库名称String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;//用户名String username = &quot;root&quot;;//密码String password = &quot;123&quot;;//获取Connection对象Connection connection = DriverManager.getConnection(url, username, password);System.out.print(connection); &emsp;&emsp;总的来说，先要获取驱动类，然后就是获取Connection对象，就是一行代码DriverManager.getConnection(url, username, password);能走通，就说明连接上了。 修改数据库123456789101112131415161718192021@Test public void test1() throws ClassNotFoundException, SQLException &#123; //获取驱动类 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //获取url String url = &quot;jdbc:mysql://localhost:3306/test4&quot;; //用户名 String username = &quot;root&quot;; //密码 String password = &quot;123&quot;; //获取Connection对象 Connection connection = DriverManager.getConnection(url, username, password); System.out.print(connection); //获取Statement对象 Statement statement = connection.createStatement(); //String sql=&quot;INSERT INTO employee (eid,ename,edid) VALUES(null,&apos;小红&apos;,2)&quot;; String sql = &quot;UPDATE employee SET edid=1 WHERE ename=&apos;小红&apos;&quot;; statement.executeUpdate(sql); statement.close(); connection.close(); &#125; &emsp;&emsp;就是在连接数据库之后，通过Connection对象获取Statement对象，通过Statement对象的execute方法执行对应的SQL语句，最后记得关闭 查询数据库1234567891011121314151617181920212223242526272829303132333435363738394041@Test public void test3() &#123; Connection con = null; Statement state = null; ResultSet resultSet = null; try &#123; String driverClassName = &quot;com.mysql.jdbc.Driver&quot;; String url = &quot;jdbc:mysql://localhost:3306/test4&quot;; String username = &quot;root&quot;; String password = &quot;123&quot;; Class.forName(driverClassName); con = DriverManager.getConnection(url, username, password); state = con.createStatement(); String querySQL = &quot;SELECT * FROM employee&quot;; resultSet = state.executeQuery(querySQL); List&lt;Map&lt;String, String&gt;&gt; mapList = new ArrayList&lt;&gt;(); while (resultSet.next()) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;ename&quot;, resultSet.getString(&quot;ename&quot;)); map.put(&quot;edid&quot;, String.valueOf(resultSet.getInt(&quot;edid&quot;))); mapList.add(map); &#125; System.out.print(mapList.size()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if (resultSet != null) &#123; resultSet.close(); &#125; if (state != null) &#123; state.close(); &#125; if (con != null) &#123; con.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &emsp;&emsp;查询数据库需要注意的地方就是： 执行SQL语句的方法是executeQuery()，只能执行查询语句。 他有一个返回值ResultSet，然后循环这个Set对象，获取数据，他提供了一个移动光标的方法next()，当他为null的时候，返回false，结束循环。 还提供了一系列的get方法，传表每一栏的下标index，或者每一栏的名称，获取对应的值。值的类型要与get的类型相同。值为int，就用getInt，值为String就用getString 最后记得关闭连接，倒着关闭。 PreparedStatement&emsp;&emsp;上面用自己拼接sql语句的方式查询数据库，会容易被sql攻击。所以，我们需要用PreparedStatement来防止被sql攻击，具体方式如下： 123456789101112131415161718192021222324public boolean login(String username, String password) throws Exception &#123; Connection connection = null; PreparedStatement pstat = null; ResultSet rs = null; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/test4&quot;; String user = &quot;root&quot;; String psw = &quot;123&quot;; connection = DriverManager.getConnection(url, user, psw); String sql = &quot;select * from t_user where username=? and psw=?&quot;; pstat = connection.prepareStatement(sql); pstat.setString(1, username); pstat.setString(2, password); rs = pstat.executeQuery(); return rs.next(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; if (rs != null) rs.close(); if (pstat != null) pstat.close(); if (connection != null) connection.close(); &#125; &#125; &emsp;&emsp;如上，是一个登录接口，传用户名，密码给后台，后台查询数据库，我们在获取了connection之后，通过connection调用prepareStatement方法，需要传一个sql模板。 1String sql = &quot;select * from t_user where username=? and psw=?&quot;; &emsp;&emsp;什么是sql模板呢？就是吧需要动态传的参数用问好代替。我们上面这个查询语句，需要动态变化的就是username和psw。然后，我们调用PreparedStatement的setXxx方法，去设置值，第一个参数表示给第几个值赋值，第二个参数就是需要赋值的值 1234//给第一个参数赋值为usernamepstat.setString(1, username);//给第二个参数赋值为passwordpstat.setString(2, password); 大数据存储&emsp;&emsp;这里以存mp3为例 12345CREATE TABLE t_binary( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(50), DATA MEDIUMBLOB) &emsp;&emsp;如上，首先创建一张表去存数据，数据类型不要错了，BLOB类型。 123456789101112@Test public void test1() throws SQLException, IOException &#123; Connection connection = JDBCUtils.getConnection(); String sql=&quot;INSERT INTO t_binary VALUE(?,?,?)&quot;; PreparedStatement pstat = connection.prepareStatement(sql); pstat.setInt(1,1); pstat.setString(2,&quot;KenT - 唱给谁听.mp3&quot;); byte[] bytes= IOUtils.toByteArray(new FileInputStream(&quot;D:/CloudMusic/KenT - 唱给谁听.mp3&quot;)); Blob blob=new SerialBlob(bytes); pstat.setBlob(3,blob); pstat.executeLargeUpdate(); &#125; &emsp;&emsp;上面test1就是存的方法，步骤： 先连接数据库，获取Connection对象 然后，获取PreparedStatement对象，设置参数，其中blob参数，Blob是一个接口，先获取他的实现类SerialBlob，这个实现类的构造方法需要传一个byte[]数组，所以，我们只用把需要存储的文件转成byte[]数组就可以了 最后，执行sql语句就可以了 这里需要注意的是，要在my.ini服务器配置文件中设置最大存储12//这个大小大于你的存储文件即可max_allowed_packet=20M &emsp;&emsp;[mysqld]下边的是服务器配置，[mysql]下边的是客户端配置 &emsp;&emsp;接下来就是怎么取文件了 1234567891011121314@Test public void test2() throws SQLException, IOException &#123; Connection connection = JDBCUtils.getConnection(); String sql=&quot;SELECT * FROM t_binary WHERE name=?&quot;; PreparedStatement pstat = connection.prepareStatement(sql); pstat.setString(1,&quot;KenT - 唱给谁听.mp3&quot;); ResultSet rs = pstat.executeQuery(); if (rs.next())&#123; Blob blob = rs.getBlob(&quot;data&quot;); InputStream in = blob.getBinaryStream(); FileOutputStream out = new FileOutputStream(&quot;D:/cgst.mp3&quot;); IOUtils.copy(in,out); &#125; &#125; &emsp;&emsp;需要说的就是获取到ResultSet之后，获取到Blob，通过他的getBinaryStream()方法，转成输入流，拿到输入流之后，转成File即可 批处理12345678910111213141516@Test public void test6() throws SQLException &#123; Connection connection = JDBCUtils.getConnection(); String sql = &quot;INSERT INTO t_user VALUE(?,?,?)&quot;; PreparedStatement pstat = connection.prepareStatement(sql); for (int i = 0; i &lt; 10000; i++) &#123; pstat.setInt(1, i + 1); pstat.setString(2, &quot;user&quot; + i); pstat.setString(3, i % 2 == 0 ? &quot;男&quot; : &quot;女&quot;); pstat.addBatch(); &#125; long start = System.currentTimeMillis(); pstat.executeBatch(); long end = System.currentTimeMillis(); System.out.print(end - start); &#125; &emsp;&emsp;注意点： 每添加一条数据，调用一遍pstat.addBatch(); 当数据添加完以后，调用pstat.executeBatch();执行sql语句 mysql要开启批处理功能，不然慢到你无法想象。在获取Connection传的url后面，添加rewriteBatchedStatements=true。完整urljdbc:mysql://localhost:3306/test4?rewriteBatchedStatements=true]]></content>
      <categories>
        <category>数据库 -JDBC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作（五）——多表查询]]></title>
    <url>%2F2018%2F10%2F11%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[合并结果集 union all(包含相同行)、union(去除相同行)&emsp;&emsp;把查询的结果合并到一起。要求： 查询的结果列数相同，列类型相同 1234567891011121314151617181920create table emp( eid int, ename varchar(50), eage int);create table stu( sid int, sname varchar(50));//合并结果集（加上all，包含相同的行）select eid,ename from empunion allselect * from stu;//合并结果集（去掉all，去除相同行）select eid,ename from empunionselect * from stu; 连接查询内连接方言： select * from 表1,表2 where 条件 12345表a有三条数据：q，w，e表b有两条数据：h，jselect * from a,b;得出的结果是表a与表b的笛卡尔集，也就是会得到6条数据，分别：qh,qj,wh,wj,eh,ej 12345678去除无用的笛卡尔集，加上where后面的条件连表查询会有附表的外键=主表的主键这个条件select * from student,teacher where student.tid=teacher.tid;查询学生的全部信息，需要查询学生表和老师表，条件是学生表里面的老师id等于老师表里面的老师id，这样查出来的结果就是我们想要的结果 12345678910例子：要求打印员工姓名，工资以及部分名称 员工姓名，工资在emp表，部门名称在dept表select emp.ename,emp.sal,dept.dnamefrom emp,deptwhere emp.did=dept.did;如果嫌弃表名字太长了可以这样：select e.ename,e.sal,d.dnamefrom emp e,dept dwhere e.did=d.did; 标准： select * from 表1 别名1 inner join 表2 别名2 on 条件1234567别名都是可选的，条件跟上面写的一样。两者的区别就只有二个：1、方言连接两个表是用逗号，标准连接两个表是用 inner join2、条件：方言用where，标准用onselect e.ename,e.sal,d.dnamefrom emp e inner join dept dwhere e.did=d.did; 外连接 一主一次左外连接 left outer join ,左表为主表，右表为次表,左表中不论满足不满足条件都查询出来，右表中对应的位置用null补位1234查询所有员工名称，工资以及部门名称，部门名称为null的填无部分select e.ename as 姓名,e.sal as 工资,d.ifnull(dname,&apos;无部门&apos;) as 部门名称from emp e left outer join dept dwhere e.did=d.did; 右外连接 right outer join 与左外对应 子查询 一条sql语句中有多个select关键字,ALL,ANY,IN1234567891011121314//查询员工中最高工资员工的详细信息select * from emp where sal=MAX(sal);//上面这个写法是错误的，条件中是不能出现集合函数//上面这个写法是错误的，条件中是不能出现集合函数//上面这个写法是错误的，条件中是不能出现集合函数//1、先查最高工资select MAX(sal) from emp;//2、最高工资的员工信息select * from emp where sal=(select MAX(sal) from emp);//上面这个写法才是正确的//上面这个写法才是正确的//上面这个写法才是正确的 出现的位置： 1、from后作为表 2、where后作为条件1234上面那条sql语句就是作为条件//查询部门等于30的员工的姓名和年龄select e.name,e.age from (select * from emp where did=30) e;//上面这条就是from后面作为表 1、打印高于平均工资的所有人的信息(单行单列作为条件)1select * from emp where (sal&gt;select AVG(sal) from emp); 2、打印大于30部门的所有员工工资的员工信息(多行单列作为条件)1select * from emp where sal &gt; ALL (select sal from emp where did=30); 3、打印大于30部门任意一人员工工资的员工信息1select * from emp where sal&gt; ANY (select sal from emp where did = 30); 4、打印工作和部门与张三相同的员工信息1select * from emp where (job,did) IN (select job,did from emp where ename=&apos;张三&apos;); 练习题前提条件已知四张表1234员工表emp(eid,ename,job,emid,etime,sal,edid)部门表dept(did,dname,dloc)薪资等级表salgrade(grade,losal,hisal)领导表mgr(mid,mname,mtime) 1、查询至少有一个员工的部门，显示部门编号，部门名称，部门位置，部门人数12345678910111213141516分析：1、列：d.did，d.dname，d.dloc，部门人数2、表：dept d，emp e条件：e.did=d.did//查询部门编号，部门名称，部门位置select * from dept;//查询部门人数select e.did,count(*) from emp group by e.did;//把上面查询的两张表内连接select * from dept inner join select e.did,count(*) from emp group by e.did;//加上条件，给出别名select d.*,z1.cnt from dept d inner join (select did,count(*) cnt from emp group by e.did) z1 where d.did=z1.did; 2、查询所有员工名称及其直接上级领导名称12345678910分析：1、列：e.ename，m.mname2、表：emp e，mgr m条件：e.emid=m.mid//查询员工名称select ename from emp;//查询领导名称select mname from mgr;select ename from emp e left outer join (select mname from mgr ) m on e.emid = m.mid; 3、列出受雇佣日期早于直接上级的所有员工编号，姓名，以及部门名称12345678910111213141516171819202122232425分析：1、列：e.eid,e.ename,d.dname2、表：emp，mgr，dept//查询受雇佣日期早于直接上级领导的员工信息select etime from emp;select mtime from mgr;select * from emp einner join select mtime from mgr mon e.emid=m.mid and e.etime&lt;m.mtime//再把部门名称加上(select eid,ename,edid from emp einner join select mtime from mgr mon e.emid=m.mid and e.etime&lt;m.mtime) z1 left outer join select dname from dept d on z1.edid = d.did;或者select e.eid,e.ename,d.dnamefrom emp e,mgr m,dept dwhere e.emid=m.mid and e.etime&lt;m.mtime and e.edid=d.did; 4、列出部门名称和这些部门的员工信息，同事列出没有员工的部门12345678分析：1、列：员工信息，和部门名称，没有员工的部门也要列出来2、表：emp,deptselect e.*,d.dname from emp e right outer join dept don e.edid=d.did; 5、列出最低薪资大于15000的各种工作以及从事此工作的人数123456789分析：1、列：工作类型，人数2、表：emp条件：min(sal)&gt;15000select job,count(*)from empgroup by jobhaving min(sal)&gt;15000 6、列出在销售部工作的员工姓名，假定不知道销售部的部门编号12345678分析：1、列：员工姓名2、表：emp,dept条件：e.edid=d.didselect enamefrom emp ewhere e.edid=(select did from dept where dname=&apos;销售部&apos;); 7、列出薪资高于公司平均工资的所有员工信息，所在部门名称，上级领导，工资等级12345678910111213141516171819202122232425262728分析：1、列：员工信息，部门名称，上级领导名称，工资等级2、表：emp,dept,mgr条件：sal&gt;avg(sal),e.edid=d.did,e.emid=m.mid//先查询高出平均工资的员工信息select * from emp where sal&gt;(select avg(sal) from emp);//把后面的表一个一个的加上去//加部门名称select e.*,d.dnamefrom emp e left outer join dept d on e.edid=d.didwhere e.sal&gt;(select avg(sal) from emp)//加上级领导名称select e.*,d.dname,m.mnamefrom emp e left outer join dept d on e.edid=d.did left outer join mgr m on e.emid = m.midwhere e.sal&gt;(select avg(sal) from emp)//最后加工资等级select e.*,d.dname,m.mname,s.gradefrom emp e left outer join dept d on e.edid=d.did left outer join mgr m on e.emid = m.mid left outer join salgrade s on e.sal between s.losal and hisalwhere e.sal&gt;(select avg(sal) from emp) 8、列出与张三从事相同工作的所有员工以及部门名称12345678910111213分析：1、列：所有员工，部门名称2、表：emp，dept条件：张三的工作相同，e.edid=d.didselect e.*,d.dname from emp e left outer join dept don e.edid=d.didwhere e.job=(select job from emp where ename=&apos;张三&apos;);或者select e.*,d.dname from emp e,dept d where e.edid=did and e.job=(select job from emp where ename=&apos;张三&apos;); 9、列出薪资高于30部门的所有员工薪资的员工的姓名和薪资，部门名称 123select e.ename,e.sal,d.dname from emp e left outer join dept dwhere e.sal &gt; all (select sal from emp where edid=30) and e.edid = d.did;]]></content>
      <categories>
        <category>数据库 -MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作（四）——多表之间的关系]]></title>
    <url>%2F2018%2F10%2F11%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[主键与外键1、一张表可以有多个外键 2、外键是表的主键，可以是别的表，也可以是本身（少见） 3、外键可以为null，可以重复，但是不能不存在，必须要查的到 创建语法 foreign key(本表的列名) references 关联的表名(关联表的主键) 123456789101112131415161718192021222324252627282930//创建一个部门表CREATE TABLE dept( did INT PRIMARY KEY AUTO_INCREMENT, dname VARCHAR(50));//插入几条数据INSERT INTO dept(did,dname) VALUE(NULL,&apos;销售部&apos;);INSERT INTO dept(did,dname) VALUE(NULL,&apos;技术部&apos;);INSERT INTO dept(did,dname) VALUE(NULL,&apos;人力部&apos;);INSERT INTO dept(did,dname) VALUE(NULL,&apos;保洁部&apos;);//创建一个员工表，这里的的edid是一个外键，对应部门表的主键didCREATE TABLE employee( eid INT PRIMARY KEY AUTO_INCREMENT, ename VARCHAR(50), edid INT, CONSTRAINT fk_empl_dept FOREIGN KEY(edid) REFERENCES dept(did));//或者CREATE TABLE employee( eid INT PRIMARY KEY AUTO_INCREMENT, ename VARCHAR(50), edid INT);alter table employee add CONSTRAINT fk_empl_dept FOREIGN KEY(edid) REFERENCES dept(did);//上面这样也可以设置外键 一对一关系 把从表的主键设置成外键与主表的主键关联1234567891011121314151617create table emp( eid int primary key auto_increment, ename varchar(50));create table hmp( hid int primary key auto_increment, hname varchar(50), constraint fk_hmp_emp foreign key(hid) references emp(eid));//如上，这样创建的两张表emp与hmp就是一对一的关系//插入数据insert into emp values(1,&apos;张三&apos;);insert into hmp values(1,&apos;李四&apos;);//这样张三跟李四就对应上了 多对多关系 两个主表+一个关联表123456789101112131415161718192021222324252627282930313233343536373839404142create table teacher( tid int primary key auto_increment, tname varchar(50));create table student( sid int primary key auto_increment, sname varchar(50));create table stu_tea( tid int, sid int, constraint fk_student foreign key(sid) references student(sid), constraint fk_teacher foreign key(tid) references teacher(tid));//这里的stu_tea就是关联表。多对多并不是说多张表对应多张表//插入数据insert into teacher values(1,&apos;黄老师&apos;);insert into teacher values(2,&apos;李老师&apos;);insert into teacher values(3,&apos;赵老师&apos;);insert into student values(1,&apos;张三&apos;);insert into student values(2,&apos;李四&apos;);insert into student values(3,&apos;王五&apos;);insert into student values(4,&apos;赵六&apos;);//这里黄老师教过张三，李四insert into stu_tea values(1,1);insert into stu_tea values(1,2);//李老师教过王五，赵六insert into stu_tea values(2,3);insert into stu_tea values(2,4);//赵老师教过张三，李四，王五，赵六insert into stu_tea values(3,1);insert into stu_tea values(3,2);insert into stu_tea values(3,3);insert into stu_tea values(3,4);//上面这样，一个学生对应多个老师，一个老师也对应多个学生，叫做多对多的关系 一对多关系 一方不变，另一方在变化123456789101112131415161718192021222324//我们一开始创建的员工表与部门表就是一对多create table dept( did int primary key auto_increment, dname varchar(50));create table emp( eid int primary key auto_increment, ename varchar(50) edid int, constraint fk_emp_dept foreign key(edid) references dept(did));//这里的一就是部门表（主表），多就是员工表（附表）//插入数据insert into dept values(10,&apos;技术部&apos;);insert into dept values(20,&apos;人事部&apos;);//张三，李四属于技术部，王五属于人事部insert into emp values(null,&apos;张三&apos;,10);insert into emp values(null,&apos;李四&apos;,10);insert into emp values(null,&apos;王五&apos;,20);//一个部门对应多个员工，一对多]]></content>
      <categories>
        <category>数据库 -MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作（三）——数据库的备份与恢复]]></title>
    <url>%2F2018%2F10%2F11%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[数据库的备份与恢复备份：mysqldump -u用户名 -p密码 数据库名&gt;生成的脚本路径 12//末尾没有分号，也不要登录mysqldunp -uroot -p123 school&gt;C:a.sql 恢复：mysqldump -u用户名 -p密码 数据库名&lt;生成的脚本路径 或者：登录之后，切换到需要恢复的数据库，输入：source 生成的脚本路径 123//要先删除school数据库，再重新创建数据库，这两步需要登录//执行下面sql语句，不要登录，末尾没有分号mysqldunp -uroot -p123 school&lt;C:a.sql 乱码问题找到你的mysql的安装目录，找到my.ini文件，更bin目录同级，修改如下代码：1234567891011[mysqld]character-set-server=utf8 [client]default-character-set=utf8 [mysql]default-character-set=utf8 修改完之后，不仅是要重新连接数据库，必须要重启数据库 修改完之后，不仅是要重新连接数据库，必须要重启数据库 修改完之后，不仅是要重新连接数据库，必须要重启数据库 net stop mysql net start mysql 主键 primary key创建表的时候直接设置123456789101112CREATE TABLE emp( esid CHAR(12) PRIMARY KEY, ename VARCHAR(20), esal INT);CREATE TABLE emp( esid CHAR(12), ename VARCHAR(20), esal INT, PRIMARY KEY(esid)); 修改主键 alter table 表名 add primary key(键名)1alter table emp add primary key(esid); 删除主键 alter table 表名 drop primary key 主键自增长 auto_increment12345CREATE TABLE emp( esid int PRIMARY KEY auto_increment, ename VARCHAR(20), esal INT); 非空约束 not null12345CREATE TABLE emp( esid int PRIMARY KEY auto_increment, ename VARCHAR(20) not null, esal INT); 唯一约束 not null unique12345CREATE TABLE emp( esid int PRIMARY KEY auto_increment, ename VARCHAR(20) not null unique, esal INT);]]></content>
      <categories>
        <category>数据库 -MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作（二）——DQL]]></title>
    <url>%2F2018%2F10%2F11%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94DQL%2F</url>
    <content type="text"><![CDATA[DQL关键字：select、from、where、group by、having、roder by 基本查询&emsp;&emsp;查询所有：select * from 表名;1select * from t_stu; &emsp;&emsp;查询部分列select 列名,...列名 from 表名;1select stu_num,stu_name from t_stu; &emsp;&emsp;查询去除完全重复的列select distinct * from 表名;12select distinct * from t_stu;select distinct stu_age from t_stu; &emsp;&emsp;也可以查询同时做加、减、乘、除运算操作：1234//把查询出来的年龄都乘以2倍。select stu_age*2 from t_stu;//如果查出来的年龄为null，就设置为29select ifnull(stu_age,29) from t_stu; &emsp;&emsp;做连接字符串操作：CONCAT1234//把名字和年龄拼接起来select CONCAT(stu_name,stu_age) from t_stu;select CONCAT(&apos;我的名字是：&apos;,stu_name,&apos;，我今年&apos;,stu_age,&apos;岁&apos;) from t_stu; &emsp;&emsp;给列起别名：as123select stu_age as 年龄 from t_stu;select stu_age as 年龄,stu_name as 姓名 from t_stu;select CONCAT(stu_name,stu_age) as 描述 from t_stu; 条件查询&emsp;&emsp;跟前面一篇讲的更新，删除里面设置条件的方法是一样的。where后面跟条件123456//查询年龄大于等于20的学生select * from t_stu where stu_age&gt;=20;//查询年龄在15到25岁之间的学生select * from t_stu where stu_age between 15 and 25;//查询名字叫zhangsan,lisi,wangwu.zhaoliu的学生select * from t_stu where stu_name in(&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhangliu&apos;); &emsp;&emsp;模糊查询like1234567891011//一个字加一个下划线，两个字就是两个下划线//查询名字中张开头，并且是两个字的学生.select * from t_stu where stu_name like &apos;张_&apos;;//查询名字是三个字的学生select * from t_stu where stu_name like &apos;___&apos;;//百分号%匹配0~N个字符//查询名字中以雷结尾的学生select * from t_stu where stu_name like &apos;%雷&apos;;//查询名字中包含晓的学生select * from t_stu where stu_name like &apos;%晓%&apos;; 排序 order by1234567// desc:降序，asc：升序//按学生年龄升序排列select * from t_stu ORDER BY stu_age ASC;//按学生年龄降序排列select * from t_stu ORDER BY stu_age DESC;//年龄相同的时候，按名字降序排列。可以无限添加排序条件select * from t_stu ORDER BY stu_age ASC,stu_name DESC; 聚合函数(纵向查询)计数count123//只要不为null，就+1select count(*) from t_stu;select count(stu_age) from t_stu; 计算和sum12//计算学生年龄加起来的总数select sum(stu_age) from t_stu; 最大值max,最小值min1234//查询年龄中最大的select max(stu_age) from t_stu;//查询年龄中最小的select min(stu_age) from t_stu; 平均值avg1select avg(stu_age) from t_stu; 分组查询group by写法：select 条件,聚合函数,...,聚合函数 from 表名 group by 条件; 分组查询必须都是聚合函数，并且，上面两个位置的条件必须相同 12345678910//按老师分组查询，每组老师名下的学生个数select stu_teacher,count(*) from t_stu group by stu_teacher;//分组前条件，不满足条件的没有参加分组//按老师分组查询，查询每组老师名下年龄大于20岁的学生的个数select stu_teacher,count(*) from t_stu where stu_age&gt;20 group by stu_teacher;//having 分组后条件//按老师分组查询，查询老师名下年龄大于20岁的学生，并且剔除学生个数小于5个的老师select stu_teacher,count(*) from t_stu where stu_age&gt;20 group by stu_teacher having count(*)&lt;5; limit(MySQL特有的)123456//从下标0开始，往后查询5条数据select * from t_stu limit 0,5;//分页查询，比方说如果你要查第N页的数据，每页数据M条//(当前页-1)*每页的数据数select * from t_stu limit (N-1)*M,M;]]></content>
      <categories>
        <category>数据库 -MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库操作（一）——DDL、DML、DCL]]></title>
    <url>%2F2018%2F10%2F11%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94DDL%E3%80%81DML%E3%80%81DCL%2F</url>
    <content type="text"><![CDATA[MySQL:&emsp;&emsp;启动：net start mysql &emsp;&emsp;停止：net stop mysql &emsp;&emsp;登录：mysql -u root -p 例如：mysql -uroot -p123 -hlocalhost &emsp;&emsp;退出：exit或者quit DDL操作：&emsp;&emsp;加上if exists或者if not exists：都是如果存在，或者如果不存在，就不做相关操作 &emsp;&emsp;查询当前有哪些数据库：show databases; &emsp;&emsp;创建数据库：CREATE DATABASE if not exists 数据库的名字 CHARSET=utf8;例如：CREATE DATABASE if not exists employee CHARSET=utf8;创建一个编码为utf-8的employee数据库。不存在就创建，存在就不管。 &emsp;&emsp;删除数据库：DRAP DATABASE if exists 数据库名称;例如：DRAP DATABASE if exists employee;删除employee数据库，如果存在就删除，不存在就不管。 &emsp;&emsp;修改数据库编码方式：ALTER DATABASE 数据库名称 CHARACTER SET utf8; &emsp;&emsp;切换数据库：use 数据库名称; &emsp;&emsp;创建表：CREATE TABLE if not exists 表名(列名 列类型,...,列名 列类型); 1234567891011CREATE TABLE if noe exists t_stu( stu_num char(11), stu_name varchar(50), stu_age int, stu_sex varchar(10) ); &emsp;&emsp;显示当前数据库包含的表：show tables; &emsp;&emsp;显示当前表结构：desc 表名称; &emsp;&emsp;删除表：drop table 表名称; &emsp;&emsp;新增列：alter table 表名 add(列名 列类型,...,列名 列类型); 1234567alter table t_stu add( stu_address varchar(100), stu_phone char(11) ); &emsp;&emsp;修改列类型：alter table 表名 modify 列名 列新类型; 1alter table t_stu modify stu_address varchar(50); &emsp;&emsp;修改列名：alter table 表名 change 原始列名 新列名 列类型; 1alter table t_stu change stu_address stu_addr varchar(100); &emsp;&emsp;删除列：alter table 表名 drop 列名;1alter table t_stu drop stu_address; &emsp;&emsp;修改表名：alter table 原始表名 rename to 新表名; DML操作：为了好操作，先用一下查询的命令，查询表的所有记录： select * from 表名; &emsp;&emsp;插入一行记录：INSERT INTO 表名 (列名,...,列名)VALUES(列值,...,列值);123456789INSERT INTO t_stu( stu_num,stu_name,stu_age,stu_sex,stu_phone )VALUES( &apos;test_num_001&apos;,&apos;张三&apos;,18,&apos;man&apos;,&apos;13888888888&apos; ); &emsp;&emsp;修改所有数据：update 表名 set 列名=列值,...,列名=列值; 1update t_stu set name=&apos;wangwu&apos;; &emsp;&emsp;修改数据(单个条件)：update 表名 set 列名=列值,...,列名=列值 where 列名=列值; 1update t_stu set stu_name=&apos;zhangsan&apos; where stu_num=&apos;testNum_00001&apos;; &emsp;&emsp;修改数据(多个条件)：update 表名 set 列名=列值,...,列名=列值 where 列名=列值 or 列名=列值;12345678910//or,或者update t_stu set stu_age=28 where stu_num=&apos;testNum_0001&apos; or stu_name=&apos;zhangliu&apos;;//and，并且update t_stu set stu_age=28 where stu_age&gt;=25 and stu_age&lt;=30;//between...and...在什么区间内update t_stu set stu_age=28 where stu_age between 25 and 30;//in(...)update t_stu set stu_age=28 where stu_name in (&apos;zhangsan&apos;,&apos;lisi&apos;);//is null，是null。不能是stu_name=nullupdate t_stu set stu_age=28 where stu_name is null; &emsp;&emsp;删除记录：DELETE FROM 表名 where ...;12//这里where后面的条件跟前面的update是一样的写法DELETE FROM t_stu where stu_age = 28; DCL操作：&emsp;&emsp;创建用户：1234//只要是写用户名的位置都可以设置固定ip，或者不固定ipCREATE USER 用户名@IP地址 IDENTIFIED BY &apos;密码&apos;;//固定ip登录CREATE USER 用户名@&apos;%&apos; IDENTIFIED BY &apos;密码&apos;;//任意ip登录CREATE USER zhangSan@&apos;%&apos; IDENTIFIED BY &apos;123&apos;; &emsp;&emsp;给用户授权：123456GRANT 权限1,权限2,...,权限n ON 数据库名称.* TO 用户名@ip地址;GRANT 权限1,权限2,...,权限n ON 数据库名称.* TO 用户名@&apos;%&apos;;GRANT CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT ON school.* TO zhangSan@&apos;%&apos;;//给所有权限GRANT ALL ON school.* TO zhangSan@&apos;%&apos;; &emsp;&emsp;撤销权限：1REVOKE 权限1,权限2,...,权限n ON 数据库名称.* FROM 用户名@&apos;%&apos;; &emsp;&emsp;查看用户权限：1SHOW GRANTS FOR 用户名@ip地址; &emsp;&emsp;删除用户：1DROP USER 用户名@ip地址;]]></content>
      <categories>
        <category>数据库 -MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android——MQTT推送]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E2%80%94%E2%80%94MQTT%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[整体介绍&emsp;&emsp;最近公司用到的推送MQTT。不想过多的介绍背景什么的，我就直接讲怎么实现这个功能。 &emsp;&emsp;他这个原理长连接，这个不用多讲，用法类似于EventBus，需要先订阅，然后通过topic再发送消息。topic是什么呢？我先来讲讲整体流程： 先连接服务器，要先建立长连接 然后需要订阅topic，连接之后才能订阅topic 最后就是通过topic推送消息，接收消息 一步一步讲： 第一步，与服务器建立连接&emsp;&emsp;先丢代码，然后看注释： 12345678910111213141516171819private void initPush() &#123; // 服务器地址（协议+地址+端口号） String uri = host; client = new MqttAndroidClient(this, uri, clientId); // 设置MQTT监听并且接受消息 client.setCallback(mqttCallback); //Mqtt的一些设置 conOpt = new MqttConnectOptions(); conOpt.setAutomaticReconnect(true); // 清除缓存 conOpt.setCleanSession(true); // 设置超时时间，单位：秒 conOpt.setConnectionTimeout(10); // 心跳包发送间隔，单位：秒 conOpt.setKeepAliveInterval(20); myTopic = String.format(TOPIC_SUB, mDeviceId); Log.e(TAG,&quot;myTopic_________&quot;+myTopic); doClientConnection(); &#125; &emsp;&emsp;上面的这些参数，我碰到了两个问题。 &emsp;&emsp;上面的这些参数，我碰到了两个问题。 &emsp;&emsp;上面的这些参数，我碰到了两个问题。 第一个问题，与服务器建立连接，你得先有一个服务器吧？我根据网上的步骤，创建了一个apache-apollo服务器，并且启动了，也启动成功了，我建立连接的时候，总是失败。然后，找啊找，找啊找。问题没有解决，但是，我找到了一个可以用的服务器，也就是这里的uri，不要设置MqttConnectOptions的用户名和密码，设置了他会拒绝 1private String host = &quot;tcp://test.mosquitto.org:1883&quot;; 第二个问题，我连接成功之后，不一会，他就会自动断开连接，或者，推送完消息之后，他就会断开连接。然后，网上搜原因，找啊找，诶，我找到了。MqttAndroidClient的构造方法： 12345678910111213141516/** * Constructor - create an MqttAndroidClient that can be used to communicate with an MQTT server on android * * @param context * object used to pass context to the callback. * @param serverURI * specifies the protocol, host name and port to be used to * connect to an MQTT server * @param clientId * specifies the name by which this connection should be * identified to the server */ public MqttAndroidClient(Context context, String serverURI, String clientId) &#123; this(context, serverURI, clientId, null, Ack.AUTO_ACK); &#125; 看第三个参数，clientId，指定一个名字，用来连接服务器的身份标识。就是说，你设置的这个值，是你在服务器的唯一标识，不能跟其他用户的相同。我把这个clientId直接用uuid生成，就没问题了。 第二步，订阅topic&emsp;&emsp;回到上面，接着往下面走， 12345678910111213141516171819202122232425262728293031323334/** * 连接MQTT服务器 */ private void doClientConnection() &#123; if (!client.isConnected() &amp;&amp; isConnectIsNormal()) &#123; try &#123; client.connect(conOpt, null, iMqttActionListener); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 判断网络是否连接 */ private boolean isConnectIsNormal() &#123; ConnectivityManager connectivityManager = (ConnectivityManager) this.getApplicationContext() .getSystemService(Context.CONNECTIVITY_SERVICE); if (connectivityManager != null) &#123; NetworkInfo info = connectivityManager.getActiveNetworkInfo(); if (info != null &amp;&amp; info.isAvailable()) &#123; String name = info.getTypeName(); Log.e(TAG, &quot;MQTT当前网络名称：&quot; + name); return true; &#125; else &#123; Log.e(TAG, &quot;MQTT 没有可用网络&quot;); return false; &#125; &#125; else &#123; return false; &#125; &#125; &emsp;&emsp;这个方法就是用来连接服务器的，首先判断是否正在连接，后面那个是判断当前有没有网络。再就是这个iMqttActionListener监听了 123456789101112131415161718192021// MQTT是否连接成功 private IMqttActionListener iMqttActionListener = new IMqttActionListener() &#123; @Override public void onSuccess(IMqttToken arg0) &#123; Log.e(TAG, &quot;连接成功 &quot;); try &#123; // 订阅myTopic话题 client.subscribe(myTopic, 0); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(IMqttToken arg0, Throwable arg1) &#123; Log.e(TAG, &quot;连接失败&quot;); arg1.printStackTrace(); // 连接失败，重连 &#125; &#125;; &emsp;&emsp;讷，就是这里，你如果服务器有问题，他一直走onFailure方法。服务器连接成功之后，就是订阅topic。我来说说这个 1client.subscribe(myTopic, 0); &emsp;&emsp;首先，这个主题，是你自己跟服务器商量好的，随便什么都可以。为什么要订阅主题呢？我提前给你瞅瞅推送消息是怎么推送的 &emsp;&emsp;第二个参数，消息的类型qos，有三种：0、1、2 0代表“至多一次”，消息发布完全依赖底层 TCP/IP 协议。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送 1代表“至少一次”，确保消息到达，但消息重复可能会发生 2代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。 &emsp;&emsp;简单说明下，如果发送的是临时的消息，例如给某topic所有在线的设备发送一条消息，丢失的话也无所谓，0就可以了。如果需要客户端保证能接收消息，需要指定QoS为1 1client.publish(topic, new MqttMessage(msg.getBytes())); &emsp;&emsp;讷，推送消息，是根据topic推送的，第二个参数，就是你要推送的具体消息。我个人认为，你可以理解成就类似于键值对的形式， 不同的用户可以订阅相同的主题 不同的用户可以订阅相同的主题 不同的用户可以订阅相同的主题 &emsp;&emsp;这个就是跟其他长连接不同的地方，底层，其实都一样，虽然我没有看底层的代码。想也想的到，服务器肯定是根据这个主题，去找对应的用户，然后推送消息。而其他的长连接就是直接指定用户。跑题了，跑题了。 第三步，推送、接收消息&emsp;&emsp;当你连接服务器成功之后，就要推送消息了，我用的EventBus发的 1234567891011121314151617181920212223242526272829private void publishData(String msg) &#123; String topic = myTopic; try &#123; Log.e(TAG,&quot;给__&quot;+topic+&quot;__topic发送的消息为：&quot;+msg); client.publish(topic, new MqttMessage(msg.getBytes())); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; // MQTT监听并且接受消息 private MqttCallback mqttCallback = new MqttCallback() &#123; @Override public void messageArrived(String topic, MqttMessage message) throws Exception &#123; Log.e(TAG,&quot;接受到__&quot;+topic+&quot;__topic的消息为：&quot;+new String(message.getPayload())); &#125; @Override public void deliveryComplete(IMqttDeliveryToken arg0) &#123; Log.e(TAG,&quot;deliveryComplete&quot;); &#125; @Override public void connectionLost(Throwable arg0) &#123; // 失去连接，重连 Log.e(TAG,&quot;失去连接&quot;); &#125; &#125;; &emsp;&emsp;当你的clientId重复的时候，他就会一直走connectionLost方法。到这里，基本上就讲完了，要注意的是，退出的时候，记得要释放资源 123456789101112@Override public void onDestroy() &#123; try &#123; if (client != null &amp;&amp; client.isConnected()) &#123; client.disconnect(); &#125; &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; EventBus.getDefault().unregister(this); super.onDestroy(); &#125; 网上很多都是直接讲整体流程，重来不讲中间碰到的问题。难受 项目链接]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android—React Native编程]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E2%80%94React-Native%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[个人博客：haichenyi.com。感谢关注 新公司，新的开始，新的技术&emsp;&emsp;新公司的项目，用到的RN编程，之前完全没有碰到过，遇到新技术，之前完全没有碰到过怎么办？google、百度咯。通过不屑的努力，找到了恋猫月亮 的三篇关于RN的文章。我感觉还是很不错的。 从Android到React Native开发（一、入门） 从Android到React Native开发（二、通信与模块实现） 从Android到React Native开发（三、自定义原生控件支持） &emsp;&emsp;可以先浏览上面的第一篇入门，再过来看我这篇文章，我这篇文章就是讲怎么运行一个RN，我只是针对我的项目，把RN的部分提取了出来，上面大佬讲的比较全面。 React Native环境配置开发工具：android studio。我不知道为什么要换开发工具。AS不好吗？环境还是跟你之前开发的一样配置，不用变 python安装：python官网，下载安装。记得配置环境变量。不用非要按照他那个上面说的去安装。安装完成之后cmd里面敲python然后回车，看到如下界面: node.js安装：node也是一样，百度安装,配置完环境变量。cmd里面敲 npm -v然后回车，看到如下界面 最后，跑如下命令： 12345//安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global//React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。npm install -g react-native-cli &emsp;&emsp;至此，RN的配置就完成了。记得配置NDK环境，然后就是上你们公司的svn，或者git去down项目下来,应该还会有一个错误，那就是找不到react.gradle的路径，找到你添加依赖的那个gradle，在最上面添加如下代码： 1apply from: &quot;../../node_modules/react-native/react.gradle&quot; 这个配置应该是添加greenDao那个是一样的，这样就能找到了react.gradle 项目结构如下： &emsp;&emsp;我用箭头标记了，你down下来的项目，应该是没有node_modules文件夹的，这个文件夹是怎么产生的呢？你在cmd进入你down的项目，就是图片上面的文件目录，跑如下命令即可 1npm install 当命令运行完，就可以跑项目了。 React Native项目搭建&emsp;&emsp;同鞋，你有freeStyle吗？有没有用过WebView？WebView就是在你的xml里面新增了一个WebView控件，RN也一样，他的这个控件就是ReactRootView。所以，这个控件哪里来？当然是添加依赖了 12//版本号你自己找compile &apos;com.facebook.react:react-native:0.50.3&apos; 最终的作用代码就是： 1mReactRootView.startReactApplication(mReactInstanceManager, &quot;XXX&quot;, null); &emsp;&emsp;这个ReacRootView对象，你可以new出来，也可以写在xml里面findViewById。只要你能获取到这个对象就可以了，然后就是这个方法： 1startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName, @Nullable Bundle initialProperties) 三个参数 ReactInstanceManager reactInstanceManager String moduleName @Nullable Bundle initialProperties 第一个参数：ReactInstanceManager就像配置WebView的参数，那些什么配置client允许js弹窗啊，新的页面直接覆盖原来的页面，并不是新建一个页面之类的参数，对应的这里，就是配置ReactInstanceManager12345678910111213ReactInstanceManagerBuilder builder = ReactInstanceManager.builder(); builder = builder .setApplication(getApplication()) .setBundleAssetName(&quot;index.android.bundle&quot;) .setJSMainModulePath(&quot;index.android&quot;); mReactInstanceManager = builder .addPackage(new MainReactPackage()) .addPackage(new YzgHDReactPackage())// .setUseDeveloperSupport(!Global.ISPRD) .setUseDeveloperSupport(true) .setInitialLifecycleState(LifecycleState.RESUMED) .build(); &emsp;&emsp;前面的builder的初始化是必须要写的，setApplication，如果你没有自己写application，那就直接getApplication，如果，你有自己实现application那就传你的application对象。 &emsp;&emsp;setBundleAssetName和setJSMainModulePath都是写死的，后面的名字也是写死的。 &emsp;&emsp;然后就是添加package，在package里面添加module。这里就是JS和Android相互调用的地方。package里面要实现ReactPackage，在createNativeModules里面去添加moudle 第二个参数：String moduleName这个moudleName是怎么来的？就是我们前面设置的MoudlePath那个JS里面的。这里的路径应该是index.android.js，是一个js文件，打开之后，最下面有如下代码： 1AppRegistry.registerComponent(&apos;zzz&apos;, () =&gt; XXX); 这里的zzz就是我们这里需要传的名字 第三个参数：Bundle initialProperties这里应该是传一个bundle，传输的数据，传个null就可以了 React Native流程&emsp;&emsp;前面的整个配置都配置完成之后，Android这边只用新建方法，给RN调用就可以了。新建的方法要用@ReactMethod标记。辣么，这个方法新建在哪呢？————Module，就是对应我们前面package里面添加的module。都说RN每个模块是独立的，怎么独立呢？就是这样独立的。每个模块功能对应一个module，每个都有该功能对应的方法。我就拿我这里的UserModule来举个例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class UserModule extends IModule implements NoticeListener&#123; public static final String MODULE_NAME = &quot;User_Module&quot;; private ReactApplicationContext mContext; public UserModule(ReactApplicationContext reactContext) &#123; super(reactContext); this.mContext = reactContext; &#125; @Override public String getName() &#123; return MODULE_NAME; &#125; /** * 用户登录接口 * @param params * @param callback */ @ReactMethod public void doLogin(String params, final Callback callback)&#123; HashMap&lt;String,String&gt; map = GsonTool.gson2Map(params); if(map == null || map.size() &lt;= 0)&#123; callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;参数异常&quot;))); return; &#125; final String userName = map.get(&quot;userName&quot;); final String password = map.get(&quot;password&quot;); if(TextUtils.isEmpty(userName) || TextUtils.isEmpty(password))&#123; callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;用户名或密码不能为空&quot;))); return; &#125; //登录 new Handler().post(new Runnable() &#123; @Override public void run() &#123; String result = new UserBridge().doLogin(userName,password, Global.DEVICE_ID,Global.APP_VERSION_NAME); callback.invoke(result); &#125; &#125;); &#125; &emsp;&emsp;这里我就粘贴出来了部分代码，module要继承IModule，这个是一个抽象类，他继承ReactContextBaseJavaModule，最主要就是继承它，继承之后，我像说的就是这两个方法，getName()和注解的方法doLogin()。 &emsp;&emsp;我们可以看到，这个getName最终返回的是一个User_Module，这个字符串是怎么确定的呢？这个登录的方法名称是怎么确定的呢？ &emsp;&emsp;这些东西都是在js里面定义好的，这里是一个登录方法，我们打开登录的js。 PS: 这里应该是通过js去确定我们这边的方法名，并不是通过这里的名称去确定js的。 &emsp;&emsp;我就不把JS代码，贴出来了，只贴出伪代码，打开js之后，搜索NativeModules。你应该会搜到类似的代码： 1const &#123; User_Module, Shop_Module &#125; = NativeModules; 这里有两个Module，没错，就是两个。我们这里现在只关注User_Module，然后，我们搜索 User_Module，你会看到如下代码： 1234567891011121314151617181920_onLogIn = () =&gt; &#123; const &#123; username, password &#125; = this.userInfo; if (username.length &lt;= 0) return this._modal.Alert(&apos;请输入用户名&apos;); if (password.length &lt;= 0) return this._modal.Alert(&apos;请输入密码&apos;); this._button.setButton(false, &apos;正在登录...&apos;); const params = &#123; userName: username, password &#125;; // 登录 const _dologin = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123; const data = Other.callHandle(values) || &#123;&#125;; if (data.status) &#123; resolve(&apos;登录成功&apos;); &#125; else &#123; reject(data.message); &#125; &#125;); &#125;); &#125;; 其他的一切，我们都不用管，我们在意的是 12345678User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123; const data = Other.callHandle(values) || &#123;&#125;; if (data.status) &#123; resolve(&apos;登录成功&apos;); &#125; else &#123; reject(data.message); &#125; &#125;); &emsp;&emsp;上面这个是我的项目里面的js，你们搜到的肯定跟我的不一样，我这里要说的是，怎么确定name的返回值，和注解方法。我们看到了，name就是这里的User_Module，方法就是这里的doLogin，android里面写用@ReactMethod标记，然后就是参数了，这里两个参数，一个是String，json格式的。用ArrayMap存储好key—value之后，转成字符串即可。第二个参数就是callback。android与JS通信，发送数据，就是一个方法 1callback.invoke(&quot;data&quot;) 他需要什么，你就发送什么。上面是RN主动调用Android方法，辣么，Android怎么主动调用RN方法呢？其实也很简单 123456//发送给RN if (mReactInstanceManager.getCurrentReactContext() != null) &#123; mReactInstanceManager.getCurrentReactContext() .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class) .emit(PUSH_DATA_RN, mqttBean.info); &#125; 就是获取ReactContext对象，通过调用getJSModule方法，参数传DeviceEventManagerModule.RCTDeviceEventEmitter.class这个类就可以了，然后通过调用emit方法，第一个参数，就是RN规定的方法名称，第二个参数就是需要传给RN的数据。为什么这样写呢？我们再来看看RN那边是怎么写的 123DeviceEventEmitter.addListener(&quot;push_data_rn&quot;,(data)=&gt;&#123; alert(data) &#125;) 他就是通过这DeviceEventEmitter类添加addListener方法，传两个参数，第一个参数就是我们规定的名称，第二个参数就是一个回调，有一个参数，就是用来接收我们的数据，最后做的处理就是简单的弹窗，当然，这是我自己测试用的，最后RN要怎么坐，就是我要担心的问题了。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android转场动画——共享元素]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[这个东西其实很简单，我这里只是做一个简单的记录。 XML代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!--第一个Activity的xml布局，需要共享的元素，加上transitionName属性。至于名字，你随便定义，要保持相同--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;bottom&quot; tools:context=&quot;com.haichenyi.activitytransitionanimation.MainActivity&quot;&gt; &lt;ImageView android:id=&quot;@+id/img&quot; android:layout_width=&quot;300dp&quot; android:layout_height=&quot;200dp&quot; android:transitionName=&quot;wang&quot; android:src=&quot;@mipmap/bg&quot;/&gt; &lt;Button android:id=&quot;@+id/btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;跳转&quot;/&gt;&lt;/LinearLayout&gt;&lt;!--第二个activity的xml布局--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/img&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; android:src=&quot;@mipmap/bg&quot; android:transitionName=&quot;wang&quot;/&gt; &lt;Button android:id=&quot;@+id/btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;back&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; java代码如下： 123456789101112131415161718192021222324252627/** * Author: 海晨忆. * Date: 2018/3/29 * Desc: */public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //共享元素转场动画，只支持android 5.0，所以加一个判断 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; startActivity(new Intent(MainActivity.this, Step1Activity.class), ActivityOptions.makeSceneTransitionAnimation(MainActivity.this, findViewById(R.id.img), &quot;wang&quot;).toBundle()); &#125; else &#123; startActivity(new Intent(MainActivity.this, Step1Activity.class)); &#125; &#125; &#125;); &#125;&#125; 上面代码，就是一个Button点击跳转。这个共享元素的核型代码，就是一个方法： 12ActivityOptions.makeSceneTransitionAnimation(Activity activity, View sharedElement, String sharedElementName) 三个参数： Activity activity：activity对象，这个不用多说了 View sharedElement：共享元素的那个控件 String sharedElementName：共享元素控件的那个transitionName属性的值。前面xml里面的注释讲过要相同，有三个位置用到这个：跳转activity的xml里面，跳转的目标activity的xml里面，再就是这里，跳转的代码这里需要设置。 就这么简单。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android——PorterDuffXfermode]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E2%80%94%E2%80%94PorterDuffXfermode%2F</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;PorterDuffXfermode是什么鬼？个人理解，简单的来讲就是做两个Bitmap操作的，什么操作呢？有裁剪，合并等等，有16种图形混合模式。先举一个简单的例子，我们在慢慢讲： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Author: 海晨忆 * Date: 2018/3/28 * Desc: */public class MyCustomView extends View &#123; private int width = 300; private int height = 300; private Bitmap dstBmp; private Bitmap srcBmp; private Paint mPaint; public MyCustomView(Context context) &#123; this(context, null); &#125; public MyCustomView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MyCustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; private void initView() &#123; setLayerType(View.LAYER_TYPE_SOFTWARE, null); srcBmp = makeSrc(width, height); dstBmp = makeDst(width, height); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2); canvas.drawColor(Color.BLUE); int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); @SuppressLint(&quot;DrawAllocation&quot;) PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN); mPaint.setXfermode(xfermode); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerID); &#125; private Bitmap makeDst(int w, int h) &#123; Bitmap dst = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas mCanvas = new Canvas(dst); Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.RED); mCanvas.drawOval(new RectF(0, 0, w, h), mPaint); return dst; &#125; private Bitmap makeSrc(int w, int h) &#123; Bitmap src = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas mCanvas = new Canvas(src); Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.YELLOW); mCanvas.drawRect(0, 0, w, h, mPaint); return src; &#125;&#125; 效果图如下： &emsp;&emsp;上面画了一个圆形bitmap，画了一个矩形bitmap，设置了一个模式 PorterDuff.Mode.SRC_IN 就变成了上面的形状，这是怎么做到的呢？带着我们的问题，进入我们的主题。 注意点&emsp;&emsp;为什么我要拿一个大标题来写这个呢？因为，我当时卡在这里很久，然后踩着巨人的肩膀，我才踏过去的。 首先，两个图形必须都是Bitmap，直接用Canvas画形状，做操作，是达不到效果的。重要的事情说三遍：两个图形必须都是Bitmap。两个图形必须都是Bitmap。两个图形必须都是Bitmap 其次，避免不必要的麻烦，请先关闭硬件加速。重要的事情说三遍：请先关闭硬件加速。请先关闭硬件加速。请先关闭硬件加速 然后，两个bitmap的大小最好一样。 最后，我要强调的是：先绘制的是目标图，后绘制的是源图。 &emsp;&emsp;这里一直说bitmap，辣么，怎么生成这个bitmap，生成这个bitmap之后怎么画图形呢？如下代码： 12345678910//第一步，我们先创建一个bitmap对象Bitmap dst = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);//第二步，我们通过这个bitmap对象创建一个画布，//说白了，就是new 一个画布，把bitmap放到画布的构造方法里面 Canvas mCanvas = new Canvas(dst); Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.RED);//最后，在这个画布上面的所有操作，最后都是呈现在bitmap上面。//就像这里的，在这个画布上面画了一个椭圆，其实，最后我们的bitmap就是一个椭圆 mCanvas.drawOval(new RectF(0, 0, w, h), mPaint); &emsp;&emsp;可以，bitmap会创建了，再就是我们前面说的两个bitmap，先绘制的是目标图，后绘制的是源图，一个是dst（目标图片，下层，先画），一个是src（源图片，上层，后画）。就是我们上面的自定view里面的onDraw()方法里面，用onDraw的canvas画的东西。 &emsp;&emsp;我们如果不用这个xfermode模式，我们的代码应该是这样的： 12345678@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2); canvas.drawColor(Color.BLUE); canvas.drawBitmap(dstBmp, 0, 0, mPaint); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); &#125; &emsp;&emsp;很简单的几行代码，把画布移到正中间，给画布加一个背景蓝色，先画dst，后画src，跑出来的效果图应该是下面这样的： &emsp;&emsp;我们如果加上这个xfermode模式里面的 PorterDuff.Mode.SRC_IN模式，代码如下： 12345678910111213@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2); canvas.drawColor(Color.BLUE); int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); @SuppressLint(&quot;DrawAllocation&quot;) PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN); mPaint.setXfermode(xfermode); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerID); &#125; &emsp;&emsp;比上面的代码，就多加了一个xfermode模式，他们要是同一个画笔，用完之后，记得要把这个模式置null这个saveLayer等会讲，先不说。跑出来的效果图，如下： &emsp;&emsp;前面，我们一直都在强调dst先画，src后画，如果调换一下，会是什么样的结果呢？代码我就不贴出来了，就把那两个drawBitmap调换一个位置，跑出来的效果图，如下： &emsp;&emsp;很明显，跟我们的预期结果不一样。这是为什么呢？带着我们的问题进入下一节。 十六种模式和saveLayer()十六种模式 名字 含义 名字 含义 CLEAR 清除模式［0，0］，即最终所有点的像素的alpha 和color 都为 0，所以画出来的效果只有白色背景 SRC 显示上层绘制图片 DST 显示下层绘制图片 SRC_OVER 正常绘制显示，上下层绘制叠盖 DST_OVER 上下层都显示，下层居上显示 SRC_IN 取两层绘制交集。显示上层 DST_IN 取两层绘制交集，显示下层 SRC_OUT 取上层绘制非交集部分 DST_OUT 取下层绘制非交集部分 SRC_ATOP 取下层非交集部分与上层交集部分 DST_ATOP 取上层非交集部分与下层交集部分 XOR 异或：去除两图层交集部分 DARKEN 取两图层全部区域，交集部分颜色加深 LIGHTEN 取两图层全部，点亮交集部分颜色 MULTIPLY 取两图层交集部分叠加后颜色 SCREEN 取两图层全部区域，交集部分变为透明色 PS：名称前面都应该有：PorterDuff.Mode ，例如：PorterDuff.Mode.CLEAR &emsp;&emsp;什么？有的看不懂什么意思？没关系，我也没指望你一次就看懂，我们先来说一说saveLayer()，且听我娓娓道来。 saveLayer()&emsp;&emsp;这个方法是干嘛用的？保存指定区域内画布的内容。 12public int saveLayer(RectF bounds, Paint paint, int saveFlags) public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags) &emsp;&emsp;后面的saveFlags，有6个值，我们这里用到的 Canvas.ALL_SAVE_FLAG，很明显，表示保存所有内容。我们这里如果把这个方法去掉，会是什么样的结果呢？代码就不贴出来了，就直接注释掉saveLayer的两行代码。还是先画dst，后画src，跑出来的效果图如下： 我们先规定两点： 先画dst，也就是目标图像，是一个圆形。 后画src，也就是源图像，是一个矩形。 代码名称1 顺序 中文名称 形状 dst 先画 目标图像 红色圆形 src 后画 源图像 黄色矩形 &emsp;&emsp;规定好之后，我们再来说一说这个 SRC_IN，我们前面说了：取两层绘制交集。显示上层。首先IN是取交集部分，OUT是取非交集部分。这个就是说最后显示的图形，他们的交集部分，显示src，也就是矩形的颜色，也就是黄色。先画的dst，他自然在src的上层。所以，显示dst的形状，两者交集部分显示src的颜色。可以看下图： &emsp;&emsp;我们再来说说saveLayer的绘制流程：如上图所示，它会创建一个全新图名的bitmap，大小跟你前面指定的保存区域相同，然后，绘制的图形会保存在这个全新透明的bitmap上面，最后把这个透明的bitmap画在画布上面。 &emsp;&emsp;辣么，没有savelayer()方法的绘制流程呢？如下图： 他是直接作用在画布上面的。 常用的PorterDuffXfermode模式介绍SRC模式&emsp;&emsp;只保留源图像的 alpha 和 color ，所以绘制出来只有源图，有时候会感觉分不清先绘制的是源图还是后绘制的是源图，这个时候可以这么记，先绘制的是目标图，不管任何时候，一定要做一个有目标的人，目标在前！（未达到我们的预期效果，感觉有问题） DST模式&emsp;&emsp;只显示目标图片，也就是只显示红色的圆形。 SRC_OVER模式&emsp;&emsp;在目标图片顶部绘制源图像,从命名上也可以看出来就是把源图像绘制在上方，也就是把黄色长方形，画在红色圆形的上面。效果图如下： DST_OVER模式&emsp;&emsp;把目标图像绘制在上方。与前一个相反，把红色圆形画在长方形上面。效果图如下： SRC_IN模式&emsp;&emsp;在两者相交的地方绘制源图像，并且绘制的效果会受到目标图像对应地方透明度的影响。 &emsp;&emsp;有点绕，我分成几段讲出来： &emsp;&emsp;也就是说，两者相交的位置，显示源图像，也就是黄色的矩形，目标图像的透明度为0，然后，&emsp;源图像的其他位置的透明度&emsp;&emsp;会跟源图像与目标图像相交的地方&emsp;&emsp;的目标图像的透明度一样。 &emsp;&emsp;有点绕。其实，就是说源图像的其他地方隐藏，就显示相交的位置。效果图如下： DST_IN模式&emsp;&emsp;跟前面刚好对应，在两者相交的地方绘制目标图像，并且，绘制效果会受到源图像对应地方透明度的影响。我们最是绘制目标图像。效果图如下： SRC_OUT模式&emsp;&emsp;在不相交的地方绘制源图像，相交处根据目标alpha进行过滤，目标色完全不透明时则完全过滤，完全透明则不过滤； DST_OUT模式&emsp;&emsp;同样，可以类比SRC_OUT , 在不相交的地方绘制目标图像，相交处根据源图像alpha进行过滤，完全不透明处则完全过滤，完全透明则不过滤； 太多了，后面就不写了，用的也比较少。 用途，加上上一篇的贝赛尔曲线的水波纹。很明显，我就想做如下效果： 这个圆只是一种，这只是一个demo，这个圆，你可以换成任意的形状。你知道水波纹用贝赛尔曲线怎么做，知道了，PorterDuffXfermode这个模式，两张图片是怎么切割。像这样的，还不就是一个道理。随手拈来。如下图： 这个水波纹的，已经全部封装好了。任意改变背景图片。项目链接]]></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View——贝赛尔曲线]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%E2%80%94%E2%80%94%E8%B4%9D%E8%B5%9B%E5%B0%94%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文针对有一定自定义View的童鞋，最好对贝赛尔曲线有辣么一丢丢了解，不了解也没关系。花5分钟看一下 GcsSloop的 安卓自定义View进阶-Path之贝塞尔曲线。 本文的最终效果图： 思路 首先他是一个只有上半部分的正弦形状的水波纹，很规则。 其次，他这个正弦图左右在移动。 然后，就是它这个自定义View，上下也在移动，是慢慢增加的 最后，优化点：一开始刚出来的时候，它那个水波纹的角度，更达到一定角度后，最后面，快要完成的时候的角度是不一样的。 第一步：画正弦形状的水波纹&emsp;&emsp;有一定自定义View基础的童鞋都知道，一阶贝赛尔画直线，这里的正弦图形是用二阶贝赛尔曲线。至于三阶，四阶，五阶用的都比较少。 &emsp;&emsp;我们这里知道了，这是用的二阶贝赛尔曲线，辣么，方法呢？ 123//不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)mPath.rQuadTo(dx1, dy1, dx2, dy2);//mPath.quadTo(dx1, dy1, dx2, dy2); &emsp;&emsp;Path调用该方法，这里就是传的两个点，也就是四个值，参数的含义：第一个点是控制点，第二个点是终点。前面还有一个起点，通过 1mPath.moveTo(x,y); &emsp;&emsp;这个方法是确定起点。不懂的童鞋，看一下文章开头推荐的文章。我们效果的是一排波浪线，我们上面这个方法只是一个。举个例子： 1234567891011121314151617181920212223242526//构造方法里面初始化private void initView() &#123; path = new Path(); paint = new Paint(); paint1 = new Paint(); paint.setColor(Color.GREEN); paint.setStyle(Paint.Style.STROKE); paint.setStrokeWidth(10); paint1.set(paint); paint1.setColor(Color.RED); &#125;//onDraw里面去画出来 @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.moveTo(0,300); path.quadTo(150, 150, 300, 300); path.quadTo(450, 450, 600, 300); canvas.drawPath(path, paint); canvas.drawCircle(0,300,5,paint1); canvas.drawCircle(150,150,5,paint1); canvas.drawCircle(300,300,5,paint1); canvas.drawCircle(450,450,5,paint1); canvas.drawCircle(600,300,5,paint1); &#125; &emsp;&emsp;上面就是简单的初始化paint，和path，然后画出path，另外，我还画出了5个点，帮助理解。跑出来的效果图如下： &emsp;&emsp;转换成对应的坐标系，手画的，有点丑，知道是这个意思就行了。如下： 画一个正弦图的思路： 首先，把path移动到起点，对应的也就是moveTo(0,300) 然后，确定终点，也就是我们前面说的quadTo()方法的第二个点(300,300) 最后，我们确定控制点，也就是我们前面说的quadTo()方法的第一个点。 辣么，这个控制点是怎么确定的呢？问题就在这里。敲黑板 因为我们画的是一个规则的正弦图，所以，控制点的x坐标肯定是终点x坐标300的一半，也就是150。再就是他的y坐标，其实y坐标是随便定义的。y坐标只是约束这个正弦图形的坡度，对坡度。你把y坐标定义的离终点的y坐标远一点，他的坡度就大一点。离他近一点，坡度就小一点。你如果定义控制点是（150,100），他相对于控制点是(150,150)的坡度就会大一点。因为100距300相差200，150距300相差150。200大于150。对，就是这样。辣么，怎么控制是上半部分的正弦图还是下半部分的正弦图呢？ |y控|&gt;|y终|，上半部分；相反，则是下半部分。 &emsp;&emsp;对了，这里我需要说明的是，上面我们调用了两次quadTo()方法，第二次调用的起点，就是第一次的终点。 &emsp;&emsp;上面效果是调用quadTo()方法，我们再来说一说rQuadTo()方法。上面的注释里面，我们也标明了两者的区别。 辣么，什么叫相对于原点的坐标系？什么叫相对于当前点的坐标系呢？ 我们知道android的坐标系原点是左上角，你可以这样理解，第一种，不带r的方法quadTo()，他的坐标原点(0,0)点始终在左上角，第二种带r的方法rQuadTo()，我们第一次移动到起点(0,300)的时候，这个时候的原点就是(0,300)，所以说此时的终点应该是(300,0),然后确定我们的控制点(150,-150)。辣么，我们调用第二次的时候，此时的终点就是(300,0)，这个时候的终点就是(300,0)，在确定此时的控制点(150,150)。两次的终点都是(300,0)，但是，意义是不一样的。有点绕，但是你理解了相对于原点坐标系，和相对于当前点的坐标系，就很简单了。理解一下，思考5分钟。辣么，上面用带r的怎么写呢？ 123456path.moveTo(0,300);// path.quadTo(150, 150, 300, 300);// path.quadTo(450, 450, 600, 300); path.rQuadTo(150,-150,300,0); path.rQuadTo(150,150,300,0); canvas.drawPath(path, paint); &emsp;&emsp;至此，怎么换一个正弦图，以及，两个方法的区别，已经讲完了，我觉得已经讲的非常清楚了。感觉，没有谁比我讲的还要清楚了。手把手教学。我们这个效果，画一个，肯定不行。要画满一个屏幕。怎么画呢？ &emsp;&emsp;找规律，一个正弦图，我们上面都是围绕这三个点，起点，控制点，终点。要想规则，控制点的x坐标是终点x坐标的一半。再就是，要画满一个屏幕，要在屏幕内部，所以，终点x坐标要小于屏幕宽度。综上所述。 三个点：起点，终点，控制点 控制点的x坐标是终点x坐标的一半 终点x坐标要小于屏幕宽度 我们就开始写代码了： 1234567891011121314151617181920212223 private int startY = 300;//定义起始点的y坐标 private int endX = 300;//定义终点的x坐标 private int controlY = 150;//定义控制点的y坐标 @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.moveTo(0, 300); path.moveTo(0, startY);// path.quadTo(150, 150, 300, 300);// path.quadTo(450, 450, 600, 300);//这里的for循环为什么每次要加2倍的终点x坐标呢？ //你想一想，我们一次for循环，画的图的终点x坐标在哪？ for (int i = 0; i &lt; getWidth(); i += 2*endX) &#123;// path.rQuadTo(150, -150, 300, 0);// path.rQuadTo(150, 150, 300, 0); path.rQuadTo(endX/2, -controlY, endX, 0); path.rQuadTo(endX/2, controlY, endX, 0); &#125; canvas.drawPath(path, paint); &#125; 效果图，如下： &emsp;&emsp;好，到这里，第一步完成了，满屏的水波纹出来了。 第二步，正弦图左右在移动&emsp;&emsp;想一想，这个动画，想一想，想一想，像不像水平位移动画？像不像？越想越像。辣么，我们就去验证一下。写一个动画，这种，明显就是属性动画。既然是左右移动，辣么就肯定是改变x轴的坐标值，改变谁的呢？肯定是起点的啊，只有改变起点的x左边的值，水波纹才会有动的效果 123456789101112131415161718192021222324public void startAnimation()&#123; ValueAnimator animator = ValueAnimator.ofFloat(0, 1); animator.setDuration(1000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Float animatedValue = (Float) animation.getAnimatedValue(); currentStartX = (int) (endX * animatedValue); postInvalidate(); &#125; &#125;); animator.start(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.reset();//不加会有重影，不是我们想要的// path.moveTo(0, 300);// path.moveTo(0, startY); path.moveTo(currentStartX, startY); ...//其他的不变 &#125; 效果图如下： &emsp;&emsp;尼玛，什么鬼？动是动起来了，为啥左边还有一段空白？不要急，想一想为什么？我们之前是从Y轴开始画的，我们这个动画是从左向又移动一个endx的值，所以，我们设置起点的时候，也向左偏移一个endx的值不就好了么？我们再试一试 12345678910111213141516171819@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.reset();// path.moveTo(0, 300);// path.moveTo(0, startY); path.moveTo(-endX + currentStartX, startY);// path.quadTo(150, 150, 300, 300);// path.quadTo(450, 450, 600, 300); //这里的for循环为什么每次要加2倍的终点x坐标呢？ //你想一想，我们一次for循环，画的图的终点x坐标在哪？ for (int i = -endX; i &lt; getWidth() + endX; i += 2 * endX) &#123;// path.rQuadTo(150, -150, 300, 0);// path.rQuadTo(150, 150, 300, 0); path.rQuadTo(endX / 2, -controlY, endX, 0); path.rQuadTo(endX / 2, controlY, endX, 0); &#125; canvas.drawPath(path, paint); &#125; 跑出来的效果图如下： &emsp;&emsp;咦，满脸的嫌弃，这是什么东西啊，空白虽然没了，为什么会卡一下，并且这个也不是我们想要的效果。我们再想一想，我们这个无线循环的动画的原理是什么？ 敲黑板，其实，我们就是多画了一个正弦波形，我们移动之后，跟移动之前一样，也就是位移了两个正弦图，结束后的图形，跟结束前的图形重合，然后一直重复动画，从而让用户感觉是无线循环的动画。 辣么，哪里出问题呢？想一想，为什么达不到我们的效果，肯定是我们水平移动距离的有问题啊。找啊找啊找，找到了，我们这里的endx坐标，是一个完整正弦图形的一半。所以，我们动画移动的距离要乘以2。如下： 12345678currentStartX = (int) (2 * endX * animatedValue);//动画里面的//动画还要加上插值器，从而达到平滑的效果animator.setInterpolator(new LinearInterpolator());辣么，这里距离变了，我们起始点的距离，循环的距离也要变。要不然会有空白path.moveTo(-endX*2 + currentStartX, startY);for (int i = -endX*2; i &lt; getWidth() + endX*2; i += 2 * endX) &#123;...&#125; &emsp;&emsp;综上所述，去除无关代码之后的完整代码，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Author: 海晨忆 * Date: 2018/3/27 * Desc: */public class WaveView1 extends View &#123; private Path path; private Paint paint; private Paint paint1; private int startY = 300; private int endX = 300; private int controlY = 150; private int currentStartX; public WaveView1(Context context) &#123; this(context, null); &#125; public WaveView1(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public WaveView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; private void initView() &#123; path = new Path(); paint = new Paint(); paint1 = new Paint(); paint.setColor(Color.GREEN); paint.setStyle(Paint.Style.STROKE); paint.setStrokeWidth(10); paint1.set(paint); paint1.setColor(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.reset(); path.moveTo(-endX*2 + currentStartX, startY); for (int i = -endX*2; i &lt; getWidth() + endX*2; i += 2 * endX) &#123; path.rQuadTo(endX / 2, -controlY, endX, 0); path.rQuadTo(endX / 2, controlY, endX, 0); &#125; canvas.drawPath(path, paint); &#125; public void startAnimation() &#123; ValueAnimator animator = ValueAnimator.ofFloat(0, 1); animator.setDuration(1000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Float animatedValue = (Float) animation.getAnimatedValue(); currentStartX = (int) (2 * endX * animatedValue); postInvalidate(); &#125; &#125;); animator.start(); &#125;&#125; 跑出来的效果图如下： 完美达到了我们的预期效果。 第三步：自定义View上下移动&emsp;&emsp;经过上面的左右动画，现在这个上下移动的动画就很简单了，很明显是改变起始点y坐标的值，当然，肯定是属性动画。代码如下： 1234567891011121314151617181920212223242526272829303132public void startAnimation() &#123; ...//这是我们的左移动画，没写上来 //这就是我们的竖着移动的动画 ValueAnimator animator1 = ValueAnimator.ofFloat(0, 1); animator1.setDuration(5000); animator1.setInterpolator(new LinearInterpolator()); animator1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Float animatedValue = (Float) animation.getAnimatedValue(); currentStartY = (int) (getHeight() * animatedValue); postInvalidate(); &#125; &#125;); animator1.start(); &#125; //改变我们的初始点的y坐标。不要只写个currentStartY， //光写这个是从下往上移动，你要的是从上往下移动 path.moveTo(-endX*2 + currentStartX, getHeight()-currentStartY); //再就是修改画笔为填充 paint.setStyle(Paint.Style.FILL_AND_STROKE); //并且把path连接成一个闭合图形 ...//这里是onDraw里面的for循环画正弦图形 path.lineTo(getWidth(),getHeight()); path.lineTo(0,getHeight()); path.close(); canvas.drawPath(path, paint); 跑出来的效果图，如下： &emsp;&emsp;到这个位置，基本上已经完成了百分之九十了。我们可以看到开始会有一个问题，结束的时候也有一个问题，这个问题是怎么产生的呢？ 第四步：优化开始和结束的动画&emsp;&emsp;其实，我们可以想一想，一开始，我们这个控制点的Y值，不应该一出来就是写死的，显得太突兀了，一开始，我们应该是慢慢涨，涨到我们规定的值，然后快结束的时候，我们应该是慢慢减，减到0为止。应该是这样才对。 1234567891011121314151617181920212223@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); path.reset(); int currentControlY = 0; if (currentStartY &lt; controlY) &#123; currentControlY = currentStartY; &#125; else &#123; currentControlY = controlY; &#125; if (getHeight() - currentStartY &lt; controlY) &#123; currentControlY = getHeight() - currentStartY; &#125; path.moveTo(-endX * 2 + currentStartX, getHeight() - currentStartY); for (int i = -endX * 2; i &lt; getWidth() + endX * 2; i += 2 * endX) &#123; path.rQuadTo(endX / 2, -currentControlY, endX, 0); path.rQuadTo(endX / 2, currentControlY, endX, 0); &#125; path.lineTo(getWidth(), getHeight()); path.lineTo(0, getHeight()); path.close(); canvas.drawPath(path, paint); &#125; 效果图如下： 经过上面的操作，就完美的达到了我们的预期效果。(PS：把画笔的宽度去掉) 把这个自定义View优化一下，把方法封装好了。项目链接]]></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android自定义刷新布局——Ultra-Pull-To-Refresh-With-Load-More（二））]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%B7%E6%96%B0%E5%B8%83%E5%B1%80%E2%80%94%E2%80%94Ultra-Pull-To-Refresh-With-Load-More%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[个人博客：haichenyi.com。感谢关注 回顾上一篇，我们讲到了Ultra-Pull-To-Refresh的基本用法。分成四步： xml里面定义控件PtrFrameLayout 设置相关属性 添加Header，Footer，并监听 监听刷新过程 思路&emsp;&emsp;目的： 做一个我们自己的自定义刷新的动画（我们先不管动画是什么，不同的需求，动画都不一样） &emsp;&emsp;我们前面讲到的主要类无非就是两个： PtrFrameLayout，Header（Footer），前者是刷新控件，监听刷新过程，后者是头布局（脚布局），以添加头布局为例：我们这里首先就会想到重写这个布局。辣么？怎么重写这个头布局呢？我们先来看看怎么添加这个头布局的： 123456789101112public void setHeaderView(View header) &#123; if (mHeaderView != null &amp;&amp; header != null &amp;&amp; mHeaderView != header) &#123; removeView(mHeaderView); &#125; ViewGroup.LayoutParams lp = header.getLayoutParams(); if (lp == null) &#123; lp = new LayoutParams(-1, -2); header.setLayoutParams(lp); &#125; mHeaderView = header; addView(header); &#125; 它这里实际上就是添加了一个View，所以，我们随便写一个自定义View，继承View就可以传进来 &emsp;&emsp;我们，再来看看另一个方法，就是监听的方法，这里好像也是传的View对象，因为，我们前面写的时候就是传的header： 123public void addPtrUIHandler(PtrUIHandler ptrUIHandler) &#123; PtrUIHandlerHolder.addHandler(mPtrUIHandlerHolder, ptrUIHandler); &#125; &emsp;&emsp;咦，不对啊，这里不是应该传的View对象么？怎么是PtrUIHandler类型的。其实，你看名字就应该看的出来，他这里传的是一个PtrUIHandler对象，点进去看，他就是一个接口。里面是下拉刷新的回调。讲到这里，我们就应该明了了，就是一个自定义View，继承View，实现PtrUIHandler接口。辣么，就开始撸了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Author: 海晨忆 * Date: 2018/3/23 * Desc: */public class MyCustomHeader extends FrameLayout implements PtrUIHandler &#123; public MyCustomHeader(@NonNull Context context) &#123; this(context, null); &#125; public MyCustomHeader(@NonNull Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MyCustomHeader(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; private void initView() &#123; LayoutInflater.from(getContext()).inflate(R.layout.header_layout, this); &#125; @Override public void onUIReset(PtrFrameLayout frame) &#123; &#125; @Override public void onUIRefreshPrepare(PtrFrameLayout frame) &#123; &#125; @Override public void onUIRefreshBegin(PtrFrameLayout frame) &#123; &#125; @Override public void onUIRefreshComplete(PtrFrameLayout frame, boolean isHeader) &#123; &#125; @Override public void onUIPositionChange(PtrFrameLayout frame, boolean isUnderTouch, byte status, PtrIndicator ptrIndicator) &#123; &#125;&#125; &emsp;&emsp;可以看到，我这里面什么都没有，就是继承了FrameLayout布局，实现了PtrUIHandler接口，然后在构造方法里面加载了一个布局，添加进来，布局也很简单，里面就只有一个ImageView。布局如下： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;200dp&quot; android:src=&quot;@drawable/psb17&quot;/&gt;&lt;/merge&gt; &emsp;&emsp;再就是调用了，跟上一篇的调用方式一样。 123456789101112131415final PtrFrameLayout ptrFrameLayout = findViewById(R.id.ptr_frame_layout); MyCustomHeader myCustomHeader = new MyCustomHeader(this); ptrFrameLayout.setHeaderView(myCustomHeader); ptrFrameLayout.addPtrUIHandler(myCustomHeader); ptrFrameLayout.setPtrHandler(new PtrDefaultHandler2() &#123; @Override public void onRefreshBegin(PtrFrameLayout frame) &#123; frame.postDelayed(ptrFrameLayout::refreshComplete, 2000); &#125; @Override public void onLoadMoreBegin(PtrFrameLayout frame) &#123; frame.postDelayed(ptrFrameLayout::refreshComplete, 2000); &#125; &#125;); &emsp;&emsp;然后运行，你就会看到，刷新的header就是你的自定义view。到此，自定义刷新布局就完成了，脚布局方式类似。 &emsp;&emsp;什么鬼？这就没了？刷新布局就一个ImageView就没了？这么敷衍。好歹你也加个动画啊。可以可以，那就加个动画。 &emsp;&emsp;如你所愿，我加了一个帧动画。 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/refresh1&quot; android:duration=&quot;100&quot;/&gt; &lt;item android:drawable=&quot;@drawable/refresh2&quot; android:duration=&quot;100&quot;/&gt; &lt;item android:drawable=&quot;@drawable/refresh3&quot; android:duration=&quot;100&quot;/&gt;&lt;/animation-list&gt; header里面的改动： 12345678910111213141516private void initView() &#123; LayoutInflater.from(getContext()).inflate(R.layout.header_layout, this); imageView = findViewById(R.id.img); animationDrawable = (AnimationDrawable) imageView.getDrawable(); &#125; @Override public void onUIRefreshBegin(PtrFrameLayout frame) &#123; imageView.setImageDrawable(animationDrawable); animationDrawable.start(); &#125; @Override public void onUIRefreshComplete(PtrFrameLayout frame, boolean isHeader) &#123; animationDrawable.stop(); &#125; 在初始化的时候，把动画获取到，然后在刷新的时候开始动画，在刷新完成的时候停止动画。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android下拉刷新，上拉加载——Ultra-Pull-To-Refresh-With-Load-More（一）]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E2%80%94%E2%80%94Ultra-Pull-To-Refresh-With-Load-More%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[个人博客：haichenyi.com。感谢关注 简介Android里面刷新和分页加载是常见的，刷新有Google的SwipeRefreshLayout，但是UI不同意，非要跟IOS一样，那就没办法了。 开源框架链接：Ultra-Pull-To-Refresh-With-Load-More。这个开源框架是基于Ultra-Pull-To-Refresh拓展了一个上拉加载功能。 作者：廖祜秋 依赖12implementation &apos;in.srain.cube:ptr-load-more:1.0.6&apos; 用法整个项目就只有一个核心类：PtrFrameLayout，继承ViewGroup。步骤： xml里面定义控件PtrFrameLayout 设置相关属性 添加Header，Footer，并监听 监听刷新过程 第一步：xml里面定义控件PtrFrameLayout1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;in.srain.cube.views.ptr.PtrFrameLayout android:id=&quot;@+id/ptr_frame_layout&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:cube_ptr=&quot;http://schemas.android.com/apk/res-auto&quot; cube_ptr:ptr_resistance_header=&quot;1.7&quot; cube_ptr:ptr_ratio_of_header_height_to_refresh=&quot;1.2&quot; cube_ptr:ptr_duration_to_back_header=&quot;300&quot; cube_ptr:ptr_duration_to_close_header=&quot;2000&quot; cube_ptr:ptr_keep_header_when_refresh=&quot;true&quot; cube_ptr:ptr_pull_to_fresh=&quot;false&quot; cube_ptr:ptr_resistance_footer=&quot;1.3&quot; cube_ptr:ptr_duration_to_back_footer=&quot;300&quot; cube_ptr:ptr_duration_to_close_footer=&quot;2000&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/colorAccent&quot; android:gravity=&quot;center&quot; android:text=&quot;textView&quot;/&gt; &lt;/LinearLayout&gt;&lt;/in.srain.cube.views.ptr.PtrFrameLayout&gt; 上面就是一个简单的布局，根布局是 PtrFrameLayout ，他的子View可以是任意view。 第二步：设置相关属性我们也看到了，他的布局里面有一些自定义属性，可以在布局里面设置，也可以在java代码里面设置，相关属性含义如下： Resistence：阻尼系数，可以分别设置header和footer。默认: 1.7f，越大，感觉下拉刷新时越吃力。上拉加载也是一样的 Ratio of the Height of the Header to Refresh：触发刷新时移动的位置比例。默认，1.2f，移动达到头部高度1.2倍时可触发刷新操作。下拉刷新，上拉加载都一样。 Duration to Close back：回弹延时。默认 200ms，回弹到刷新或者高度所用时间，可以跟上面一样分开设置，也可以设置一个 Duration to Close Header：刷新完成之后隐藏头部的时间。默认1000mscube_ptr:ptr_duration_to_close_either=”2000” Keep Header while Refreshing：刷新是保持头部，也就是显示头部。默认值 true。false：隐藏头部 Pull to Refresh / Release to Refresh：下拉刷新 / 释放刷新。默认为释放的时候刷新 在java代码中设置方式如下： 1234567891011final PtrFrameLayout ptrFrameLayout = findViewById(R.id.ptr_frame_layout);//配置头部参数,可以在xml中设置// the following are default settings ptrFrameLayout.setResistance(1.7f); ptrFrameLayout.setRatioOfHeaderHeightToRefresh(1.2f); ptrFrameLayout.setDurationToClose(200); ptrFrameLayout.setDurationToCloseHeader(1000);// default is false ptrFrameLayout.setPullToRefresh(false);// default is true ptrFrameLayout.setKeepHeaderWhenRefresh(true); 第三步：添加Header，Footer，并监听12345678910111213141516171819202122232425//第一种头部,StoreHouse风格的头部实现 /*StoreHouseHeader storeHouseHeader = new StoreHouseHeader(this); storeHouseHeader.setPadding(0,100,0,0); storeHouseHeader.setBackgroundColor(Color.BLACK); storeHouseHeader.setTextColor(Color.WHITE); storeHouseHeader.initWithString(&quot;haichenyi&quot;);//只可英文，中文不可运行(添加时间) ptrFrameLayout.setHeaderView(storeHouseHeader); ptrFrameLayout.addPtrUIHandler(storeHouseHeader);*/ //第二种头部,Material Design风格的头部实现,类似SwipeRefreshLayout /*MaterialHeader materialHeader = new MaterialHeader(this); materialHeader.setColorSchemeColors(new int[]&#123;Color.RED, Color.GREEN, Color.BLUE&#125;); ptrFrameLayout.setHeaderView(materialHeader); ptrFrameLayout.addPtrUIHandler(materialHeader);*/ //第三种头部,经典 风格的头部实现，下拉箭头+时间 PtrClassicDefaultHeader ptrClassicDefaultHeader = new PtrClassicDefaultHeader(this); ptrFrameLayout.setHeaderView(ptrClassicDefaultHeader); PtrClassicDefaultFooter ptrClassicDefaultFooter = new PtrClassicDefaultFooter(this); ptrFrameLayout.setFooterView(ptrClassicDefaultFooter); ptrFrameLayout.addPtrUIHandler(ptrClassicDefaultHeader); ptrFrameLayout.addPtrUIHandler(ptrClassicDefaultFooter); 如上面代码所示，Header，Footer的种类是一样的，Header有三种，Footer也有三种，定义好之后，通过 setHeaderView(), setFooterView() 添加到 ptrFrameLayout 中，然后通过调用 addPtrUIHandler 监听两者的状态即可。不监听会显示空白，看不到具体内容 第四步：监听刷新过程123456789101112ptrFrameLayout.setPtrHandler(new PtrDefaultHandler2() &#123; @Override public void onLoadMoreBegin(PtrFrameLayout frame) &#123; frame.postDelayed(ptrFrameLayout::refreshComplete, 2000); &#125; @Override public void onRefreshBegin(PtrFrameLayout frame) &#123; frame.postDelayed(ptrFrameLayout::refreshComplete, 2000); &#125; &#125;); ptrFrameLayout.setMode(PtrFrameLayout.Mode.LOAD_MORE); 通过设置 setPtrHandler() 方法监听刷新过程。默认的是 PtrDefaultHandler2(),它是后来加的，包括刷新和加载。PtrDefaultHandler() 只包含刷新功能。通过setMode()方法设置：只要下拉刷新，或者只要上拉加载，或者两者都要。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[**个人博客：haichenyi.com。感谢关注**]]></title>
    <url>%2F2018%2F05%2F13%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9Ahaichenyi-com%E3%80%82%E6%84%9F%E8%B0%A2%E5%85%B3%E6%B3%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java 加密算法（二）]]></title>
    <url>%2F2018%2F05%2F13%2FJava-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[补充知识点：密钥： 加密方用公钥，解密方用私钥 重要的事情强调六遍： 不用自己写加密算法 不用自己写加密算法 不用自己写加密算法 不用自己写加密算法 不用自己写加密算法 不用自己写加密算法 Cipher类&emsp;&emsp;Android有专门用来加密的工具类Cipher类，他里面封装了几种常用的加密算法，本篇介绍两种AES，RSA。 用法 12345678910111213141516171819202122232425262728293031分三步：以AES举例说明 /** * 加密方式：AES * 工作模式：ECB,CBC,CTR,OFB,CFB * 填充模式：PKCS5Padding，PKCS7Padding，ZEROPadding等等 */String CBC_PKCS5_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;//AES是加密方式 CBC是工作模式 PKCS5Padding是填充模式//第一步：获取对象Cipher cipher = Cipher.getInstance(String transformation);//传 CBC_PKCS5_PADDING//第二步：设置初始化参数 /** * 第一个参数：传类型，是加密Cipher.ENCRYPT_MODE，还是解密Cipher.DECRYPT_MODE * 第二个参数：传密钥key，我们这里传的是SecretKeySpec，它实现SecretKey，SecretKey实现Key接口。 * SecretKeySpec keySpec = new SecretKeySpec(raw, AES);//第一个参数传密钥byte数组，第二个参数传加密类型也就是&quot;AES&quot;字符串即可 * 第三个参数：传偏移量AlgorithmParameterSpec，我们这里传的IvParameterSpec，他实现AlgorithmParameterSpec接口，iv偏移量传默认的16个0的字节数组 * new IvParameterSpec(new byte[cipher.getBlockSize()])，这里是传的默认的16个0的byte数组，也是常用的方式 */cipher.init(int opmode, Key key, AlgorithmParameterSpec params)第三步：加密。传需要加密的字符串的byte数组cipher.doFinal(byte[] input)经过以上三步：AES加密就算完成了，加密之后就需要解密，辣么，怎么解密呢？ 草鸡简单，第二步初始化的时候，第一个参数传解密即可，其他都是一样的。 对称加密概念出自百度百科 &emsp;&emsp;需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。 &emsp;&emsp;所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。 &emsp;&emsp;因此，加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。 &emsp;&emsp;说了这么多废话，要我说，就一句话公钥，私钥 相同 的加密方式称之为对称加密 用法——AES&emsp;&emsp;申明：我这里并不是说对称加密就只有AES这一种方式，相反，对称加密有很多种，我这里只讲我用到的对称加密中的一种方式——AES 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 private static final String CBC_PKCS5_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;//AES是加密方式 CBC是工作模式 PKCS5Padding是填充模式 private static final String AES = &quot;AES&quot;;//AES 加密 private static final String SHA1PRNG = &quot;SHA1PRNG&quot;;// SHA1PRNG 强随机种子算法, 要区别4.2以上版本的调用方法/** * 随机生成密钥，传同一个字符串，每次都生成的不一样 * @param seed 一般传用户的密码 * @return 返回密钥的byte数组 * @throws Exception 异常 */ private static byte[] getRawKey(String seed) throws Exception &#123; SecureRandom sr = null; // 在4.2以上版本中，SecureRandom获取方式发生了改变 if (android.os.Build.VERSION.SDK_INT &gt;= 17) &#123; sr = SecureRandom.getInstance(SHA1PRNG, &quot;Crypto&quot;); &#125; else &#123; sr = SecureRandom.getInstance(&quot;SHA1PRNG&quot;); // 获得一个随机数，传入的参数为默认方式。 &#125; sr.setSeed(seed.getBytes()); // 设置一个种子，这个种子一般是用户设定的密码。也可以是其它某个固定的字符串 KeyGenerator keyGen = KeyGenerator.getInstance(&quot;AES&quot;); // 获得一个key生成器（AES加密模式） //AES中128位密钥版本有10个加密循环，192比特密钥版本有12个加密循环，256比特密钥版本则有14个加密循环。 keyGen.init(128, sr); // 设置密匙长度128位 SecretKey key = keyGen.generateKey(); // 获得密匙 return key.getEncoded(); &#125; /** * 加密过程 * @param raw 密钥的数组 * @param clear 需要加密的byte数组 * @return 加密后的byte数组 * @throws Exception 异常 */ private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception &#123; SecretKeySpec keySpec = new SecretKeySpec(raw, AES); Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING); //iv偏移量传默认的16个0的字节数组 cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); return cipher.doFinal(clear); &#125; /* * 解密 */ private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception &#123; SecretKeySpec keySpec = new SecretKeySpec(raw, AES); Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING); cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); return cipher.doFinal(encrypted); &#125; &emsp;&emsp;上面给的三个方法，一个获取密钥，一个加密，一个解密，注释写的很清楚，我就不用再讲了，转16进制的方法，我前一篇讲加密的时候就给出来了，不知道的可以去前一篇看一下，我下面给出调用方式和结果截图 1234567891011121314try &#123; byte[] rawKey = getRawKey(key); Log.v(&quot;wz&quot;, rawKey.length + &quot;&quot;); String s = bytesToHexFun1(rawKey); Log.v(&quot;wz&quot;,&quot;密钥16进制--&gt;&quot;+s); byte[] encrypt = encrypt(rawKey, data.getBytes()); String after = Base64.encodeToString(encrypt, Base64.NO_WRAP); Log.v(&quot;wz&quot;,&quot;加密后--&gt;&quot;+after); byte[] decode = Base64.decode(after, Base64.NO_WRAP); byte[] before = decrypt(rawKey, decode); Log.v(&quot;wz&quot;,&quot;解密后--&gt;&quot;+new String(before)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 结果： 非对称加密概念出自百度百科 &emsp;&emsp;1976年，美国学者Dime和Henman为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。 &emsp;&emsp;与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 &emsp;&emsp;说了这么多废话，要我说，就一句话公钥，私钥 不相同 的加密方式称之为对称加密 用法——RSA&emsp;&emsp;申明：我这里并不是说非对称加密就只有RSA这一种方式，相反，对非称加密有很多种，我这里只讲我用到的非对称加密中的一种方式——RSA &emsp;&emsp;辣么，成对公钥，私钥怎么来呢？难道我们自己去写吗？你要是会写，那你很棒棒哦，反正我不会(爱咋咋)，我是在线生成公钥，私钥对。用法跟上面讲的AES是类似的： 12345678910111213141516171819202122232425262728293031323334353637383940/** * 我们之前拿到的是公钥，我们还要把公钥转成Key * 因为cipher.init()初始化的时候，第二个参数需要传Key类型的，并不是String * 获取Key，我这里返回的是PublicKey，它实现的Key接口 * @param pubKey 生成的公钥 * @return 最后需要的key * @throws Exception 异常 */ public static PublicKey loadPublicKey(String pubKey) throws Exception &#123; byte[] buffer = Base64.decode(pubKey, Base64.DEFAULT); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer); return keyFactory.generatePublic(keySpec); &#125; /** * 加密 * @param data 需要加密的数据 * @param publicKey key * @return 返回加密后的byte，需要转成字符串 * @throws Exception 异常 */ private static byte[] encryptRSA(String data,PublicKey publicKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;); cipher.init(Cipher.ENCRYPT_MODE,publicKey); return cipher.doFinal(data.getBytes()); &#125; /** * 解密（我们需要注意的是，我们解密的是私钥加密的数据，不能解密公钥加密的数据） * @param data 需要解密的数据 * @param publicKey key * @return 返回解密后的数组 * @throws Exception 异常 */ private static byte[] decryptRSA(String data,PublicKey publicKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;); cipher.init(Cipher.DECRYPT_MODE,publicKey); return cipher.doFinal(data.getBytes()); &#125; &emsp;&emsp;这里，注释说的很清楚，看懂了前面的AES，辣么，这个RSA应该不是问题。]]></content>
      <categories>
        <category>Android -加密算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 加密算法（一）]]></title>
    <url>%2F2018%2F03%2F08%2FJava-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[补充知识点：字节：也就是 byte 是一种统计单位，表示数量的多少 字符：是指计算机中使用的文字和符号，比如：1、2、3、A、S、D、$、%等等符号 字节与字符的对应关系：它们完全不是一个概念，所以，没有什么有没有区别这个说法。不同的编码，两者的对应关系是不相同的，我这里就说常用的两种编码： ASCII码中，一个英文字母（不区分大小写）占一个字节，一个中文汉字占两个字节 UTF-8中，一个英文字母占一个字节，一个中文汉字占三个字节 &emsp;&emsp;我们加密最终常常操作的是bit，而我们加密首先得到的是byte数组的，byte的取值范围-128~127，中间包括0，刚好256个。也就是2^8=256。并且，1 byte = 8 bit（1kb = 1024 byte = 8^1024 bit等等） &emsp;&emsp;我们获得了byte之后，要把byte数组转成String字符串，String其实就是char数组，我们java有一个new String(char[] chars)，应该都用过。我们转成字符串的前提是转成char数组，由于，1 char = 2 byte，所以，我们byte转成char长度扩大了1倍。 四种分类 MD5加密 Base64加密 对称加密 非对称加密 MD5加密——不可逆概念&emsp;&emsp;MD5加密是我们常见的加密算法，是不可逆的，也就是说加密完成之后，无法解密转成原来的内容。MD5加密算法其实是一种散列函数，使用的是hash算法。MD5的原文是无线多个，但是MD5的值是有限的。所以一个MD5的值可能对应多个原文。SHA算法跟MD5是差不多的，只是MD5是128位，SHA是160位，多32位 &emsp;&emsp;为什么MD5的值是有限多个呢？主流的MD5使用的是将任意长度的字节串映射为一个128bit的大整数。也就是一共有2^128种可能，所以说这个数字是有限的，而，我们的原文则是无限多个。发现两段原文对应同一个MD5的值概率非常小，也就忽略不记了。 使用1234567891011121314String name1 = &quot;haichenyi&quot;; String name2 = &quot;海晨忆&quot;; try &#123; MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); byte[] digest1 = md5.digest(name1.getBytes(&quot;UTF-8&quot;)); Log.v(&quot;WZ&quot;,&quot;length1:&quot;+digest1.length); byte[] digest2 = md5.digest(name2.getBytes(&quot;UTF-8&quot;)); Log.v(&quot;WZ&quot;,&quot;length1:&quot;+digest2.length); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &emsp;&emsp;我们通过MD5，得到的是一个byte数组（这个byte数组的长度跟我们的1byte=8bit没有直接关系），我们需要做的就是对这个byte数组进行操作，我们习惯上就是把这个btye转成16进制数存进数据库，当然，你也可以转成其他的类型存到数据库。这里给出几个byte数组转16进制字符串的方法，亲测可用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private static final char[] HEX_CHAR = &#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;; /** * 方法一： * byte[] to hex string * * @param bytes * @return */ public String bytesToHexFun1(byte[] bytes) &#123; // 一个byte为8位，可用两个十六进制位标识 char[] buf = new char[bytes.length * 2]; int a = 0; int index = 0; for (byte b : bytes) &#123; // 使用除与取余进行转换 if (b &lt; 0) &#123; a = 256 + b; &#125; else &#123; a = b; &#125; buf[index++] = HEX_CHAR[a / 16]; buf[index++] = HEX_CHAR[a % 16]; &#125; return new String(buf); &#125; /** * 方法二： * byte[] to hex string * * @param bytes * @return */ public String bytesToHexFun2(byte[] bytes) &#123; char[] buf = new char[bytes.length * 2]; int index = 0; for(byte b : bytes) &#123; // 利用位运算进行转换，可以看作方法一的变种 buf[index++] = HEX_CHAR[b &gt;&gt;&gt; 4 &amp; 0xf]; buf[index++] = HEX_CHAR[b &amp; 0xf]; &#125; return new String(buf); &#125; /** * 方法三： * byte[] to hex string * * @param bytes * @return */ public String bytesToHexFun3(byte[] bytes) &#123; StringBuilder buf = new StringBuilder(bytes.length * 2); for(byte b : bytes) &#123; // 使用String的format方法进行转换 buf.append(String.format(&quot;%02x&quot;, new Integer(b &amp; 0xff))); &#125; return buf.toString(); &#125; /** * 将16进制字符串转换为byte[] * * @param str * @return */ public byte[] toBytes(String str) &#123; if(str == null || str.trim().equals(&quot;&quot;)) &#123; return new byte[0]; &#125; byte[] bytes = new byte[str.length() / 2]; for(int i = 0; i &lt; str.length() / 2; i++) &#123; String subStr = str.substring(i * 2, i * 2 + 2); bytes[i] = (byte) Integer.parseInt(subStr, 16); &#125; return bytes; &#125; Base64加密——可逆流程 要知道的是有一个64个数的表，也称Base64编码表。可以字节定义，不过都是用的一样的。 Base64是按照字符长度，以3个字符为一组 接着增对每组的每个字符，取ASCII编码 然后将获得的编码转换成8bit的二进制，就会得到3*8=24bit的字节 然后将这24bit的字节以6个bit为一组，分成4组 接着在每组前面填两个高位0，凑成每组8bit 最后将这每组8bit的二进制转成十进制，对应下面的Base64编码表 Base64 编码表 value char value char value char value char 0 A 16 Q 32 g 48 w 1 B 17 R 33 h 49 x 2 C 18 S 34 i 50 y 3 D 19 T 35 j 51 z 4 E 20 U 36 k 52 0 5 F 21 V 37 l 53 1 6 G 22 U 38 m 54 2 7 H 23 X 39 n 55 3 8 I 24 Y 40 o 56 4 9 J 25 Z 41 p 57 5 10 K 26 a 42 q 58 6 11 L 27 b 43 r 59 7 12 M 28 c 44 s 60 8 13 N 29 d 45 t 61 9 14 O 30 e 46 u 62 + 15 P 31 f 47 v 63 / 使用1234567891011String str = &quot;hai&quot;; byte[] encode = Base64.encode(str.getBytes(), Base64.NO_WRAP); try &#123; String a = new String(encode,&quot;UTF-8&quot;); String a1 = new String(encode,&quot;US-ASCII&quot;); Log.v(&quot;wz&quot;,a); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; String after = Base64.encodeToString(str.getBytes(), Base64.NO_WRAP); Log.v(&quot;wz&quot;,&quot;after--&gt;&quot;+after); 解析&emsp;&emsp;这里，我要使用Base64加密”hai”这个字符串，根据上面的流程： 待加密字符串 h a i ASCII编码 104 97 105 二进制 01101000 01100001 01101001 下面，上面的表不好表示，我再换一个表，下一步，该6位分一组了 现在的字符串：01101000 01100001 01101001 六位分一组 011010 000110 000101 101001 每组前面补0 00011010 00000110 00000101 00101001 转成10进制 26 6 5 41 Base64编码 a G F p 结果图： PS： Base64.encodeToString()方法直接转成加密后的字符串 Base64.encode()方法返回的byte数组是16进制的，不用手动在去转一遍16进制]]></content>
      <categories>
        <category>Android -加密算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EventBus源码解析(二)——注册]]></title>
    <url>%2F2018%2F03%2F07%2FEventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前我们讲过获取EventBus对象的源码，这一篇，我们来讲讲注册的源码。推荐EventBus 3.0进阶：源码及其设计模式 完全解析 简介12345678/** * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they * are no longer interested in receiving events. * &lt;p/&gt; * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;. * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link * ThreadMode&#125; and priority. */ &emsp;&emsp; 翻译： 注册给订阅方去接收事件，订阅者一旦对接收事件不感兴趣了，就要unregister，订阅者必须要有用Subscribe注解的方法，注解也可以设置线程和优先级 &emsp;&emsp; 白话文： 订阅者要是想接收消息，必须要先注册。当页面退出，或者不想接收消息的时候必须要反注册，不然他会一直处于接收消息的状态，页面退出会内存泄漏。订阅者的接收方法必须要用Subscribe注解，这个注解的后面可以设置接收这个消息的线程和优先级。如下： 1234@Subscribe(threadMode = ThreadMode.MAIN,priority = 100,sticky = true) public void handleMsg(DataBean dataBean)&#123; &#125; &emsp;&emsp;就像上面这样写，我一个一个来讲。我们先来说说这个ThreadMode类，点进去，我们可以看到如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 每个订阅的方法都有一个线程，决定那个线程的方法被叫做EventBus * EventBus的线程可以跟Post事件的那个线程不相同 */public enum ThreadMode &#123; /** *订阅者将在跟Post事件的那个线程的同一个线程中被调用，这是默认值， * 因为，他没有线程切换，所以开销最少，所以也是推荐模式。需要注意的是 * post事件的线程可能是UI线程，也可能是其他线程，所以，这里的操作要做判断， * 如果是UI操作，你必须要在UI线程中完成，如果是耗时操作，你必须要新开线程 */ POSTING, /** * 在Android上面，订阅者将会在UI线程中调用，如果post事件的线程是UI线程， * 辣么，这个订阅方法将直接被调用，如果不是UI线程，辣么，它将要排队交付， * 所以，这里可能阻塞线程，订阅者使用这个模式必须要快速返回，避免阻塞UI线程， * 就是不要在这里做耗时操作。谢谢。 */ MAIN, /** *这一个，跟上面的刚好对应，就是不管怎么样，都要排队交付， * 不论post事件是不是处于UI线程发送的 */ MAIN_ORDERED, /** * 在android上面，订阅方法将在子线程中调用。如果post事件处于子线程， * 辣么，订阅方法将直接被调用。如果post事件处于UI线程，辣么，eventBus * 就会新开线程，按照顺序处理事件，当然，也要注意，避免阻塞子线程 */ BACKGROUND, /** * 订阅方法将会在独立的线程中调用，这个线程总是独立语post事件 * 所处的线程和主线程。如果post事件是耗时操作：例如网络请求， * 订阅方法调用的时候，不会等待。我们不用考虑线程数量的问题， * EventBus已经限制了并发线程，并使用线程池高效的重用线程 */ ASYNC&#125; 他就是一个枚举类，几个值的意义，我说的很清楚了。 &emsp;&emsp;我们再来讲讲另外两个： sticky，默认值是false，如果设置成true，辣么，这个事件将会是粘性事件。发送事件的方式从post变成了postSticky，其他都没变。 &emsp;&emsp;再来讲讲 priority ，默认值是0，在同一个线程中值越大，优先级越高。优先级高的比优先级低的先收到消息。 好，终于准备工作做完了，我们来看看 register() 方法 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; &emsp;&emsp;注册方法。首先，他通过反射的方式获得当前类名，然后通过当前类名，找到订阅方法，存到list里面。我们来看看 findSubscriberMethods()方法 123456789101112131415161718192021List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;//首先从缓存中读取当前类的订阅方法，如果不等于null，就直接返回从缓存中读取到的list List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125;//ignoreGeneratedIndex的值，从Builder可知，一般为false。 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; //将获取的subscriberMeyhods放入缓存中 METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; &emsp;&emsp;上面的注释写的很清楚，ignoreGeneratedIndex为false，辣么就会走findUsingInfo() 方法 123456789101112131415161718192021222324private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;//首先新建了一个FindState，FindState是一个静态内部类，保存订阅者的信息 FindState findState = prepareFindState(); //初始化FindState findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findState.subscriberInfo = getSubscriberInfo(findState); //初始化的findState获得的订阅者信息，一般都是null if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; //就会跳到这里 findUsingReflectionInSingleClass(findState); &#125; //移动到父类继续查找 findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; 上面，我们提到了FindState类，我们来看看这个类的代码 1234567891011121314151617181920static class FindState &#123;//订阅方法的列表 final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;();//以class的名称为key，以方法为value final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;();//以方法名称为key，订阅者类为value final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;(); final StringBuilder methodKeyBuilder = new StringBuilder(128); Class&lt;?&gt; subscriberClass; Class&lt;?&gt; clazz; boolean skipSuperClasses; SubscriberInfo subscriberInfo;//初始化 void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; this.subscriberClass = clazz = subscriberClass; skipSuperClasses = false; subscriberInfo = null; &#125; &#125; &emsp;&emsp;不难看出，这里的几个map包括了，类名找方法，方法名找类，我们后面都用的到，然后就是初始化方法，前面我们注释里面写了，初始化之后一般信息都是null，这里我们也可以看到。所以，它会走 findUsingReflectionInSingleClass 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; /*------------------------------上面就是获取方法，重要的是在下面------------------------------------*/ //这里我强调的是我们前面的用法里面有说过注意点 //1.必须是public修饰 //2.必须是void类型 //3.必须是一个参数 //4.必须用Subscribe注解 for (Method method : methods) &#123; //获取方法的修饰符 int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; //获取方法参数类型 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //如果参数个数等于1 if (parameterTypes.length == 1) &#123; //获取方法注解名称 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; //参数类型 即为事件类型 Class&lt;?&gt; eventType = parameterTypes[0]; //调用checkAdd方法判断是否添加过 if (findState.checkAdd(method, eventType)) &#123; //从注解里面获取线程模式 ThreadMode threadMode = subscribeAnnotation.threadMode(); //新建一个SubscriberMethod对象，并添加到findState的subscriberMethods这个集合内 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; //如果开启了严格验证，同时当前方法又有@Subscribe注解，对不符合要求的方法会抛出异常 &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125; &#125; &emsp;&emsp;这个方法非常重要！！！在这个方法内部，利用反射的方式，对订阅者类进行扫描判断，是否满足条件从而找出订阅方法，并用上面的容器进行保存。辣么，上面提到的 checkAdd() 方法是怎么检查的呢？ 123456789101112131415161718boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123; // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required. // Usually a subscriber doesn&apos;t have methods listening to the same event type. Object existing = anyMethodByEventType.put(eventType, method); if (existing == null) &#123; return true; &#125; else &#123; if (existing instanceof Method) &#123; if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123; // Paranoia check throw new IllegalStateException(); &#125; // Put any non-Method object to &quot;consume&quot; the existing Method anyMethodByEventType.put(eventType, this); &#125; return checkAddWithMethodSignature(method, eventType); &#125; &#125; &emsp;&emsp;这个注释写的很清楚，两层检验，第一层是检测事件类型，第二次检验则是检验判断方法的完整，首先以eventType为键，方法为值，存到map中（这个map是在FindState类初始化的），put方法会有一个返回值，返回value，这个value是这个key对应的上一个值，所以说，如果是第一次存放，那么就会返回null。否则，之前存放过，辣么就会进入下一个判断 checkAddWithMethodSignature 1234567891011121314151617private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append(&apos;&gt;&apos;).append(eventType.getName()); String methodKey = methodKeyBuilder.toString(); Class&lt;?&gt; methodClass = method.getDeclaringClass(); Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy subscriberClassByMethodKey.put(methodKey, methodClassOld); return false; &#125; &#125; &emsp;&emsp;这个方法就是用来判断方法签名是否相同的，方法签名是什么呢？就是修饰符+返回类型+方法名+参数list是否相同。如果方法签名相同，辣么，就把旧值赋值给methodClassOld，判断这个值不是为null，第一次调用，没有旧值，就肯定为null，所以，if前面的一个条件是满足的，后面一个条件methodClassOld.isAssignableFrom(methodClass) 的意思是判断旧值是否是methodClass或者同一个类，如果两个条件都不满足，辣么当前方法就不会添加为订阅方法。 &emsp;&emsp;那么，说了一大堆关于checkAdd和checkAddWithMethodSignature方法的源码，那么这两个方法到底有什么作用呢？从这两个方法的逻辑来看，第一层判断根据eventType来判断是否有多个方法订阅该事件，而第二层判断根据完整的方法签名(包括方法名字以及参数名字)来判断。下面是笔者的理解： &emsp;&emsp;第一种情况：比如一个类有多个订阅方法，方法名不同，但它们的参数类型都是相同的(虽然一般不这样写，但不排除这样的可能)，那么遍历这些方法的时候，会多次调用到checkAdd方法，由于existing不为null，那么会进而调用checkAddWithMethodSignature方法，但是由于每个方法的名字都不同，因此methodClassOld会一直为null，因此都会返回true。也就是说，允许一个类有多个参数相同的订阅方法。 &emsp;&emsp;第二种情况：类B继承自类A，而每个类都是有相同订阅方法，换句话说，类B的订阅方法继承并重写自类A，它们都有着一样的方法签名。方法的遍历会从子类开始，即B类，在checkAddWithMethodSignature方法中，methodClassOld为null，那么B类的订阅方法会被添加到列表中。接着，向上找到类A的订阅方法，由于methodClassOld不为null而且显然类B不是类A的父类，methodClassOld.isAssignableFrom(methodClass)也会返回false，那么会返回false。也就是说，子类继承并重写了父类的订阅方法，那么只会把子类的订阅方法添加到订阅者列表，父类的方法会忽略。 &emsp;&emsp;让我们回到findUsingReflectionInSingleClass方法，当遍历完当前类的所有方法后，会回到findUsingInfo方法，接着会执行最后一行代码，即return getMethodsAndRelease(findState);那么我们继续 getMethodsAndRelease 123456789101112131415private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123; //从findState获取subscriberMethods，放进新的ArrayList List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); //把findState回收 findState.recycle(); synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; if (FIND_STATE_POOL[i] == null) &#123; FIND_STATE_POOL[i] = findState; break; &#125; &#125; &#125; return subscriberMethods; &#125; 通过该方法，把subscriberMethods不断逐层返回，直到返回EventBus#register()方法，最后开始遍历每一个订阅方法，并调用subscribe(subscriber, subscriberMethod)方法，那么，我们继续来看subscribe方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Must be called in synchronized block private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; //将subscriber和subscriberMethod封装成 Subscription Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //根据事件类型获取特定的 Subscription CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); //如果为null，说明该subscriber尚未注册该事件 if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; //如果不为null，并且包含了这个subscription 那么说明该subscriber已经注册了该事件，抛出异常 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125; //根据优先级来设置放进subscriptions的位置，优先级高的会先被通知 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; //根据subscriber(订阅者)来获取它的所有订阅事件 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); //下面是对粘性事件的处理 if (subscriberMethod.sticky) &#123; //从EventBusBuilder可知，eventInheritance默认为true if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; //根据eventType，从stickyEvents列表中获取特定的事件 Object stickyEvent = stickyEvents.get(eventType); //分发事件 checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; 到目前为止，注册流程基本分析完毕，丢一张流程图]]></content>
      <categories>
        <category>Android -源码解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（Design Patterns）（三）]]></title>
    <url>%2F2018%2F03%2F07%2FJava-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[十三、策略模式顾名思义:不同的策略，对应我们项目中用到的地方就是，同一个功能，不同的实现方法。就比方说登录功能：我们有帐号密码登录，QQ第三方登录，微信第三方登录等等。其实我个人认为最典型的就是：同一个接口方法，不同的实现方式。 12345678910111213141516171819interface LoginInterface&#123; void login();&#125;public class PhoneLogin implements LoginInterface&#123; @Override public void login()&#123; //具体的逻辑 Log.v(&quot;wz&quot;,&quot;帐号密码登录&quot;) &#125;&#125;public class QqLogin implements LoginInterface&#123; @Override public void login()&#123; //具体的逻辑 Log.v(&quot;wz&quot;,&quot;QQ第三方登录&quot;) &#125;&#125; 就像上面这样，同一个登录功能，不同的实现。 十四、责任链模式责任链模式，我项目里面用的比较少，但是我知道一个android里面绝对常用的东西用的是责任连模式，那就是——andoid事件分发 十五、状态模式状态模式，我项目里面用的比较少，但是我知道的是游戏里面用的很多。就是那种存档功能，遇到自己感觉过不去的地方，把当前进度存起来，过不去了之后，死了，游戏结束了，再读当前的存档。 PS：其他的设计模式等用到了再补充]]></content>
      <categories>
        <category>Android -设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（Design Patterns）（二）]]></title>
    <url>%2F2018%2F03%2F07%2FJava-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[六、适配器模式分类有三种：类的适配器模式，对象的适配器模式，接口的适配器模式，我印象最深刻的是接口适配器模式 接口适配器模式 &emsp;&emsp;有的时候，我们写的一个接口，会有很多种方法。而，我们的实现类只需要实现某一种，或者某几种，所以，我们这里会借助一个抽象类，去实现接口的所有方法。我们的具体实现类跟这个抽象类去打交道，而不是跟原始的接口去打交道。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123; private BaseView baseView; private boolean showLoading; public MySubscriber(BaseView baseView) &#123; this.baseView = baseView; &#125; public MySubscriber(BaseView baseView, boolean showLoading) &#123; this.baseView = baseView; this.showLoading = showLoading; &#125; @Override protected void onStart() &#123; super.onStart(); if (null != baseView &amp;&amp; showLoading) &#123; baseView.showLoading(); &#125; &#125; @Override public void onError(Throwable t) &#123; if (null == baseView) &#123; return; &#125; baseView.hideLoading(); if (t instanceof ApiException) &#123; ApiException apiException = (ApiException) t; switch (apiException.getCode()) &#123; case HttpCode.NO_PARAMETER: baseView.showTipMsg(&quot;参数为空&quot;); break; case HttpCode.SERVER_ERR: baseView.showTipMsg(&quot;服务器错误&quot;); break; default: break; &#125; &#125; &#125; @Override public void onComplete() &#123; if (null != baseView) &#123; baseView.hideLoading(); &#125; &#125;&#125;addSubscribe(helper.selectBrandList() .compose(RxUtil.handleHttp()) .subscribeWith(new MySubscriber&lt;List&lt;String&gt;&gt;(baseView, true) &#123; @Override public void onNext(List&lt;String&gt; dataList) &#123; Log.v(&quot;wz&quot;,&quot;111&quot;) &#125; &#125;)); &emsp;&emsp;上面这个代码，就是我之前写的从零开始搭建一个主流项目框架系列里面的网络请求，处理返回结果的回调方法，我的返回结果，不可能每个去实现onStart，onError，onNext，onCompleted方法。我的实现类只用去继承这个类，实现某一个，或者某几个方法。更直接的就是，我之前写的框架，BaseActivity，实现BaseView接口，然后，我其他的Activity去继承BaseActivity，选择实现BaseView的方法。 如果上面这样，你还无法认同，那我们看看下面这个： 12345678910//success动画结束监听 successAnim.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); if (null != myAnimotionInterface) &#123; myAnimotionInterface.AnimationEnd(); &#125; &#125; &#125;); 动画监听，我这里只想监听动画结束，在动画结束的时候，我做我的逻辑处理，但是，他的接口有开始，结束，暂停，重复等等监听，我不要这么，你们可以点 AnimatorListenerAdapter() 这个类，去看一下他是什么，他就是一个抽象类，实现了动画监听的那个接口，这个是官方封装好的一个类。 七、装饰器模式这个模式就是我之前写从零开始搭建一个主流项目框架系列里面网络请求，SP的操作，Socket的操作，关于他们的封装都是用的装饰者模式。说的官方一点：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。项目中的应用就是： 12345678910111213141516/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public interface HttpHelper &#123; Flowable&lt;WeatherBean&gt; getWeather(String city); /** * 登录时获取验证码. * * @param phone 手机号 * @return &#123;&quot;code&quot;:0&#125; */ Flowable&lt;HttpNoResult&gt; loginCode(String phone); &#125; &emsp;&emsp;这个就是装饰对象和被装饰对象实现的同一个接口，他们一开始就只有一个功能，那就是获取天气，后来他们又新加了一个功能，必须登录之后才能获取天气，那就多了一个登录功能 12345678910111213141516171819202122232425262728293031323334/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public class DataHelper implements HttpHelper, PreferencesHelper, SqlHelper &#123; private SqlHelper sqlHelper; private HttpHelper httpHelper; private PreferencesHelper preferencesHelper; /** * 初始化数据帮助类. * * @param sqlHelper &#123;@link SqlHelper&#125; * @param httpHelper &#123;@link HttpHelper&#125; * @param preferencesHelper &#123;@link PreferencesHelper&#125; */ public DataHelper(SqlHelper sqlHelper, HttpHelper httpHelper, PreferencesHelper preferencesHelper) &#123; this.sqlHelper = sqlHelper; this.httpHelper = httpHelper; this.preferencesHelper = preferencesHelper; &#125; @Override public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123; return httpHelper.getWeather(city); &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return httpHelper.loginCode(phone); &#125;&#125; &emsp;&emsp;这个就是装饰类，负责调用接口的方法 12345678910111213141516171819202122232425/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public class RetrofitHttp implements HttpHelper &#123; private WardrobeApi wardrobeApi; private WeatherApi weatherApi; @Inject RetrofitHttp(WardrobeApi wardrobeApi, WeatherApi weatherApi) &#123; this.wardrobeApi = wardrobeApi; this.weatherApi = weatherApi; &#125; @Override public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123; return weatherApi.getWeather(city, &quot;c41d9ca568d449e2802244d8eeb3d3c6&quot;); &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return wardrobeApi.loginCode(phone); &#125;&#125; &emsp;&emsp;这个就是被装饰类，负责具体的实现，这里是retrofit网络请求。以上都是伪代码。具体就是为了说明这个装饰者模式的中心思想，以及我在项目中的运用，不保证一定完全正确，都是按照自己的理解写的。 PS：其他的设计模式等用到了再补充]]></content>
      <categories>
        <category>Android -设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（Design Patterns）（一）]]></title>
    <url>%2F2018%2F03%2F06%2FJava-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[设计模式的分类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 我只讲我用的多的，用的多的印象深刻，知道怎么讲，用的少的，不知道怎么讲。只讲我熟练的。 一、单例模式单例模式，我想应该做过开发的人都用过。 懒汉式（用的时候初始化，延迟加载）12345678910public class MySocket&#123; private static MySocket instance; private MySocket()&#123;&#125; public static synchronized MySocket getInstance()&#123; if(null == instance)&#123; instance = new MySocket(); &#125; return instance; &#125;&#125; &emsp;&emsp;这里在懒汉式的单例模式中加上了同步锁synchronized，所以，这是线程安全的，但是，也是因为锁，所以造成的效率低，可以根据不同实际情况判断是否需要加同步锁。 饿汉式（加载类的时候直接初始化）1234567public class MySocket&#123; private static MySocket instance = new MySocket(); private MySocket()&#123;&#125; public static MySocket getInstance()&#123; return instance; &#125;&#125; 双重校验锁1234567891011121314public class MySocket&#123; private static MySocket instance; private MySocket()&#123;&#125; public static MySocket getInstance()&#123; if(null == instance)&#123; synchronized(MySocket.class)&#123; if(null == instance)&#123; instance = new MySocket(); &#125; &#125; &#125; return instance; &#125;&#125; &emsp;&emsp;这里的双重校验锁，其实就是我这里的线程安全懒汉式的升级版本，双重校验锁很多开源框架都是用的这种单例，比方说：EventBus。关于单例模式的其他变种我就不说了。单例模式的最终目的，就是全局单例，一个项目不论哪里调用这个类都是引用的同一个对象。 二、工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public class FragmentFactory &#123; public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz) &#123; return createFragment(clz, null); &#125; public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz, Bundle bundle) &#123; if (HomeFragment.class == clz) &#123; return new HomeFragment(); &#125; else if (MyClothesFragment.class == clz) &#123; return new MyClothesFragment(); &#125; else if (WardrobeStructureFragment.class == clz) &#123; return new WardrobeStructureFragment(); &#125; else if (WifiFragment.class == clz) &#123; return new WifiFragment(); &#125; else if (WardrobeConfigFragment.class == clz) &#123; return new WardrobeConfigFragment(); &#125; else if (ShowFragment.class == clz) &#123; return new ShowFragment(); &#125; else &#123; throw new NullPointerException(&quot;not found fragment&quot;); &#125; &#125; public static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz) &#123; return createDialogFragment(clz, null); &#125; @SuppressWarnings(&quot;unchecked&quot;) private static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz, Bundle bundle) &#123; if (clz == IconDialogFragment.class) &#123; return (T) new IconDialogFragment(); &#125; else if (clz == PasswordDialogFragment.class) &#123; return (T) PasswordDialogFragment.newInstance(); &#125; else &#123; throw new NullPointerException(&quot;not found fragment&quot;); &#125; &#125;&#125; &emsp;&emsp;这个fragment工厂类，就是我项目里面用到的。常用的工厂模式就是静态工厂，利用static方法，我这里的工厂就是静态工厂。我们常说的工厂方法对应的这里是什么呢？其实，工厂方法也是一个普通的方法，对应的这里就是createFragment(Class&lt;? extends BaseFragment&gt; clz)。工厂模式什么时候用呢？在需要大量类似的数据的时候（个人观点），Android里面，工厂方法用的最多的就是创建Fragment。 三、抽象工厂模式1234567891011121314151617public interface IFragmentFactory&#123; BaseFragment createFragment();&#125;public class HomeFactory implements IFragmentFactory&#123; @Override public BaseFragment createFragment()&#123; return new HomeFragment(); &#125;&#125;public class WifiFragment implements IFragmentFactory&#123; @Override public BaseFragment createFragment()&#123; return new WifiFragment(); &#125;&#125; &emsp;&emsp;我把上面的静态工厂类，改成了抽象工厂类，就是上面的代码。就是有一个工厂接口或者抽象的工厂类，然后创建不同的工厂类去实现这个接口，实现对应的类，返回你需要的东西 四、建造者模式我之前写Luban源码解析的时候就讲过建造者模式，可以去看一下，就在源码解析的一开始 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.haichenyi.mytakephoto;/** * Author: 海晨忆 * Date: 2018/3/6 * Desc: */public class DataBean &#123; private String name; private int age; private String sex; public DataBean(Builder builder) &#123; this.name = builder.name; this.age = builder.age; this.sex = builder.sex; &#125; public static class Builder &#123; private String name; private int age = 20; private String sex = &quot;男&quot;; public Builder setName(String name) &#123; this.name = name; return this; &#125; public Builder setAge(int age) &#123; this.age = age; return this; &#125; public Builder setSex(String sex) &#123; this.sex = sex; return this; &#125; public DataBean build() &#123; return new DataBean(this); &#125; &#125;&#125; &emsp;&emsp;上面的代码就是一个DataBean类，用建造者模式创建。要是还是不懂，你可以理解成，我们常常在写bean类的时候，往往要写set方法，你可以理解成，把set方法写在Builder里面，在Builder里面赋好值之后，在我们bean类的构造方法里面传递过来就可以了。 五、原型模式这个模式，我没用到过，网上搜的是，类似于拷贝功能。可以自行搜索。]]></content>
      <categories>
        <category>Android -设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2F2018%2F03%2F06%2FJava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;在运行过程中，对任意一个类，都能知道这个类的所有属性和方法。对于任一个对象，都能调用他的任意一个方法和属性。这种动态获取信息以及动态调用对象的方法称为java语言的反射机制 用法我这里就列出我常用的两个方法私有类和变量 方法Methods 方法 用途 getDeclaredMethods() 获取当前类的所有方法，包括public/private/protected/default修饰的方法 getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取当前类的某一个方法,包括public/private/protected/default修饰的方法 getMethods() 获取当前类和所继承父类的public标识的所有方法，仅仅包括public getMethod(String name, Class&lt;?&gt;… parameterTypes) 获取当前类和所继承父类的public标识的某一个方法，仅仅包括public &emsp;&emsp;上面就是两个类型的方法，一个是只获取当前类的方法，获取当前类的方法，包括所有类型的方法：public/private/protected/default。还有一个是获取当前类和所继承的父类的方法，仅仅包括public修饰的方法。 调用方式1234567//在TakePhotoActivity.class类中有两个重载方法，一个无参，一个有一个String类型的参数private void myTest()&#123; Log.v(&quot;WZ&quot;,&quot;myTest无参&quot;); &#125;private void myTest(String msg)&#123; Log.v(&quot;WZ&quot;,&quot;myTest有参&quot;); &#125; 调用无参的方法1234567891011TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象try &#123;Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象Method myTest = aClass1.getDeclaredMethod(&quot;myTest&quot;);myTest.setAccessible(true);//参数值为true，禁止访问控制检查myTest.invoke(takePhotoActivity);//执行私有方法&#125; catch (Exception e) &#123; e.printStackTrace(); Log.v(&quot;WZ&quot;, e.getMessage()); &#125; 调用有参的方法123456789101112TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象Class[] arr = new Class[]&#123;String.class&#125;;try &#123;Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象Method myTest = aClass1.getDeclaredMethod(&quot;myTest&quot;,arr);myTest.setAccessible(true);//参数值为true，禁止访问控制检查myTest.invoke(takePhotoActivity,&quot;s&quot;);//执行私有方法&#125; catch (Exception e) &#123; e.printStackTrace(); Log.v(&quot;WZ&quot;, e.getMessage()); &#125; 有参的方法，在获取方法的时候，传一个Class[]数组，里面的值就是参数类型的类。或者还有另一种传的方法，前面获取方法的时候： 获取方法的时候，无参的传一个空的Class[]，有参就传有值的Class[]数组 执行方法的时候，无参的传一个空的Object[]，有参就传有值的Object[]数组,至于传的值随便写，类型一样就行 变量Field 方法 用途 getDeclaredFields() 获取当前类的所有类型的全局变量,包括public/private/protected/default修饰的变量 getDeclaredField(String name) 获取当前类的某一个类型的全局变量,包括public/private/protected/default修饰的变量 getFields() 获取当前类和继承父类的所有用public修饰的变量 getField(String name) 获取当前类和继承父类的某一个用public修饰的变量 调用方式12//在TakePhotoActivity里面定义private int flag; 获取变量123456789101112TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象try &#123;Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象Field flag = aClass.getDeclaredField(&quot;flag&quot;);flag.setAccessible(true);Object o = flag.get(takePhotoActivity);//这里就获取到了对象...//做你自己的逻辑处理&#125; catch (Exception e) &#123; e.printStackTrace(); Log.v(&quot;WZ&quot;, e.getMessage()); &#125; 设置变量的值12//获取变量的值跟上面一样flag.set(takePhotoActivity,10);//这样写会改变TakePhotoActivity中flag的值 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * Author: 海晨忆. * Date: 2018/3/6 * Desc: 反射工具类 */public class ReflectionUtil &#123; /*** * 获取私有成员变量的值 * */ public static Object getValue(Object instance, String fieldName) throws IllegalAccessException, NoSuchFieldException &#123; Field field = instance.getClass().getDeclaredField(fieldName); field.setAccessible(true); // 参数值为true，禁止访问控制检查 return field.get(instance); &#125; /*** * 设置私有成员变量的值 * */ public static void setValue(Object instance, String fileName, Object value) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123; Field field = instance.getClass().getDeclaredField(fileName); field.setAccessible(true); field.set(instance, value); &#125; /*** * 访问私有方法 * */ public static Object callMethod(Object instance, String methodName, Class[] classes, Object[] objects) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; Method method = instance.getClass().getDeclaredMethod(methodName, classes); method.setAccessible(true); return method.invoke(instance, objects); &#125;&#125;]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EventBus源码解析(一)——获取EventBus对象]]></title>
    <url>%2F2018%2F03%2F06%2FEventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96EventBus%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[简介我们先来看一下他的类注释 12345678910/** * EventBus is a central publish/subscribe event system for Android. Events are posted (&#123;@link #post(Object)&#125;) to the * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events, * subscribers must register themselves to the bus using &#123;@link #register(Object)&#125;. Once registered, subscribers * receive events until &#123;@link #unregister(Object)&#125; is called. Event handling methods must be annotated by * &#123;@link Subscribe&#125;, must be public, return nothing (void), and have exactly one parameter * (the event). * * @author Markus Junginger, greenrobot */ &emsp;&emsp;英语不是很好，大致讲一下这段话是什么意思：EventBus是重要的发布/订阅的Android事件系统。事件被发布给总线，这个总线将这个事件传递给跟他匹配类型的订阅者。接收事件必须在总线使用的时候注册他们。一旦注册，订阅者就会一直接收事件，直到他们被取消注册。这个接收方法必须增加注解Subscribe标识，必须是public，返回类型是void，并且只有一个参数。 简单的来说，就是用之前必须先注册，然后接收方法必须有Subscribe注解，必须是public，返回类型是void并且只有一个参数 简单用法第一步：依赖1implementation &apos;org.greenrobot:eventbus:3.1.1&apos; 第二步：注册与反注册1234//注册，在onCrate里面EventBus.getDefault().register(this)//反注册，在onDestory里面EventBus.getDefault().unregister(this) 第三步：接收方法1234@Subscribepublic void handle(MyClothes myClothes)&#123; //你的具体逻辑&#125; 第四步：发送1EventBus.getDefault().post(new MyClothes()) &emsp;&emsp;经过上面三步，你就可以正常使用EventBus了，前面两步要在一个类里面，因为接收之前，必须要注册，可以在任意的地方post 源码解析—getDefault()12345678910public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; &emsp;&emsp;可以看到这里使用的是双重校验锁的单例模式，保证不同的线程调用该方法得到的都是同一个EventBus实例。 EventBus()看到上面的单例模式之后，我们再来瞅瞅单例模式里面调用的构造方法 123public EventBus() &#123; this(DEFAULT_BUILDER); &#125; 这里他的空参数的构造方法里面调用的是一个参数的构造方法，我们来看看这个参数是什么？ 1private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder(); EventBusBuilder()12EventBusBuilder() &#123; &#125; 这个builder的构造方法里面什么都没有，也就是说没有初始化任何变量，那我们看一看他的变量，这里我就说一个： 123private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE; Executors.newCachedThreadPool() 创建的是一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空线程池，若无回收，可新建线程。 接下来，我们再来看看只有EventBusBuilder参数的构造方法 EventBus(EventBusBuilder builder)123456789EventBus(EventBusBuilder builder) &#123; subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null; backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); ... &#125; &emsp;&emsp;讲到这里，很明显，他这里用的是建造者模式，跟我们之前讲的Luban的模式是一样的，这个建造者模式，我就不讲了。讲Luban的时候讲过的 &emsp;&emsp;这里我列出来的6个变量，其他变量并没有列出来，因为，其他变量都是builder里面的赋值，没有啥好讲的。我们来看看这6个成员变量的类型 123456private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;private final Poster mainThreadPoster;private final BackgroundPoster backgroundPoster;private final AsyncPoster asyncPoster; 意义： subscriptionsByEventType：可以看到这是一个是以event的class为key，以subscribe的list为value的map，有的人可能不知道CopyOnWriteArrayList，这是ArrayList的一个线程安全变种。（这里，有人会点到Subscription里面去看一下，可以看到就是一个类，封装了订阅者和订阅方法，重写了hashcode和equal方法） typesBySubscriber：这是以订阅者类为key，以event的list为value的map，在注册和反注册的时候用的到 stickyEvents：粘性事件，以event的class为key，订阅者为value的map 后面这三个Poster都是用来处理粘性事件的 &emsp;&emsp;我们说了这么多成员变量。我们知道这里的EventBusBuilder就是给EventBus初始化成员变量的，辣么，我们可不可以不用getDefault，获取eventBus对象呢？ 123EventBus build1 = EventBus.getDefault();EventBus build2 = EventBus.builder().build(); 这两个build的区别是什么呢？我们可以点到build()方法里面去看一下： 123public EventBus build() &#123; return new EventBus(this); &#125; 他这里是直接new出来的，并没有单例，所以每次使用的都是new一个新的对象，而通过getDefault，获得是同一个对象]]></content>
      <categories>
        <category>Android -源码解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android二维码扫描——BGAQRCode-Android]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E2%80%94%E2%80%94BGAQRCode-Android%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;做过二维码扫描的童鞋都知道，要用Zxing，可是google官方推的Zxing，我们集成扫描的时候很慢，有时候就直接扫不出来，体验太差了。因为他适配了太多东西，我们只要一个扫描功能，然后就去网上搜索，怎么使zxing扫描变的很快，zxing的优化，然后跟着网上的博客，一步一步走，即使最终做完了，感觉体验还是不够好。我这里推荐一个二维码扫描的开源框架——BGAQRCode-Android &emsp;&emsp;QRCode 扫描二维码、扫描条形码、相册获取图片后识别、生成带 Logo 二维码、支持微博微信、QQ 二维码扫描样式。他把Zbar和Zxing，都做了优化，扫描速度非常快，用户体验很好，用起来也非常方便 依赖123implementation &apos;cn.bingoogolapple:bga-qrcode-zbar:1.2.1&apos;或者implementation &apos;cn.bingoogolapple:bga-qrcode-zxing:1.2.1&apos; 用法以Zbar为例（Zxing类似） 第一步：XML文件1234567891011121314&lt;cn.bingoogolapple.qrcode.zbar.ZBarView android:id=&quot;@+id/zbarview&quot; style=&quot;@style/MatchMatch&quot; app:qrcv_animTime=&quot;1000&quot; app:qrcv_borderColor=&quot;@android:color/white&quot; app:qrcv_borderSize=&quot;1dp&quot; app:qrcv_cornerColor=&quot;@color/colorPrimaryDark&quot; app:qrcv_cornerLength=&quot;20dp&quot; app:qrcv_cornerSize=&quot;3dp&quot; app:qrcv_isShowDefaultScanLineDrawable=&quot;true&quot; app:qrcv_maskColor=&quot;#33FFFFFF&quot; app:qrcv_rectWidth=&quot;200dp&quot; app:qrcv_scanLineColor=&quot;@color/colorPrimaryDark&quot; app:qrcv_topOffset=&quot;90dp&quot; /&gt; 自定义属性说明 属性名 说明 默认值 qrcv_topOffset 扫描框距离 toolbar 底部的距离 90dp qrcv_cornerSize 扫描框边角线的宽度 3dp qrcv_cornerLength 扫描框边角线的长度 20dp qrcv_cornerColor 扫描框边角线的颜色 @android:color/white qrcv_rectWidth 扫描框的宽度 200dp qrcv_barcodeRectHeight 条码扫样式描框的高度 140dp qrcv_maskColor 除去扫描框，其余部分阴影颜色 #33FFFFFF qrcv_scanLineSize 扫描线的宽度 1dp qrcv_scanLineColor 扫描线的颜色「扫描线和默认的扫描线图片的颜色」 @android:color/white qrcv_scanLineMargin 扫描线距离上下或者左右边框的间距 0dp qrcv_isShowDefaultScanLineDrawable 是否显示默认的图片扫描线「设置该属性后 qrcv_scanLineSize 将失效，可以通过 qrcv_scanLineColor 设置扫描线的颜色，避免让你公司的UI单独给你出特定颜色的扫描线图片」 false qrcv_customScanLineDrawable 扫描线的图片资源「默认的扫描线图片样式不能满足你的需求时使用，设置该属性后 qrcv_isShowDefaultScanLineDrawable、qrcv_scanLineSize、qrcv_scanLineColor 将失效」 null qrcv_borderSize 扫描边框的宽度 1dp qrcv_borderColor 扫描边框的颜色 @android:color/white qrcv_animTime 扫描线从顶部移动到底部的动画时间「单位为毫秒」 1000 qrcv_isCenterVertical 扫描框是否垂直居中，该属性为true时会忽略 qrcv_topOffset 属性 false qrcv_toolbarHeight Toolbar 的高度，通过该属性来修正由 Toolbar 导致扫描框在垂直方向上的偏差 0dp qrcv_isBarcode 是否是扫条形码 false qrcv_tipText 提示文案 null qrcv_tipTextSize 提示文案字体大小 14sp qrcv_tipTextColor 提示文案颜色 @android:color/white qrcv_isTipTextBelowRect 提示文案是否在扫描框的底部 false qrcv_tipTextMargin 提示文案与扫描框之间的间距 20dp qrcv_isShowTipTextAsSingleLine 是否把提示文案作为单行显示 false qrcv_isShowTipBackground 是否显示提示文案的背景 false qrcv_tipBackgroundColor 提示文案的背景色 #22000000 qrcv_isScanLineReverse 扫描线是否来回移动 true qrcv_isShowDefaultGridScanLineDrawable 是否显示默认的网格图片扫描线 false qrcv_customGridScanLineDrawable 扫描线的网格图片资源 null qrcv_isOnlyDecodeScanBoxArea 是否只识别扫描框区域的二维码 false 第二步：获取控件，并实现QRCodeView.Delegate接口123456789101112131415QRCodeView mQRCodeView = (ZBarView) findViewById(R.id.zbarview);mQRCodeView.setDelegate(this);@Override public void onScanQRCodeSuccess(String result) &#123; vibrate(); Toast.makeText(this,result,Toast.LENGTH_SHORT).show(); mQRCodeView.startSpot(); &#125; @Override public void onScanQRCodeOpenCameraError() &#123; Toast.makeText(this,&quot;错误&quot;,Toast.LENGTH_SHORT).show(); &#125; 第四步：实现onStart，onStop，onDestroy方法1234567891011121314151617181920212223242526@Override protected void onStart() &#123; super.onStart(); mQRCodeView.startCamera();//打开相机 mQRCodeView.showScanRect();//显示扫描框 mQRCodeView.startSpot();//开始识别二维码 //mQRCodeView.openFlashlight();//开灯 //mQRCodeView.closeFlashlight();//关灯 &#125; @Override protected void onStop() &#123; mQRCodeView.stopCamera(); super.onStop(); &#125; @Override protected void onDestroy() &#123; mQRCodeView.onDestroy(); super.onDestroy(); &#125; private void vibrate() &#123; Vibrator vibrator = (Vibrator) getSystemService(VIBRATOR_SERVICE); vibrator.vibrate(200); &#125; 第五步：添加权限12&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt; 经过上面5步，扫描功能就已经出来了，Zbar扫描比Zxing快，Zbar是基于C实现的，Zxing是基于C++。有个问题就是Zbar无法生成二维码，如果你是集成的BGA的Zxing可以生成二维码。Zxing生成二维码的方式如下： 耗时操作，新开线程 123456//中文Bitmap bitmap = QRCodeEncoder.syncEncodeQRCode(&quot;海晨忆&quot;, BGAQRCodeUtil.dp2px(this, 150));//带logoBitmap logoBitmap = BitmapFactory.decodeResource(TestGeneratectivity.this.getResources(), R.mipmap.logo);QRCodeEncoder.syncEncodeQRCode(&quot;海晨忆&quot;, BGAQRCodeUtil.dp2px(TestGeneratectivity.this, 150), Color.parseColor(&quot;#ff0000&quot;), logoBitmap); 解析图片二维码 1234567//mEnglishLogoIv：显示二维码的控件mEnglishLogoIv.setDrawingCacheEnabled(true);Bitmap bitmap = mEnglishLogoIv.getDrawingCache();//返回二维码图片里的内容 或 nullString result = QRCodeDecoder.syncDecodeQRCode(bitmap);String result = QRCodeDecoder.syncDecodeQRCode(picturePath);]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android WIFI功能——WifiManager]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid-WIFI%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94WifiManager%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前做了关于Android wifi的相关功能，这里做一个记录 第一步：获取WifiManager1WifiManager wifiMgr = (WifiManager)Context.getSystemService(Context.WIFI_SERVICE); 第二步：获取周围热点信息和已连接wifi信息12List&lt;ScanResult&gt; scanResults = wifiMgr.getScanResults();//扫描到的周围热点信息WifiInfo info = wifiMgr.getConnectionInfo();//已连接wifi信息 这里我说一下几个字段的意思： 1234public String name;//ssid对应的wifi名字public String capabilities;//用来判断是否有密码public int level;//信号等级，这里是负数public String BSSID;//macid 这里我需要强调的就是level，是负数，负数越大，信号越好 第三步：检测wifi信息，这里我给出几个工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 连接有密码的wifi. * * @param SSID ssid * @param Password Password * @return apConfig */ private WifiConfiguration setWifiParamsPassword(String SSID, String Password) &#123; WifiConfiguration apConfig = new WifiConfiguration(); apConfig.SSID = &quot;\&quot;&quot; + SSID + &quot;\&quot;&quot;; apConfig.preSharedKey = &quot;\&quot;&quot; + Password + &quot;\&quot;&quot;; //不广播其SSID的网络 apConfig.hiddenSSID = true; apConfig.status = WifiConfiguration.Status.ENABLED; //公认的IEEE 802.11验证算法。 apConfig.allowedAuthAlgorithms.clear(); apConfig.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN); //公认的的公共组密码 apConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP); apConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP); //公认的密钥管理方案 apConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK); //密码为WPA。 apConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP); apConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP); //公认的安全协议。 apConfig.allowedProtocols.set(WifiConfiguration.Protocol.RSN); return apConfig; &#125; /** * 连接没有密码wifi. * * @param ssid ssid * @return configuration */ private WifiConfiguration setWifiParamsNoPassword(String ssid) &#123; WifiConfiguration configuration = new WifiConfiguration(); configuration.SSID = &quot;\&quot;&quot; + ssid + &quot;\&quot;&quot;; configuration.status = WifiConfiguration.Status.ENABLED; configuration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP); configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK); configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE); configuration.allowedPairwiseCiphers .set(WifiConfiguration.PairwiseCipher.TKIP); configuration.allowedPairwiseCiphers .set(WifiConfiguration.PairwiseCipher.CCMP); configuration.allowedProtocols.set(WifiConfiguration.Protocol.RSN); return configuration; &#125; public static final int WIFI_NO_PASS = 0; private static final int WIFI_WEP = 1; private static final int WIFI_PSK = 2; private static final int WIFI_EAP = 3; /** * 判断是否有密码. * * @param result ScanResult * @return 0 */ public static int getSecurity(MyScanResult result) &#123; if (null != result &amp;&amp; null != result.capabilities) &#123; if (result.capabilities.contains(&quot;WEP&quot;)) &#123; return WIFI_WEP; &#125; else if (result.capabilities.contains(&quot;PSK&quot;)) &#123; return WIFI_PSK; &#125; else if (result.capabilities.contains(&quot;EAP&quot;)) &#123; return WIFI_EAP; &#125; &#125; return WIFI_NO_PASS; &#125; 上面三个工具类，一个用来判断是否需要密码，另外两个用来连接wifi 连接wifi123456//需要密码wifiMgr.enableNetwork(wifiMgr.addNetwork( setWifiParamsPassword(mClickResult.name, password)), true);//不需要密码wifiMgr.enableNetwork(wifiMgr.addNetwork(setWifiParamsNoPassword(mClickResult.name)), true); wifi监听PS：关于wifi状态的监听，就是监听你当前的网络状态即可。 12345678&lt;receiver android:name=&quot;.receiver.NetworkReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.net.wifi.WIFI_STATE_CHANGED&quot;/&gt; &lt;action android:name=&quot;android.net.wifi.STATE_CHANGE&quot;/&gt; &lt;action android:name=&quot;android.net.wifi.supplicant.STATE_CHANGE&quot;/&gt; &lt;action android:name=&quot;android.net.wifi.NETWORK_IDS_CHANGED&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 首先在你的清单文件注册这四种action的广播，这里给出我的网络监听广播 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * Author: 海晨忆. * Date: 2018/1/10 * Desc: 网络广播监听 */public class NetworkReceiver extends BroadcastReceiver &#123; public static final int STATE1 = 1;//密码错误 public static final int STATE2 = 2;//连接成功 public static final int STATE3 = 3;//连接失败 public static final int STATE4 = 4;//正在获取ip地址 public static final int STATE5 = 5;//正在连接 @Override public void onReceive(Context context, Intent intent) &#123; if (WifiManager.SUPPLICANT_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123; //密码错误广播,是不是正在获得IP地址 int linkWifiResult = intent.getIntExtra(WifiManager.EXTRA_SUPPLICANT_ERROR, -1); if (linkWifiResult == WifiManager.ERROR_AUTHENTICATING) &#123; //密码错误 ToastUtils.showTipMsg(R.string.password_wrong); sendNetworkStateChange(new NetWorkInfo().setState(STATE1)); &#125; SupplicantState supplicantState = intent.getParcelableExtra(WifiManager.EXTRA_NEW_STATE); NetworkInfo.DetailedState state = WifiInfo.getDetailedStateOf(supplicantState); Log.v(Constants.HTTP_WZ, state.name()); if (state == NetworkInfo.DetailedState.CONNECTING) &#123; //正在连接 ToastUtils.showTipMsg(R.string.linking); sendNetworkStateChange(new NetWorkInfo().setState(STATE5)); &#125; else if (state == NetworkInfo.DetailedState.FAILED || state == NetworkInfo.DetailedState.DISCONNECTING) &#123; //连接失败 sendNetworkStateChange(new NetWorkInfo().setState(STATE3)); ToastUtils.showTipMsg(R.string.linked_failed); &#125; else if (state == NetworkInfo.DetailedState.CONNECTED) &#123; //连接成功 ToastUtils.showTipMsg(R.string.linked_success); &#125; else if (state == NetworkInfo.DetailedState.OBTAINING_IPADDR) &#123; //正在获取ip地址 sendNetworkStateChange(new NetWorkInfo().setState(STATE4)); &#125; else if (state == NetworkInfo.DetailedState.IDLE) &#123; //闲置的 ConnectivityManager connectManager = (ConnectivityManager) BaseApplication.getInstance() .getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo activeNetworkInfo = null; if (connectManager != null) &#123; activeNetworkInfo = connectManager.getActiveNetworkInfo(); &#125; if (activeNetworkInfo == null) &#123; sendNetworkStateChange(new NetWorkInfo().setState(STATE3)); ToastUtils.showTipMsg(R.string.linked_failed); &#125; &#125; &#125; else if (WifiManager.WIFI_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123; // 监听wifi的打开与关闭，与wifi的连接无关 int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, 0); Log.v(Constants.HTTP_WZ, &quot;wifiState:&quot; + wifiState); switch (wifiState) &#123; case WifiManager.WIFI_STATE_DISABLING://正在停止0 ToastUtils.showTipMsg(R.string.close_wifi); break; case WifiManager.WIFI_STATE_DISABLED://已停止1 break; case WifiManager.WIFI_STATE_UNKNOWN://未知4 break; case WifiManager.WIFI_STATE_ENABLING://正在打开2 ToastUtils.showTipMsg(R.string.opening_wifi); break; case WifiManager.WIFI_STATE_ENABLED://已开启3 break; default: break; &#125; &#125; else if (WifiManager.NETWORK_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123; // 监听wifi的连接状态即是否连上了一个有效无线路由 Parcelable parcelableExtra = intent .getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO); if (null != parcelableExtra) &#123; // 获取联网状态的NetWorkInfo对象 NetworkInfo networkInfo = (NetworkInfo) parcelableExtra; //获取的State对象则代表着连接成功与否等状态 NetworkInfo.State state = networkInfo.getState(); //判断网络是否已经连接 boolean isConnected = state == NetworkInfo.State.CONNECTED; Log.v(Constants.HTTP_WZ, &quot;isConnected:&quot; + isConnected); if (isConnected) &#123; ToastUtils.showTipMsg(R.string.linked_success); sendNetworkStateChange(new NetWorkInfo().setState(STATE2)); &#125; &#125; &#125; &#125; /** * 发送网络状态eventBus. * * @param info info */ private void sendNetworkStateChange(NetWorkInfo info) &#123; EventBus.getDefault().post(info); &#125; @SuppressWarnings(&quot;unused&quot;) private String getConnectionType(int type) &#123; String connType = &quot;&quot;; if (type == ConnectivityManager.TYPE_MOBILE) &#123; connType = &quot;移动网络&quot;; &#125; else if (type == ConnectivityManager.TYPE_WIFI) &#123; connType = &quot;WIFI网络&quot;; &#125; return connType; &#125; public static class NetWorkInfo &#123; public int state;//1密码错误，2:连接成功，3:连接失败 private NetWorkInfo setState(int state) &#123; this.state = state; return this; &#125; &#125;&#125; 注释应该写的很清楚，我就不做过多的解释了。]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单的蓝牙通信]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%AE%80%E5%8D%95%E7%9A%84%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前公司做智能家居类型，其中做了一个智能衣柜项目，与衣柜通信就是用的蓝牙通信。一些操作一些简单的开关指令，蓝牙通信与socket是类似的。 步骤 清单文件注册权限 启动蓝牙服务（记得在清单文件中静态注册服务） 注册蓝牙广播（在蓝牙服务中动态注册蓝牙广播） 搜索，绑定，完成 退出app，停止服务，并在蓝牙服务的onDestory方法中取消注册蓝牙广播 不想写说明，只想贴代码 第一步：注册权限123&lt;!--获取蓝牙信息状态权限--&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 第二步、第三步、第五步：启动蓝牙服务，注册蓝牙广播，停止服务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Author: 海晨忆. * Date: 2018/1/4 * Desc: */public class BluetoothService extends Service &#123; //得到蓝牙适配器 private BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); private BluetoothReceiver mReceiver; @Override public void onCreate() &#123; super.onCreate(); EventBus.getDefault().register(this); if (mBluetoothAdapter != null) &#123; mReceiver = new BluetoothReceiver().setBluetoothAdapter(mBluetoothAdapter); //注册设备被发现时的广播 IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); registerReceiver(mReceiver, filter); //注册一个搜索结束时的广播 IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); registerReceiver(mReceiver, filter2); startLinkBluetooth(); &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; /** * 开始连接蓝牙设备. */ private void startLinkBluetooth() &#123; if (null != mBluetoothAdapter) &#123; //判断蓝牙是否打开 if (!mBluetoothAdapter.isEnabled()) &#123; //若没打开则打开蓝牙 mBluetoothAdapter.enable(); &#125; mBluetoothAdapter.startDiscovery(); Log.v(Constants.HTTP_WZ, &quot;正在扫描&quot;); &#125; &#125; @Subscribe @SuppressWarnings(&quot;unused&quot;) public void handleMsg(BluetoothInfo bluetoothInfo) &#123; if (bluetoothInfo.isLink) &#123; startLinkBluetooth(); &#125; &#125; public static class BluetoothInfo &#123; private boolean isLink = false; public BluetoothInfo setLink(boolean link) &#123; this.isLink = link; return this; &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); if (mReceiver != null) &#123; mReceiver.unRegister(); unregisterReceiver(mReceiver); &#125; &#125;&#125; 这个就是我的蓝牙服务类，这个类的逻辑怎么走的呢？ EventBus的东西我就不说了 首先获取蓝牙适配器 1BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); 初始化蓝牙广播，注册蓝牙广播 12345678910if (mBluetoothAdapter != null) &#123; mReceiver = new BluetoothReceiver().setBluetoothAdapter(mBluetoothAdapter); //注册设备被发现时的广播 IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); registerReceiver(mReceiver, filter); //注册一个搜索结束时的广播 IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); registerReceiver(mReceiver, filter2); startLinkBluetooth(); &#125; 开始准备连接蓝牙设备 1234567891011121314/** * 开始连接蓝牙设备. */ private void startLinkBluetooth() &#123; if (null != mBluetoothAdapter) &#123; //判断蓝牙是否打开 if (!mBluetoothAdapter.isEnabled()) &#123; //若没打开则打开蓝牙 mBluetoothAdapter.enable(); &#125; mBluetoothAdapter.startDiscovery(); Log.v(Constants.HTTP_WZ, &quot;正在扫描&quot;); &#125; &#125; 上面4步蓝牙扫描就完成了，这里我还要说的是，在服务的onDestory方法里面，记得停止服务 123456789@Override public void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); if (mReceiver != null) &#123; mReceiver.unRegister(); unregisterReceiver(mReceiver); &#125; &#125; 再就是在清单文件里面静态注册蓝牙服务 1&lt;service android:name=&quot;.service.BluetoothService&quot;/&gt; 启动服务的方式，我用的是非绑定的方式，同样，记得停止服务。 12Intent bluetoothService = new Intent(this, BluetoothService.class);startService(bluetoothService);//启动蓝牙服务 1stopService(bluetoothService); 123456@Nullable @Override public IBinder onBind(Intent intent) &#123; //非绑定方式，返回值为null return null; &#125; 第四步：搜索，绑定，完成搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * Author: 海晨忆. * Date: 2018/1/4 * Desc: 蓝牙广播监听 */public class BluetoothReceiver extends BroadcastReceiver &#123; //衣柜的蓝牙名称 private static final String WARDROBE_NAME = &quot;WARDROBE&quot;; // 固定的UUID private static final String SPP_UUID = &quot;00001101-0000-1000-8000-00805F9B34FB&quot;; private BluetoothSocket bluetoothSocket; private BluetoothAdapter bluetoothAdapter; private InputStream mInputStream; private OutputStream outputStream; private boolean isRunning = false; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (action != null) &#123; if (action.equals(BluetoothDevice.ACTION_FOUND)) &#123; BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); Log.v(Constants.HTTP_WZ, device.getName() + device.getAddress()); if (device.getBondState() == BluetoothDevice.BOND_BONDED &amp;&amp; device.getName().equals(WARDROBE_NAME)) &#123; UUID uuid = UUID.fromString(SPP_UUID); try &#123; bluetoothSocket = device.createRfcommSocketToServiceRecord(uuid); Log.v(Constants.HTTP_WZ, &quot;准备连接&quot;); connect(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; else if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) &#123; if (!EventBus.getDefault().isRegistered(this)) EventBus.getDefault().register(this); Observable.timer(2, TimeUnit.SECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe(aLong -&gt; &#123; if (null == bluetoothSocket || !bluetoothSocket.isConnected()) ToastUtils.showTipMsg(R.string.no_wardrobe); &#125;); &#125; &#125; &#125; private void connect() &#123; new Thread(() -&gt; &#123; if (bluetoothSocket != null) &#123; bluetoothAdapter.cancelDiscovery(); try &#123; bluetoothSocket.connect(); Observable.just(1) .observeOn(AndroidSchedulers.mainThread()) .subscribe(integer -&gt; ToastUtils.showTipMsg(R.string.link_wardrobe)); Log.v(Constants.HTTP_WZ, &quot;连接成功&quot;); mInputStream = bluetoothSocket.getInputStream(); Log.v(Constants.HTTP_WZ, &quot;mInputSream:&quot; + mInputStream.toString()); isRunning = true; outputStream = bluetoothSocket.getOutputStream(); Log.v(Constants.HTTP_WZ, &quot;outputStream:&quot; + outputStream.toString()); BufferedReader br; while (isRunning) &#123; br = new BufferedReader(new InputStreamReader(mInputStream, &quot;utf-8&quot;)); String s = br.readLine(); //acceptReply(s); Log.v(Constants.HTTP_WZ, &quot;收到的数据:&quot; + s); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); try &#123; if (mInputStream != null) &#123; mInputStream.close(); Log.v(Constants.HTTP_WZ, &quot;mInputSream.close()&quot;); &#125; if (outputStream != null) &#123; outputStream.close(); Log.v(Constants.HTTP_WZ, &quot;outputStream.close()&quot;); &#125; if (bluetoothSocket != null) &#123; bluetoothSocket.close(); Log.v(Constants.HTTP_WZ, &quot;socket.close()&quot;); bluetoothSocket = null; &#125; isRunning = false; &#125; catch (Exception e2) &#123; // TODO: handle exception &#125; &#125; &#125; &#125;).start(); &#125; public BluetoothReceiver setBluetoothAdapter(BluetoothAdapter adapter) &#123; this.bluetoothAdapter = adapter; return this; &#125; /** * 反注册eventBus. */ public void unRegister() &#123; EventBus.getDefault().unregister(this); &#125;&#125; 这个就是我的蓝牙广播类，这个逻辑又是怎么走的呢？ 前面服务里面注册的两个action，一个BluetoothDevice.ACTION_FOUND，还有一个BluetoothAdapter.ACTION_DISCOVERY_FINISHED，做了一个if判断，是发现了设备还是已经完成了扫描设备 发现设备之后，获取蓝牙信息，他这里是获取到一个蓝牙信息就会走一遍这个方法，并不是说一次获取一个列表。 找到了蓝牙设备之后就是连接了，伪代码讲解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 固定的UUID连接的时候需要uuid private static final String SPP_UUID = &quot;00001101-0000-1000-8000-00805F9B34FB&quot;; //获取socketBluetoothSocket bluetoothSocket =device.createRfcommSocketToServiceRecord(uuid);//连接之前取消扫描，注意非空判断。adapter是在服务里面申明的，通过setBluetoothAdapter方法传过来的bluetoothAdapter.cancelDiscovery();//连接，这里是阻塞的方式，注意要新开线程连接bluetoothSocket.connect();//获取输入流对象和输出流对象InputStream mInputStream = bluetoothSocket.getInputStream();OutputStream outputStream = bluetoothSocket.getOutputStream();//发送消息private void sendInstruct(String msg) &#123; try &#123; if (null == bluetoothSocket || !bluetoothSocket.isConnected()) &#123; SocketUtils.reLinkBluetooth(); return; &#125; Log.v(Constants.HTTP_WZ, &quot;发送的数据--&gt;&quot; + msg + BluetoothInstruct.FINISH); outputStream.write(msg.getBytes()); outputStream.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;//接收消息，一次读一行，简单的蓝牙通信换行符作为结束标记BufferedReader br;while (isRunning) &#123; br = new BufferedReader(new InputStreamReader(mInputStream, &quot;utf-8&quot;)); String s = br.readLine(); acceptReply(s); Log.v(Constants.HTTP_WZ, &quot;收到的数据:&quot; + s); &#125; //异常的时候释放资源try &#123; if (mInputStream != null) &#123; mInputStream.close(); Log.v(Constants.HTTP_WZ, &quot;mInputSream.close()&quot;); &#125; if (outputStream != null) &#123; outputStream.close(); Log.v(Constants.HTTP_WZ, &quot;outputStream.close()&quot;); &#125; if (bluetoothSocket != null) &#123; bluetoothSocket.close(); Log.v(Constants.HTTP_WZ, &quot;socket.close()&quot;); bluetoothSocket = null; &#125; isRunning = false; &#125; catch (Exception e2) &#123; // TODO: handle exception &#125;]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android拍照功能——TakePhoto]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E6%8B%8D%E7%85%A7%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94TakePhoto%2F</url>
    <content type="text"><![CDATA[之前在写项目框架Andoroid 6.0，动态获取权限的时候就提到过TakePhoto开源框架 简介一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库 依赖1implementation &apos;com.jph.takephoto:takephoto_library:4.0.3&apos; 用法我这里就说拍照，选择相册的功能。其他功能请移步TakePhoto开源框架看说明文档，写的很清楚。最后会给出一个工具类，拷贝过去就可以直接用。 定义两个变量 12private TakePhoto takePhoto;private InvokeParam invokeParam; 添加如下代码获取TakePhoto实例 12345678public TakePhoto getTakePhoto()&#123; if (takePhoto==null)&#123; takePhoto= (TakePhoto) TakePhotoInvocationHandler.of(this).bind(new TakePhotoImpl(this,this)); &#125; //设置压缩规则，最大500kb takePhoto.onEnableCompress(new CompressConfig.Builder().setMaxSize(500 * 1024).create(), true); return takePhoto; &#125; 实现两个接口：TakePhoto.TakeResultListener,InvokeListener 在 onCreate,onActivityResult,onSaveInstanceState方法中调用TakePhoto对用的方法 1234567891011121314151617@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; getTakePhoto().onCreate(savedInstanceState); super.onCreate(savedInstanceState); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; getTakePhoto().onActivityResult(requestCode, resultCode, data); super.onActivityResult(requestCode, resultCode, data); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; getTakePhoto().onSaveInstanceState(outState); super.onSaveInstanceState(outState); &#125; 重写TPermissionType invoke(InvokeParam invokeParam)方法，添加如下代码：12345678910111213141516@Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); //以下代码为处理Android6.0、7.0动态权限所需 PermissionManager.TPermissionType type=PermissionManager.onRequestPermissionsResult(requestCode,permissions,grantResults); PermissionManager.handlePermissionsResult(this,type,invokeParam,this); &#125; @Override public PermissionManager.TPermissionType invoke(InvokeParam invokeParam) &#123; PermissionManager.TPermissionType type=PermissionManager.checkPermission(TContextWrap.of(this),invokeParam.getMethod()); if(PermissionManager.TPermissionType.WAIT.equals(type))&#123; this.invokeParam=invokeParam; &#125; return type; &#125; &emsp;&emsp;到这里，根据他官方的介绍就已经全部写完了，然后怎么分调用相机，相册还是文件夹呢？ 调用不同的方法，常用的：相机，相册，多选 123456789101112131415161718192021 flag = getIntent().getIntExtra(&quot;flag&quot;, 0); File file = new File(getExternalCacheDir(), System.currentTimeMillis() + &quot;.png&quot;); Uri uri = Uri.fromFile(file); int size = Math.min(getResources().getDisplayMetrics().widthPixels, getResources().getDisplayMetrics().heightPixels); CropOptions cropOptions = new CropOptions.Builder().setOutputX(size).setOutputX(size).setWithOwnCrop(false).create(); if (flag == 1) &#123; //相机获取照片并剪裁 takePhoto.onPickFromCaptureWithCrop(uri, cropOptions); //相机获取不剪裁 //takePhoto.onPickFromCapture(uri); &#125; else if (flag == 2) &#123; //相册获取照片并剪裁 takePhoto.onPickFromGalleryWithCrop(uri, cropOptions); //相册获取不剪裁// takePhoto.onPickFromGallery(); &#125; else if (flag == 3) &#123; //多选，并剪裁 takePhoto.onPickMultipleWithCrop(9, cropOptions); //多选，不剪裁// takePhoto.onPickMultiple(9); &#125; &emsp;&emsp;前面一个页面调用startActivityForResult，传一个标记过来，用来判断调用不同的方式。 &emsp;&emsp;我这里还想多说的是，一般我们这个拍照功能，都有三个选项，拍照，相册，取消，从底部弹出。这个我估计还是大部分人写的动画实现的。我想说的是BottomSheetDialog，这个是MD推出的一个控件，现在微信用的就是这个，用起来也非常方便，简单。 &emsp;&emsp;至于，工具类，直接下载项目，把对应的TakePhotoActivity文件拷贝过去就可以了。 资源链接]]></content>
      <categories>
        <category>Android -常用功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android图片压缩——Luban鲁班压缩]]></title>
    <url>%2F2018%2F03%2F02%2FAndroid%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E2%80%94%E2%80%94Luban%E9%B2%81%E7%8F%AD%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Android让人头疼的OOM，造成OOM的原因之一就是图片，现在的手机像素越来越高，随便一张图片都是好几M，甚至几十M，这样的照片加载到app，可想而知，随便加载几张图片，手机内存就不够用了，自然而然就造成了OOM，所以，Android的图片压缩异常重要。这里，我推荐一款开源框架——Luban 效果与对比&emsp;&emsp;这里就不放效果图了，我拷贝了鲁班github上面的介绍——Android图片压缩工具，仿微信朋友圈压缩策略，因为是逆向推算，效果还没法跟微信一模一样，但是已经很接近微信朋友圈压缩后的效果，具体看以下对比！ 内容 原图 Luban Wechat 截屏 720P 720*1280,390k 720*1280,87k 720*1280,56k 截屏 1080P 1080*1920,2.21M 1080*1920,104k 1080*1920,112k 拍照 13M(4:3) 3096*4128,3.12M 1548*2064,141k 1548*2064,147k 拍照 9.6M(16:9) 4128*2322,4.64M 1032*581,97k 1032*581,74k 滚动截屏 1080*6433,1.56M 1080*6433,351k 1080*6433,482k 从这里就能看出，效果还是非常不错的 依赖1implementation &apos;top.zibin:Luban:1.1.3&apos; 调用方式异步调用&emsp;&emsp;Luban内部采用IO线程进行图片压缩，外部调用只需设置好结果监听即可： 1234567891011121314151617181920Luban.with(this) .load(photos) // 传人要压缩的图片列表 .ignoreBy(100) // 忽略不压缩图片的大小 .setTargetDir(getPath()) // 设置压缩后文件存储位置 .setCompressListener(new OnCompressListener() &#123; //设置回调 @Override public void onStart() &#123; // TODO 压缩开始前调用，可以在方法内启动 loading UI &#125; @Override public void onSuccess(File file) &#123; // TODO 压缩成功后调用，返回压缩后的图片文件 &#125; @Override public void onError(Throwable e) &#123; // TODO 当压缩过程出现问题时调用 &#125; &#125;).launch(); //启动压缩 同步调用&emsp;&emsp;同步方法请尽量避免在主线程调用以免阻塞主线程，下面以rxJava调用为例 12345678910Flowable.just(photos) .observeOn(Schedulers.io()) .map(new Function&lt;List&lt;String&gt;, List&lt;File&gt;&gt;() &#123; @Override public List&lt;File&gt; apply(@NonNull List&lt;String&gt; list) throws Exception &#123; // 同步方法直接返回压缩后的文件 return Luban.with(MainActivity.this).load(list).get(); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(); &emsp;&emsp;以上，均是它github上面说明都有的，我这里就是copy过来了而已。重点要说的是，他是怎么实现的，源码分析。 源码分析第一步：Luban.with()点击去看到源码为： 123public static Builder with(Context context) &#123; return new Builder(context); &#125; &emsp;&emsp;这里是一个静态的with方法，返回值是Builder，一般对设计模式比较熟悉的人，看到这里就应该懂了，他这里使用的是建造者模式。什么是建造者模式呢？建造者模式和工厂模式很相似，比工厂模式多了一个控制类，其实说白了，就是在创建对象的时候，减少初始化数据的代码，怎么理解呢？我们接着往下看。我们点到Builder里面看到如下代码： 12345678910111213141516public static class Builder &#123; private Context context;//上下文对象 private String mTargetDir;//压缩后图片存放位置 private List&lt;String&gt; mPaths;//多个文件的list private int mLeastCompressSize = 100;//忽略100kb以下的图片，不压缩 private OnCompressListener mCompressListener;//回调方法 Builder(Context context) &#123; this.context = context; this.mPaths = new ArrayList&lt;&gt;(); &#125; private Luban build() &#123; return new Luban(this); &#125;&#125; &emsp;&emsp;我们看到了是一个静态的内部类Builder，我们这里看到了有5个变量，上面我们说道了，为了减少初始化数据的代码，就拿这个举例子说明，我如果有4个地方调用这个鲁班压缩，其中这4个地方，mTargetDir，mLeastCompressSize这2个变量的值都是一样的，其他3个不一样，按照我们以往的写法都得一个一个的赋值，要写4遍，那如果使用建造者模式了，这里就只用写一遍赋值，这2个变量。其他3个不一样，就得写多遍。当然，这是我个人对于建造者模式的理解。 &emsp;&emsp;我上面多粘贴了一个build()方法，为什么会多粘贴一个呢？就是为了更好的说明建造者模式，我们可以看到他这个方法，返回的是Luban对象，调用的是需要传Builder的构造方法，我们点进去看 1234567private Luban(Builder builder) &#123; this.mPaths = builder.mPaths; this.mTargetDir = builder.mTargetDir; this.mCompressListener = builder.mCompressListener; this.mLeastCompressSize = builder.mLeastCompressSize; mHandler = new Handler(Looper.getMainLooper(), this); &#125; &emsp;&emsp;他这里就是赋值，他这个值就是Builder里面默认的，我们不论在哪里调用这个方法，都不用去一个一个赋值，因为，他已经处理好了。 第二步：load()点击去看到源码为 1234567891011121314public Builder load(File file) &#123; this.mPaths.add(file.getAbsolutePath()); return this; &#125; public Builder load(String string) &#123; this.mPaths.add(string); return this; &#125; public Builder load(List&lt;String&gt; list) &#123; this.mPaths.addAll(list); return this; &#125; &emsp;&emsp;这里，我们会看到三个重载方法，一个传文件，他会获取到文件的绝对路径存进去，实际上还是存的字符串，中间那个存的是字符串，最后面那个传String类型的list，它调用的addAll方法，最后还是存的String在mPaths里面。我们点击mPaths，他就是一个String类型的list，在Builder的构造方法里面初始化的。他就是存放你的图片路径的集合 第三步：ignoreBy() 和 setTargetDir()点击去看到源码为 123456789101112131415/** * do not compress when the origin image file size less than one value * * @param size * the value of file size, unit KB, default 100K */public Builder ignoreBy(int size) &#123; this.mLeastCompressSize = size; return this;&#125;public Builder setTargetDir(String targetDir) &#123; this.mTargetDir = targetDir; return this;&#125; &emsp;&emsp;这两个我为啥要放在一起讲呢？因为这两个没啥好说的，都是设置值，跟我们平时写的set方法的作用是一样的。没啥好说的 第四步：setCompressListener(OnCompressListener listener)点击去看到源码为 1234public Builder setCompressListener(OnCompressListener listener) &#123; this.mCompressListener = listener; return this; &#125; &emsp;&emsp;这个就是我们平时写自定义view的时候，要写回调方法，是一样的道理，他这里就是压缩方法的回调 第五步：launch()点击去看到源码为 123456/** * begin compress image with asynchronous */public void launch() &#123; build().launch(context);&#125; &emsp;&emsp;这里，我们看到他先调用了build(),我们前面讲了，他这个方法就是赋值，然后调用了launch(context)方法，我们点进去看： 123456789101112131415161718192021222324252627282930313233/** * start asynchronous compress thread */ @UiThread private void launch(final Context context) &#123; if (mPaths == null || mPaths.size() == 0 &amp;&amp; mCompressListener != null) &#123; mCompressListener.onError(new NullPointerException(&quot;image file cannot be null&quot;)); &#125; Iterator&lt;String&gt; iterator = mPaths.iterator(); while (iterator.hasNext()) &#123; final String path = iterator.next(); if (Checker.isImage(path)) &#123; AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_START)); File result = Checker.isNeedCompress(mLeastCompressSize, path) ? new Engine(path, getImageCacheFile(context, Checker.checkSuffix(path))).compress() : new File(path); mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_SUCCESS, result)); &#125; catch (IOException e) &#123; mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_ERROR, e)); &#125; &#125; &#125;); &#125; else &#123; Log.e(TAG, &quot;can not read the path : &quot; + path); &#125; iterator.remove(); &#125; &#125; &emsp;&emsp;这个方法就是最后，执行压缩的方法，前面都是初始化，我们可以看到，他这个方法是在主线程调用的，所以，我们不用考虑切换线程的问题，直接可以操作UI变化。我一步一步的讲： 首先，他这个是用的迭代器，循环遍历，遍历一个就移除一个 然后就是通过handler发消息调用 具体压缩代码。最重要的就是第三点，我把第三点，提到下面讲 接着上面的第三点，具体压缩 123File result = Checker.isNeedCompress(mLeastCompressSize, path) ? new Engine(path, getImageCacheFile(context, Checker.checkSuffix(path))).compress() : new File(path); 首先，他整体是一个三目运算符，我们点isNeedCompress()方法看一下 12345678910111213static boolean isNeedCompress(int leastCompressSize, String path) &#123; if (leastCompressSize &gt; 0) &#123; File source = new File(path); if (!source.exists()) &#123; return false; &#125; if (source.length() &lt;= (leastCompressSize &lt;&lt; 10)) &#123; return false; &#125; &#125; return true; &#125; &emsp;&emsp;这个方法就是用来判断，你给定路径的图片大小和你规定的忽略文件大小比较，他这里先做了你给定的最小值判断，要大于0，不大于0就返回ture。然后做了文件是否存在的判断，如果文件不存在，就返回fals。最后，给定文件大小是不是小于等于最小值左移10位的值，小于就返回false。 然后，如果返回的是true，就去压缩，如果，返回的是false，就直接返回file文件。压缩的方法点进去： 123456789101112131415Engine(String srcImg, File tagImg) throws IOException &#123; if (Checker.isJPG(srcImg)) &#123; this.srcExif = new ExifInterface(srcImg); &#125; this.tagImg = tagImg; this.srcImg = srcImg; BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; options.inSampleSize = 1; BitmapFactory.decodeFile(srcImg, options); this.srcWidth = options.outWidth; this.srcHeight = options.outHeight; &#125; &emsp;&emsp;这就又要说道另一个类了Engine类，它的类注释就是：用于操作，开始压缩，管理活动，缓存资源的类。他这里传原文件，也就是你需要压缩的图片，还有一个就是目标文件，也就是你压缩之后，要保存的文件。 &emsp;&emsp;我们先看第二个参数是什么怎么传的，有的人看不懂 123456789101112131415161718/** * Returns a mFile with a cache audio name in the private cache directory. * * @param context * A context. */ private File getImageCacheFile(Context context, String suffix) &#123; if (TextUtils.isEmpty(mTargetDir)) &#123; mTargetDir = getImageCacheDir(context).getAbsolutePath(); &#125; String cacheBuilder = mTargetDir + &quot;/&quot; + System.currentTimeMillis() + (int) (Math.random() * 1000) + (TextUtils.isEmpty(suffix) ? &quot;.jpg&quot; : suffix); return new File(cacheBuilder); &#125; &emsp;&emsp;他这里就是新建一个文件，设置路径，设置名称，然后返回文件 &emsp;&emsp;再掉回去看Engine的构造方法，我们这里获取到了源文件和目标文件，我们只用把压缩后的流存到目标文件就行了。我之前写过一篇关于图片压缩的博客。它这里的option就是设置压缩的参数，不懂的可以看一下我之前的博客，或者用google百度一下就知道了。具体压缩就是用的bitmap的工厂类，调用的decodeFile方法。没错就是这一句 BitmapFactory.decodeFile(srcImg, options); 最后，辣么一切都准备就绪了，怎么样开始压缩呢？compress() 12345678910111213141516171819File compress() throws IOException &#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = computeSize(); Bitmap tagBitmap = BitmapFactory.decodeFile(srcImg, options); ByteArrayOutputStream stream = new ByteArrayOutputStream(); tagBitmap = rotatingImage(tagBitmap); tagBitmap.compress(Bitmap.CompressFormat.JPEG, 60, stream); tagBitmap.recycle(); FileOutputStream fos = new FileOutputStream(tagImg); fos.write(stream.toByteArray()); fos.flush(); fos.close(); stream.close(); return tagImg; &#125; &emsp;&emsp;这里面就是常规的压缩，存储的逻辑了，最最重要的压缩算法呢？就是这里的computeSize()方法 123456789101112131415161718192021222324private int computeSize() &#123; srcWidth = srcWidth % 2 == 1 ? srcWidth + 1 : srcWidth; srcHeight = srcHeight % 2 == 1 ? srcHeight + 1 : srcHeight; int longSide = Math.max(srcWidth, srcHeight); int shortSide = Math.min(srcWidth, srcHeight); float scale = ((float) shortSide / longSide); if (scale &lt;= 1 &amp;&amp; scale &gt; 0.5625) &#123; if (longSide &lt; 1664) &#123; return 1; &#125; else if (longSide &gt;= 1664 &amp;&amp; longSide &lt; 4990) &#123; return 2; &#125; else if (longSide &gt; 4990 &amp;&amp; longSide &lt; 10240) &#123; return 4; &#125; else &#123; return longSide / 1280 == 0 ? 1 : longSide / 1280; &#125; &#125; else if (scale &lt;= 0.5625 &amp;&amp; scale &gt; 0.5) &#123; return longSide / 1280 == 0 ? 1 : longSide / 1280; &#125; else &#123; return (int) Math.ceil(longSide / (1280.0 / scale)); &#125; &#125; 12345678910111213141516171819202122private Bitmap rotatingImage(Bitmap bitmap) &#123; if (srcExif == null) return bitmap; Matrix matrix = new Matrix(); int angle = 0; int orientation = srcExif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); switch (orientation) &#123; case ExifInterface.ORIENTATION_ROTATE_90: angle = 90; break; case ExifInterface.ORIENTATION_ROTATE_180: angle = 180; break; case ExifInterface.ORIENTATION_ROTATE_270: angle = 270; break; &#125; matrix.postRotate(angle); return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true); &#125; &emsp;&emsp;你以为我会一步一步给你讲Luban算法逻辑吗？那是不可能的，我特么都不会，怎么给你讲。我直接把他github上算法逻辑的介绍拷贝过来了： 判断图片比例值，是否处于以下区间内； [1, 0.5625) 即图片处于 [1:1 ~ 9:16) 比例范围内 [0.5625, 0.5) 即图片处于 [9:16 ~ 1:2) 比例范围内 [0.5, 0) 即图片处于 [1:2 ~ 1:∞) 比例范围内 判断图片最长边是否过边界值； [1, 0.5625) 边界值为：1664 n（n=1）, 4990 n（n=2）, 1280 * pow(2, n-1)（n≥3） [0.5625, 0.5) 边界值为：1280 * pow(2, n-1)（n≥1） [0.5, 0) 边界值为：1280 * pow(2, n-1)（n≥1） 计算压缩图片实际边长值，以第2步计算结果为准，超过某个边界值则：width / pow(2, n-1)，height/pow(2, n-1) 计算压缩图片的实际文件大小，以第2、3步结果为准，图片比例越大则文件越大。size = (newW newH) / (width height) * m； [1, 0.5625) 则 width &amp; height 对应 1664，4990，1280 * n（n≥3），m 对应 150，300，300； [0.5625, 0.5) 则 width = 1440，height = 2560, m = 200； [0.5, 0) 则 width = 1280，height = 1280 / scale，m = 500；注：scale为比例值 判断第4步的size是否过小 [1, 0.5625) 则最小 size 对应 60，60，100 [0.5625, 0.5) 则最小 size 都为 100 [0.5, 0) 则最小 size 都为 100 将前面求到的值压缩图片 width, height, size 传入压缩流程，压缩图片直到满足以上数值]]></content>
      <categories>
        <category>Android -源码解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（八）—— 私有目录被限制访问(Android 7.0)]]></title>
    <url>%2F2018%2F03%2F01%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E7%A7%81%E6%9C%89%E7%9B%AE%E5%BD%95%E8%A2%AB%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE-Android7.0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我这里只说我关心的问题，并不是说Android 7.0只增加了一个“私有目录被限制访问”，当然还有其他的变化。android 7.0的新特性中，对程序员开发造成最直接的变化就是FileUriExposedException异常，这个异常的产生就是由私有目录被限制访问造成的 &emsp;&emsp;Andoird 7.0中为了提高文件的安全性，面向Android N或者更高版本的应用私有目录将会被禁止访问，常见最直接的bug就是：你的应用给其他应用传递file:// URI类型的Uri时，可能导致接受者无法访问该路径会造成我们前面说的文件uri异常。 调用系统相机最直接的就是我们常用的拍照功能,我们自己的应用启动手机相机，这里手机相机就是其他应用，按照我们以前的写法就是： 1234567File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);if (!file.getParentFile().exists())file.getParentFile().mkdirs();Uri imageUri = Uri.fromFile(file);Intent intent = new Intent();intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);//设置Action为拍照intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);//将拍取的照片保存到指定URIstartActivityForResult(intent,986); &emsp;&emsp;先创建一个存放我们拍照图片的存放file，参数就是路径+文件名称，当我们还是按之前的写法，跑在android N及以上的机型的时候，会报如下异常： FileUriExposedException.png &emsp;&emsp;这就是由于Android 7.0执行了“StrictMode API 政策禁”对我们广大程序员造成的最常见，最直接的结果。辣么，怎么解决呢？ 解决办法FileProvider使用FileProvider解决上面的问题，步骤如下： 第一步：在清单文件里面申请provider123456789&lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;com.haichenyi.myproject.fileprovider&quot; android:grantUriPermissions=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; /&gt;&lt;/provider&gt; &emsp;&emsp;FileProvider是V4包下面的类，这里exproted属性必须给false，不然也会报异常，grantUriPermissions的值给true，表示授予临时URI访问权限，下面meta-data就是指定共享目录，authorities属性后面讲 第二步：指定共享目录12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;path&gt; &lt;external-path name=&quot;camera_photos&quot; path=&quot;&quot;/&gt; &lt;/path&gt;&lt;/resources&gt; &emsp;&emsp;有点android开发基础的人就知道，这个@xml目录是位于res根目录，跟layout目录平级的。所以，你得先创建xml文件夹，然后新建file_paths文件，添加上面的代码在文件中。这里的path路径，我们先瞅瞅下面的表： 物理路径 写法 Context.getFilesDir() + /path/ Context.getCacheDir() + /path/ Environment.getExternalStorageDirectory() + /path/ Context.getExternalFilesDir(String) + /path/ Context.getExternalCacheDir() + /path/ &emsp;&emsp;辣么，我们代码中path=””，是有特殊意义的，它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为path=”pictures”， 那么它代表着根目录下的pictures目录(eg:/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的 第三步：使用FileProvider12345678910val file = File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot; + System.currentTimeMillis() + &quot;.jpg&quot;) if (!file.parentFile.exists()) file.parentFile.mkdirs() //变化 val imageUri = FileProvider.getUriForFile(this, &quot;com.haichenyi.myproject.fileprovider&quot;, file)//通过FileProvider创建一个content类型的Uri val intent = Intent() //变化 intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION) //添加这一句表示对目标应用临时授权该Uri所代表的文件 intent.action = MediaStore.ACTION_IMAGE_CAPTURE//设置Action为拍照 intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri)//将拍取的照片保存到指定URI startActivityForResult(intent, 986) &emsp;&emsp;我们调用系统相机的代码发生了变化，变化的位置，我都注明了获取imageUri的方式发生了变化，其中，第二个参数就是我们在前面说放在后面讲的authorities属性的内容，再就是增加了一个flag，表示临时授权。加上如上代码，我们就可以正常调用系统相机了。 &emsp;&emsp;经过如上步骤之后，我们就能拍照了，拍完照片之后的存放路径在哪里呢？我们前面说了，这里我打印出了路径， 123file!!.absolutePath:/storage/emulated/0/temp/1519896174785.jpgimageUri:content://com.haichenyi.myproject.fileprovider/camera_photos/temp/1519896174785.jpg 照片裁剪Android 7.0之前，我们裁剪照片 1234567891011121314File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);if (!file.getParentFile().exists())file.getParentFile().mkdirs();Uri outputUri = Uri.fromFile(file);Uri imageUri=Uri.fromFile(new File(&quot;/storage/emulated/0/temp/1519896174785.jpg&quot;));Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);intent.setDataAndType(imageUri, &quot;image/*&quot;);intent.putExtra(&quot;crop&quot;, &quot;true&quot;);intent.putExtra(&quot;aspectX&quot;, 1);intent.putExtra(&quot;aspectY&quot;, 1);intent.putExtra(&quot;scale&quot;, true);intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri);intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());intent.putExtra(&quot;noFaceDetection&quot;, true); // no face detectionstartActivityForResult(intent,987); Android 7.0之后，我们裁剪照片 123456789101112131415File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);if (!file.getParentFile().exists())file.getParentFile().mkdirs();Uri outputUri = FileProvider.getUriForFile(context, &quot;com.haichenyi.myproject.fileprovider&quot;,file);Uri imageUri=FileProvider.getUriForFile(context, &quot;com.haichenyi.myproject.fileprovider&quot;, new File(&quot;/storage/emulated/0/temp/1519896174785.jpg&quot;);//通过FileProvider创建一个content类型的UriIntent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);intent.setDataAndType(imageUri, &quot;image/*&quot;);intent.putExtra(&quot;crop&quot;, &quot;true&quot;);intent.putExtra(&quot;aspectX&quot;, 1);intent.putExtra(&quot;aspectY&quot;, 1);intent.putExtra(&quot;scale&quot;, true);intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri);intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());intent.putExtra(&quot;noFaceDetection&quot;, true); // no face detectionstartActivityForResult(intent,987); &emsp;&emsp;拍照裁剪这是一个很常用的功能，很早之前就写过一篇，封装的不是很好。最近，又做了一遍这个功能，发现了一个好用的框架——TakePhoto 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（七）—— 权限申请(Android 6.0)]]></title>
    <url>%2F2018%2F03%2F01%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7-Android6.0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;总所周知，Android 6.0以上的版本，google对权限做了更严格的限制，不能app自动给权限，必须要让用户选择是否给权限。如果，用户不给权限，辣么，用这个功能的时候，app会造成崩溃，所以，最简单的办法就是，用户不给权限，不让用户用这个功能，也就是页面不做跳转。 &emsp;&emsp;当时，刚出来这个权限问题的时候，本人用原生的写，写了封装，搞了好长时间，总感觉各种不爽，各种不舒服，后来好了，大牛封装了一个开源框架——RxPermission，一行代码解决动态申请权限问题。 依赖1implementation &apos;com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar&apos; 工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.haichenyi.myproject.utilsimport android.app.Activityimport android.content.Intentimport android.net.Uriimport android.os.Buildimport android.os.Environmentimport android.provider.Settingsimport android.support.v7.app.AlertDialogimport com.haichenyi.myproject.Rimport com.tbruyelle.rxpermissions2.RxPermissionsimport java.io.Fileimport java.io.FileInputStreamimport java.io.IOExceptionimport java.util.*/** * Author: 海晨忆 * Date: 2018/2/28 * Desc: */object RxPerUtils &#123; /** * 请求权限的获取方法 * activity：Activity对象 * permissions：需要获取的权限，可以传多个 * aloe: (b: Boolean)：一个参数的回调方法，b为true，表示用户给了权限，false，表示没有给权限 */ fun requestPermission(activity: Activity, vararg permissions: String, aloe: (b: Boolean) -&gt; Unit) &#123; RxPermissions(activity).request(*permissions) .subscribe &#123; aBoolean -&gt; aloe(aBoolean) &#125; &#125; /** * 当用户拒绝给权限的时候调用，跳转权限设置页面，让用户手动给权限 * activity：Activity对象 * permissionName：权限名称 * msg：提示信息 */ fun setupPermission(activity: Activity, permissionName: String, msg: String, aloe: () -&gt; Unit) &#123; AlertDialog.Builder(activity, R.style.Theme_AppCompat_Dialog).setTitle(&quot;权限申请&quot;) .setMessage(String.format(Locale.getDefault(), &quot;请在“权限”中开启“%1s权限”，以正常使用%2s&quot;, permissionName, msg)) .setCancelable(false) .setNegativeButton(android.R.string.cancel) &#123; dialog, which -&gt; aloe &#125;.setPositiveButton(&quot;去设置&quot;) &#123; dialog, which -&gt; if (isMiUi()) &#123; setMiUiPermissions(activity) &#125; else &#123; activity.startActivityForResult(Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS) .setData(Uri.fromParts(&quot;package&quot;, activity.packageName, null)), 1000) &#125; &#125;.create().show() &#125; private fun setMiUiPermissions(activity: Activity) &#123; if (isMiUi()) &#123; try &#123; // MIUI 8 activity.startActivityForResult(Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;) .setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;) .putExtra(&quot;extra_pkgname&quot;, activity.packageName), 1000) &#125; catch (e: Exception) &#123; try &#123; // MIUI 5/6/7 activity.startActivityForResult(Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;) .setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;) .putExtra(&quot;extra_pkgname&quot;, activity.packageName), 1000) &#125; catch (e1: Exception) &#123; // 否则跳转到应用详情 activity.startActivityForResult(Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS) .setData(Uri.fromParts(&quot;package&quot;, activity.packageName, null)), 1000) &#125; &#125; &#125; &#125; private fun isMiUi(): Boolean &#123; val device = Build.MANUFACTURER if (device == &quot;Xiaomi&quot;) &#123; try &#123; val prop = Properties() prop.load(FileInputStream(File(Environment.getRootDirectory(), &quot;build.prop&quot;))) return (prop.getProperty(&quot;ro.miui.ui.version.code&quot;, null) != null || prop.getProperty(&quot;ro.miui.ui.version.name&quot;, null) != null || prop.getProperty(&quot;ro.miui.internal.storage&quot;, null) != null) &#125; catch (e: IOException) &#123; e.printStackTrace() &#125; &#125; return false &#125;&#125; 调用12345678910RxPerUtils.requestPermission(this, Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE) &#123; if (it) &#123; //这里写你自己的逻辑，已经获得权限，做你自己的业务逻辑操作 ToastUtils.showTipMsg(&quot;已经获得权限&quot;) &#125; else &#123; RxPerUtils.setupPermission(this, &quot;相机和存储&quot;, &quot;相机功能&quot;) &#123; &#125; &#125; &#125; &emsp;&emsp;请求权限的整个过程就是： 用RxPermission去请求权限，需要传activity对象,然后就是你需要获取的权限（可以传多个），再就是回调方法 在回调方法里面做判断，用户是否给了权限，如果给了，就走你正常的逻辑。如果没有给，就弹对话框提示用户，去设置页面给权限。 &emsp;&emsp;就这么简单，方法都封装好了，如果，你嫌弃系统自带的对话框样式不好看，你也可以自己写一个样式。项目就不传了，如果你有之前的代码，就直接把我这几个方法拷贝过去用就可以了，没有之前的代码，就去瞅瞅之前的博客吧。]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（六）——Socket网络编程]]></title>
    <url>%2F2018%2F02%2F26%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Android中常用的网络编程方式：Http和Socket，Http通讯方式，我们在前面已经加到框架里面了，用的是现在主流的RxJava+Retrofit+OkHttp的方式，用起来也很方便。今天，我们来说说Socket网络编程。前面已经有一篇讲过IO和NIO的区别，还有一篇讲过Netty了，今天这篇的目的就是把Netty加到我们这个框架里面。 添加依赖1implementation &apos;io.netty:netty-all:5.0.0.Alpha2&apos; 添加依赖，老生常谈的问题了，我就不多说了。 TCP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.haichenyi.myproject.model.socketimport android.util.Logimport com.haichenyi.myproject.model.bean.SocketTcpBeanimport io.netty.bootstrap.Bootstrapimport io.netty.channel.Channelimport io.netty.channel.ChannelInitializerimport io.netty.channel.ChannelOptionimport io.netty.channel.EventLoopGroupimport io.netty.channel.nio.NioEventLoopGroupimport io.netty.channel.socket.SocketChannelimport io.netty.channel.socket.nio.NioSocketChannelimport io.netty.handler.codec.LineBasedFrameDecoderimport io.netty.handler.codec.string.StringDecoderimport io.netty.handler.codec.string.StringEncoderimport io.netty.util.CharsetUtilimport org.greenrobot.eventbus.EventBusimport org.greenrobot.eventbus.Subscribe/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class SocketTcp &#123; companion object &#123; private val socket = SocketTcp() fun getInstance(): SocketTcp = socket &#125; private var port: Int = 0 private var host: String = &quot;&quot; private var channel: Channel? = null private var group: EventLoopGroup? = null fun setPort(port: Int): SocketTcp &#123; this.port = port return this &#125; fun setHost(host: String): SocketTcp &#123; this.host = host return this &#125; fun connect() &#123; if (null != channel) return if (null == group) &#123; if (!EventBus.getDefault().isRegistered(this)) EventBus.getDefault().register(this) group = NioEventLoopGroup() &#125; val bootstrap = Bootstrap() try &#123; bootstrap.group(group) .channel(NioSocketChannel::class.java) .option(ChannelOption.TCP_NODELAY, true) .handler(object : ChannelInitializer&lt;SocketChannel&gt;() &#123; override fun initChannel(ch: SocketChannel?) &#123; //以换行符为结束标记 val pipeline = ch!!.pipeline() pipeline.addLast(&quot;encoder&quot;, StringEncoder(CharsetUtil.UTF_8)) pipeline.addLast(LineBasedFrameDecoder(Integer.MAX_VALUE)) pipeline.addLast(StringDecoder()) pipeline.addLast(HeartTcp()) //以&quot;#_&quot;作为分隔符 /*val pipeline = ch!!.pipeline() pipeline.addLast(&quot;encoder&quot;, StringEncoder(CharsetUtil.UTF_8)) val s = &quot;#_&quot; val byteBuf = Unpooled.copiedBuffer(s.toByteArray()) pipeline.addLast(DelimiterBasedFrameDecoder(Integer.MAX_VALUE, byteBuf)) pipeline.addLast(StringDecoder())*/ &#125; &#125;) //发起异步连接操作 val channelFuture = bootstrap.connect(host, port).sync() channel = channelFuture.channel() //等待服务端监听端口关闭 channel!!.closeFuture().sync() &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; finally &#123; disConnect() &#125; &#125; //连接成功后，通过Channel提供的接口进行IO操作 fun sendMessage(msg: String) &#123; try &#123; if (channel != null &amp;&amp; channel!!.isOpen) &#123; channel!!.writeAndFlush(msg).sync() Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg) &#125; else &#123; throw Exception(&quot;channel is null | closed&quot;) &#125; &#125; catch (e: Exception) &#123; reConnect() e.printStackTrace() &#125; &#125; /** * 断开tcp连接. */ private fun disConnect() &#123; if (null != group) &#123; group!!.shutdownGracefully() &#125;// EventBus.getDefault().unregister(this) group = null channel = null Log.v(&quot;WZ&quot;, &quot;disConnect&quot;) &#125; @Subscribe fun handle(socketTcpBean: SocketTcpBean) &#123; sendMessage(socketTcpBean.msg) &#125; /** * 重连. */ private fun reConnect() &#123; Thread(Runnable &#123; this.connect() &#125;).start() &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.haichenyi.myproject.model.socketimport android.os.SystemClockimport android.util.Logimport io.netty.buffer.Unpooledimport io.netty.channel.ChannelHandlerContextimport io.netty.channel.SimpleChannelInboundHandlerimport java.util.concurrent.TimeUnitclass HeartTcp : SimpleChannelInboundHandler&lt;Any&gt;() &#123; private var ctx: ChannelHandlerContext? = null private var isConnect = false @Throws(Exception::class) override fun channelActive(ctx: ChannelHandlerContext) &#123; super.channelActive(ctx) Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;) isConnect = true if (this.ctx == null) &#123; synchronized(HeartTcp::class.java) &#123; if (this.ctx == null) &#123; this.ctx = ctx myAppHeart() &#125; &#125; &#125; &#125; private fun myAppHeart() &#123; Thread &#123; while (ctx != null &amp;&amp; isConnect) &#123; val data = &quot;123&quot; val bytes = data.toByteArray() if (isConnect) &#123; ctx!!.writeAndFlush(Unpooled.buffer(bytes.size).writeBytes(bytes)) SystemClock.sleep(3000) &#125; &#125; &#125;.start() &#125; @Throws(Exception::class) override fun channelInactive(ctx: ChannelHandlerContext) &#123; val loop = ctx.channel().eventLoop() loop.schedule(&#123; SocketTcp.getInstance().connect() &#125;, 5, TimeUnit.SECONDS) super.channelInactive(ctx) Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;) isConnect = false &#125; @Throws(Exception::class) override fun userEventTriggered(ctx: ChannelHandlerContext, evt: Any) &#123; super.userEventTriggered(ctx, evt) Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;) &#125; @Throws(Exception::class) override fun exceptionCaught(ctx: ChannelHandlerContext, cause: Throwable) &#123; super.exceptionCaught(ctx, cause) Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;) this.ctx = null &#125; @Throws(Exception::class) override fun messageReceived(ctx: ChannelHandlerContext, msg: Any) &#123; Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;) /*val msg1 = msg val bytes = ByteArray(msg1.readableBytes()) msg1.readBytes(bytes) val s = String(bytes*//*, &quot;UTF-8&quot;*//*)*/ val s = msg.toString() Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s) &#125;&#125; &emsp;&emsp;我这里就是把我前面那个讲Netty创建Socket连接的代码拷贝过来转成了kotlin代码，这里我就不做过多的解释了。 &emsp;&emsp;一般，我们都是后台新开一个服务去启动socket，所以，我们还要创建一个Service，去处理socket。我这里就是非绑定启动这个服务。在oncreate方法里面去连接服务器即可 123456789101112131415161718192021package com.haichenyi.myproject.model.socketimport android.app.Serviceimport android.content.Intentimport android.os.IBinder/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class SocketService : Service() &#123; override fun onBind(intent: Intent?): IBinder? &#123; return null &#125; override fun onCreate() &#123; super.onCreate() Thread(Runnable &#123; SocketTcp.getInstance().setPort(8080).setHost(&quot;192.168.0.235&quot;).connect() &#125;).start() &#125;&#125; &emsp;&emsp;之所以要新建一个服务，就是可能你在连接socket的时候，可能要做一些其他信息的初始化，而这些信息初始化也是只有在连接socket服务器之前才需要的，写在这里方便一起管理，要是写在activity里面不便于管理。上面都是扯淡，最主要的是我们在最初学Android的时候，教你们的老师应该讲过，什么时候需要用到服务，就是不需要页面，用户并不关心它长什么样子，需要长连接的任务，都放在服务里面。正好，socket连接正好满足这些条件。 &emsp;&emsp;细心的同学可能注意了，我在Tcp类里面有一个EventBus，我这里是把发TCP消息给拿出来了，便于管理。我这边还新建了一个SocketUtils类，就是处理Socket请求的方法，我们发消息之类的方法，都是调用SocketUtils类里面的方法，不用去改Tcp类。这样做就只有一个目的，就是便于统一管理，代码如下 12345678910111213141516171819package com.haichenyi.myproject.model.socketimport com.haichenyi.myproject.model.bean.SocketTcpBeanimport org.greenrobot.eventbus.EventBus/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */object SocketUtils &#123; fun sendTcpMsg(msg: String) &#123; sendTcpMsg(SocketTcpBean(msg)) &#125; private fun sendTcpMsg(socketTcpBean: SocketTcpBean) &#123; EventBus.getDefault().post(socketTcpBean) &#125;&#125; &emsp;&emsp;至于这个SocketTcpBean类，就是一个普通的java bean类，里面就只有一个参数msg，你需要发的消息 UDP我先给出来代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.haichenyi.myproject.model.socketimport android.util.Logimport com.haichenyi.myproject.model.bean.SocketUdpBeanimport io.netty.bootstrap.Bootstrapimport io.netty.buffer.Unpooledimport io.netty.channel.Channelimport io.netty.channel.ChannelOptionimport io.netty.channel.EventLoopGroupimport io.netty.channel.nio.NioEventLoopGroupimport io.netty.channel.socket.DatagramPacketimport io.netty.channel.socket.nio.NioDatagramChannelimport org.greenrobot.eventbus.EventBusimport org.greenrobot.eventbus.Subscribeimport java.net.InetSocketAddressimport java.nio.charset.Charset/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class SocketUdp &#123; companion object &#123; private val socket = SocketUdp() fun getInstance(): SocketUdp = socket &#125; private var port: Int = 0 private var channel: Channel? = null private var group: EventLoopGroup? = null fun setPort(port: Int): SocketUdp &#123; this.port = port return this &#125; fun connect() &#123; if (null != channel) return if (null == group) &#123; if (!EventBus.getDefault().isRegistered(this)) EventBus.getDefault().register(this) group = NioEventLoopGroup() &#125; val bootstrap = Bootstrap() bootstrap.group(group) .channel(NioDatagramChannel::class.java) .option(ChannelOption.SO_BROADCAST, true) .handler(UdpHandler()) try &#123; channel = bootstrap.bind(port).sync().channel() channel!!.closeFuture().sync() &#125; catch (e: InterruptedException) &#123; e.printStackTrace() &#125; finally &#123; disConnect() &#125; &#125; /** * 断开tcp连接. */ private fun disConnect() &#123; if (null != group) &#123; group!!.shutdownGracefully() &#125;// EventBus.getDefault().unregister(this) group = null channel = null Log.v(&quot;WZ&quot;, &quot;disConnect&quot;) &#125; //连接成功后，通过Channel提供的接口进行IO操作 private fun sendMessage(host: String, port: Int, data: ByteArray) &#123; val packet = DatagramPacket(Unpooled.copiedBuffer(data), InetSocketAddress(host, port)) channel?.let &#123; try &#123; it.writeAndFlush(packet).sync() Log.d(&quot;wz&quot;, &quot;send succeed &quot; + String(data, Charset.forName(&quot;UTF-8&quot;))) &#125; catch (e: Exception) &#123; reConnect() e.printStackTrace() &#125; &#125; &#125; @Subscribe fun handle(socketUdpBean: SocketUdpBean) &#123; sendMessage(socketUdpBean.host,socketUdpBean.port,socketUdpBean.data) &#125; /** * 重连. */ private fun reConnect() &#123; Thread(Runnable &#123; this.connect() &#125;).start() &#125;&#125; 123456789101112131415161718192021222324package com.haichenyi.myproject.model.socketimport android.util.Logimport io.netty.channel.ChannelHandlerContextimport io.netty.channel.SimpleChannelInboundHandlerimport io.netty.channel.socket.DatagramPacketimport java.nio.charset.Charset/** * Author: 海晨忆 * Date: 2018/2/26 * Desc: */class UdpHandler : SimpleChannelInboundHandler&lt;DatagramPacket&gt;() &#123; override fun messageReceived(ctx: ChannelHandlerContext?, msg: DatagramPacket?) &#123; val byteBuf = msg!!.content() val bytes = ByteArray(byteBuf.readableBytes()) byteBuf.readBytes(bytes) val s = String(bytes, Charset.forName(&quot;UTF-8&quot;)) Log.v(&quot;WZ&quot;, &quot;UDP收到的消息是--&gt;$s&quot;) &#125;&#125; &emsp;&emsp;这里的代码跟TCP类似，我想说的就只有三点： 首先你客户端开启UDP的时候，需要bind一个端口号，这个端口号是服务器给你发消息的时候，需要的端口号。 它的管道里面的handle类型DatagramPacket 再有就是给目标主机发消息，UDP需要传目标地址，端口号，还有消息。这里的目标地址就是服务器的地址，端口号就是服务器跟你通信的端口号，消息就是你需要发送给服务器的信息 &emsp;&emsp;其实，这里的区别就是TCP与UDP的区别，TCP和UDP什么区别呢？ 类型 TCP UDP 是否连接 面向连接 面向非连接 传输效率 慢 快 数据是否有序 有序 无序 安全性 安全 不安全 模式 流模式 报文模式 系统资源 多 少 区别的总结：最典型的对比就是打电话（TCP）和发短信（UDP）的区别 是否连接方面，TCP是1对1，UDP可以1对N 传输效率：TCP必须等到一个消息全部传完了才能传下一个，UDP可以一直发 数据是否有序：TCP是按顺序一条一条的发，当然是有序的。UDP则是无序的 安全性方面：TCP有3次握手机制，采用的全双工的可靠信道，保证了数据的安全，UDP则没有3次握手机制，采用的是不可靠信道 模式方面：TCP是面向字节流，实际上TCP把数据看成了一连串无结构的字节流，UDP则是面向报文的 系统资源方面：TCP首部开销20个字节，UDP首部开销8个字节 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（五）—GreenDao的增删改查]]></title>
    <url>%2F2018%2F02%2F24%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94GreenDao%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇我们讲了GreenDao的数据库的依赖和创建，这一篇，我们来讲常用的增删改查四种方法。我们操作数据库都是Dao层，不同的表，有不懂的Dao层对象。我们上一篇的数据库接口的实现类里面，我们定义了UserDao，我们这一篇讲的就是操作我们昨天创建的user表。 &emsp;&emsp;在写下面几个方法之前，我还是先把MVP的用法先讲一遍吧，防止有人不知道，以增操作为例，另外三个就不再讲了： 点击页面的增按钮，我们要调用P层的方法去做增操作。效果图如下： P层的方法从哪来呢？P层实现的接口来撒，所以，我们只用在接口定义对应的方法，在P层去实现，效果图如下： 辣么，具体实现代码怎么写呢？既不记得，我们的装饰者模式，我们P层里面有一个DataHelper对象，通过它去调用对应的方法就可以了，效果图如下： 接下来，datahelper的方法又是从哪里来呢？我们的DataHelper是不是实现了SqlHelper接口，所以，直接在SqlHelper定义方法，在datahelper实现即可，效果图如下： 最后，前面只是调用了，具体实现在哪里呢？我之前有没有讲过装饰者模式，一个接口，两个实现方法，对，没错，就是在SqlImpl方法里面实现，效果图如下： &emsp;&emsp;通过以上5步，就完成我们的增操作。有同鞋就会问，那参数怎么传？我特么怎么知道需要传什么传输，你这个方法是干什么的，调用这个方法需要什么数据，你就丢在参数里面传过去，即可。 增方法12345//插入单个对象userDao.insert(user);//插入一个listuserDao.insertInTx(users); 调用12345//basePresenter.onAdd(User(&quot;小红&quot;, 1, 165, &quot;50KG&quot;, 18))val dataList = mutableListOf&lt;User&gt;()dataList.add(User(&quot;小刚&quot;, 2, 175, &quot;60KG&quot;, 28))dataList.add(User(&quot;小东&quot;, 2, 185, &quot;65KG&quot;, 25))basePresenter.onAddList(dataList) 效果图我就不贴出来了，如果，你的效果出不来，就肯定是你的代码写的有问题，我写这个博客都是边写代码，边写博客，我这边肯定是没问题的。 查方法1234//查询单个对象userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();//查询一个listuserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list(); 调用123456val user = basePresenter.onSelect(&quot;小红&quot;)println(user.name)val users = basePresenter.onSelectList(&quot;小东&quot;) users.forEach &#123; println(it.name) &#125; &emsp;&emsp;这里，我需要做一点说明，那就是手动能力强的宝宝，看见有两个查询方法，一个查询一个对象，一个查询list，这两个方法没问题，查询肯定是查询的一个，list里面也是只有一个对象，就有宝宝想着多插入几条数据，这个时候，项目就可能崩掉，因为，你插入的名字是相同的，我们这里名字是作为主键，表里面主键是不能相同的，所以就崩掉了，所以，你就得改表结构，正好测试我们之前说的版本更新问题，我这里亲测可用，数据也不会丢失。步骤如下： 修改数据库版本，把1改成2 User bean里面增加一个字段id Long类型，递增即可，clean，build项目 在你的Activity里面会报错，因为，你User的构造方法里面新增了一个参数，辣么这里你用的时候参数个数都不对，肯定报错，你把id字段对应的参数传null即可，他自己递增。这里也只有Long类型可以传null 重新运行项目，没有问题 删方法1234567891011121314151617181920/*//通过主键删除一个对象，删除满足条件的第一个对象 User user1 = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique(); //一定要记得做非空判断 if (user1 != null) &#123; userDao.deleteByKey(user1.getId()); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;); &#125;*/ //通过主键删除一个满足条件的List List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list(); if (list.size() &gt; 0) &#123; List&lt;Long&gt; keys = new ArrayList&lt;&gt;(); for (User user : list) &#123; keys.add(user.getId()); &#125; userDao.deleteByKeyInTx(keys); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;); &#125; 调用12//basePresenter.onDelete(&quot;小红&quot;)basePresenter.onDelete(&quot;小东&quot;) 改方法1234567891011List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(oldName)).build().list(); if (list.size() &gt; 0) &#123; for (User user : list) &#123; user.setName(newName); &#125;// userDao.update(user1); userDao.updateInTx(list); ToastUtils.Companion.showTipMsg(&quot;修改成功&quot;); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;未查询到相关数据&quot;); &#125; 调用1basePresenter.onUpdate(&quot;小刚&quot;, &quot;小贝&quot;) 完了，数据库的简单的增删改查 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（四）—Kotlin+GreenDao3.2]]></title>
    <url>%2F2018%2F02%2F24%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94Kotlin-GreenDao3-2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本篇介绍android常用的数据库之一GreenDao的简单用法，增删改查。基于前面搭的框架，当然，你也可以选择不用。看懂用法之后，用起来很方便。GreenDao数据库升级到3.0版本之后api用起来更加方便了，便于让开发人员专注于业务逻辑。我需要额外说明的是，我把之前的项目框架转成了kotlin，不会kotlin语法的同学，可以去研究一下。 添加依赖最终，我们要添加如下代码，效果图如下： 第一步&emsp;&emsp;打开的你根目录下面的build.gradle文件，也就是项目下面的，并不是app目录下面的build.gradle。 12345678910111213// In your root build.gradle file:buildscript &#123; repositories &#123; jcenter() ...//其他你自己的 mavenCentral() // add repository &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.0&apos; ...//其他你自己的 classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin &#125;&#125; 第二步&emsp;&emsp;打开你的项目下面的build.gradle文件，也就是你的app目录下面的，之前我们添加依赖的时候的那个文件 1234567// In your app projects build.gradle file:apply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin dependencies &#123; compile &apos;org.greenrobot:greendao:3.2.2&apos; // add library&#125; &emsp;&emsp;完成上面两步，辣么，关于greendao的依赖我们就添加完成了 初始化&emsp;&emsp;我们首先得有一个bean类，这个bean类对应的就是数据库表的表结构。我这里想说明的是（敲黑板了），看到了很多网上说的什么主键id必须用Long类型，这种说法是不准确的，准确的说，你的主键字段名称，如果是“id”，辣么，你这个字段“id”，必须用Long类型，如果你换一个名称，比方说“myId”，辣么，你就不必用Long类型，这个问题，说大不大，说小，又困扰了我有一会。我这里新建用户表，就需要一个User的java bean类。如下： 1234567891011121314151617181920212223242526package com.haichenyi.myproject.model.bean;import org.greenrobot.greendao.annotation.Entity;import org.greenrobot.greendao.annotation.Id;import org.greenrobot.greendao.annotation.NotNull;import org.greenrobot.greendao.annotation.Property;import org.greenrobot.greendao.annotation.Transient;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: 用户表的bean类 */@Entitypublic class User &#123; @Id private String name; private int sex; @Property(nameInDb = &quot;Height&quot;) private int height; private String weight; @NotNull private int age; @Transient private String character;&#125; &emsp;&emsp;这里我把几个常用的注解都写出来了，说一下这几个注解是什么意思 注解 意义 @Entity 用于标识这是一个需要Greendao帮我们生成代码的bean @Id 标明主键，括号里可以指定是否自增 @Property 用于设置属性在数据库中的列名（默认不写就是保持一致） @NotNull 非空 @Transient 标识这个字段是自定义的不会创建到数据库表里 简单的讲一下： @Entity：标识的bean类，我们在运行的时候，greendao会自动帮我们生成对应的表 @Id：标识的字段就是这个表对应的主键 @Property：标识的字段在表中对应的那一栏的名称是后面括号里面的，这个表height字段对应表中的Height，一般我们直接设置成默认就可以了 @NotNull：标识的字段，这个字段在表中不能为空，不然就出错，所以，在添加数据的时候设置默认值 @Transient：标识的字段，在生成表的时候不会生成对应的字段。这个什么时候用呢？这个，我一般用作标记flag，比方说，从数据库拿数据，又不想重新写一个bean类，就用这个bean类，RecyclerView，填充完数据，item点击的时候，状态发生变化，我们要有一个flag，就通过修改这个字段的值，页面做出相应的变化。 &emsp;&emsp;写到这里，我们的bean类也有了，要怎么生成数据库呢？在生成数据库之前，我们先把项目重新clean一遍，再build一遍，看到你刚写的需要生成表的bean类变成了如下样子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.haichenyi.myproject.model.bean;import org.greenrobot.greendao.annotation.Entity;import org.greenrobot.greendao.annotation.Id;import org.greenrobot.greendao.annotation.NotNull;import org.greenrobot.greendao.annotation.Property;import org.greenrobot.greendao.annotation.Transient;import org.greenrobot.greendao.annotation.Generated;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: 用户表的bean类 */@Entitypublic class User &#123; @Id private String name; private int sex; @Property(nameInDb = &quot;Height&quot;) private int height; private String weight; @NotNull private int age; @Transient private String character; @Generated(hash = 717717955) public User(String name, int sex, int height, String weight, int age) &#123; this.name = name; this.sex = sex; this.height = height; this.weight = weight; this.age = age; &#125; @Generated(hash = 586692638) public User() &#123; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getSex() &#123; return this.sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public int getHeight() &#123; return this.height; &#125; public void setHeight(int height) &#123; this.height = height; &#125; public String getWeight() &#123; return this.weight; &#125; public void setWeight(String weight) &#123; this.weight = weight; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; &emsp;&emsp;如上，greendao通过注解的方式帮我们自动生成了set/get方法，还有构造方法，这就对了，我们不用关，之后我们再执行如下代码生成数据库和表： 123DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(getApplicationContext(), &quot;haichenyi.db&quot;, null);DaoMaster daoMaster = new DaoMaster(devOpenHelper.getWritableDb());DaoSession daoSession = daoMaster.newSession(); &emsp;&emsp;通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。注意：默认的 DaoMaster.DevOpenHelper会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。升级的问题，我们在后面讲，这里我们先把数据库和表先创建了。 &emsp;&emsp;上面这个方式是java格式的，由于，我昨天写完框架之后，我把项目转成了kotlin代码，所以这里有点不一样，项目我后面会上传。这里我要说明的是（敲黑板）我用kotlin的时候，碰到了一个问题，当我使用greendao的时候，他提示我，无法引入用注解方式生成的类，dagger2也是一样的，我用java代码写就没有问题，我写这篇博客的时候，目前还没有找到解决的办法。 &emsp;&emsp;我用了另外一种方式，采用跟之前网络请求一样的设计模式——装饰者模式。我这里就不多做说明了。我贴出我的代码。 SqlHelper 12345678910111213141516package com.haichenyi.myproject.model.sql;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public interface SqlHelper &#123; void onAdd(); void onDelete(); void onUpdate(); void onSelect();&#125; &emsp;&emsp;这里定义增删改查4个方法，用于测试这4个功能 SqlImpl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.haichenyi.myproject.model.sql;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.model.bean.DaoMaster;import com.haichenyi.myproject.model.bean.DaoSession;import com.haichenyi.myproject.model.bean.UserDao;import com.haichenyi.myproject.utils.ToastUtils;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public class SqlImpl implements SqlHelper &#123; private final UserDao userDao; /** * 初始化Sql Dao. * * @param application &#123;@link MyApplication&#125; */ public SqlImpl(MyApplication application) &#123; SqlOpenHelper helper = new SqlOpenHelper(application, &quot;haichenyi.db&quot;); DaoSession daoSession = new DaoMaster(helper.getWritableDb()).newSession(); userDao = daoSession.getUserDao(); &#125; @Override public void onAdd() &#123; ToastUtils.Companion.showTipMsg(&quot;增加数据&quot;); &#125; @Override public void onDelete() &#123; ToastUtils.Companion.showTipMsg(&quot;删除数据&quot;); &#125; @Override public void onUpdate() &#123; ToastUtils.Companion.showTipMsg(&quot;更新数据&quot;); &#125; @Override public void onSelect() &#123; ToastUtils.Companion.showTipMsg(&quot;查询数据&quot;); &#125;&#125; &emsp;&emsp;功能实现类，看到他的构造方法里面，第二个参数就是我们的数据库名称，后面通过getWritableDb()获取的是可写的数据库，可写就肯定可读。然后就是接口的实现类了，这里就是具体的增删改查功能的实现类，我这里在对应的方法里面就写了Toast，增删改查具体怎么写后面再说 SqlOpenHelper 12345678910111213141516171819202122232425262728293031323334353637package com.haichenyi.myproject.model.sql;import android.content.Context;import com.haichenyi.myproject.model.bean.DaoMaster;import com.haichenyi.myproject.model.bean.UserDao;import org.greenrobot.greendao.database.Database;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public class SqlOpenHelper extends DaoMaster.OpenHelper &#123; public SqlOpenHelper(Context context, String name) &#123; super(context, name); &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123; super.onUpgrade(db, oldVersion, newVersion); MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() &#123; @Override public void onCreateAllTables(Database db, boolean ifNotExists) &#123; DaoMaster.createAllTables(db, ifNotExists); &#125; @Override public void onDropAllTables(Database db, boolean ifExists) &#123; DaoMaster.dropAllTables(db, ifExists); &#125; &#125;, UserDao.class); &#125;&#125; &emsp;&emsp;这个类用于管理数据库的表对应的字段发生变化的时候，数据库需要进行的版本更新，连上下面那个类，都是用于版本数据库版本更新的，防止数据丢失。怎么写呢？看到最后面的&emsp;UserDao.class&emsp;了吗？这个就是我们需要更新的表，你哪个表需要更新，直接写在后面就可以了，这个是可以一次传多个表的，并不是一次只能传一个 MigrationHelper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246package com.haichenyi.myproject.model.sql;import android.database.Cursor;import android.database.SQLException;import android.database.sqlite.SQLiteDatabase;import android.support.annotation.NonNull;import android.text.TextUtils;import android.util.Log;import org.greenrobot.greendao.AbstractDao;import org.greenrobot.greendao.database.Database;import org.greenrobot.greendao.database.StandardDatabase;import org.greenrobot.greendao.internal.DaoConfig;import java.lang.ref.WeakReference;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * Author: 海晨忆. * Date: 2018/2/24 * Desc: */public final class MigrationHelper &#123; public static boolean DEBUG = false; private static String TAG = &quot;MigrationHelper&quot;; private static final String SQLITE_MASTER = &quot;sqlite_master&quot;; private static final String SQLITE_TEMP_MASTER = &quot;sqlite_temp_master&quot;; private static WeakReference&lt;ReCreateAllTableListener&gt; weakListener; public interface ReCreateAllTableListener &#123; void onCreateAllTables(Database db, boolean ifNotExists); void onDropAllTables(Database db, boolean ifExists); &#125; public static void migrate(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; printLog(&quot;【The Old Database Version】&quot; + db.getVersion()); Database database = new StandardDatabase(db); migrate(database, daoClasses); &#125; public static void migrate(SQLiteDatabase db, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; weakListener = new WeakReference&lt;&gt;(listener); migrate(db, daoClasses); &#125; public static void migrate(Database database, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; weakListener = new WeakReference&lt;&gt;(listener); migrate(database, daoClasses); &#125; public static void migrate(Database database, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; printLog(&quot;【Generate temp table】start&quot;); generateTempTables(database, daoClasses); printLog(&quot;【Generate temp table】complete&quot;); ReCreateAllTableListener listener = null; if (weakListener != null) &#123; listener = weakListener.get(); &#125; if (listener != null) &#123; listener.onDropAllTables(database, true); printLog(&quot;【Drop all table by listener】&quot;); listener.onCreateAllTables(database, false); printLog(&quot;【Create all table by listener】&quot;); &#125; else &#123; dropAllTables(database, true, daoClasses); createAllTables(database, false, daoClasses); &#125; printLog(&quot;【Restore data】start&quot;); restoreData(database, daoClasses); printLog(&quot;【Restore data】complete&quot;); &#125; private static void generateTempTables(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; String tempTableName = null; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; if (!isTableExists(db, false, tableName)) &#123; printLog(&quot;【New Table】&quot; + tableName); continue; &#125; try &#123; tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;); StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append(&quot;DROP TABLE IF EXISTS &quot;).append(tempTableName).append(&quot;;&quot;); db.execSQL(dropTableStringBuilder.toString()); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append(&quot;CREATE TEMPORARY TABLE &quot;).append(tempTableName); insertTableStringBuilder.append(&quot; AS SELECT * FROM &quot;).append(tableName).append(&quot;;&quot;); db.execSQL(insertTableStringBuilder.toString()); printLog(&quot;【Table】&quot; + tableName + &quot;\n ---Columns--&gt;&quot; + getColumnsStr(daoConfig)); printLog(&quot;【Generate temp table】&quot; + tempTableName); &#125; catch (SQLException e) &#123; Log.e(TAG, &quot;【Failed to generate temp table】&quot; + tempTableName, e); &#125; &#125; &#125; private static boolean isTableExists(Database db, boolean isTemp, String tableName) &#123; if (db == null || TextUtils.isEmpty(tableName)) &#123; return false; &#125; String dbName = isTemp ? SQLITE_TEMP_MASTER : SQLITE_MASTER; String sql = &quot;SELECT COUNT(*) FROM &quot; + dbName + &quot; WHERE type = ? AND name = ?&quot;; Cursor cursor = null; int count = 0; try &#123; cursor = db.rawQuery(sql, new String[]&#123;&quot;table&quot;, tableName&#125;); if (cursor == null || !cursor.moveToFirst()) &#123; return false; &#125; count = cursor.getInt(0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); &#125; return count &gt; 0; &#125; private static String getColumnsStr(DaoConfig daoConfig) &#123; if (daoConfig == null) &#123; return &quot;no columns&quot;; &#125; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; daoConfig.allColumns.length; i++) &#123; builder.append(daoConfig.allColumns[i]); builder.append(&quot;,&quot;); &#125; if (builder.length() &gt; 0) &#123; builder.deleteCharAt(builder.length() - 1); &#125; return builder.toString(); &#125; private static void dropAllTables(Database db, boolean ifExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; reflectMethod(db, &quot;dropTable&quot;, ifExists, daoClasses); printLog(&quot;【Drop all table by reflect】&quot;); &#125; private static void createAllTables(Database db, boolean ifNotExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; reflectMethod(db, &quot;createTable&quot;, ifNotExists, daoClasses); printLog(&quot;【Create all table by reflect】&quot;); &#125; /** * dao class already define the sql exec method, so just invoke it */ private static void reflectMethod(Database db, String methodName, boolean isExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; if (daoClasses.length &lt; 1) &#123; return; &#125; try &#123; for (Class cls : daoClasses) &#123; Method method = cls.getDeclaredMethod(methodName, Database.class, boolean.class); method.invoke(null, db, isExists); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; private static void restoreData(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; String tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;); if (!isTableExists(db, true, tempTableName)) &#123; continue; &#125; try &#123; // get all columns from tempTable, take careful to use the columns list List&lt;String&gt; columns = getColumns(db, tempTableName); ArrayList&lt;String&gt; properties = new ArrayList&lt;&gt;(columns.size()); for (int j = 0; j &lt; daoConfig.properties.length; j++) &#123; String columnName = daoConfig.properties[j].columnName; if (columns.contains(columnName)) &#123; properties.add(&quot;`&quot; + columnName + &quot;`&quot;); &#125; &#125; if (properties.size() &gt; 0) &#123; final String columnSQL = TextUtils.join(&quot;,&quot;, properties); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append(&quot;REPLACE INTO &quot;).append(tableName).append(&quot; (&quot;); insertTableStringBuilder.append(columnSQL); insertTableStringBuilder.append(&quot;) SELECT &quot;); insertTableStringBuilder.append(columnSQL); insertTableStringBuilder.append(&quot; FROM &quot;).append(tempTableName).append(&quot;;&quot;); db.execSQL(insertTableStringBuilder.toString()); printLog(&quot;【Restore data】 to &quot; + tableName); &#125; StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append(&quot;DROP TABLE &quot;).append(tempTableName); db.execSQL(dropTableStringBuilder.toString()); printLog(&quot;【Drop temp table】&quot; + tempTableName); &#125; catch (SQLException e) &#123; Log.e(TAG, &quot;【Failed to restore data from temp table 】&quot; + tempTableName, e); &#125; &#125; &#125; private static List&lt;String&gt; getColumns(Database db, String tableName) &#123; List&lt;String&gt; columns = null; Cursor cursor = null; try &#123; cursor = db.rawQuery(&quot;SELECT * FROM &quot; + tableName + &quot; limit 0&quot;, null); if (null != cursor &amp;&amp; cursor.getColumnCount() &gt; 0) &#123; columns = Arrays.asList(cursor.getColumnNames()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); if (null == columns) columns = new ArrayList&lt;&gt;(); &#125; return columns; &#125; private static void printLog(String info) &#123; if (DEBUG) &#123; Log.d(TAG, info); &#125; &#125;&#125; &emsp;&emsp;这个类是工具类，拿过去用就好了，还有就是，应用怎么判断是否需要版本更新呢？打开你的app下面的build.grade，在根结点下面添加如下代码： 123greendao &#123; schemaVersion 1&#125; 每当你发布新版本的时候，把这个版本号+1即可。 &emsp;&emsp;当然，我门这里依然是用的dagger生成的全局单例，所以，你还需要在你的AppModule下面添加如下代码： 12345@Provides@SingletonSqlHelper provideSqlHelper() &#123; return new SqlImpl(application);&#125; &emsp;&emsp;记得把项目重新clean一遍，build一遍，重新跑项目的时候，找到你的数据库。data-data-你的应用包名-databases-haichenyi.db，这个就是我们的数据库。找个Sqlite可视化工具打开，你会看到如下结构。 &emsp;&emsp;太多了，不写了，下一篇写增删改查。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（三）—RxJava2.0+Retrofit2.0+OkHttp]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94RxJava2-0-Retrofit2-0-OkHttp%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇，我们把mvp+dagger加进去了，这一篇，我们把网络请求加上 &emsp;&emsp;我这里的网络请求是用的装饰者模式去写的，什么是装饰者模式呢？在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。我的理解就是一个接口，两个实现类，一个实现类负责调用接口的方法，另一个类负责功能的具体实现。本文中所提到的代码都是伪代码，最后会给出完整的，最初版本的项目框架。不包含任何业务逻辑 &emsp;&emsp;容我一个一个来说，首先，我们一般请求网络的时候，会有统一的返回数据格式，一个是需要判断返回code码的，就比方说登录功能，那登录成功，还是失败，我们只用判断code码即可，这种类型，我们统一是HttpNoResult。还有一个是返回数据的，就比方说查一个列表数据。这里我们统一的是HttpResult。我先给出这两个类的代码： 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.model.http;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:没有解析数据的返回 */public class HttpNoResult &#123; private int code; private String msg; public int getCode() &#123; return code; &#125; public HttpNoResult setCode(int code) &#123; this.code = code; return this; &#125; public String getMsg() &#123; return msg; &#125; public HttpNoResult setMsg(String msg) &#123; this.msg = msg; return this; &#125; @Override public String toString() &#123; return &quot;HttpNoResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.haichenyi.myproject.model.http;import com.google.gson.annotations.SerializedName;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:有解析数据的返回 */public class HttpResult&lt;T&gt; &#123; private int code; private String msg; @SerializedName(value = &quot;result&quot;) private T data; public int getCode() &#123; return code; &#125; public HttpResult setCode(int code) &#123; this.code = code; return this; &#125; public String getMsg() &#123; return msg; &#125; public HttpResult setMsg(String msg) &#123; this.msg = msg; return this; &#125; public T getData() &#123; return data; &#125; public HttpResult setData(T data) &#123; this.data = data; return this; &#125; @Override public String toString() &#123; return &quot;HttpResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &quot;, data=&quot; + data + &apos;&#125;&apos;; &#125;&#125; &emsp;&emsp;这里我就需要说一点，有数据返回的时候，每个数据类型都是不一样的，所以，这里我用的泛型传递，不同的数据类型，传不同的bean对象 &emsp;&emsp;言归正传，我们来说说网络请求的一个接口，两个实现类。 一个接口—HttpHelper 1234567891011121314151617181920package com.haichenyi.myproject.model.http;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络接口，接口参数Token统一处理，方法中不传Token */public interface HttpHelper &#123; /** * 登录时获取验证码. * * @param phone 手机号 * @return &#123;&quot;code&quot;:0&#125; */ Flowable&lt;HttpNoResult&gt; loginCode(String phone); /*Flowable&lt;HttpResult&lt;Login&gt;&gt; login(String phone, String code); Flowable&lt;HttpResult&lt;List&lt;DiyBean&gt;&gt;&gt; diyKeys(String allId);*/&#125; &emsp;&emsp;Flowable是RxJava2.0新增的，所以说RxJava完美兼容Retrofit，泛型就是我们需要解析的数据 loginCode方法是说返回数据，我们只用判断是否是成功还是失败， login方法是说返回数据是一个Login对象，至于对象是什么内容，那就是和你们后台确认了 diyKeys方法就是说，返回数据是一个list对象，每个list的item是DiyBean对象 123456789101112131415161718192021222324package com.haichenyi.myproject.model;import com.haichenyi.myproject.model.http.HttpHelper;import com.haichenyi.myproject.model.http.HttpNoResult;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求的实现类 */public class DataHelper implements HttpHelper &#123; private HttpHelper http; public DataHelper(HttpHelper http) &#123; this.http = http; &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return http.loginCode(phone); &#125;&#125; &emsp;&emsp;DataHelper是HttpHelper的实现类，他的唯一作用就是调用接口的方法即可，具体的功能实现是后面一个类，这里需要说明的是这个类的构造方法要public表示，因为他要dagger生成，用private或者protected表示无法生成。 123456789101112131415161718192021222324package com.haichenyi.myproject.model.http;import com.haichenyi.myproject.model.http.api.HttpApi;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: 网络接口Retrofit实现 */public class RetrofitHelper implements HttpHelper&#123; private HttpApi httpApi; @Inject RetrofitHelper(HttpApi httpApi) &#123; this.httpApi = httpApi; &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return httpApi.loginCode(phone); &#125;&#125; &emsp;&emsp;RetrofitHelper类作为HttpHelper接口的实现类，他是具体功能的实现类，为什么说他是具体功能的实现类呢？因为，他是调用HttpApi接口的方法。HttpApi接口是干什么用的呢？ 1234567891011121314151617181920212223242526package com.haichenyi.myproject.model.http.api;import com.haichenyi.myproject.model.http.HttpNoResult;import com.haichenyi.myproject.model.http.ProtocolHttp;import io.reactivex.Flowable;import retrofit2.http.Field;import retrofit2.http.FormUrlEncoded;import retrofit2.http.POST;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求接口api */public interface HttpApi &#123; /** * 登录时获取验证码. * * @param phone 手机号 * @return &#123;&quot;code&quot;:0&#125; */ @FormUrlEncoded @POST(ProtocolHttp.METHOD_LOGIN_CODE) Flowable&lt;HttpNoResult&gt; loginCode(@Field(&quot;phone&quot;) String phone);&#125; 这个就是Retrofit的网络请求的方式，看不懂？这个就是Retrofit的东西了方法注解，包含@GET、@POST、@PUT、@DELETE、@PATH、@HEAD、@OPTIONS、@HTTP。标记注解，包含@FormUrlEncoded、@Multipart、@Streaming。参数注解，包含@Query、@QueryMap、@Body、@Field，@FieldMap、@Part，@PartMap。其他注解，包含@Path、@Header、@Headers、@Url。 这里我们还差一个接口 123456789101112package com.haichenyi.myproject.model.http;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface ProtocolHttp &#123; String HTTP_HOST = &quot;http://xxx.xx.xxx.xxx:8080/app/con/&quot;; String HTTP_COMMON = &quot;common/&quot;; String METHOD_LOGIN_CODE = HTTP_COMMON + &quot;code&quot;;//登录发送验证码&#125; &emsp;&emsp;如上，这里需要注意的是不能以”\”结尾，然后就是，跟你们后台商量，格式不要错了，尽量就只有接口名字不同，接口名字前面部分都是一样的。 &emsp;&emsp;到此，这里基本上就说完了，那么有同鞋就会问了，接口定义方法的时候，我们知道该如何写返回数据类型呢？这个我就不知道了，你得问你们后台，根据后台返回的数据类型去写对应的bean类。推荐一个功能PostMan。 &emsp;&emsp;到目前为止，我们都还没有初始化网络请求的参数，这些网络请求的参数在哪里初始化呢？这些参数，我们就只用初始化一次，我们就想到了dagger的全局单例模式，没错，就是这个，我们上一篇写了很多没有用的东西，里面有一个HttpModule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.di.qualifier.ApiUrl;import com.haichenyi.myproject.model.http.ProtocolHttp;import com.haichenyi.myproject.model.http.api.HttpApi;import java.util.concurrent.TimeUnit;import javax.inject.Singleton;import dagger.Module;import dagger.Provides;import okhttp3.OkHttpClient;import retrofit2.Retrofit;import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;import retrofit2.converter.gson.GsonConverterFactory;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求的参数初始化 */@Modulepublic class HttpModule &#123; @Provides @Singleton OkHttpClient.Builder providesOkHttpHelper() &#123;//请求读写超时时间 return new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .readTimeout(10, TimeUnit.SECONDS) .writeTimeout(10, TimeUnit.SECONDS); &#125; @Provides @Singleton OkHttpClient provideClient(OkHttpClient.Builder builder) &#123; return builder// .addInterceptor(new MyHttpInterceptor()) .build(); &#125; @Provides @Singleton Retrofit.Builder providesRetrofitBuilder() &#123; return new Retrofit.Builder(); &#125; @Provides @Singleton HttpApi provideApi(@ApiUrl Retrofit retrofit) &#123; return retrofit.create(HttpApi.class); &#125; @Provides @Singleton @ApiUrl Retrofit providesApiRetrofit(Retrofit.Builder builder, OkHttpClient client) &#123; return createRetrofit(builder, client, ProtocolHttp.HTTP_HOST);//这里就是你的网络请求的url &#125; private Retrofit createRetrofit(Retrofit.Builder builder, OkHttpClient client, String host) &#123; return builder.client(client) .baseUrl(host) .addConverterFactory(GsonConverterFactory.create())//添加gson自动解析，我们不用关 .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); &#125;&#125; 如上代码，注释写的都有，考过去用就行了 在AppModule里面添加如下代码 12345678910111213141516171819202122232425262728293031323334353637package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.model.DataHelper;import com.haichenyi.myproject.model.http.HttpHelper;import com.haichenyi.myproject.model.http.RetrofitHelper;import javax.inject.Singleton;import dagger.Module;import dagger.Provides;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class AppModule &#123; private MyApplication application; public AppModule(MyApplication application) &#123; this.application = application; &#125; @Provides @Singleton DataHelper provideDataHelper(HttpHelper httpHelper) &#123; return new DataHelper(httpHelper); &#125; @Provides @Singleton HttpHelper provideHttpHelper(RetrofitHelper retrofitHelper) &#123; return retrofitHelper; &#125;&#125; 这里都是dagger了生成全局单例对象需要的东西 在AppComponent里面添加如下代码 1234567891011121314151617181920package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.di.module.AppModule;import com.haichenyi.myproject.di.module.HttpModule;import com.haichenyi.myproject.model.DataHelper;import javax.inject.Singleton;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Singleton@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)public interface AppComponent &#123; DataHelper getDataHelper();&#125; 在BaseMvpPresenter里面添加如下代码 123456789101112131415161718192021222324252627282930313233343536373839package com.haichenyi.myproject.base;import io.reactivex.disposables.CompositeDisposable;import io.reactivex.disposables.Disposable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123; protected T baseView; private CompositeDisposable disposables; @Override public void attachView(T baseView) &#123; this.baseView = baseView; &#125; protected void addSubscribe(Disposable disposable) &#123; if (null == disposables) &#123; disposables = new CompositeDisposable(); &#125; disposables.add(disposable); &#125; @Override public void detachView() &#123; this.baseView = null; unSubscribe(); &#125; private void unSubscribe() &#123; if (null != disposables) &#123; disposables.clear(); disposables = null; &#125; &#125;&#125; 至此，就全部写完了，关于网络请求的内容。调用方式如下： 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.model.DataHelper;import javax.inject.Inject;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; private DataHelper dataHelper; @Inject MainPresenter() &#123; dataHelper = MyApplication.getAppComponent().getDataHelper(); &#125; @Override public void loadData() &#123; addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe());// baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; 记得在清单文件里面，加上网络权限 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 网络请求，这样调用之后在哪处理呢？我给出我的几个处理的工具类。首先，按如下图设置1.8支持lambda表达式 然后添加如下几个类 HttpCode 123456789101112131415161718192021package com.haichenyi.myproject.model.http;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 网络请求状态码 */public interface HttpCode &#123; /** * 成功. */ int SUCCESS = 0; /** * 参数为空. */ int NO_PARAMETER = 1; /** * 服务器错误. */ int SERVER_ERR = 3;&#125; ApiException 1234567891011121314151617181920212223242526272829package com.haichenyi.myproject.model.http;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 接口异常判断处理 */public class ApiException extends Exception &#123; private int code; @SuppressWarnings(&quot;unused&quot;) public ApiException(int code) &#123; this.code = code; &#125; public ApiException(int code, String message) &#123; super(message); this.code = code; &#125; public int getCode() &#123; return code; &#125; public ApiException setCode(int code) &#123; this.code = code; return this; &#125;&#125; MyRxUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.haichenyi.myproject.model.http;import io.reactivex.BackpressureStrategy;import io.reactivex.Flowable;import io.reactivex.FlowableTransformer;import io.reactivex.Scheduler;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆. * Date: 2017/12/27 * Desc:切换线程的工具类 */public class MyRxUtils &#123; /** * 从其他线程转到主线程. * * @param scheduler Schedulers.io()等等 * @param &lt;T&gt; t * @return FlowableTransformer */ public static &lt;T&gt; FlowableTransformer&lt;T, T&gt; toMain(Scheduler scheduler) &#123; return upstream -&gt; upstream.subscribeOn(scheduler).observeOn(AndroidSchedulers.mainThread()); &#125; public static &lt;T&gt; FlowableTransformer&lt;HttpResult&lt;T&gt;, T&gt; handResult() &#123; return upstream -&gt; upstream.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .flatMap(tHttpResult -&gt; &#123; if (tHttpResult.getCode() == HttpCode.SUCCESS) &#123; return /*createData(tHttpResult.data)*/Flowable.just(tHttpResult.getData()); &#125; else &#123; return Flowable.error(new ApiException(tHttpResult.getCode(), tHttpResult.getMsg())); &#125; &#125;); &#125; private static &lt;T&gt; Flowable&lt;T&gt; createData(final T data) &#123; return Flowable.create(e -&gt; &#123; e.onNext(data); e.onComplete(); &#125;, BackpressureStrategy.ERROR); &#125;&#125; MySubscriber 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.haichenyi.myproject.model.http;import com.haichenyi.myproject.base.BaseView;import io.reactivex.subscribers.ResourceSubscriber;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123; private BaseView baseView; private boolean showLoading; public MySubscriber(BaseView baseView) &#123; this.baseView = baseView; &#125; public MySubscriber(BaseView baseView, boolean showLoading) &#123; this.baseView = baseView; this.showLoading = showLoading; &#125; @Override protected void onStart() &#123; super.onStart(); if (null != baseView &amp;&amp; showLoading) &#123; baseView.showLoading(); &#125; &#125; @Override public void onError(Throwable t) &#123; if (null == baseView) &#123; return; &#125; baseView.hideLoading(); if (t instanceof ApiException) &#123; ApiException apiException = (ApiException) t; switch (apiException.getCode()) &#123; case HttpCode.NO_PARAMETER: baseView.showTipMsg(&quot;参数为空&quot;); break; case HttpCode.SERVER_ERR: baseView.showTipMsg(&quot;服务器错误&quot;); break; default: break; &#125; &#125; &#125; @Override public void onComplete() &#123; if (null != baseView) &#123; baseView.hideLoading(); &#125; &#125;&#125; 这几个类不想多做解释，结合注释，仔细看几遍，就知道是干嘛用的了 加上这几个之后调用方式就变成了以下的方式： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.model.DataHelper;import com.haichenyi.myproject.model.http.HttpNoResult;import com.haichenyi.myproject.model.http.MyRxUtils;import com.haichenyi.myproject.model.http.MySubscriber;import javax.inject.Inject;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; private DataHelper dataHelper; @Inject MainPresenter() &#123; dataHelper = MyApplication.getAppComponent().getDataHelper(); &#125; @Override public void loadData() &#123; addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;) .compose(MyRxUtils.toMain(Schedulers.io())) .subscribeWith(new MySubscriber&lt;HttpNoResult&gt;(baseView, true) &#123; @Override public void onNext(HttpNoResult httpNoResult) &#123; &#125; &#125;));// baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; 完了，完了，终于写完了。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（二）—MVP+dagger2]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94MVP-dagger2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;接着上一篇简单的框架，没有看过的同鞋可以去喵一眼。上一篇我们搭好了简单的框架，初始化一次的内容丢在Application里面，所有的activity继承一个类BaseActivity，还有Fragment继承的一个类BaseFragment &emsp;&emsp;现在我们来加上MVP，不懂MVP的同鞋可以看一下，我前面写过的三种主流框架的对比。我们先导入dagger2的两个包，代码如下： 12implementation &apos;com.google.dagger:dagger:2.14.1&apos;annotationProcessor &quot;com.google.dagger:dagger-compiler:2.14.1&quot; 第一步&emsp;&emsp;新建BasePresenter接口，BaseMvpPresenter类去实现BasePresenter接口，代码如下 123456789101112package com.shfzwkeji.smartwardrobe.base;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 不带mvp的presenter的基类 */public interface BasePresenter&lt;T extends BaseView&gt; &#123; void attachView(T baseView); void detachView();&#125; 1234567891011121314151617181920package com.haichenyi.myproject.base;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:带mvp的presenter的基类 */public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123; protected T baseView; @Override public void attachView(T baseView) &#123; this.baseView = baseView; &#125; @Override public void detachView() &#123; this.baseView = null; &#125;&#125; &emsp;&emsp;这里就只有两个方法，一个是绑定view，还有一个是在ondestory方法里面解除绑定的方法，用来保证P层的生命周期和V层同步，避免了，当V层销毁的时候，P层仍然存在造成的内存泄漏。 第二步&emsp;&emsp;新建BaseMvpActivity 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.base;import javax.inject.Inject;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:带MVP的Activity */public abstract class BaseMvpActivity&lt;T extends BasePresenter&gt; extends BaseActivity&#123; @Inject protected T basePresenter; @Override @SuppressWarnings(&quot;unchecked&quot;) protected void initView() &#123; super.initView(); initInject(); if (null != basePresenter) &#123; basePresenter.attachView(this); &#125; &#125; protected abstract void initInject(); @Override protected void onDestroy() &#123; if (null != basePresenter) &#123; basePresenter.detachView(); basePresenter = null; &#125; super.onDestroy(); &#125;&#125; &emsp;&emsp;运用dagger2注解的方式，生成P层，这里我们在用P层之前得先生成P层，所以initject方法一定要在basePresenter用之前调用，因为他就是生成P层的代码。 &emsp;&emsp;怎么生成呢？dagger我们一般都命名成di层，所以，我们先创建di层的package，项目结构图如下： &emsp;&emsp;这里给出的是mvp+dagger加入之后的项目结构。我们重点看选中的di层，里面有4个package分别是component，module，qualifier，scope四个包，至于他们的作用分别是什么，请自行百度，google，dagger的用法。我这里先贴出这几个类，接口的代码： ActivityComponent 123456789101112131415161718package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.MainActivity;import com.haichenyi.myproject.di.module.ActivityModule;import com.haichenyi.myproject.di.scope.ActivityScope;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@ActivityScope@Component(dependencies = AppComponent.class, modules = ActivityModule.class)public interface ActivityComponent &#123; void inject(MainActivity mainActivity);&#125; AppComponent 123456789101112131415161718package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.di.module.AppModule;import com.haichenyi.myproject.di.module.HttpModule;import javax.inject.Singleton;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Singleton@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)public interface AppComponent &#123;&#125; ActivityModule 123456789101112package com.haichenyi.myproject.di.module;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class ActivityModule &#123;&#125; AppModule 12345678910111213141516171819package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.base.MyApplication;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class AppModule &#123; private MyApplication application; public AppModule(MyApplication application) &#123; this.application = application; &#125;&#125; HttpModule 123456789101112package com.haichenyi.myproject.di.module;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class HttpModule &#123;&#125; ActivityScope 12345678910111213141516package com.haichenyi.myproject.di.scope;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import javax.inject.Scope;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Scope@Retention(RetentionPolicy.RUNTIME)public @interface ActivityScope &#123;&#125; &emsp;&emsp;这几个类，接口里面基本上都没有内容，因为这几个类都是后面才会用的到的，这里我直接贴出来，说起来方便一些。还需要加两个方法，在MyApplication里面加如下方法: 1234567891011121314/** * 获取AppComponent. * * @return AppComponent */ public static synchronized AppComponent getAppComponent() &#123; if (null == appComponent) &#123; appComponent = DaggerAppComponent.builder() .appModule(new AppModule(getInstance())) .httpModule(new HttpModule()) .build(); &#125; return appComponent; &#125; 在BaseActivity里面加如下方法： 123456protected ActivityComponent getActivityComponent() &#123; return DaggerActivityComponent.builder() .appComponent(MyApplication.getAppComponent()) .activityModule(new ActivityModule()) .build(); &#125; &emsp;&emsp;加完这两个方法之后，肯定会有错误提示，重新编译一遍项目就可以了，如果重新编译一遍，还是不行，请重新对比一下，哪里不一样。 第三步&emsp;&emsp;就是关于mvp的了，从上面图应该看到了，有一个presenter包，和contract包，我们之前有一篇博客讲过，MVP就是多了很多个接口，这些接口写在哪呢？就在contract层 MainContract 代码如下： 123456789101112131415161718package com.haichenyi.myproject.contract;import com.haichenyi.myproject.base.BasePresenter;import com.haichenyi.myproject.base.BaseView;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface MainContract &#123; interface IView extends BaseView&#123; &#125; interface Presenter extends BasePresenter&lt;IView&gt;&#123; void loadData(); &#125;&#125; &emsp;&emsp;这里我需要说明的就是Presenter接口继承的是IVew，不是BaseView，页面变化的方法都是在IView接口里面定义，逻辑处理，网络请求方法都是在Presenter接口里面定义 MainPresenter 代码如下 1234567891011121314151617181920212223package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.contract.MainContract;import javax.inject.Inject;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; @Inject MainPresenter() &#123; &#125; @Override public void loadData() &#123; baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; &emsp;&emsp;这里我需要说明的是注意继承BaseMvpPresenter传的是MainContract.IView，不是BaseView，实现MainContract.Presenter接口，还有一点就是注意构造方法，上面有注解，这里的loadData里面应该是我们的网络请求逻辑，这里我放到后面一篇在说，这里我先就直接Toast，表示走了这个方法 第四步&emsp;&emsp;就是MainActivity，这里我贴出代码 123456789101112131415161718192021222324252627package com.haichenyi.myproject;import android.os.Bundle;import com.haichenyi.myproject.base.BaseMvpActivity;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.presenter.MainPresenter;public class MainActivity extends BaseMvpActivity&lt;MainPresenter&gt; implements MainContract.IView &#123; @Override protected int getLayoutId(Bundle savedInstanceState) &#123; return R.layout.activity_main; &#125; @Override protected void initData() &#123; super.initData(); initToolbar(true, false, true).setMyTitle(&quot;主页&quot;).setMoreTitle(&quot;更多&quot;); basePresenter.loadData(); &#125; @Override protected void initInject() &#123; getActivityComponent().inject(this); &#125;&#125; &emsp;&emsp;这里我需要说明的是继承BaseMvpActivity，泛型直接传MainPresenter，然后，实现MainContract.IView接口，直接用basePresenter调用方法，需要实现initInject方法，只要是是继承BaseMvpActivity的activity，都需要在ActivityComponent()里面注册一边。比方说，LoginActivity也是继承的BaseMvpActivity，辣么，在di层的component包下面的ActivityComponent接口里面定义一个方法 1void inject(LoginActivity loginActivity); 在LoginActivity的initInject方法里面写同样的代码 1getActivityComponent().inject(this); 就像这样写就可以了。 总结&emsp;&emsp;写到这里，mvp+dagger2基本上完成了，MVP的目的就是解藕，把业务逻辑，网络请求丢在P层，页面不发生变化，就只用改P层逻辑，从而达到了解藕的目的。dagger2简化了代码，并且，它有着全局单例模式，和局部单例模式，优化了我们的内存，减少了内存浪费。不用每次都去new一个P层对象出来。下一篇，我们就把网络请求加上 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（一）—简单的框架]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[目的&emsp;&emsp;首先先说出，最终的目的是现在主流的MVP+RxJava+Retrofit+OkHttp框架。让大家心里有底 &emsp;&emsp;开发工具Android Studio3.0，还在用eclipse的同鞋，强烈推荐你跨出这一步，你会发现一个新的世界。android studio都出来这么久了，你还在远古时代做开发，说句不好听的，你完全与时代脱轨，你不适合做开发（纯属个人观点） &emsp;&emsp;本篇就只有三部分，第一部分就是新建一个Application，第二部分就是BaseActivity，第三部分就是BaseFragment Application&emsp;&emsp;首先你得有application类，去初始化应用只用初始化一次的内容，继承Application，然后在清单文件里面注册。 123456789101112131415161718192021222324252627282930313233343536373839package com.haichenyi.myproject;import android.app.Application;import com.squareup.leakcanary.LeakCanary;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MyApplication extends Application &#123; private static MyApplication instance; public MyApplication getInstance() &#123; return instance; &#125; private void setInstance(MyApplication instance) &#123; MyApplication.instance = instance; &#125; @Override public void onCreate() &#123; super.onCreate(); setInstance(this); initLeakCanary(); &#125; /** * 初始化内存检测工具 */ private void initLeakCanary() &#123; if (LeakCanary.isInAnalyzerProcess(this)) &#123; return; &#125; LeakCanary.install(this); &#125;&#125; &emsp;&emsp;如上代码，我这里就初始化了一个全局application单例对象，还初始化square公司出品的一个内存检测工具，用于检测你项目中内存泄漏情况。便于你优化项目。 &emsp;&emsp;如上图所示，这个就是清单文件，在application结点下面，添加name标签，内容就是你创建的application的名字。这里你还需要添加两个内存检测的依赖。 &emsp;&emsp;如上图所示，首先把你的项目结构视图切换到Project，打开你的app目录下的build.gradle文件，在dependencies结点下面（只要是添加开源库都是在该结点下面，后面就不说了），添加如下两行代码： 12releaseImplementation &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos; &emsp;&emsp;最后的1.5.4是版本号，你可以在github上面搜索leakcanary，找最新的版本 BaseActivity&emsp;&emsp;创建基类BaseActivity，也就是所有Activity的父类。还有一个基类的接口BaseView，BaseActivity继承刚才添加的依赖的SupportActivity类，实现BaseView接口，并且实现点击事件的接口（选择实现，你要是不乐意在基类里面写，你可以在你自己的子类里面重新实现一遍也是可以的）。代码如下：每个方法注释写的很清楚，就不用一一解释了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.haichenyi.myproject.base;import android.app.AlertDialog;import android.graphics.Color;import android.graphics.drawable.ColorDrawable;import android.os.Bundle;import android.support.annotation.Nullable;import android.view.Window;import android.widget.ProgressBar;import com.haichenyi.myproject.utils.ToastUtils;import me.yokeyword.fragmentation.SupportActivity;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public abstract class BaseActivity extends SupportActivity implements BaseView &#123; private AlertDialog loadingDialog; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; /** * Toast 提示用户 * @param msg 提示内容String */ @Override public void showTipMsg(String msg) &#123; ToastUtils.showTipMsg(msg); &#125; /** * Toast 提示用户 * @param msg 提示内容res目录下面的String的int值 */ @Override public void showTipMsg(int msg) &#123; ToastUtils.showTipMsg(msg); &#125; /** * 网络请求的时候显示正在加载的对话框 */ @Override public void showLoading() &#123; if (null == loadingDialog) &#123; loadingDialog = new AlertDialog.Builder(this).setView(new ProgressBar(this)).create(); loadingDialog.setCanceledOnTouchOutside(false); Window window = loadingDialog.getWindow(); if (null != window) &#123; window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); &#125; &#125; if (!loadingDialog.isShowing()) &#123; loadingDialog.show(); &#125; &#125; /** * 网络请求完成时隐藏加载对话框 */ @Override public void hideLoading() &#123; if (null != loadingDialog) &#123; if (loadingDialog.isShowing()) &#123; loadingDialog.dismiss(); &#125; loadingDialog = null; &#125; &#125; @Override public void invalidToken() &#123; //用于检测你当前用户的token是否有效，无效就返回登录界面，具体的业务逻辑你自己实现 //如果需要做到实时检测，推荐用socket长连接，每隔10秒发送一个验证当前登录用户token是否过期的请求 &#125; /** * Finish当前页面，最好实现onBackPressedSupport()，这个方法会有一个退栈操作， * 开源框架实现的，我们不用管 */ @Override public void myFinish() &#123; onBackPressedSupport(); &#125; @Override public void onBackPressedSupport() &#123; super.onBackPressedSupport(); &#125;&#125; &emsp;&emsp;上面是目前BaseActivity代码，注释写的很清楚，你会发现BaseView你并没有，下面我给出BaseView的代码 12345678910111213141516171819202122package com.haichenyi.myproject.base;import android.support.annotation.StringRes;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface BaseView &#123; void showTipMsg(String msg); void showTipMsg(@StringRes int msg); void showLoading(); void hideLoading(); void invalidToken(); void myFinish();&#125; &emsp;&emsp;BaseView就是一个接口，是所有V层的基类，代码很简单，Toast方法，显示隐藏加载的对话框方法，检验token是否过期的方法，finish当前页面的方法。什么？Toast方法你没有，下面我贴出来我的Toast的工具类 1234567891011121314151617181920212223242526272829303132333435/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 实时更新的Toast工具类 */public final class ToastUtils &#123; private static Toast toast; private ToastUtils() &#123; throw new RuntimeException(&quot;工具类不允许创建对象&quot;); &#125; @SuppressWarnings(&quot;all&quot;) private static void init() &#123; if (toast == null) &#123; toast = Toast.makeText(MyApplication.getInstance(), &quot;&quot;, Toast.LENGTH_SHORT); &#125; &#125; public static void showTipMsg(String msg) &#123; if (null == toast) &#123; init(); &#125; toast.setText(msg); toast.show(); &#125; public static void showTipMsg(@StringRes int msg) &#123; if (null == toast) &#123; init(); &#125; toast.setText(msg); toast.show(); &#125;&#125; &emsp;&emsp;上面我贴出了三个类，这里我要说明的是，我又创建了两个package，一个是base，一个是utils，我把BaseActivity,BaseView,MyApplication放在base包下面，Toast的工具类放在utils包下面 &emsp;&emsp;再就是添加一些常用的东西了，这里我没有用黄油刀，用过一段时间之后，感觉他的每个控件都是全局的，有点占内存，就放弃了。我下面贴出BaseActivity新增的伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 保存当前activity对象，在OnCreate里面添加，记得在OnDestroy里面移除 * 有什么用呢？ * 比方说有一个需求，让你在任意位置弹出对话框，弹对话框又需要一个context对象，这个时候， * 你就只用传当前list的最上层的activity对象就可以了 * 当然还有其他需求 */ public static List&lt;BaseActivity&gt; activities = new ArrayList&lt;&gt;(); private Toolbar toolbar; private TextView tvToolbarTitle; private TextView tvToolbarRight; private TextView tvBack; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); activities.add(this); //强制竖屏(不强制加) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); int layoutId = getLayoutId(savedInstanceState); View inflate = getLayoutInflater().inflate(R.layout.activity_base, toolbar, false); LinearLayout rootLinearLayout = inflate.findViewById(R.id.ll_layout_base_activity); //没有布局的时候传0 if (0 == layoutId) &#123; setContentView(rootLinearLayout); &#125; else &#123; View rootView = getLayoutInflater().inflate(layoutId, rootLinearLayout, true); setContentView(rootView); &#125; stateBar(); initView(); initData(); setOnClick(R.id.tv_back_base_activity); &#125; /** * 设置点击事件. * * @param ids 被点击View的ID * @return &#123;@link BaseActivity&#125; */ public BaseActivity setOnClick(@IdRes int... ids) &#123; View view; for (int id : ids) &#123; view = findViewById(id); if (null != view) &#123; view.setOnClickListener(this); &#125; &#125; return this; &#125; /** * 设置点击事件. * * @param views 被点击View * @return &#123;@link BaseActivity&#125; */ public BaseActivity setOnClick(View... views) &#123; for (View view : views) &#123; view.setOnClickListener(this); &#125; return this; &#125; /** * 获取当前布局对象 * * @param savedInstanceState 这个是当前activity保存的数据，最常见的就是横竖屏切换的时候， * 数据丢失问题 * @return 当前布局的int值 */ protected abstract int getLayoutId(Bundle savedInstanceState); @Override protected void onDestroy() &#123; activities.remove(this); super.onDestroy(); &#125; protected void initData() &#123; &#125; protected void initView() &#123; toolbar = findViewById(R.id.toolbar_base_activity); tvToolbarTitle = findViewById(R.id.tv_title_base_activity); tvToolbarRight = findViewById(R.id.tv_right_base_activity); &#125; /** * 设置状态栏背景颜色，不能改变状态栏内容的颜色 */ private void stateBar() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; SystemBarTintManager tintManager = new SystemBarTintManager(this); tintManager.setStatusBarTintEnabled(true); tintManager.setNavigationBarTintEnabled(true); tintManager.setTintColor(Color.parseColor(&quot;#000000&quot;)); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.tv_back_base_activity: onBackPressedSupport(); break; default: break; &#125; &#125; &emsp;&emsp;这里我需要说明的是，新增了一个开源框架，就是设置状态栏背景颜色的systembartint。 1implementation &apos;com.readystatesoftware.systembartint:systembartint:1.0.3&apos; &emsp;&emsp;再就是设置activity标题内容，左边，右边的内容，左边右边可能是文字，也可能是图片。所以，我在用的时候，都是用的TextView，ImageView，不能设置文字。方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public BaseActivity setTitles(CharSequence title) &#123; tvToolbarTitle.setText(title); return this; &#125; /** * 初始化toolbar的内容 * @param isShowToolbar 是否显示toolbar * @param isShowBack 是否显示左边的TextView * @param isShowMore 是否显示右边的TextView * @return 当前activity对象，可以连点 */ protected BaseActivity initToolbar(boolean isShowToolbar, boolean isShowBack, boolean isShowMore) &#123; setSupportActionBar(toolbar); ActionBar actionBar = getSupportActionBar(); if (null != actionBar) &#123; if (isShowToolbar) &#123; actionBar.show(); tvBack = findViewById(R.id.tv_back_base_activity); TextView textView = findViewById(R.id.tv_right_base_activity); if (null != tvBack &amp;&amp; null != textView) &#123; tvBack.setVisibility(isShowBack ? View.VISIBLE : View.INVISIBLE); textView.setVisibility(isShowMore ? View.VISIBLE : View.INVISIBLE); &#125; &#125; else &#123; actionBar.hide(); &#125; &#125; return this; &#125; public BaseActivity setToolbarBack(int colorId) &#123; toolbar.setBackgroundColor(getResources().getColor(colorId)); return this; &#125; @SuppressWarnings(&quot;unused&quot;) public BaseActivity setMyTitle(String title) &#123; tvToolbarTitle.setText(title); return this; &#125; public BaseActivity setMyTitle(@StringRes int stringId) &#123; tvToolbarTitle.setText(stringId); return this; &#125; public void setMoreTitle(String moreTitle) &#123; tvToolbarRight.setText(moreTitle); &#125; public BaseActivity setMoreTitle(@StringRes int stringId) &#123; tvToolbarRight.setText(stringId); return this; &#125; /** * 设置左边内容. * * @param leftTitle 内容 * @return &#123;@link BaseActivity&#125; */ public BaseActivity setLeftTitle(String leftTitle) &#123; if (tvBack != null) &#123; tvBack.setBackground(null); tvBack.setText(leftTitle); &#125; return this; &#125; /** * 设置左边内容. * * @param leftTitle 内容 */ public void setLeftTitle(@StringRes int leftTitle) &#123; if (tvBack != null) &#123; tvBack.setBackground(null); tvBack.setText(leftTitle); &#125; &#125; @SuppressWarnings(&quot;unused&quot;) protected BaseActivity setMoreBackground(int resId) &#123; tvToolbarRight.setBackgroundResource(resId); return this; &#125; &emsp;&emsp;可以看到上面的方法返回值都是BaseActivity，这样做的目的就只有一个，可以连点，写一个方法之后，可以接着点写下一个方法，不用写一个方法就要加分号，就换一行写下一个方法。 &emsp;&emsp;还要加一句，在你的app主题里面添加两个item，也就是你的res目录下面的style： 12&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &emsp;&emsp;我这里贴出我目前的style的图片 &emsp;&emsp;下面有一个LineHorizontal样式，就是你toolbar下面的那个横线 BaseFragment&emsp;&emsp;BaseFragment跟BaseActivity的逻辑是差不多的，我这里就贴出代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package com.haichenyi.myproject.base;import android.os.Bundle;import android.support.annotation.IdRes;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.haichenyi.myproject.utils.ToastUtils;import me.yokeyword.fragmentation.SupportFragment;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public abstract class BaseFragment extends SupportFragment implements BaseView, View.OnClickListener &#123; protected boolean isInit; private View rootView; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; int layoutRes = layoutRes(); if (0 != layoutRes) &#123; return inflater.inflate(layoutRes, null); &#125; else &#123; return super.onCreateView(inflater, container, savedInstanceState); &#125; &#125; @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); rootView = view; &#125; @Override public void onLazyInitView(@Nullable Bundle savedInstanceState) &#123; super.onLazyInitView(savedInstanceState); isInit = true; init(); &#125; protected &lt;T extends View&gt; T findViewById(@IdRes int id) &#123; return rootView.findViewById(id); &#125; /** * 设置点击事件. * * @param ids 被点击View的ID * @return &#123;@link BaseFragment&#125; */ public BaseFragment setOnClick(@IdRes int... ids) &#123; for (int id : ids) &#123; rootView.findViewById(id).setOnClickListener(this); &#125; return this; &#125; /** * 设置点击事件. * * @param views 被点击View的ID * @return &#123;@link BaseFragment&#125; */ public BaseFragment setOnClick(View... views) &#123; for (View view : views) &#123; view.setOnClickListener(this); &#125; return this; &#125; protected abstract void init(); @Override public void onDestroy() &#123; rootView = null; super.onDestroy(); &#125; protected abstract int layoutRes(); @Override public void showTipMsg(String msg) &#123; ToastUtils.showTipMsg(msg); &#125; @Override public void showTipMsg(int msg) &#123; ToastUtils.showTipMsg(msg); &#125; @Override public void showLoading() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.showLoading(); &#125;*/ &#125; @Override public void hideLoading() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.hideLoading(); &#125;*/ &#125; @Override public void invalidToken() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.invalidToken(); &#125;*/ &#125; @Override public void onClick(View v) &#123; &#125; @Override public void myFinish() &#123; onBackPressedSupport(); &#125;&#125; &emsp;&emsp;两者在布局抽象方法里面有一点区别，Activity的传了Boundle参数，Fragment没有传，因为Fragment可以通过getArguments()方法获取到这个对象，而Activity不能获取到。 总结&emsp;&emsp;到此，一个简单的项目框架就出来了，目前还是框架的第一步，是一个雏形，还不包括MVP，dagger等等，下一篇就加上MVP，我这个人有个好习惯，就是喜欢写注释，我注释写的很清楚，是干什么用的，我也衷心的希望，你能写好注释。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVC、MVP、MVVM比较]]></title>
    <url>%2F2018%2F02%2F22%2FMVC%E3%80%81MVP%E3%80%81MVVM%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[Android框架的最终目的，也是体现一个项目好坏的唯一标准——高类聚，低耦合 MVC&emsp;&emsp;我们刚接触android写代码的时候基本上都是MVC架构。什么是MVC架构呢？ &emsp;&emsp;MVC：Model View Controller的简称。流程图如下： &emsp;&emsp;当用户发出事件的时候，首先通过V层，通知C层，然后C层通知Model层数据发生了变化，更新数据，M层直接显示数据到V层。 &emsp;&emsp;通俗的讲，xml可以理解层View层，你封装的网络请求的帮助类理解成model层，activity，fragment理解成Controller层。这么理解是可以的，但是，你不能说xml就是view层，这样说是不对的 &emsp;&emsp;举个例子，比方说一个登录的网络请求，首先，你需要点击按钮去触发网络请求的方法，你点击的这个button就是写在xml布局里面的，这就是V层。然后触发的网络请求帮助类去发送对应的登录请求方法，这就是model层。两者是怎么联系在一起的呢？就是我们在activity，fragment层里面写的onclick方法。activity，fragment就是Controller层。 MVP&emsp;&emsp;所有的UI变化，网络请求等等业务逻辑之类的都写在Activity里面，Activity既要处理业务逻辑，又要处理UI变化，代码就显得非常臃肿。 &emsp;&emsp;这个时候，MVP就顺势而生，什么是MVP架构呢？ &emsp;&emsp;MVP：Model View Presenter的简称 &emsp;&emsp;MVP作为MVC的演化版本，解决了MVC不少的缺点，对于Android来说，MVP的M层，相对于MVC来说是一样的，而不一样的就是activity不再是controller，而是纯粹的V层，所有关于用户事件的转发，全都由P层去处理 &emsp;&emsp;MVP和MVC最明显的差别就是，M层和V层完全解藕，两者的通信是通过P层，P层作为桥梁，用于操作View层发送的事件到P层，P层去操作M层，并且，讲数据返回给V层。整个过层M层和V层两者完全没有联系。辣么，就有好奇的宝宝就问了，这样做解决不了更本问题，你这样做P层和V层不一样耦合在一起了吗？我们并不能完全不耦合，只是尽可能减少耦合度。我们写程序最终目的就是高类聚，低耦合，不是说完全不耦合。并且，我们这里P层和V层是通过接口通信的，如果网络请求逻辑发生变化，直接修改P层里面的代码，就可以了。V层完全不用改。如果业务逻辑发生变化，我们直接重新定义接口也非常方便 MVVM&emsp;&emsp;由微软提出来的—MVVM。什么是MVVM架构呢？ &emsp;&emsp;MVVM：Model View ViewModel &emsp;&emsp;一眼看上去更MVP差不多，只是把P层换成了ViewModel层。还有一点就是View层和ViewModel层是相互绑定的关系，当你更新ViewMdel层数据的时候，View层的UI就要相应的发生变化。 &emsp;&emsp;不管怎么说，三种模式的出现，或者说所有的开发模式，或者说是架构的出现，他们都有一个最终的目的，那就体现是一个项目架构好坏的：高类聚，低耦合 &emsp;&emsp;学习成本，MVC最简单，弊端也是最多的，学起来也是最快的。MVP和MVVM两者都是MVC的演化版本，两者没法评论优缺点，各有千秋。MVP是目前最火的架构（-.-）。 总结&emsp;&emsp;吹了这么多，MVP有没有什么缺点呢？答案是肯定的：有。本人认为，MVP是目前已知框架最好的 缺点 P层比较臃肿，所有的逻辑代码，网络请求都丢在P层 接口很多，一个功能，相对于MVC来讲，需要多写很多代码 V层P层耦合度过于高，一旦视图需要变更，P层就要相应的发生变化 优点 解藕，这个不用说了 结构清晰明了，不会过了一个月就变成别人的代码 提高了维护性，功能出了问题，直接定位到接口，修改接口就行了 容易进行单元测试，虽然会用单元测试的人比较少]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制原理]]></title>
    <url>%2F2018%2F02%2F22%2FAndroid%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[推荐：非著名程序员的安卓自定义View教程目录，我的自定义view就是看他的这个系列学会的 &emsp;&emsp;首先，我们需要确认的是android的事件传递机制是责任链模式，如果自己能处理就拦截下来自己处理，如果自己处理不了或者不确定就传递给下一个对象 事件的拦截、分发、消费&emsp;&emsp;我们要知道三个方法，控制事件反而拦截，分发与消费。如下表： 类型 相关方法 Activity ViewGroup View 事件分发 dispatchTouchEvent 有 有 无 事件拦截 onInterceptTouchEvent 无 有 无 事件处理 onTouchEvent 有 有 有 以上三个方法，均有boolean类型的返回值，通过设置true，false来控制事件传递的流程 Activity和View均没有事件拦截方法，是因为 Activity作为事件响应起点，如果，Activity把事件拦截了，辣么将为导致整个屏幕都无法点击 View作为事件响应的最末端，要么消费事件，要么不处理回传，没必要拦截事件 事件分发流程&emsp;&emsp;先给出一张图 &emsp;&emsp;这里，我们看到多了两个东西，一个是PhoneWindow，一个是DecorView，我们平时写的布局，最外层的父布局就是这里的RootView，有过几个app开发经验的程序员都应该知道，app的状态栏颜色的修改，还有那个主题的内容修改，修改后显示在哪呢？没错，就是DecorView里面。 &emsp;&emsp;再有就是phoneWindow，其实，知不知道没什么用，phonewindow是Window的唯一实现类，Window是干嘛的呢？Window是一个抽象类，所有的视图，事件传递都归它管理，所以，phonewindow管理视图，上面说的DecorView就是phonewindow的一个内部实现类，除了自己的功能外，还负责消息传递。 &emsp;&emsp;说了这么多，该来讲讲事件传递的流程了。android的view是树形结构的，基于这样的结构，我们的事件可以有序的分发。事件收集之后，起点是Activity，然后有序的向下传递，大致如下： Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View 如果这个事件没有对象处理，辣么，它会依次往回传递，如果还是没有人处理，辣么就会被Activity抛弃掉 Activity &lt;－ PhoneWindow &lt;－ DecorView &lt;－ ViewGroup &lt;－ ... &lt;－ View 这就是文章开头我们提到的，责任链模式 下面我给出ViewGroup的事件分发机制的伪代码： 12345678910111213public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean result = false; // 默认状态为没有消费过 if (!onInterceptTouchEvent(ev)) &#123; // 如果没有拦截交给子View result = child.dispatchTouchEvent(ev); &#125; if (!result) &#123; // 如果事件没有被消费,询问自身onTouchEvent result = onTouchEvent(ev); &#125; return result;&#125; &emsp;&emsp;情景：老板: 我看公司最近业务不咋地，准备发展一下电商业务，下周之前做个淘宝出来试试怎么样。&emsp;&emsp;事件顺序，老板(MainActivity)要做淘宝，这个事件通过各个部门(ViewGroup)一层一层的往下传，传到最底层的时候，码农小王(View1)发现做不了，于是消息又一层一层的回传到老板那里。&emsp;&emsp;可以看到整个事件传递路线非常有序。从Activity开始，最后回传给Activity结束(由于我们无法操作Phone Window和DecorView，所以没有它们的信息)。 1234567891011MainActivity [老板]: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.RootView [经理]: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.RootView [经理]: onInterceptTouchEvent (老板可能疯了,但又不是我做.)ViewGroupA [组长]: dispatchTouchEvent 老板要做淘宝,下周上线?ViewGroupA [组长]: onInterceptTouchEvent (看着不太靠谱,先问问小王怎么看)View1 [码农]: dispatchTouchEvent 做淘宝???View1 [码农]: onTouchEvent 这个真心做不了啊.ViewGroupA [组长]: onTouchEvent 小王说做不了.RootView [经理]: onTouchEvent 报告老板, 技术部说做不了.MainActivity [老板]: onTouchEvent 这么简单都做不了,你们都是干啥的(愤怒). 总结事件分发机制设计到到情形非常多，这里就不一一列举了，记住以下几条原则就行了。 如果事件被消费，就意味着事件信息传递终止。 如果事件一直没有被消费，最后会传给Activity，如果Activity也不需要就被抛弃。 判断事件是否被消费是根据返回值，而不是根据你是否使用了事件。]]></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View]]></title>
    <url>%2F2018%2F02%2F08%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Netty的简单使用，实现socket通讯]]></title>
    <url>%2F2018%2F02%2F08%2FNetty%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[自从用了netty框架，妈妈再也不用担心我的socket通讯了&emsp;&emsp;题外话，很多人都把JDK1.4提供的NIO称之为异步非阻塞I/O；其实，并不然，从严格意义上面讲，它只能称为非阻塞I/O。在JDK1.7提供的NIO 2.0，新增了异步的套接字通道Channel，它才是真正的异步非阻塞I/O。下表是不同I/O模型的对比： 表1-1 几种I/O模型和同能对比 同步阻塞I/O(BIO) 伪异步I/O 非阻塞I/O(NIO) 异步I/O(AIO) 客户端个数：I/O线程 1:1 M:N(M可以大于N) M:1(1个I/O线程处理多个客户端连接) M:0(不需要启动额外的I/O线程，被动回调) I/O类型(阻塞) 阻塞I/O 阻塞I/O 非阻塞I/O 非阻塞I/O I/O类型(同步) 同步I/O 同步I/O 同步I/O(I/O多路复用) 异步I/O API使用难度 简单 简单 非常复杂 复杂 调试难度 简单 简单 复杂 复杂 可靠性 非常差 差 高 高 吞吐量 低 中 高 高 简介&emsp;&emsp;Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 &emsp;&emsp;也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。 &emsp;&emsp;“快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。——百度百科 优点 API使用简单，开发门槛低 功能强大，预置了多种编解码功能，支持多种主流协议 性能高，通过与业界其他主流NIO框架相比，netty的综合性能最高 成熟，稳定，Netty已经修复了已经发现的所有的JDK NIO BUG，业务开发人员不用再为NIO的bug而烦恼 社区活跃，版本迭代周期短，发现bug可以及时被修复，同时有更多的新功能加入 经历了大规模的商界业务考验，只能得到了验证 粘包、拆包概念&emsp;&emsp;TCP是一个流协议，所谓的流，就是没有界限的一串数据。可以考虑河里的流水，他们并没有界限。tcp底层并不了解业务层数据的具体含义，他会根据tcp缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被tcp拆分成多个包进行发送，也可能把多个小包封装成一个大数据一起发送，这就是所谓的tcp粘包，拆包问题 产生原因 应用程序write写入的字节大小大于套接口发送缓冲区的大小 进行MSS大小的tcp分段 以太网帧的payload大于MTU进行IP分片 解决办法 消息定长，每个报文大小固定长度，不够的补0 包尾增加回车换行符进行分割。例如：FTP协议 将消息分为消息头和消息体。消息头中包含消息的总长度字段 更复杂的应用层协议 Netty框架的解决办法&emsp;&emsp;LineBasedFrameDecoder和StringDecoder两个类 LineBasedFrameDecoder&emsp;&emsp;LineBasedFrameDecoder的工作原理是依次遍历ByteBuf中的可读字节，判断看是否有”\r”或者”\r\n”，如果有就以此为结束位置，从可读索引位置到结束区间的字节就组成了一行。他是以换行符为结束标志的解码器，支持携带结束符和不带结束符两种解码方式。同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读取的异常流 StringDecoder&emsp;&emsp;StringDecoder的功能就非常简单，就是将接收到的对象换成字符串，然后继续调用后面的handler，LineBasedFrameDecoder+StringDecoder组合就是按换行符切换文本解码器，他被设计用来支持TCP粘包和拆包。Netty支持其他其他符号的解码器(DelimiterBasedFrameDecode) &emsp;&emsp;说了这么多，代码来了，就是用Netty实现的心跳。对于懒癌晚期，已经风装好，可以直接拿过去用，注释也写的很清楚 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import android.util.Log;import io.netty.bootstrap.Bootstrap;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import io.netty.util.CharsetUtil;/** * @author 海晨忆 * @date 2018/2/6 * @desc */public class SocketTcp &#123; private static SocketTcp socketTcp = new SocketTcp(); private Channel channel = null; private EventLoopGroup group; private int port; private String host; public static SocketTcp getInstance() &#123; return socketTcp; &#125; public SocketTcp setPort(int port) &#123; this.port = port; return this; &#125; public SocketTcp setHost(String host) &#123; this.host = host; return this; &#125; public void connect() &#123; if (channel != null) return; if (group == null) &#123; //NIO线程组 group = new NioEventLoopGroup(); &#125; try &#123;//配置Bootstrap Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; //以换行符为结束标记 ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); pipeline.addLast(new LineBasedFrameDecoder(Integer.MAX_VALUE)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket()); //以&quot;$_&quot;作为分隔符 /*ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); String s = &quot;$_&quot;; ByteBuf byteBuf = Unpooled.copiedBuffer(s.getBytes()); pipeline.addLast(new DelimiterBasedFrameDecoder(Integer.MAX_VALUE,byteBuf)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket());*/ &#125; &#125;); //发起异步连接操作 ChannelFuture channelFuture = bootstrap.connect(host, port).sync(); channel = channelFuture.channel(); //等待服务端监听端口关闭 channel.closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; disConnect(); &#125; &#125; /** * 断开tcp连接. */ private void disConnect() &#123; if (null != group) &#123; group.shutdownGracefully(); &#125; group = null; channel = null; &#125; public void sendMessage(String msg) &#123;//连接成功后，通过Channel提供的接口进行IO操作 try &#123; if (channel != null &amp;&amp; channel.isOpen()) &#123; channel.writeAndFlush(msg).sync(); Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg); &#125; else &#123; reConnect(); throw new Exception(&quot;channel is null | closed&quot;); &#125; &#125; catch (Exception e) &#123; reConnect(); e.printStackTrace(); &#125; &#125; /** * 重连. */ private void reConnect() &#123; new Thread(this::connect); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.example.zwang.myapplication.socket;import android.os.SystemClock;import android.util.Log;import java.util.concurrent.TimeUnit;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.EventLoop;import io.netty.channel.SimpleChannelInboundHandler;public class MyHeartSocket extends SimpleChannelInboundHandler&lt;Object&gt; &#123; private ChannelHandlerContext ctx; private boolean isConnect = false; @Override protected void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception &#123; Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;); ByteBuf msg1 = (ByteBuf) msg; byte[] bytes = new byte[msg1.readableBytes()]; msg1.readBytes(bytes); String s = new String(bytes, &quot;UTF-8&quot;); Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;); isConnect = true; if (this.ctx == null) &#123; synchronized (MyHeartSocket.class) &#123; if (this.ctx == null) &#123; this.ctx = ctx; MyAppHeart(); &#125; &#125; &#125; &#125; private void MyAppHeart() &#123; new Thread(() -&gt; &#123; while (ctx != null &amp;&amp; isConnect) &#123; String data = &quot;123&quot;; byte[] bytes = data.getBytes(); if (isConnect) &#123; ctx.writeAndFlush(Unpooled.buffer(bytes.length).writeBytes(bytes)); SystemClock.sleep(3000); &#125; &#125; &#125;).start(); &#125; @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; EventLoop loop = ctx.channel().eventLoop(); loop.schedule(() -&gt; SocketTcp.getInstance().connect(), 5, TimeUnit.SECONDS); super.channelInactive(ctx); Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;); isConnect = false; &#125; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; super.userEventTriggered(ctx, evt); Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.exceptionCaught(ctx, cause); Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;); this.ctx.close(); this.ctx = null; &#125;&#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO编程和NIO编程简介]]></title>
    <url>%2F2018%2F02%2F07%2FIO%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;传统的同步阻塞I/O通讯模型，导致的结果就是只要有一方处理数据缓慢，都会影响另外一方的处理性能。按照故障设计原则，一方的处理出现问题，不应该影响到另外一方才对。但是，在同步阻塞的模式下面，这样的情况是无法避免的，很难通过业务层去解决。既然同步无法避免，为了避免就产生了异步。Netty框架就一个完全异步非阻塞的I/O通讯方式 同步阻塞式I/O编程&emsp;&emsp;简单的来说，传统同步阻塞的I/O通讯模式，服务器端处理的方式是，每当有一个新用户接入的时候，就new一个新的线程，一个线程只能处理一个客户端的连接，在高性能方面，并发高的情景下无法满足。伪代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; public void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); while (true) &#123; socket = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; new TimerServerHandler(socket).run(); &#125; &#125;).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //释放资源 if (server != null) &#123; try &#123; server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; server = null; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimerServerHandler implements Runnable &#123; private Socket socket; public TimerServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; BufferedReader in = null; PrintWriter out = null; try &#123; in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); out = new PrintWriter(this.socket.getOutputStream(), true); String currentTime = null; String body = null; while (true) &#123; body = in.readLine(); if (body == null) break; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); //释放in，out，socket资源 &#125; &#125;&#125; &emsp;&emsp;上面这个就是最原始的服务端IO的代码，这里我就给出的是最简化的，当有新的客户端接入的时候，服务端是怎么处理线程的，可以看出，每当有新的客户端接入的时候，总是回新创建一个线程去服务这个新的客户端 伪异步式编程&emsp;&emsp;后来慢慢演化出一个版本“伪异步”模型，新增加一个线程池或者消息队列，满足一个线程或者多个线程满足N个客户端，通过线程池可以灵活的调用线程资源。通过设置线程池的最大值，防止海量并发接入造成的线程耗尽，它的底层实现依然是同步阻塞模型，伪代码如下：1234567891011121314151617181920212223242526272829303132333435import com.example.zwang.mysocket.server.TimerServerHandler;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; private void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); TimeServerHandlerExecutePool executePool = new TimeServerHandlerExecutePool(50, 1000); while (true) &#123; socket = server.accept(); executePool.execute(new TimerServerHandler(socket)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //释放资源 &#125; &#125;&#125; 12345678910111213141516171819202122import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimeServerHandlerExecutePool &#123; private ExecutorService executor; public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123; executor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize, 120L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize)); &#125; public void execute(Runnable task) &#123; executor.execute(task); &#125;&#125; &emsp;&emsp;“伪异步”的代码和传统同步的唯一区别就是在于，首先先创建了一个时间服务处理类的线程池，当有新的客户端接入的时候，先将socket请求封装成task，然后调用线程池的execute方法执行，从而避免了每一个新请求创建一个新线程。由于线程池和消息队列都是有限的，因此，无论客户端的并发量多大，它都不会导致线程个数过于大，而造成的内存溢出。相对于传统的同步阻塞，是一种改良。 &emsp;&emsp;但是他没有从更本上解决同步的问题，伪异步的问题在于，他还是有一方处理出现问题还是会影响到另一方。因为： &emsp;&emsp;当对socket的输入流进行读取操作的时候，它会一直阻塞直到一下三种方式发生： 有数据可读 可读数据已经读取完 发生空指针或者I/O异常。 这意味者，当读取inputstream方处理速度缓慢(不管是什么原因造成的速度缓慢)，另一方会一直同步阻塞，直到这一方把数据处理完. &emsp;&emsp;当调用outputstream的write方法写输出流的时候，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。学过TCP/IP相关知识的人都直到，当消息的接收方处理消息缓慢，不能及时的从TCP缓冲区读取数据，这将会导致发送方的TCP缓冲区的size一直减少，直到0.缓冲区为0，那么发消息的一方将无法将消息写入缓冲区，直到缓冲区的size大于0 &emsp;&emsp;通过以上。我们了解到读和写的操作都是同步阻塞的，阻塞的时间取决于对方的I/O线程的处理速度和网络I/O的传送速度。从本质上面看，我们无法保证对方的处理速度和网络传送速度。如果，我们的程序依靠与对方的处理速度，那么，他的可靠性将会非常差。 NIO编程&emsp;&emsp;官方叫法new I/O，也就是新的IO编程，更多的人喜欢称它为：Non-block IO即非阻塞IO。 &emsp;&emsp;与Socket和serverSocket类对应，NIO提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现，这两种都支持阻塞式编程和非阻塞式编程。开发人员可以根据自己的需求选择合适的编程模式。一般低负载，低并发的应用程序选择同步阻塞的方式以降低编程的复杂度。高负载，高并发的不用想了，非阻塞就是为了解决这个问题的 缓冲区Buffer &emsp;&emsp;Buffer是一个对象，它包含一些写入或者读出的数据。再NIO中加入buffer对象，体现了新库和旧库的一个重要区别。在面向流的io中，可以直接把数据读取或者写入到stream对象中。在NIO库中，所有数据操作都是通过缓冲区处理的。 &emsp;&emsp;缓冲区实质上是一个数组，通常是一个字节数组（ByteBuffer），基本数据类型除了boolean没有，其他都有，如ShortBuffer,CharBuffer等等 通道Channel &emsp;&emsp;Channel是一个通道，双向通道，网络数据都是通过Channel读取，写入的。是的，没错，Channel它既可以进行读操作，也可以进行写操作。而流只能是一个方向。只能读操作或者只能写操作，而channel是全双工，读写可以同时进行。channel可以分为两大类：网络读写的SelectableChannel和文件操作的FileChannel。我们前面提到的SocketChannel和ServerSocketChannel都是SelectableChannel的子类。 多路复用器Selector &emsp;&emsp;selector多路复用器，他是java NIO编程的基础，熟练的掌握selector对于NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单的讲就是他会不断的轮询注册的channel，如果一个Channel发生了读写操作，这个Chnnel就会处于就绪状态，会被selector轮询出来，通过SelectorKey获取就绪Channel集合，进行后续的IO操作。一个selector对应多个Channel &emsp;&emsp;由于原生NIO编码比较麻烦和复杂，我这里就给出了思路的伪代码。下一篇我们将用NIO中的Netty框架实现Socket通信，编码简单，一行代码解决烦人粘包、拆包问题。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 服务端nio过程的伪代码 * * @param port 端口号 * @throws IOException IOException */ private void init(int port) throws IOException &#123; //第一步：打开ServerSocketChannel，用于监听客户端连接，它是所有客户端连接的父管道 ServerSocketChannel socketChannel = ServerSocketChannel.open(); //第二步：监听绑定端口，设置连接模式为非阻塞模式， socketChannel.socket().bind(new InetSocketAddress(InetAddress.getByName(&quot;IP&quot;), port)); socketChannel.configureBlocking(false); //第三步：创建Reactor线程，创建多路复用器，并启动线程。 Selector selector = Selector.open(); new Thread().start(); //第四步：将ServerSocketChannel注册到Reactor线程的多路复用器上，监听accept事件 SelectionKey key = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第五步：多路复用器在线程run方法的无线循环体内轮询准备就绪的key int num = selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator(); while (it.hasNext()) &#123; SelectionKey next = it.next(); //deal with io event... &#125; //第六步：多路复用器检测到有新客户端接入，处理新的接入请求，完成TCP三次握手，建立物理链路 SocketChannel channel = socketChannel.accept(); //第七步：设置客户端为非阻塞模式 channel.configureBlocking(false); channel.socket().setReuseAddress(true); //第八步：将新接入的客户端注册到reactor线程的多路复用器上，监听读操作，读取客户端发送的消息 SelectionKey key1 = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第九步：异步读取客户端消息到缓冲区， /*int readNumber = channel.read(&quot;receivebuff&quot;);*/ //第十步：对byteBuffer进行编解码，如果有半包信息指针reset，继续读取到后续的报文，将解码成功消息封装成task，投递到业务线程池，进行业务逻辑编排 Object massage = null; while (buff.hasRemain()) &#123; buff.mark(); Object massage1 = decode(btyeBuffer); if (massage1 == null) &#123; byteBuffer.reset(); break; &#125; massageList.add(massage1); &#125; if (!byteBuffer.hasRemain()) &#123; byteBuffer.clean(); &#125; else &#123; byteBuffer.compact(); &#125; if (massageList != null &amp;&amp; !massageList.isEmpty()) &#123; for (Object massage3 : massageList)&#123; handlerTask(massage3); &#125; &#125; //第十一步：将POJO对象encode成ByteBuff，调用SocketChannel的异步write接口，将异步消息发送到客户端 socketChannel.write(buffer); &#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
</search>
