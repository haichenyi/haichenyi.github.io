<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（五）—GreenDao的增删改查]]></title>
    <url>%2F2018%2F02%2F24%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94GreenDao%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇我们讲了GreenDao的数据库的依赖和创建，这一篇，我们来讲常用的增删改查四种方法。我们操作数据库都是Dao层，不同的表，有不懂的Dao层对象。我们上一篇的数据库接口的实现类里面，我们定义了UserDao，我们这一篇讲的就是操作我们昨天创建的user表。 &emsp;&emsp;在写下面几个方法之前，我还是先把MVP的用法先讲一遍吧，防止有人不知道，以增操作为例，另外三个就不再讲了： 点击页面的增按钮，我们要调用P层的方法去做增操作。效果图如下： P层的方法从哪来呢？P层实现的接口来撒，所以，我们只用在接口定义对应的方法，在P层去实现，效果图如下： 辣么，具体实现代码怎么写呢？既不记得，我们的装饰者模式，我们P层里面有一个DataHelper对象，通过它去调用对应的方法就可以了，效果图如下： 接下来，datahelper的方法又是从哪里来呢？我们的DataHelper是不是实现了SqlHelper接口，所以，直接在SqlHelper定义方法，在datahelper实现即可，效果图如下： 最后，前面只是调用了，具体实现在哪里呢？我之前有没有讲过装饰者模式，一个接口，两个实现方法，对，没错，就是在SqlImpl方法里面实现，效果图如下： &emsp;&emsp;通过以上5步，就完成我们的增操作。有同鞋就会问，那参数怎么传？我特么怎么知道需要传什么传输，你这个方法是干什么的，调用这个方法需要什么数据，你就丢在参数里面传过去，即可。 增方法12345//插入单个对象userDao.insert(user);//插入一个listuserDao.insertInTx(users); 调用12345//basePresenter.onAdd(User(&quot;小红&quot;, 1, 165, &quot;50KG&quot;, 18))val dataList = mutableListOf&lt;User&gt;()dataList.add(User(&quot;小刚&quot;, 2, 175, &quot;60KG&quot;, 28))dataList.add(User(&quot;小东&quot;, 2, 185, &quot;65KG&quot;, 25))basePresenter.onAddList(dataList) 效果图我就不贴出来了，如果，你的效果出不来，就肯定是你的代码写的有问题，我写这个博客都是边写代码，边写博客，我这边肯定是没问题的。 查方法1234//查询单个对象userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();//查询一个listuserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list(); 调用123456val user = basePresenter.onSelect(&quot;小红&quot;)println(user.name)val users = basePresenter.onSelectList(&quot;小东&quot;) users.forEach &#123; println(it.name) &#125; &emsp;&emsp;这里，我需要做一点说明，那就是手动能力强的宝宝，看见有两个查询方法，一个查询一个对象，一个查询list，这两个方法没问题，查询肯定是查询的一个，list里面也是只有一个对象，就有宝宝想着多插入几条数据，这个时候，项目就可能崩掉，因为，你插入的名字是相同的，我们这里名字是作为主键，表里面主键是不能相同的，所以就崩掉了，所以，你就得改表结构，正好测试我们之前说的版本更新问题，我这里亲测可用，数据也不会丢失。步骤如下： 修改数据库版本，把1改成2 User bean里面增加一个字段id Long类型，递增即可，clean，build项目 在你的Activity里面会报错，因为，你User的构造方法里面新增了一个参数，辣么这里你用的时候参数个数都不对，肯定报错，你把id字段对应的参数传null即可，他自己递增。这里也只有Long类型可以传null 重新运行项目，没有问题 删方法1234567891011121314151617181920/*//通过主键删除一个对象，删除满足条件的第一个对象 User user1 = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique(); //一定要记得做非空判断 if (user1 != null) &#123; userDao.deleteByKey(user1.getId()); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;); &#125;*/ //通过主键删除一个满足条件的List List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list(); if (list.size() &gt; 0) &#123; List&lt;Long&gt; keys = new ArrayList&lt;&gt;(); for (User user : list) &#123; keys.add(user.getId()); &#125; userDao.deleteByKeyInTx(keys); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;); &#125; 调用12//basePresenter.onDelete(&quot;小红&quot;)basePresenter.onDelete(&quot;小东&quot;) 改方法1234567891011List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(oldName)).build().list(); if (list.size() &gt; 0) &#123; for (User user : list) &#123; user.setName(newName); &#125;// userDao.update(user1); userDao.updateInTx(list); ToastUtils.Companion.showTipMsg(&quot;修改成功&quot;); &#125; else &#123; ToastUtils.Companion.showTipMsg(&quot;未查询到相关数据&quot;); &#125; 调用1basePresenter.onUpdate(&quot;小刚&quot;, &quot;小贝&quot;) 完了，数据库的简单的增删改查 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（四）—Kotlin+GreenDao3.2]]></title>
    <url>%2F2018%2F02%2F24%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94Kotlin-GreenDao3-2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本篇介绍android常用的数据库之一GreenDao的简单用法，增删改查。基于前面搭的框架，当然，你也可以选择不用。看懂用法之后，用起来很方便。GreenDao数据库升级到3.0版本之后api用起来更加方便了，便于让开发人员专注于业务逻辑。我需要额外说明的是，我把之前的项目框架转成了kotlin，不会kotlin语法的同学，可以去研究一下。 添加依赖最终，我们要添加如下代码，效果图如下： 第一步&emsp;&emsp;打开的你根目录下面的build.gradle文件，也就是项目下面的，并不是app目录下面的build.gradle。 12345678910111213// In your root build.gradle file:buildscript &#123; repositories &#123; jcenter() ...//其他你自己的 mavenCentral() // add repository &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.0&apos; ...//其他你自己的 classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin &#125;&#125; 第二步&emsp;&emsp;打开你的项目下面的build.gradle文件，也就是你的app目录下面的，之前我们添加依赖的时候的那个文件 1234567// In your app projects build.gradle file:apply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin dependencies &#123; compile &apos;org.greenrobot:greendao:3.2.2&apos; // add library&#125; &emsp;&emsp;完成上面两步，辣么，关于greendao的依赖我们就添加完成了 初始化&emsp;&emsp;我们首先得有一个bean类，这个bean类对应的就是数据库表的表结构。我这里想说明的是（敲黑板了），看到了很多网上说的什么主键id必须用Long类型，这种说法是不准确的，准确的说，你的主键字段名称，如果是“id”，辣么，你这个字段“id”，必须用Long类型，如果你换一个名称，比方说“myId”，辣么，你就不必用Long类型，这个问题，说大不大，说小，又困扰了我有一会。我这里新建用户表，就需要一个User的java bean类。如下： 1234567891011121314151617181920212223242526package com.haichenyi.myproject.model.bean;import org.greenrobot.greendao.annotation.Entity;import org.greenrobot.greendao.annotation.Id;import org.greenrobot.greendao.annotation.NotNull;import org.greenrobot.greendao.annotation.Property;import org.greenrobot.greendao.annotation.Transient;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: 用户表的bean类 */@Entitypublic class User &#123; @Id private String name; private int sex; @Property(nameInDb = &quot;Height&quot;) private int height; private String weight; @NotNull private int age; @Transient private String character;&#125; &emsp;&emsp;这里我把几个常用的注解都写出来了，说一下这几个注解是什么意思 注解 意义 @Entity 用于标识这是一个需要Greendao帮我们生成代码的bean @Id 标明主键，括号里可以指定是否自增 @Property 用于设置属性在数据库中的列名（默认不写就是保持一致） @NotNull 非空 @Transient 标识这个字段是自定义的不会创建到数据库表里 简单的讲一下： @Entity：标识的bean类，我们在运行的时候，greendao会自动帮我们生成对应的表 @Id：标识的字段就是这个表对应的主键 @Property：标识的字段在表中对应的那一栏的名称是后面括号里面的，这个表height字段对应表中的Height，一般我们直接设置成默认就可以了 @NotNull：标识的字段，这个字段在表中不能为空，不然就出错，所以，在添加数据的时候设置默认值 @Transient：标识的字段，在生成表的时候不会生成对应的字段。这个什么时候用呢？这个，我一般用作标记flag，比方说，从数据库拿数据，又不想重新写一个bean类，就用这个bean类，RecyclerView，填充完数据，item点击的时候，状态发生变化，我们要有一个flag，就通过修改这个字段的值，页面做出相应的变化。 &emsp;&emsp;写到这里，我们的bean类也有了，要怎么生成数据库呢？在生成数据库之前，我们先把项目重新clean一遍，再build一遍，看到你刚写的需要生成表的bean类变成了如下样子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.haichenyi.myproject.model.bean;import org.greenrobot.greendao.annotation.Entity;import org.greenrobot.greendao.annotation.Id;import org.greenrobot.greendao.annotation.NotNull;import org.greenrobot.greendao.annotation.Property;import org.greenrobot.greendao.annotation.Transient;import org.greenrobot.greendao.annotation.Generated;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: 用户表的bean类 */@Entitypublic class User &#123; @Id private String name; private int sex; @Property(nameInDb = &quot;Height&quot;) private int height; private String weight; @NotNull private int age; @Transient private String character; @Generated(hash = 717717955) public User(String name, int sex, int height, String weight, int age) &#123; this.name = name; this.sex = sex; this.height = height; this.weight = weight; this.age = age; &#125; @Generated(hash = 586692638) public User() &#123; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getSex() &#123; return this.sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public int getHeight() &#123; return this.height; &#125; public void setHeight(int height) &#123; this.height = height; &#125; public String getWeight() &#123; return this.weight; &#125; public void setWeight(String weight) &#123; this.weight = weight; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; &emsp;&emsp;如上，greendao通过注解的方式帮我们自动生成了set/get方法，还有构造方法，这就对了，我们不用关，之后我们再执行如下代码生成数据库和表： 123DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(getApplicationContext(), &quot;haichenyi.db&quot;, null);DaoMaster daoMaster = new DaoMaster(devOpenHelper.getWritableDb());DaoSession daoSession = daoMaster.newSession(); &emsp;&emsp;通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。注意：默认的 DaoMaster.DevOpenHelper会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。升级的问题，我们在后面讲，这里我们先把数据库和表先创建了。 &emsp;&emsp;上面这个方式是java格式的，由于，我昨天写完框架之后，我把项目转成了kotlin代码，所以这里有点不一样，项目我后面会上传。这里我要说明的是（敲黑板）我用kotlin的时候，碰到了一个问题，当我使用greendao的时候，他提示我，无法引入用注解方式生成的类，dagger2也是一样的，我用java代码写就没有问题，我写这篇博客的时候，目前还没有找到解决的办法。 &emsp;&emsp;我用了另外一种方式，采用跟之前网络请求一样的设计模式——装饰者模式。我这里就不多做说明了。我贴出我的代码。 SqlHelper 12345678910111213141516package com.haichenyi.myproject.model.sql;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public interface SqlHelper &#123; void onAdd(); void onDelete(); void onUpdate(); void onSelect();&#125; &emsp;&emsp;这里定义增删改查4个方法，用于测试这4个功能 SqlImpl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.haichenyi.myproject.model.sql;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.model.bean.DaoMaster;import com.haichenyi.myproject.model.bean.DaoSession;import com.haichenyi.myproject.model.bean.UserDao;import com.haichenyi.myproject.utils.ToastUtils;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public class SqlImpl implements SqlHelper &#123; private final UserDao userDao; /** * 初始化Sql Dao. * * @param application &#123;@link MyApplication&#125; */ public SqlImpl(MyApplication application) &#123; SqlOpenHelper helper = new SqlOpenHelper(application, &quot;haichenyi.db&quot;); DaoSession daoSession = new DaoMaster(helper.getWritableDb()).newSession(); userDao = daoSession.getUserDao(); &#125; @Override public void onAdd() &#123; ToastUtils.Companion.showTipMsg(&quot;增加数据&quot;); &#125; @Override public void onDelete() &#123; ToastUtils.Companion.showTipMsg(&quot;删除数据&quot;); &#125; @Override public void onUpdate() &#123; ToastUtils.Companion.showTipMsg(&quot;更新数据&quot;); &#125; @Override public void onSelect() &#123; ToastUtils.Companion.showTipMsg(&quot;查询数据&quot;); &#125;&#125; &emsp;&emsp;功能实现类，看到他的构造方法里面，第二个参数就是我们的数据库名称，后面通过getWritableDb()获取的是可写的数据库，可写就肯定可读。然后就是接口的实现类了，这里就是具体的增删改查功能的实现类，我这里在对应的方法里面就写了Toast，增删改查具体怎么写后面再说 SqlOpenHelper 12345678910111213141516171819202122232425262728293031323334353637package com.haichenyi.myproject.model.sql;import android.content.Context;import com.haichenyi.myproject.model.bean.DaoMaster;import com.haichenyi.myproject.model.bean.UserDao;import org.greenrobot.greendao.database.Database;/** * Author: 海晨忆 * Date: 2018/2/24 * Desc: */public class SqlOpenHelper extends DaoMaster.OpenHelper &#123; public SqlOpenHelper(Context context, String name) &#123; super(context, name); &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123; super.onUpgrade(db, oldVersion, newVersion); MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() &#123; @Override public void onCreateAllTables(Database db, boolean ifNotExists) &#123; DaoMaster.createAllTables(db, ifNotExists); &#125; @Override public void onDropAllTables(Database db, boolean ifExists) &#123; DaoMaster.dropAllTables(db, ifExists); &#125; &#125;, UserDao.class); &#125;&#125; &emsp;&emsp;这个类用于管理数据库的表对应的字段发生变化的时候，数据库需要进行的版本更新，连上下面那个类，都是用于版本数据库版本更新的，防止数据丢失。怎么写呢？看到最后面的&emsp;UserDao.class&emsp;了吗？这个就是我们需要更新的表，你哪个表需要更新，直接写在后面就可以了，这个是可以一次传多个表的，并不是一次只能传一个 MigrationHelper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246package com.haichenyi.myproject.model.sql;import android.database.Cursor;import android.database.SQLException;import android.database.sqlite.SQLiteDatabase;import android.support.annotation.NonNull;import android.text.TextUtils;import android.util.Log;import org.greenrobot.greendao.AbstractDao;import org.greenrobot.greendao.database.Database;import org.greenrobot.greendao.database.StandardDatabase;import org.greenrobot.greendao.internal.DaoConfig;import java.lang.ref.WeakReference;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * Author: 海晨忆. * Date: 2018/2/24 * Desc: */public final class MigrationHelper &#123; public static boolean DEBUG = false; private static String TAG = &quot;MigrationHelper&quot;; private static final String SQLITE_MASTER = &quot;sqlite_master&quot;; private static final String SQLITE_TEMP_MASTER = &quot;sqlite_temp_master&quot;; private static WeakReference&lt;ReCreateAllTableListener&gt; weakListener; public interface ReCreateAllTableListener &#123; void onCreateAllTables(Database db, boolean ifNotExists); void onDropAllTables(Database db, boolean ifExists); &#125; public static void migrate(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; printLog(&quot;【The Old Database Version】&quot; + db.getVersion()); Database database = new StandardDatabase(db); migrate(database, daoClasses); &#125; public static void migrate(SQLiteDatabase db, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; weakListener = new WeakReference&lt;&gt;(listener); migrate(db, daoClasses); &#125; public static void migrate(Database database, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; weakListener = new WeakReference&lt;&gt;(listener); migrate(database, daoClasses); &#125; public static void migrate(Database database, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; printLog(&quot;【Generate temp table】start&quot;); generateTempTables(database, daoClasses); printLog(&quot;【Generate temp table】complete&quot;); ReCreateAllTableListener listener = null; if (weakListener != null) &#123; listener = weakListener.get(); &#125; if (listener != null) &#123; listener.onDropAllTables(database, true); printLog(&quot;【Drop all table by listener】&quot;); listener.onCreateAllTables(database, false); printLog(&quot;【Create all table by listener】&quot;); &#125; else &#123; dropAllTables(database, true, daoClasses); createAllTables(database, false, daoClasses); &#125; printLog(&quot;【Restore data】start&quot;); restoreData(database, daoClasses); printLog(&quot;【Restore data】complete&quot;); &#125; private static void generateTempTables(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; String tempTableName = null; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; if (!isTableExists(db, false, tableName)) &#123; printLog(&quot;【New Table】&quot; + tableName); continue; &#125; try &#123; tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;); StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append(&quot;DROP TABLE IF EXISTS &quot;).append(tempTableName).append(&quot;;&quot;); db.execSQL(dropTableStringBuilder.toString()); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append(&quot;CREATE TEMPORARY TABLE &quot;).append(tempTableName); insertTableStringBuilder.append(&quot; AS SELECT * FROM &quot;).append(tableName).append(&quot;;&quot;); db.execSQL(insertTableStringBuilder.toString()); printLog(&quot;【Table】&quot; + tableName + &quot;\n ---Columns--&gt;&quot; + getColumnsStr(daoConfig)); printLog(&quot;【Generate temp table】&quot; + tempTableName); &#125; catch (SQLException e) &#123; Log.e(TAG, &quot;【Failed to generate temp table】&quot; + tempTableName, e); &#125; &#125; &#125; private static boolean isTableExists(Database db, boolean isTemp, String tableName) &#123; if (db == null || TextUtils.isEmpty(tableName)) &#123; return false; &#125; String dbName = isTemp ? SQLITE_TEMP_MASTER : SQLITE_MASTER; String sql = &quot;SELECT COUNT(*) FROM &quot; + dbName + &quot; WHERE type = ? AND name = ?&quot;; Cursor cursor = null; int count = 0; try &#123; cursor = db.rawQuery(sql, new String[]&#123;&quot;table&quot;, tableName&#125;); if (cursor == null || !cursor.moveToFirst()) &#123; return false; &#125; count = cursor.getInt(0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); &#125; return count &gt; 0; &#125; private static String getColumnsStr(DaoConfig daoConfig) &#123; if (daoConfig == null) &#123; return &quot;no columns&quot;; &#125; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; daoConfig.allColumns.length; i++) &#123; builder.append(daoConfig.allColumns[i]); builder.append(&quot;,&quot;); &#125; if (builder.length() &gt; 0) &#123; builder.deleteCharAt(builder.length() - 1); &#125; return builder.toString(); &#125; private static void dropAllTables(Database db, boolean ifExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; reflectMethod(db, &quot;dropTable&quot;, ifExists, daoClasses); printLog(&quot;【Drop all table by reflect】&quot;); &#125; private static void createAllTables(Database db, boolean ifNotExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; reflectMethod(db, &quot;createTable&quot;, ifNotExists, daoClasses); printLog(&quot;【Create all table by reflect】&quot;); &#125; /** * dao class already define the sql exec method, so just invoke it */ private static void reflectMethod(Database db, String methodName, boolean isExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; if (daoClasses.length &lt; 1) &#123; return; &#125; try &#123; for (Class cls : daoClasses) &#123; Method method = cls.getDeclaredMethod(methodName, Database.class, boolean.class); method.invoke(null, db, isExists); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; private static void restoreData(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; String tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;); if (!isTableExists(db, true, tempTableName)) &#123; continue; &#125; try &#123; // get all columns from tempTable, take careful to use the columns list List&lt;String&gt; columns = getColumns(db, tempTableName); ArrayList&lt;String&gt; properties = new ArrayList&lt;&gt;(columns.size()); for (int j = 0; j &lt; daoConfig.properties.length; j++) &#123; String columnName = daoConfig.properties[j].columnName; if (columns.contains(columnName)) &#123; properties.add(&quot;`&quot; + columnName + &quot;`&quot;); &#125; &#125; if (properties.size() &gt; 0) &#123; final String columnSQL = TextUtils.join(&quot;,&quot;, properties); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append(&quot;REPLACE INTO &quot;).append(tableName).append(&quot; (&quot;); insertTableStringBuilder.append(columnSQL); insertTableStringBuilder.append(&quot;) SELECT &quot;); insertTableStringBuilder.append(columnSQL); insertTableStringBuilder.append(&quot; FROM &quot;).append(tempTableName).append(&quot;;&quot;); db.execSQL(insertTableStringBuilder.toString()); printLog(&quot;【Restore data】 to &quot; + tableName); &#125; StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append(&quot;DROP TABLE &quot;).append(tempTableName); db.execSQL(dropTableStringBuilder.toString()); printLog(&quot;【Drop temp table】&quot; + tempTableName); &#125; catch (SQLException e) &#123; Log.e(TAG, &quot;【Failed to restore data from temp table 】&quot; + tempTableName, e); &#125; &#125; &#125; private static List&lt;String&gt; getColumns(Database db, String tableName) &#123; List&lt;String&gt; columns = null; Cursor cursor = null; try &#123; cursor = db.rawQuery(&quot;SELECT * FROM &quot; + tableName + &quot; limit 0&quot;, null); if (null != cursor &amp;&amp; cursor.getColumnCount() &gt; 0) &#123; columns = Arrays.asList(cursor.getColumnNames()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); if (null == columns) columns = new ArrayList&lt;&gt;(); &#125; return columns; &#125; private static void printLog(String info) &#123; if (DEBUG) &#123; Log.d(TAG, info); &#125; &#125;&#125; &emsp;&emsp;这个类是工具类，拿过去用就好了，还有就是，应用怎么判断是否需要版本更新呢？打开你的app下面的build.grade，在根结点下面添加如下代码： 123greendao &#123; schemaVersion 1&#125; 每当你发布新版本的时候，把这个版本号+1即可。 &emsp;&emsp;当然，我门这里依然是用的dagger生成的全局单例，所以，你还需要在你的AppModule下面添加如下代码： 12345@Provides@SingletonSqlHelper provideSqlHelper() &#123; return new SqlImpl(application);&#125; &emsp;&emsp;记得把项目重新clean一遍，build一遍，重新跑项目的时候，找到你的数据库。data-data-你的应用包名-databases-haichenyi.db，这个就是我们的数据库。找个Sqlite可视化工具打开，你会看到如下结构。 &emsp;&emsp;太多了，不写了，下一篇写增删改查。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（三）—RxJava2.0+Retrofit2.0+OkHttp]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94RxJava2-0-Retrofit2-0-OkHttp%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上一篇，我们把mvp+dagger加进去了，这一篇，我们把网络请求加上 &emsp;&emsp;我这里的网络请求是用的装饰者模式去写的，什么是装饰者模式呢？在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。我的理解就是一个接口，两个实现类，一个实现类负责调用接口的方法，另一个类负责功能的具体实现。本文中所提到的代码都是伪代码，最后会给出完整的，最初版本的项目框架。不包含任何业务逻辑 &emsp;&emsp;容我一个一个来说，首先，我们一般请求网络的时候，会有统一的返回数据格式，一个是需要判断返回code码的，就比方说登录功能，那登录成功，还是失败，我们只用判断code码即可，这种类型，我们统一是HttpNoResult。还有一个是返回数据的，就比方说查一个列表数据。这里我们统一的是HttpResult。我先给出这两个类的代码： 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.model.http;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:没有解析数据的返回 */public class HttpNoResult &#123; private int code; private String msg; public int getCode() &#123; return code; &#125; public HttpNoResult setCode(int code) &#123; this.code = code; return this; &#125; public String getMsg() &#123; return msg; &#125; public HttpNoResult setMsg(String msg) &#123; this.msg = msg; return this; &#125; @Override public String toString() &#123; return &quot;HttpNoResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.haichenyi.myproject.model.http;import com.google.gson.annotations.SerializedName;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:有解析数据的返回 */public class HttpResult&lt;T&gt; &#123; private int code; private String msg; @SerializedName(value = &quot;result&quot;) private T data; public int getCode() &#123; return code; &#125; public HttpResult setCode(int code) &#123; this.code = code; return this; &#125; public String getMsg() &#123; return msg; &#125; public HttpResult setMsg(String msg) &#123; this.msg = msg; return this; &#125; public T getData() &#123; return data; &#125; public HttpResult setData(T data) &#123; this.data = data; return this; &#125; @Override public String toString() &#123; return &quot;HttpResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &quot;, data=&quot; + data + &apos;&#125;&apos;; &#125;&#125; &emsp;&emsp;这里我就需要说一点，有数据返回的时候，每个数据类型都是不一样的，所以，这里我用的泛型传递，不同的数据类型，传不同的bean对象 &emsp;&emsp;言归正传，我们来说说网络请求的一个接口，两个实现类。 一个接口—HttpHelper 1234567891011121314151617181920package com.haichenyi.myproject.model.http;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络接口，接口参数Token统一处理，方法中不传Token */public interface HttpHelper &#123; /** * 登录时获取验证码. * * @param phone 手机号 * @return &#123;&quot;code&quot;:0&#125; */ Flowable&lt;HttpNoResult&gt; loginCode(String phone); /*Flowable&lt;HttpResult&lt;Login&gt;&gt; login(String phone, String code); Flowable&lt;HttpResult&lt;List&lt;DiyBean&gt;&gt;&gt; diyKeys(String allId);*/&#125; &emsp;&emsp;Flowable是RxJava2.0新增的，所以说RxJava完美兼容Retrofit，泛型就是我们需要解析的数据 loginCode方法是说返回数据，我们只用判断是否是成功还是失败， login方法是说返回数据是一个Login对象，至于对象是什么内容，那就是和你们后台确认了 diyKeys方法就是说，返回数据是一个list对象，每个list的item是DiyBean对象 123456789101112131415161718192021222324package com.haichenyi.myproject.model;import com.haichenyi.myproject.model.http.HttpHelper;import com.haichenyi.myproject.model.http.HttpNoResult;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求的实现类 */public class DataHelper implements HttpHelper &#123; private HttpHelper http; public DataHelper(HttpHelper http) &#123; this.http = http; &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return http.loginCode(phone); &#125;&#125; &emsp;&emsp;DataHelper是HttpHelper的实现类，他的唯一作用就是调用接口的方法即可，具体的功能实现是后面一个类，这里需要说明的是这个类的构造方法要public表示，因为他要dagger生成，用private或者protected表示无法生成。 123456789101112131415161718192021222324package com.haichenyi.myproject.model.http;import com.haichenyi.myproject.model.http.api.HttpApi;import io.reactivex.Flowable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: 网络接口Retrofit实现 */public class RetrofitHelper implements HttpHelper&#123; private HttpApi httpApi; @Inject RetrofitHelper(HttpApi httpApi) &#123; this.httpApi = httpApi; &#125; @Override public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123; return httpApi.loginCode(phone); &#125;&#125; &emsp;&emsp;RetrofitHelper类作为HttpHelper接口的实现类，他是具体功能的实现类，为什么说他是具体功能的实现类呢？因为，他是调用HttpApi接口的方法。HttpApi接口是干什么用的呢？ 1234567891011121314151617181920212223242526package com.haichenyi.myproject.model.http.api;import com.haichenyi.myproject.model.http.HttpNoResult;import com.haichenyi.myproject.model.http.ProtocolHttp;import io.reactivex.Flowable;import retrofit2.http.Field;import retrofit2.http.FormUrlEncoded;import retrofit2.http.POST;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求接口api */public interface HttpApi &#123; /** * 登录时获取验证码. * * @param phone 手机号 * @return &#123;&quot;code&quot;:0&#125; */ @FormUrlEncoded @POST(ProtocolHttp.METHOD_LOGIN_CODE) Flowable&lt;HttpNoResult&gt; loginCode(@Field(&quot;phone&quot;) String phone);&#125; 这个就是Retrofit的网络请求的方式，看不懂？这个就是Retrofit的东西了方法注解，包含@GET、@POST、@PUT、@DELETE、@PATH、@HEAD、@OPTIONS、@HTTP。标记注解，包含@FormUrlEncoded、@Multipart、@Streaming。参数注解，包含@Query、@QueryMap、@Body、@Field，@FieldMap、@Part，@PartMap。其他注解，包含@Path、@Header、@Headers、@Url。 这里我们还差一个接口 123456789101112package com.haichenyi.myproject.model.http;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface ProtocolHttp &#123; String HTTP_HOST = &quot;http://xxx.xx.xxx.xxx:8080/app/con/&quot;; String HTTP_COMMON = &quot;common/&quot;; String METHOD_LOGIN_CODE = HTTP_COMMON + &quot;code&quot;;//登录发送验证码&#125; &emsp;&emsp;如上，这里需要注意的是不能以”\”结尾，然后就是，跟你们后台商量，格式不要错了，尽量就只有接口名字不同，接口名字前面部分都是一样的。 &emsp;&emsp;到此，这里基本上就说完了，那么有同鞋就会问了，接口定义方法的时候，我们知道该如何写返回数据类型呢？这个我就不知道了，你得问你们后台，根据后台返回的数据类型去写对应的bean类。推荐一个功能PostMan。 &emsp;&emsp;到目前为止，我们都还没有初始化网络请求的参数，这些网络请求的参数在哪里初始化呢？这些参数，我们就只用初始化一次，我们就想到了dagger的全局单例模式，没错，就是这个，我们上一篇写了很多没有用的东西，里面有一个HttpModule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.di.qualifier.ApiUrl;import com.haichenyi.myproject.model.http.ProtocolHttp;import com.haichenyi.myproject.model.http.api.HttpApi;import java.util.concurrent.TimeUnit;import javax.inject.Singleton;import dagger.Module;import dagger.Provides;import okhttp3.OkHttpClient;import retrofit2.Retrofit;import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;import retrofit2.converter.gson.GsonConverterFactory;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:网络请求的参数初始化 */@Modulepublic class HttpModule &#123; @Provides @Singleton OkHttpClient.Builder providesOkHttpHelper() &#123;//请求读写超时时间 return new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .readTimeout(10, TimeUnit.SECONDS) .writeTimeout(10, TimeUnit.SECONDS); &#125; @Provides @Singleton OkHttpClient provideClient(OkHttpClient.Builder builder) &#123; return builder// .addInterceptor(new MyHttpInterceptor()) .build(); &#125; @Provides @Singleton Retrofit.Builder providesRetrofitBuilder() &#123; return new Retrofit.Builder(); &#125; @Provides @Singleton HttpApi provideApi(@ApiUrl Retrofit retrofit) &#123; return retrofit.create(HttpApi.class); &#125; @Provides @Singleton @ApiUrl Retrofit providesApiRetrofit(Retrofit.Builder builder, OkHttpClient client) &#123; return createRetrofit(builder, client, ProtocolHttp.HTTP_HOST);//这里就是你的网络请求的url &#125; private Retrofit createRetrofit(Retrofit.Builder builder, OkHttpClient client, String host) &#123; return builder.client(client) .baseUrl(host) .addConverterFactory(GsonConverterFactory.create())//添加gson自动解析，我们不用关 .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); &#125;&#125; 如上代码，注释写的都有，考过去用就行了 在AppModule里面添加如下代码 12345678910111213141516171819202122232425262728293031323334353637package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.model.DataHelper;import com.haichenyi.myproject.model.http.HttpHelper;import com.haichenyi.myproject.model.http.RetrofitHelper;import javax.inject.Singleton;import dagger.Module;import dagger.Provides;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class AppModule &#123; private MyApplication application; public AppModule(MyApplication application) &#123; this.application = application; &#125; @Provides @Singleton DataHelper provideDataHelper(HttpHelper httpHelper) &#123; return new DataHelper(httpHelper); &#125; @Provides @Singleton HttpHelper provideHttpHelper(RetrofitHelper retrofitHelper) &#123; return retrofitHelper; &#125;&#125; 这里都是dagger了生成全局单例对象需要的东西 在AppComponent里面添加如下代码 1234567891011121314151617181920package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.di.module.AppModule;import com.haichenyi.myproject.di.module.HttpModule;import com.haichenyi.myproject.model.DataHelper;import javax.inject.Singleton;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Singleton@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)public interface AppComponent &#123; DataHelper getDataHelper();&#125; 在BaseMvpPresenter里面添加如下代码 123456789101112131415161718192021222324252627282930313233343536373839package com.haichenyi.myproject.base;import io.reactivex.disposables.CompositeDisposable;import io.reactivex.disposables.Disposable;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123; protected T baseView; private CompositeDisposable disposables; @Override public void attachView(T baseView) &#123; this.baseView = baseView; &#125; protected void addSubscribe(Disposable disposable) &#123; if (null == disposables) &#123; disposables = new CompositeDisposable(); &#125; disposables.add(disposable); &#125; @Override public void detachView() &#123; this.baseView = null; unSubscribe(); &#125; private void unSubscribe() &#123; if (null != disposables) &#123; disposables.clear(); disposables = null; &#125; &#125;&#125; 至此，就全部写完了，关于网络请求的内容。调用方式如下： 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.model.DataHelper;import javax.inject.Inject;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; private DataHelper dataHelper; @Inject MainPresenter() &#123; dataHelper = MyApplication.getAppComponent().getDataHelper(); &#125; @Override public void loadData() &#123; addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe());// baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; 记得在清单文件里面，加上网络权限 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 网络请求，这样调用之后在哪处理呢？我给出我的几个处理的工具类。首先，按如下图设置1.8支持lambda表达式 然后添加如下几个类 HttpCode 123456789101112131415161718192021package com.haichenyi.myproject.model.http;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 网络请求状态码 */public interface HttpCode &#123; /** * 成功. */ int SUCCESS = 0; /** * 参数为空. */ int NO_PARAMETER = 1; /** * 服务器错误. */ int SERVER_ERR = 3;&#125; ApiException 1234567891011121314151617181920212223242526272829package com.haichenyi.myproject.model.http;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 接口异常判断处理 */public class ApiException extends Exception &#123; private int code; @SuppressWarnings(&quot;unused&quot;) public ApiException(int code) &#123; this.code = code; &#125; public ApiException(int code, String message) &#123; super(message); this.code = code; &#125; public int getCode() &#123; return code; &#125; public ApiException setCode(int code) &#123; this.code = code; return this; &#125;&#125; MyRxUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.haichenyi.myproject.model.http;import io.reactivex.BackpressureStrategy;import io.reactivex.Flowable;import io.reactivex.FlowableTransformer;import io.reactivex.Scheduler;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆. * Date: 2017/12/27 * Desc:切换线程的工具类 */public class MyRxUtils &#123; /** * 从其他线程转到主线程. * * @param scheduler Schedulers.io()等等 * @param &lt;T&gt; t * @return FlowableTransformer */ public static &lt;T&gt; FlowableTransformer&lt;T, T&gt; toMain(Scheduler scheduler) &#123; return upstream -&gt; upstream.subscribeOn(scheduler).observeOn(AndroidSchedulers.mainThread()); &#125; public static &lt;T&gt; FlowableTransformer&lt;HttpResult&lt;T&gt;, T&gt; handResult() &#123; return upstream -&gt; upstream.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .flatMap(tHttpResult -&gt; &#123; if (tHttpResult.getCode() == HttpCode.SUCCESS) &#123; return /*createData(tHttpResult.data)*/Flowable.just(tHttpResult.getData()); &#125; else &#123; return Flowable.error(new ApiException(tHttpResult.getCode(), tHttpResult.getMsg())); &#125; &#125;); &#125; private static &lt;T&gt; Flowable&lt;T&gt; createData(final T data) &#123; return Flowable.create(e -&gt; &#123; e.onNext(data); e.onComplete(); &#125;, BackpressureStrategy.ERROR); &#125;&#125; MySubscriber 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.haichenyi.myproject.model.http;import com.haichenyi.myproject.base.BaseView;import io.reactivex.subscribers.ResourceSubscriber;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: */public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123; private BaseView baseView; private boolean showLoading; public MySubscriber(BaseView baseView) &#123; this.baseView = baseView; &#125; public MySubscriber(BaseView baseView, boolean showLoading) &#123; this.baseView = baseView; this.showLoading = showLoading; &#125; @Override protected void onStart() &#123; super.onStart(); if (null != baseView &amp;&amp; showLoading) &#123; baseView.showLoading(); &#125; &#125; @Override public void onError(Throwable t) &#123; if (null == baseView) &#123; return; &#125; baseView.hideLoading(); if (t instanceof ApiException) &#123; ApiException apiException = (ApiException) t; switch (apiException.getCode()) &#123; case HttpCode.NO_PARAMETER: baseView.showTipMsg(&quot;参数为空&quot;); break; case HttpCode.SERVER_ERR: baseView.showTipMsg(&quot;服务器错误&quot;); break; default: break; &#125; &#125; &#125; @Override public void onComplete() &#123; if (null != baseView) &#123; baseView.hideLoading(); &#125; &#125;&#125; 这几个类不想多做解释，结合注释，仔细看几遍，就知道是干嘛用的了 加上这几个之后调用方式就变成了以下的方式： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.base.MyApplication;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.model.DataHelper;import com.haichenyi.myproject.model.http.HttpNoResult;import com.haichenyi.myproject.model.http.MyRxUtils;import com.haichenyi.myproject.model.http.MySubscriber;import javax.inject.Inject;import io.reactivex.schedulers.Schedulers;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; private DataHelper dataHelper; @Inject MainPresenter() &#123; dataHelper = MyApplication.getAppComponent().getDataHelper(); &#125; @Override public void loadData() &#123; addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;) .compose(MyRxUtils.toMain(Schedulers.io())) .subscribeWith(new MySubscriber&lt;HttpNoResult&gt;(baseView, true) &#123; @Override public void onNext(HttpNoResult httpNoResult) &#123; &#125; &#125;));// baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; 完了，完了，终于写完了。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（二）—MVP+dagger2]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94MVP-dagger2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;接着上一篇简单的框架，没有看过的同鞋可以去喵一眼。上一篇我们搭好了简单的框架，初始化一次的内容丢在Application里面，所有的activity继承一个类BaseActivity，还有Fragment继承的一个类BaseFragment &emsp;&emsp;现在我们来加上MVP，不懂MVP的同鞋可以看一下，我前面写过的三种主流框架的对比。我们先导入dagger2的两个包，代码如下： 12implementation &apos;com.google.dagger:dagger:2.14.1&apos;annotationProcessor &quot;com.google.dagger:dagger-compiler:2.14.1&quot; 第一步&emsp;&emsp;新建BasePresenter接口，BaseMvpPresenter类去实现BasePresenter接口，代码如下 123456789101112package com.shfzwkeji.smartwardrobe.base;/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 不带mvp的presenter的基类 */public interface BasePresenter&lt;T extends BaseView&gt; &#123; void attachView(T baseView); void detachView();&#125; 1234567891011121314151617181920package com.haichenyi.myproject.base;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:带mvp的presenter的基类 */public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123; protected T baseView; @Override public void attachView(T baseView) &#123; this.baseView = baseView; &#125; @Override public void detachView() &#123; this.baseView = null; &#125;&#125; &emsp;&emsp;这里就只有两个方法，一个是绑定view，还有一个是在ondestory方法里面解除绑定的方法，用来保证P层的生命周期和V层同步，避免了，当V层销毁的时候，P层仍然存在造成的内存泄漏。 第二步&emsp;&emsp;新建BaseMvpActivity 12345678910111213141516171819202122232425262728293031323334package com.haichenyi.myproject.base;import javax.inject.Inject;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc:带MVP的Activity */public abstract class BaseMvpActivity&lt;T extends BasePresenter&gt; extends BaseActivity&#123; @Inject protected T basePresenter; @Override @SuppressWarnings(&quot;unchecked&quot;) protected void initView() &#123; super.initView(); initInject(); if (null != basePresenter) &#123; basePresenter.attachView(this); &#125; &#125; protected abstract void initInject(); @Override protected void onDestroy() &#123; if (null != basePresenter) &#123; basePresenter.detachView(); basePresenter = null; &#125; super.onDestroy(); &#125;&#125; &emsp;&emsp;运用dagger2注解的方式，生成P层，这里我们在用P层之前得先生成P层，所以initject方法一定要在basePresenter用之前调用，因为他就是生成P层的代码。 &emsp;&emsp;怎么生成呢？dagger我们一般都命名成di层，所以，我们先创建di层的package，项目结构图如下： &emsp;&emsp;这里给出的是mvp+dagger加入之后的项目结构。我们重点看选中的di层，里面有4个package分别是component，module，qualifier，scope四个包，至于他们的作用分别是什么，请自行百度，google，dagger的用法。我这里先贴出这几个类，接口的代码： ActivityComponent 123456789101112131415161718package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.MainActivity;import com.haichenyi.myproject.di.module.ActivityModule;import com.haichenyi.myproject.di.scope.ActivityScope;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@ActivityScope@Component(dependencies = AppComponent.class, modules = ActivityModule.class)public interface ActivityComponent &#123; void inject(MainActivity mainActivity);&#125; AppComponent 123456789101112131415161718package com.haichenyi.myproject.di.component;import com.haichenyi.myproject.di.module.AppModule;import com.haichenyi.myproject.di.module.HttpModule;import javax.inject.Singleton;import dagger.Component;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Singleton@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)public interface AppComponent &#123;&#125; ActivityModule 123456789101112package com.haichenyi.myproject.di.module;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class ActivityModule &#123;&#125; AppModule 12345678910111213141516171819package com.haichenyi.myproject.di.module;import com.haichenyi.myproject.base.MyApplication;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class AppModule &#123; private MyApplication application; public AppModule(MyApplication application) &#123; this.application = application; &#125;&#125; HttpModule 123456789101112package com.haichenyi.myproject.di.module;import dagger.Module;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Modulepublic class HttpModule &#123;&#125; ActivityScope 12345678910111213141516package com.haichenyi.myproject.di.scope;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import javax.inject.Scope;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */@Scope@Retention(RetentionPolicy.RUNTIME)public @interface ActivityScope &#123;&#125; &emsp;&emsp;这几个类，接口里面基本上都没有内容，因为这几个类都是后面才会用的到的，这里我直接贴出来，说起来方便一些。还需要加两个方法，在MyApplication里面加如下方法: 1234567891011121314/** * 获取AppComponent. * * @return AppComponent */ public static synchronized AppComponent getAppComponent() &#123; if (null == appComponent) &#123; appComponent = DaggerAppComponent.builder() .appModule(new AppModule(getInstance())) .httpModule(new HttpModule()) .build(); &#125; return appComponent; &#125; 在BaseActivity里面加如下方法： 123456protected ActivityComponent getActivityComponent() &#123; return DaggerActivityComponent.builder() .appComponent(MyApplication.getAppComponent()) .activityModule(new ActivityModule()) .build(); &#125; &emsp;&emsp;加完这两个方法之后，肯定会有错误提示，重新编译一遍项目就可以了，如果重新编译一遍，还是不行，请重新对比一下，哪里不一样。 第三步&emsp;&emsp;就是关于mvp的了，从上面图应该看到了，有一个presenter包，和contract包，我们之前有一篇博客讲过，MVP就是多了很多个接口，这些接口写在哪呢？就在contract层 MainContract 代码如下： 123456789101112131415161718package com.haichenyi.myproject.contract;import com.haichenyi.myproject.base.BasePresenter;import com.haichenyi.myproject.base.BaseView;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface MainContract &#123; interface IView extends BaseView&#123; &#125; interface Presenter extends BasePresenter&lt;IView&gt;&#123; void loadData(); &#125;&#125; &emsp;&emsp;这里我需要说明的就是Presenter接口继承的是IVew，不是BaseView，页面变化的方法都是在IView接口里面定义，逻辑处理，网络请求方法都是在Presenter接口里面定义 MainPresenter 代码如下 1234567891011121314151617181920212223package com.haichenyi.myproject.presenter;import com.haichenyi.myproject.base.BaseMvpPresenter;import com.haichenyi.myproject.contract.MainContract;import javax.inject.Inject;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt; implements MainContract.Presenter &#123; @Inject MainPresenter() &#123; &#125; @Override public void loadData() &#123; baseView.showTipMsg(&quot;加载数据&quot;); &#125;&#125; &emsp;&emsp;这里我需要说明的是注意继承BaseMvpPresenter传的是MainContract.IView，不是BaseView，实现MainContract.Presenter接口，还有一点就是注意构造方法，上面有注解，这里的loadData里面应该是我们的网络请求逻辑，这里我放到后面一篇在说，这里我先就直接Toast，表示走了这个方法 第四步&emsp;&emsp;就是MainActivity，这里我贴出代码 123456789101112131415161718192021222324252627package com.haichenyi.myproject;import android.os.Bundle;import com.haichenyi.myproject.base.BaseMvpActivity;import com.haichenyi.myproject.contract.MainContract;import com.haichenyi.myproject.presenter.MainPresenter;public class MainActivity extends BaseMvpActivity&lt;MainPresenter&gt; implements MainContract.IView &#123; @Override protected int getLayoutId(Bundle savedInstanceState) &#123; return R.layout.activity_main; &#125; @Override protected void initData() &#123; super.initData(); initToolbar(true, false, true).setMyTitle(&quot;主页&quot;).setMoreTitle(&quot;更多&quot;); basePresenter.loadData(); &#125; @Override protected void initInject() &#123; getActivityComponent().inject(this); &#125;&#125; &emsp;&emsp;这里我需要说明的是继承BaseMvpActivity，泛型直接传MainPresenter，然后，实现MainContract.IView接口，直接用basePresenter调用方法，需要实现initInject方法，只要是是继承BaseMvpActivity的activity，都需要在ActivityComponent()里面注册一边。比方说，LoginActivity也是继承的BaseMvpActivity，辣么，在di层的component包下面的ActivityComponent接口里面定义一个方法 1void inject(LoginActivity loginActivity); 在LoginActivity的initInject方法里面写同样的代码 1getActivityComponent().inject(this); 就像这样写就可以了。 总结&emsp;&emsp;写到这里，mvp+dagger2基本上完成了，MVP的目的就是解藕，把业务逻辑，网络请求丢在P层，页面不发生变化，就只用改P层逻辑，从而达到了解藕的目的。dagger2简化了代码，并且，它有着全局单例模式，和局部单例模式，优化了我们的内存，减少了内存浪费。不用每次都去new一个P层对象出来。下一篇，我们就把网络请求加上 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建一个主流项目框架（一）—简单的框架]]></title>
    <url>%2F2018%2F02%2F23%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[目的&emsp;&emsp;首先先说出，最终的目的是现在主流的MVP+RxJava+Retrofit+OkHttp框架。让大家心里有底 &emsp;&emsp;开发工具Android Studio3.0，还在用eclipse的同鞋，强烈推荐你跨出这一步，你会发现一个新的世界。android studio都出来这么久了，你还在远古时代做开发，说句不好听的，你完全与时代脱轨，你不适合做开发（纯属个人观点） &emsp;&emsp;本篇就只有三部分，第一部分就是新建一个Application，第二部分就是BaseActivity，第三部分就是BaseFragment Application&emsp;&emsp;首先你得有application类，去初始化应用只用初始化一次的内容，继承Application，然后在清单文件里面注册。 123456789101112131415161718192021222324252627282930313233343536373839package com.haichenyi.myproject;import android.app.Application;import com.squareup.leakcanary.LeakCanary;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public class MyApplication extends Application &#123; private static MyApplication instance; public MyApplication getInstance() &#123; return instance; &#125; private void setInstance(MyApplication instance) &#123; MyApplication.instance = instance; &#125; @Override public void onCreate() &#123; super.onCreate(); setInstance(this); initLeakCanary(); &#125; /** * 初始化内存检测工具 */ private void initLeakCanary() &#123; if (LeakCanary.isInAnalyzerProcess(this)) &#123; return; &#125; LeakCanary.install(this); &#125;&#125; &emsp;&emsp;如上代码，我这里就初始化了一个全局application单例对象，还初始化square公司出品的一个内存检测工具，用于检测你项目中内存泄漏情况。便于你优化项目。 &emsp;&emsp;如上图所示，这个就是清单文件，在application结点下面，添加name标签，内容就是你创建的application的名字。这里你还需要添加两个内存检测的依赖。 &emsp;&emsp;如上图所示，首先把你的项目结构视图切换到Project，打开你的app目录下的build.gradle文件，在dependencies结点下面（只要是添加开源库都是在该结点下面，后面就不说了），添加如下两行代码： 12releaseImplementation &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos; &emsp;&emsp;最后的1.5.4是版本号，你可以在github上面搜索leakcanary，找最新的版本 BaseActivity&emsp;&emsp;创建基类BaseActivity，也就是所有Activity的父类。还有一个基类的接口BaseView，BaseActivity继承刚才添加的依赖的SupportActivity类，实现BaseView接口，并且实现点击事件的接口（选择实现，你要是不乐意在基类里面写，你可以在你自己的子类里面重新实现一遍也是可以的）。代码如下：每个方法注释写的很清楚，就不用一一解释了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.haichenyi.myproject.base;import android.app.AlertDialog;import android.graphics.Color;import android.graphics.drawable.ColorDrawable;import android.os.Bundle;import android.support.annotation.Nullable;import android.view.Window;import android.widget.ProgressBar;import com.haichenyi.myproject.utils.ToastUtils;import me.yokeyword.fragmentation.SupportActivity;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public abstract class BaseActivity extends SupportActivity implements BaseView &#123; private AlertDialog loadingDialog; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; /** * Toast 提示用户 * @param msg 提示内容String */ @Override public void showTipMsg(String msg) &#123; ToastUtils.showTipMsg(msg); &#125; /** * Toast 提示用户 * @param msg 提示内容res目录下面的String的int值 */ @Override public void showTipMsg(int msg) &#123; ToastUtils.showTipMsg(msg); &#125; /** * 网络请求的时候显示正在加载的对话框 */ @Override public void showLoading() &#123; if (null == loadingDialog) &#123; loadingDialog = new AlertDialog.Builder(this).setView(new ProgressBar(this)).create(); loadingDialog.setCanceledOnTouchOutside(false); Window window = loadingDialog.getWindow(); if (null != window) &#123; window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); &#125; &#125; if (!loadingDialog.isShowing()) &#123; loadingDialog.show(); &#125; &#125; /** * 网络请求完成时隐藏加载对话框 */ @Override public void hideLoading() &#123; if (null != loadingDialog) &#123; if (loadingDialog.isShowing()) &#123; loadingDialog.dismiss(); &#125; loadingDialog = null; &#125; &#125; @Override public void invalidToken() &#123; //用于检测你当前用户的token是否有效，无效就返回登录界面，具体的业务逻辑你自己实现 //如果需要做到实时检测，推荐用socket长连接，每隔10秒发送一个验证当前登录用户token是否过期的请求 &#125; /** * Finish当前页面，最好实现onBackPressedSupport()，这个方法会有一个退栈操作， * 开源框架实现的，我们不用管 */ @Override public void myFinish() &#123; onBackPressedSupport(); &#125; @Override public void onBackPressedSupport() &#123; super.onBackPressedSupport(); &#125;&#125; &emsp;&emsp;上面是目前BaseActivity代码，注释写的很清楚，你会发现BaseView你并没有，下面我给出BaseView的代码 12345678910111213141516171819202122package com.haichenyi.myproject.base;import android.support.annotation.StringRes;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public interface BaseView &#123; void showTipMsg(String msg); void showTipMsg(@StringRes int msg); void showLoading(); void hideLoading(); void invalidToken(); void myFinish();&#125; &emsp;&emsp;BaseView就是一个接口，是所有V层的基类，代码很简单，Toast方法，显示隐藏加载的对话框方法，检验token是否过期的方法，finish当前页面的方法。什么？Toast方法你没有，下面我贴出来我的Toast的工具类 1234567891011121314151617181920212223242526272829303132333435/** * Author: 海晨忆. * Date: 2017/12/21 * Desc: 实时更新的Toast工具类 */public final class ToastUtils &#123; private static Toast toast; private ToastUtils() &#123; throw new RuntimeException(&quot;工具类不允许创建对象&quot;); &#125; @SuppressWarnings(&quot;all&quot;) private static void init() &#123; if (toast == null) &#123; toast = Toast.makeText(MyApplication.getInstance(), &quot;&quot;, Toast.LENGTH_SHORT); &#125; &#125; public static void showTipMsg(String msg) &#123; if (null == toast) &#123; init(); &#125; toast.setText(msg); toast.show(); &#125; public static void showTipMsg(@StringRes int msg) &#123; if (null == toast) &#123; init(); &#125; toast.setText(msg); toast.show(); &#125;&#125; &emsp;&emsp;上面我贴出了三个类，这里我要说明的是，我又创建了两个package，一个是base，一个是utils，我把BaseActivity,BaseView,MyApplication放在base包下面，Toast的工具类放在utils包下面 &emsp;&emsp;再就是添加一些常用的东西了，这里我没有用黄油刀，用过一段时间之后，感觉他的每个控件都是全局的，有点占内存，就放弃了。我下面贴出BaseActivity新增的伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 保存当前activity对象，在OnCreate里面添加，记得在OnDestroy里面移除 * 有什么用呢？ * 比方说有一个需求，让你在任意位置弹出对话框，弹对话框又需要一个context对象，这个时候， * 你就只用传当前list的最上层的activity对象就可以了 * 当然还有其他需求 */ public static List&lt;BaseActivity&gt; activities = new ArrayList&lt;&gt;(); private Toolbar toolbar; private TextView tvToolbarTitle; private TextView tvToolbarRight; private TextView tvBack; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); activities.add(this); //强制竖屏(不强制加) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); int layoutId = getLayoutId(savedInstanceState); View inflate = getLayoutInflater().inflate(R.layout.activity_base, toolbar, false); LinearLayout rootLinearLayout = inflate.findViewById(R.id.ll_layout_base_activity); //没有布局的时候传0 if (0 == layoutId) &#123; setContentView(rootLinearLayout); &#125; else &#123; View rootView = getLayoutInflater().inflate(layoutId, rootLinearLayout, true); setContentView(rootView); &#125; stateBar(); initView(); initData(); setOnClick(R.id.tv_back_base_activity); &#125; /** * 设置点击事件. * * @param ids 被点击View的ID * @return &#123;@link BaseActivity&#125; */ public BaseActivity setOnClick(@IdRes int... ids) &#123; View view; for (int id : ids) &#123; view = findViewById(id); if (null != view) &#123; view.setOnClickListener(this); &#125; &#125; return this; &#125; /** * 设置点击事件. * * @param views 被点击View * @return &#123;@link BaseActivity&#125; */ public BaseActivity setOnClick(View... views) &#123; for (View view : views) &#123; view.setOnClickListener(this); &#125; return this; &#125; /** * 获取当前布局对象 * * @param savedInstanceState 这个是当前activity保存的数据，最常见的就是横竖屏切换的时候， * 数据丢失问题 * @return 当前布局的int值 */ protected abstract int getLayoutId(Bundle savedInstanceState); @Override protected void onDestroy() &#123; activities.remove(this); super.onDestroy(); &#125; protected void initData() &#123; &#125; protected void initView() &#123; toolbar = findViewById(R.id.toolbar_base_activity); tvToolbarTitle = findViewById(R.id.tv_title_base_activity); tvToolbarRight = findViewById(R.id.tv_right_base_activity); &#125; /** * 设置状态栏背景颜色，不能改变状态栏内容的颜色 */ private void stateBar() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; SystemBarTintManager tintManager = new SystemBarTintManager(this); tintManager.setStatusBarTintEnabled(true); tintManager.setNavigationBarTintEnabled(true); tintManager.setTintColor(Color.parseColor(&quot;#000000&quot;)); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.tv_back_base_activity: onBackPressedSupport(); break; default: break; &#125; &#125; &emsp;&emsp;这里我需要说明的是，新增了一个开源框架，就是设置状态栏背景颜色的systembartint。 1implementation &apos;com.readystatesoftware.systembartint:systembartint:1.0.3&apos; &emsp;&emsp;再就是设置activity标题内容，左边，右边的内容，左边右边可能是文字，也可能是图片。所以，我在用的时候，都是用的TextView，ImageView，不能设置文字。方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public BaseActivity setTitles(CharSequence title) &#123; tvToolbarTitle.setText(title); return this; &#125; /** * 初始化toolbar的内容 * @param isShowToolbar 是否显示toolbar * @param isShowBack 是否显示左边的TextView * @param isShowMore 是否显示右边的TextView * @return 当前activity对象，可以连点 */ protected BaseActivity initToolbar(boolean isShowToolbar, boolean isShowBack, boolean isShowMore) &#123; setSupportActionBar(toolbar); ActionBar actionBar = getSupportActionBar(); if (null != actionBar) &#123; if (isShowToolbar) &#123; actionBar.show(); tvBack = findViewById(R.id.tv_back_base_activity); TextView textView = findViewById(R.id.tv_right_base_activity); if (null != tvBack &amp;&amp; null != textView) &#123; tvBack.setVisibility(isShowBack ? View.VISIBLE : View.INVISIBLE); textView.setVisibility(isShowMore ? View.VISIBLE : View.INVISIBLE); &#125; &#125; else &#123; actionBar.hide(); &#125; &#125; return this; &#125; public BaseActivity setToolbarBack(int colorId) &#123; toolbar.setBackgroundColor(getResources().getColor(colorId)); return this; &#125; @SuppressWarnings(&quot;unused&quot;) public BaseActivity setMyTitle(String title) &#123; tvToolbarTitle.setText(title); return this; &#125; public BaseActivity setMyTitle(@StringRes int stringId) &#123; tvToolbarTitle.setText(stringId); return this; &#125; public void setMoreTitle(String moreTitle) &#123; tvToolbarRight.setText(moreTitle); &#125; public BaseActivity setMoreTitle(@StringRes int stringId) &#123; tvToolbarRight.setText(stringId); return this; &#125; /** * 设置左边内容. * * @param leftTitle 内容 * @return &#123;@link BaseActivity&#125; */ public BaseActivity setLeftTitle(String leftTitle) &#123; if (tvBack != null) &#123; tvBack.setBackground(null); tvBack.setText(leftTitle); &#125; return this; &#125; /** * 设置左边内容. * * @param leftTitle 内容 */ public void setLeftTitle(@StringRes int leftTitle) &#123; if (tvBack != null) &#123; tvBack.setBackground(null); tvBack.setText(leftTitle); &#125; &#125; @SuppressWarnings(&quot;unused&quot;) protected BaseActivity setMoreBackground(int resId) &#123; tvToolbarRight.setBackgroundResource(resId); return this; &#125; &emsp;&emsp;可以看到上面的方法返回值都是BaseActivity，这样做的目的就只有一个，可以连点，写一个方法之后，可以接着点写下一个方法，不用写一个方法就要加分号，就换一行写下一个方法。 &emsp;&emsp;还要加一句，在你的app主题里面添加两个item，也就是你的res目录下面的style： 12&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &emsp;&emsp;我这里贴出我目前的style的图片 &emsp;&emsp;下面有一个LineHorizontal样式，就是你toolbar下面的那个横线 BaseFragment&emsp;&emsp;BaseFragment跟BaseActivity的逻辑是差不多的，我这里就贴出代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package com.haichenyi.myproject.base;import android.os.Bundle;import android.support.annotation.IdRes;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.haichenyi.myproject.utils.ToastUtils;import me.yokeyword.fragmentation.SupportFragment;/** * Author: 海晨忆 * Date: 2018/2/23 * Desc: */public abstract class BaseFragment extends SupportFragment implements BaseView, View.OnClickListener &#123; protected boolean isInit; private View rootView; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; int layoutRes = layoutRes(); if (0 != layoutRes) &#123; return inflater.inflate(layoutRes, null); &#125; else &#123; return super.onCreateView(inflater, container, savedInstanceState); &#125; &#125; @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); rootView = view; &#125; @Override public void onLazyInitView(@Nullable Bundle savedInstanceState) &#123; super.onLazyInitView(savedInstanceState); isInit = true; init(); &#125; protected &lt;T extends View&gt; T findViewById(@IdRes int id) &#123; return rootView.findViewById(id); &#125; /** * 设置点击事件. * * @param ids 被点击View的ID * @return &#123;@link BaseFragment&#125; */ public BaseFragment setOnClick(@IdRes int... ids) &#123; for (int id : ids) &#123; rootView.findViewById(id).setOnClickListener(this); &#125; return this; &#125; /** * 设置点击事件. * * @param views 被点击View的ID * @return &#123;@link BaseFragment&#125; */ public BaseFragment setOnClick(View... views) &#123; for (View view : views) &#123; view.setOnClickListener(this); &#125; return this; &#125; protected abstract void init(); @Override public void onDestroy() &#123; rootView = null; super.onDestroy(); &#125; protected abstract int layoutRes(); @Override public void showTipMsg(String msg) &#123; ToastUtils.showTipMsg(msg); &#125; @Override public void showTipMsg(int msg) &#123; ToastUtils.showTipMsg(msg); &#125; @Override public void showLoading() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.showLoading(); &#125;*/ &#125; @Override public void hideLoading() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.hideLoading(); &#125;*/ &#125; @Override public void invalidToken() &#123; BaseActivity activity = (BaseActivity) getActivity(); /*if (activity instanceof BaseMvpActivity) &#123; activity.invalidToken(); &#125;*/ &#125; @Override public void onClick(View v) &#123; &#125; @Override public void myFinish() &#123; onBackPressedSupport(); &#125;&#125; &emsp;&emsp;两者在布局抽象方法里面有一点区别，Activity的传了Boundle参数，Fragment没有传，因为Fragment可以通过getArguments()方法获取到这个对象，而Activity不能获取到。 总结&emsp;&emsp;到此，一个简单的项目框架就出来了，目前还是框架的第一步，是一个雏形，还不包括MVP，dagger等等，下一篇就加上MVP，我这个人有个好习惯，就是喜欢写注释，我注释写的很清楚，是干什么用的，我也衷心的希望，你能写好注释。 项目链接]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVC、MVP、MVVM比较]]></title>
    <url>%2F2018%2F02%2F22%2FMVC%E3%80%81MVP%E3%80%81MVVM%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[Android框架的最终目的，也是体现一个项目好坏的唯一标准——高类聚，低耦合 MVC&emsp;&emsp;我们刚接触android写代码的时候基本上都是MVC架构。什么是MVC架构呢？ &emsp;&emsp;MVC：Model View Controller的简称。流程图如下： &emsp;&emsp;当用户发出事件的时候，首先通过V层，通知C层，然后C层通知Model层数据发生了变化，更新数据，M层直接显示数据到V层。 &emsp;&emsp;通俗的讲，xml可以理解层View层，你封装的网络请求的帮助类理解成model层，activity，fragment理解成Controller层。这么理解是可以的，但是，你不能说xml就是view层，这样说是不对的 &emsp;&emsp;举个例子，比方说一个登录的网络请求，首先，你需要点击按钮去触发网络请求的方法，你点击的这个button就是写在xml布局里面的，这就是V层。然后触发的网络请求帮助类去发送对应的登录请求方法，这就是model层。两者是怎么联系在一起的呢？就是我们在activity，fragment层里面写的onclick方法。activity，fragment就是Controller层。 MVP&emsp;&emsp;所有的UI变化，网络请求等等业务逻辑之类的都写在Activity里面，Activity既要处理业务逻辑，又要处理UI变化，代码就显得非常臃肿。 &emsp;&emsp;这个时候，MVP就顺势而生，什么是MVP架构呢？ &emsp;&emsp;MVP：Model View Presenter的简称 &emsp;&emsp;MVP作为MVC的演化版本，解决了MVC不少的缺点，对于Android来说，MVP的M层，相对于MVC来说是一样的，而不一样的就是activity不再是controller，而是纯粹的V层，所有关于用户事件的转发，全都由P层去处理 &emsp;&emsp;MVP和MVC最明显的差别就是，M层和V层完全解藕，两者的通信是通过P层，P层作为桥梁，用于操作View层发送的事件到P层，P层去操作M层，并且，讲数据返回给V层。整个过层M层和V层两者完全没有联系。辣么，就有好奇的宝宝就问了，这样做解决不了更本问题，你这样做P层和V层不一样耦合在一起了吗？我们并不能完全不耦合，只是尽可能减少耦合度。我们写程序最终目的就是高类聚，低耦合，不是说完全不耦合。并且，我们这里P层和V层是通过接口通信的，如果网络请求逻辑发生变化，直接修改P层里面的代码，就可以了。V层完全不用改。如果业务逻辑发生变化，我们直接重新定义接口也非常方便 MVVM&emsp;&emsp;由微软提出来的—MVVM。什么是MVVM架构呢？ &emsp;&emsp;MVVM：Model View ViewModel &emsp;&emsp;一眼看上去更MVP差不多，只是把P层换成了ViewModel层。还有一点就是View层和ViewModel层是相互绑定的关系，当你更新ViewMdel层数据的时候，View层的UI就要相应的发生变化。 &emsp;&emsp;不管怎么说，三种模式的出现，或者说所有的开发模式，或者说是架构的出现，他们都有一个最终的目的，那就体现是一个项目架构好坏的：高类聚，低耦合 &emsp;&emsp;学习成本，MVC最简单，弊端也是最多的，学起来也是最快的。MVP和MVVM两者都是MVC的演化版本，两者没法评论优缺点，各有千秋。MVP是目前最火的架构（-.-）。 总结&emsp;&emsp;吹了这么多，MVP有没有什么缺点呢？答案是肯定的：有。本人认为，MVP是目前已知框架最好的 缺点 P层比较臃肿，所有的逻辑代码，网络请求都丢在P层 接口很多，一个功能，相对于MVC来讲，需要多写很多代码 V层P层耦合度过于高，一旦视图需要变更，P层就要相应的发生变化 优点 解藕，这个不用说了 结构清晰明了，不会过了一个月就变成别人的代码 提高了维护性，功能出了问题，直接定位到接口，修改接口就行了 容易进行单元测试，虽然会用单元测试的人比较少]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制原理]]></title>
    <url>%2F2018%2F02%2F22%2FAndroid%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[推荐：非著名程序员的安卓自定义View教程目录，我的自定义view就是看他的这个系列学会的 &emsp;&emsp;首先，我们需要确认的是android的事件传递机制是责任链模式，如果自己能处理就拦截下来自己处理，如果自己处理不了或者不确定就传递给下一个对象 事件的拦截、分发、消费&emsp;&emsp;我们要知道三个方法，控制事件反而拦截，分发与消费。如下表： 类型 相关方法 Activity ViewGroup View 事件分发 dispatchTouchEvent 有 有 无 事件拦截 onInterceptTouchEvent 无 有 无 事件处理 onTouchEvent 有 有 有 以上三个方法，均有boolean类型的返回值，通过设置true，false来控制事件传递的流程 Activity和View均没有事件拦截方法，是因为 Activity作为事件响应起点，如果，Activity把事件拦截了，辣么将为导致整个屏幕都无法点击 View作为事件响应的最末端，要么消费事件，要么不处理回传，没必要拦截事件 事件分发流程&emsp;&emsp;先给出一张图 &emsp;&emsp;这里，我们看到多了两个东西，一个是PhoneWindow，一个是DecorView，我们平时写的布局，最外层的父布局就是这里的RootView，有过几个app开发经验的程序员都应该知道，app的状态栏颜色的修改，还有那个主题的内容修改，修改后显示在哪呢？没错，就是DecorView里面。 &emsp;&emsp;再有就是phoneWindow，其实，知不知道没什么用，phonewindow是Window的唯一实现类，Window是干嘛的呢？Window是一个抽象类，所有的视图，事件传递都归它管理，所以，phonewindow管理视图，上面说的DecorView就是phonewindow的一个内部实现类，除了自己的功能外，还负责消息传递。 &emsp;&emsp;说了这么多，该来讲讲事件传递的流程了。android的view是树形结构的，基于这样的结构，我们的事件可以有序的分发。事件收集之后，起点是Activity，然后有序的向下传递，大致如下： Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View 如果这个事件没有对象处理，辣么，它会依次往回传递，如果还是没有人处理，辣么就会被Activity抛弃掉 Activity &lt;－ PhoneWindow &lt;－ DecorView &lt;－ ViewGroup &lt;－ ... &lt;－ View 这就是文章开头我们提到的，责任链模式 下面我给出ViewGroup的事件分发机制的伪代码： 12345678910111213public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean result = false; // 默认状态为没有消费过 if (!onInterceptTouchEvent(ev)) &#123; // 如果没有拦截交给子View result = child.dispatchTouchEvent(ev); &#125; if (!result) &#123; // 如果事件没有被消费,询问自身onTouchEvent result = onTouchEvent(ev); &#125; return result;&#125; &emsp;&emsp;情景：老板: 我看公司最近业务不咋地，准备发展一下电商业务，下周之前做个淘宝出来试试怎么样。&emsp;&emsp;事件顺序，老板(MainActivity)要做淘宝，这个事件通过各个部门(ViewGroup)一层一层的往下传，传到最底层的时候，码农小王(View1)发现做不了，于是消息又一层一层的回传到老板那里。&emsp;&emsp;可以看到整个事件传递路线非常有序。从Activity开始，最后回传给Activity结束(由于我们无法操作Phone Window和DecorView，所以没有它们的信息)。 1234567891011MainActivity [老板]: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.RootView [经理]: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.RootView [经理]: onInterceptTouchEvent (老板可能疯了,但又不是我做.)ViewGroupA [组长]: dispatchTouchEvent 老板要做淘宝,下周上线?ViewGroupA [组长]: onInterceptTouchEvent (看着不太靠谱,先问问小王怎么看)View1 [码农]: dispatchTouchEvent 做淘宝???View1 [码农]: onTouchEvent 这个真心做不了啊.ViewGroupA [组长]: onTouchEvent 小王说做不了.RootView [经理]: onTouchEvent 报告老板, 技术部说做不了.MainActivity [老板]: onTouchEvent 这么简单都做不了,你们都是干啥的(愤怒). 总结事件分发机制设计到到情形非常多，这里就不一一列举了，记住以下几条原则就行了。 如果事件被消费，就意味着事件信息传递终止。 如果事件一直没有被消费，最后会传给Activity，如果Activity也不需要就被抛弃。 判断事件是否被消费是根据返回值，而不是根据你是否使用了事件。]]></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View]]></title>
    <url>%2F2018%2F02%2F08%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Netty的简单使用，实现socket通讯]]></title>
    <url>%2F2018%2F02%2F08%2FNetty%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[自从用了netty框架，妈妈再也不用担心我的socket通讯了&emsp;&emsp;题外话，很多人都把JDK1.4提供的NIO称之为异步非阻塞I/O；其实，并不然，从严格意义上面讲，它只能称为非阻塞I/O。在JDK1.7提供的NIO 2.0，新增了异步的套接字通道Channel，它才是真正的异步非阻塞I/O。下表是不同I/O模型的对比： 表1-1 几种I/O模型和同能对比 同步阻塞I/O(BIO) 伪异步I/O 非阻塞I/O(NIO) 异步I/O(AIO) 客户端个数：I/O线程 1:1 M:N(M可以大于N) M:1(1个I/O线程处理多个客户端连接) M:0(不需要启动额外的I/O线程，被动回调) I/O类型(阻塞) 阻塞I/O 阻塞I/O 非阻塞I/O 非阻塞I/O I/O类型(同步) 同步I/O 同步I/O 同步I/O(I/O多路复用) 异步I/O API使用难度 简单 简单 非常复杂 复杂 调试难度 简单 简单 复杂 复杂 可靠性 非常差 差 高 高 吞吐量 低 中 高 高 简介&emsp;&emsp;Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 &emsp;&emsp;也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。 &emsp;&emsp;“快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。——百度百科 优点 API使用简单，开发门槛低 功能强大，预置了多种编解码功能，支持多种主流协议 性能高，通过与业界其他主流NIO框架相比，netty的综合性能最高 成熟，稳定，Netty已经修复了已经发现的所有的JDK NIO BUG，业务开发人员不用再为NIO的bug而烦恼 社区活跃，版本迭代周期短，发现bug可以及时被修复，同时有更多的新功能加入 经历了大规模的商界业务考验，只能得到了验证 粘包、拆包概念&emsp;&emsp;TCP是一个流协议，所谓的流，就是没有界限的一串数据。可以考虑河里的流水，他们并没有界限。tcp底层并不了解业务层数据的具体含义，他会根据tcp缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被tcp拆分成多个包进行发送，也可能把多个小包封装成一个大数据一起发送，这就是所谓的tcp粘包，拆包问题 产生原因 应用程序write写入的字节大小大于套接口发送缓冲区的大小 进行MSS大小的tcp分段 以太网帧的payload大于MTU进行IP分片 解决办法 消息定长，每个报文大小固定长度，不够的补0 包尾增加回车换行符进行分割。例如：FTP协议 将消息分为消息头和消息体。消息头中包含消息的总长度字段 更复杂的应用层协议 Netty框架的解决办法&emsp;&emsp;LineBasedFrameDecoder和StringDecoder两个类 LineBasedFrameDecoder&emsp;&emsp;LineBasedFrameDecoder的工作原理是依次遍历ByteBuf中的可读字节，判断看是否有”\r”或者”\r\n”，如果有就以此为结束位置，从可读索引位置到结束区间的字节就组成了一行。他是以换行符为结束标志的解码器，支持携带结束符和不带结束符两种解码方式。同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读取的异常流 StringDecoder&emsp;&emsp;StringDecoder的功能就非常简单，就是将接收到的对象换成字符串，然后继续调用后面的handler，LineBasedFrameDecoder+StringDecoder组合就是按换行符切换文本解码器，他被设计用来支持TCP粘包和拆包。Netty支持其他其他符号的解码器(DelimiterBasedFrameDecode) &emsp;&emsp;说了这么多，代码来了，就是用Netty实现的心跳。对于懒癌晚期，已经风装好，可以直接拿过去用，注释也写的很清楚 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import android.util.Log;import io.netty.bootstrap.Bootstrap;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import io.netty.util.CharsetUtil;/** * @author 海晨忆 * @date 2018/2/6 * @desc */public class SocketTcp &#123; private static SocketTcp socketTcp = new SocketTcp(); private Channel channel = null; private EventLoopGroup group; private int port; private String host; public static SocketTcp getInstance() &#123; return socketTcp; &#125; public SocketTcp setPort(int port) &#123; this.port = port; return this; &#125; public SocketTcp setHost(String host) &#123; this.host = host; return this; &#125; public void connect() &#123; if (channel != null) return; if (group == null) &#123; //NIO线程组 group = new NioEventLoopGroup(); &#125; try &#123;//配置Bootstrap Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; //以换行符为结束标记 ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); pipeline.addLast(new LineBasedFrameDecoder(Integer.MAX_VALUE)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket()); //以&quot;$_&quot;作为分隔符 /*ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); String s = &quot;$_&quot;; ByteBuf byteBuf = Unpooled.copiedBuffer(s.getBytes()); pipeline.addLast(new DelimiterBasedFrameDecoder(Integer.MAX_VALUE,byteBuf)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket());*/ &#125; &#125;); //发起异步连接操作 ChannelFuture channelFuture = bootstrap.connect(host, port).sync(); channel = channelFuture.channel(); //等待服务端监听端口关闭 channel.closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; disConnect(); &#125; &#125; /** * 断开tcp连接. */ private void disConnect() &#123; if (null != group) &#123; group.shutdownGracefully(); &#125; group = null; channel = null; &#125; public void sendMessage(String msg) &#123;//连接成功后，通过Channel提供的接口进行IO操作 try &#123; if (channel != null &amp;&amp; channel.isOpen()) &#123; channel.writeAndFlush(msg).sync(); Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg); &#125; else &#123; reConnect(); throw new Exception(&quot;channel is null | closed&quot;); &#125; &#125; catch (Exception e) &#123; reConnect(); e.printStackTrace(); &#125; &#125; /** * 重连. */ private void reConnect() &#123; new Thread(this::connect); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.example.zwang.myapplication.socket;import android.os.SystemClock;import android.util.Log;import java.util.concurrent.TimeUnit;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.EventLoop;import io.netty.channel.SimpleChannelInboundHandler;public class MyHeartSocket extends SimpleChannelInboundHandler&lt;Object&gt; &#123; private ChannelHandlerContext ctx; private boolean isConnect = false; @Override protected void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception &#123; Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;); ByteBuf msg1 = (ByteBuf) msg; byte[] bytes = new byte[msg1.readableBytes()]; msg1.readBytes(bytes); String s = new String(bytes, &quot;UTF-8&quot;); Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;); isConnect = true; if (this.ctx == null) &#123; synchronized (MyHeartSocket.class) &#123; if (this.ctx == null) &#123; this.ctx = ctx; MyAppHeart(); &#125; &#125; &#125; &#125; private void MyAppHeart() &#123; new Thread(() -&gt; &#123; while (ctx != null &amp;&amp; isConnect) &#123; String data = &quot;123&quot;; byte[] bytes = data.getBytes(); if (isConnect) &#123; ctx.writeAndFlush(Unpooled.buffer(bytes.length).writeBytes(bytes)); SystemClock.sleep(3000); &#125; &#125; &#125;).start(); &#125; @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; EventLoop loop = ctx.channel().eventLoop(); loop.schedule(() -&gt; SocketTcp.getInstance().connect(), 5, TimeUnit.SECONDS); super.channelInactive(ctx); Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;); isConnect = false; &#125; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; super.userEventTriggered(ctx, evt); Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.exceptionCaught(ctx, cause); Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;); this.ctx.close(); this.ctx = null; &#125;&#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO编程和NIO编程简介]]></title>
    <url>%2F2018%2F02%2F07%2FIO%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;传统的同步阻塞I/O通讯模型，导致的结果就是只要有一方处理数据缓慢，都会影响另外一方的处理性能。按照故障设计原则，一方的处理出现问题，不应该影响到另外一方才对。但是，在同步阻塞的模式下面，这样的情况是无法避免的，很难通过业务层去解决。既然同步无法避免，为了避免就产生了异步。Netty框架就一个完全异步非阻塞的I/O通讯方式 同步阻塞式I/O编程&emsp;&emsp;简单的来说，传统同步阻塞的I/O通讯模式，服务器端处理的方式是，每当有一个新用户接入的时候，就new一个新的线程，一个线程只能处理一个客户端的连接，在高性能方面，并发高的情景下无法满足。伪代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; public void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); while (true) &#123; socket = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; new TimerServerHandler(socket).run(); &#125; &#125;).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //释放资源 if (server != null) &#123; try &#123; server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; server = null; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimerServerHandler implements Runnable &#123; private Socket socket; public TimerServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; BufferedReader in = null; PrintWriter out = null; try &#123; in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); out = new PrintWriter(this.socket.getOutputStream(), true); String currentTime = null; String body = null; while (true) &#123; body = in.readLine(); if (body == null) break; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); //释放in，out，socket资源 &#125; &#125;&#125; &emsp;&emsp;上面这个就是最原始的服务端IO的代码，这里我就给出的是最简化的，当有新的客户端接入的时候，服务端是怎么处理线程的，可以看出，每当有新的客户端接入的时候，总是回新创建一个线程去服务这个新的客户端 伪异步式编程&emsp;&emsp;后来慢慢演化出一个版本“伪异步”模型，新增加一个线程池或者消息队列，满足一个线程或者多个线程满足N个客户端，通过线程池可以灵活的调用线程资源。通过设置线程池的最大值，防止海量并发接入造成的线程耗尽，它的底层实现依然是同步阻塞模型，伪代码如下：1234567891011121314151617181920212223242526272829303132333435import com.example.zwang.mysocket.server.TimerServerHandler;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; private void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); TimeServerHandlerExecutePool executePool = new TimeServerHandlerExecutePool(50, 1000); while (true) &#123; socket = server.accept(); executePool.execute(new TimerServerHandler(socket)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //释放资源 &#125; &#125;&#125; 12345678910111213141516171819202122import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimeServerHandlerExecutePool &#123; private ExecutorService executor; public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123; executor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize, 120L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize)); &#125; public void execute(Runnable task) &#123; executor.execute(task); &#125;&#125; &emsp;&emsp;“伪异步”的代码和传统同步的唯一区别就是在于，首先先创建了一个时间服务处理类的线程池，当有新的客户端接入的时候，先将socket请求封装成task，然后调用线程池的execute方法执行，从而避免了每一个新请求创建一个新线程。由于线程池和消息队列都是有限的，因此，无论客户端的并发量多大，它都不会导致线程个数过于大，而造成的内存溢出。相对于传统的同步阻塞，是一种改良。 &emsp;&emsp;但是他没有从更本上解决同步的问题，伪异步的问题在于，他还是有一方处理出现问题还是会影响到另一方。因为： &emsp;&emsp;当对socket的输入流进行读取操作的时候，它会一直阻塞直到一下三种方式发生： 有数据可读 可读数据已经读取完 发生空指针或者I/O异常。 这意味者，当读取inputstream方处理速度缓慢(不管是什么原因造成的速度缓慢)，另一方会一直同步阻塞，直到这一方把数据处理完. &emsp;&emsp;当调用outputstream的write方法写输出流的时候，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。学过TCP/IP相关知识的人都直到，当消息的接收方处理消息缓慢，不能及时的从TCP缓冲区读取数据，这将会导致发送方的TCP缓冲区的size一直减少，直到0.缓冲区为0，那么发消息的一方将无法将消息写入缓冲区，直到缓冲区的size大于0 &emsp;&emsp;通过以上。我们了解到读和写的操作都是同步阻塞的，阻塞的时间取决于对方的I/O线程的处理速度和网络I/O的传送速度。从本质上面看，我们无法保证对方的处理速度和网络传送速度。如果，我们的程序依靠与对方的处理速度，那么，他的可靠性将会非常差。 NIO编程&emsp;&emsp;官方叫法new I/O，也就是新的IO编程，更多的人喜欢称它为：Non-block IO即非阻塞IO。 &emsp;&emsp;与Socket和serverSocket类对应，NIO提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现，这两种都支持阻塞式编程和非阻塞式编程。开发人员可以根据自己的需求选择合适的编程模式。一般低负载，低并发的应用程序选择同步阻塞的方式以降低编程的复杂度。高负载，高并发的不用想了，非阻塞就是为了解决这个问题的 缓冲区Buffer &emsp;&emsp;Buffer是一个对象，它包含一些写入或者读出的数据。再NIO中加入buffer对象，体现了新库和旧库的一个重要区别。在面向流的io中，可以直接把数据读取或者写入到stream对象中。在NIO库中，所有数据操作都是通过缓冲区处理的。 &emsp;&emsp;缓冲区实质上是一个数组，通常是一个字节数组（ByteBuffer），基本数据类型除了boolean没有，其他都有，如ShortBuffer,CharBuffer等等 通道Channel &emsp;&emsp;Channel是一个通道，双向通道，网络数据都是通过Channel读取，写入的。是的，没错，Channel它既可以进行读操作，也可以进行写操作。而流只能是一个方向。只能读操作或者只能写操作，而channel是全双工，读写可以同时进行。channel可以分为两大类：网络读写的SelectableChannel和文件操作的FileChannel。我们前面提到的SocketChannel和ServerSocketChannel都是SelectableChannel的子类。 多路复用器Selector &emsp;&emsp;selector多路复用器，他是java NIO编程的基础，熟练的掌握selector对于NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单的讲就是他会不断的轮询注册的channel，如果一个Channel发生了读写操作，这个Chnnel就会处于就绪状态，会被selector轮询出来，通过SelectorKey获取就绪Channel集合，进行后续的IO操作。一个selector对应多个Channel &emsp;&emsp;由于原生NIO编码比较麻烦和复杂，我这里就给出了思路的伪代码。下一篇我们将用NIO中的Netty框架实现Socket通信，编码简单，一行代码解决烦人粘包、拆包问题。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 服务端nio过程的伪代码 * * @param port 端口号 * @throws IOException IOException */ private void init(int port) throws IOException &#123; //第一步：打开ServerSocketChannel，用于监听客户端连接，它是所有客户端连接的父管道 ServerSocketChannel socketChannel = ServerSocketChannel.open(); //第二步：监听绑定端口，设置连接模式为非阻塞模式， socketChannel.socket().bind(new InetSocketAddress(InetAddress.getByName(&quot;IP&quot;), port)); socketChannel.configureBlocking(false); //第三步：创建Reactor线程，创建多路复用器，并启动线程。 Selector selector = Selector.open(); new Thread().start(); //第四步：将ServerSocketChannel注册到Reactor线程的多路复用器上，监听accept事件 SelectionKey key = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第五步：多路复用器在线程run方法的无线循环体内轮询准备就绪的key int num = selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator(); while (it.hasNext()) &#123; SelectionKey next = it.next(); //deal with io event... &#125; //第六步：多路复用器检测到有新客户端接入，处理新的接入请求，完成TCP三次握手，建立物理链路 SocketChannel channel = socketChannel.accept(); //第七步：设置客户端为非阻塞模式 channel.configureBlocking(false); channel.socket().setReuseAddress(true); //第八步：将新接入的客户端注册到reactor线程的多路复用器上，监听读操作，读取客户端发送的消息 SelectionKey key1 = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第九步：异步读取客户端消息到缓冲区， /*int readNumber = channel.read(&quot;receivebuff&quot;);*/ //第十步：对byteBuffer进行编解码，如果有半包信息指针reset，继续读取到后续的报文，将解码成功消息封装成task，投递到业务线程池，进行业务逻辑编排 Object massage = null; while (buff.hasRemain()) &#123; buff.mark(); Object massage1 = decode(btyeBuffer); if (massage1 == null) &#123; byteBuffer.reset(); break; &#125; massageList.add(massage1); &#125; if (!byteBuffer.hasRemain()) &#123; byteBuffer.clean(); &#125; else &#123; byteBuffer.compact(); &#125; if (massageList != null &amp;&amp; !massageList.isEmpty()) &#123; for (Object massage3 : massageList)&#123; handlerTask(massage3); &#125; &#125; //第十一步：将POJO对象encode成ByteBuff，调用SocketChannel的异步write接口，将异步消息发送到客户端 socketChannel.write(buffer); &#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
</search>
