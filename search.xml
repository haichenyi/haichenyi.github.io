<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MVC、MVP、MVVM比较]]></title>
    <url>%2F2018%2F02%2F22%2FMVC%E3%80%81MVP%E3%80%81MVVM%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[Android框架的最终目的，也是体现一个项目好坏的唯一标准——高类聚，低耦合 MVC&emsp;&emsp;我们刚接触android写代码的时候基本上都是MVC架构。什么是MVC架构呢？ &emsp;&emsp;MVC：Model View Controller的简称。流程图如下： &emsp;&emsp;当用户发出事件的时候，首先通过V层，通知C层，然后C层通知Model层数据发生了变化，更新数据，M层直接显示数据到V层。 &emsp;&emsp;通俗的讲，xml可以理解层View层，你封装的网络请求的帮助类理解成model层，activity，fragment理解成Controller层。这么理解是可以的，但是，你不能说xml就是view层，这样说是不对的 &emsp;&emsp;举个例子，比方说一个登录的网络请求，首先，你需要点击按钮去触发网络请求的方法，你点击的这个button就是写在xml布局里面的，这就是V层。然后触发的网络请求帮助类去发送对应的登录请求方法，这就是model层。两者是怎么联系在一起的呢？就是我们在activity，fragment层里面写的onclick方法。activity，fragment就是Controller层。 MVP&emsp;&emsp;所有的UI变化，网络请求等等业务逻辑之类的都写在Activity里面，Activity既要处理业务逻辑，又要处理UI变化，代码就显得非常臃肿。 &emsp;&emsp;这个时候，MVP就顺势而生，什么是MVP架构呢？ &emsp;&emsp;MVP：Model View Presenter的简称 &emsp;&emsp;MVP作为MVC的演化版本，解决了MVC不少的缺点，对于Android来说，MVP的M层，相对于MVC来说是一样的，而不一样的就是activity不再是controller，而是纯粹的V层，所有关于用户事件的转发，全都由P层去处理 &emsp;&emsp;MVP和MVC最明显的差别就是，M层和V层完全解藕，两者的通信是通过P层，P层作为桥梁，用于操作View层发送的事件到P层，P层去操作M层，并且，讲数据返回给V层。整个过层M层和V层两者完全没有联系。辣么，就有好奇的宝宝就问了，这样做解决不了更本问题，你这样做P层和V层不一样耦合在一起了吗？我们并不能完全不耦合，只是尽可能减少耦合度。我们写程序最终目的就是高类聚，低耦合，不是说完全不耦合。并且，我们这里P层和V层是通过接口通信的，如果网络请求逻辑发生变化，直接修改P层里面的代码，就可以了。V层完全不用改。如果业务逻辑发生变化，我们直接重新定义接口也非常方便 MVVM&emsp;&emsp;由微软提出来的—MVVM。什么是MVVM架构呢？ &emsp;&emsp;MVVM：Model View ViewModel &emsp;&emsp;一眼看上去更MVP差不多，只是把P层换成了ViewModel层。还有一点就是View层和ViewModel层是相互绑定的关系，当你更新ViewMdel层数据的时候，View层的UI就要相应的发生变化。 &emsp;&emsp;不管怎么说，三种模式的出现，或者说所有的开发模式，或者说是架构的出现，他们都有一个最终的目的，那就体现是一个项目架构好坏的：高类聚，低耦合 &emsp;&emsp;学习成本，MVC最简单，弊端也是最多的，学起来也是最快的。MVP和MVVM两者都是MVC的演化版本，两者没法评论优缺点，各有千秋。MVP是目前最火的架构（-.-）。 总结&emsp;&emsp;吹了这么多，MVP有没有什么缺点呢？答案是肯定的：有。本人认为，MVP是目前已知框架最好的 缺点 P层比较臃肿，所有的逻辑代码，网络请求都丢在P层 接口很多，一个功能，相对于MVC来讲，需要多写很多代码 V层P层耦合度过于高，一旦视图需要变更，P层就要相应的发生变化 优点 解藕，这个不用说了 结构清晰明了，不会过了一个月就变成别人的代码 提高了维护性，功能出了问题，直接定位到接口，修改接口就行了 容易进行单元测试，虽然会用单元测试的人比较少]]></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制原理]]></title>
    <url>%2F2018%2F02%2F22%2FAndroid%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[推荐：非著名程序员的安卓自定义View教程目录，我的自定义view就是看他的这个系列学会的 &emsp;&emsp;首先，我们需要确认的是android的事件传递机制是责任链模式，如果自己能处理就拦截下来自己处理，如果自己处理不了或者不确定就传递给下一个对象 事件的拦截、分发、消费&emsp;&emsp;我们要知道三个方法，控制事件反而拦截，分发与消费。如下表： 类型 相关方法 Activity ViewGroup View 事件分发 dispatchTouchEvent 有 有 无 事件拦截 onInterceptTouchEvent 无 有 无 事件处理 onTouchEvent 有 有 有 以上三个方法，均有boolean类型的返回值，通过设置true，false来控制事件传递的流程 Activity和View均没有事件拦截方法，是因为 Activity作为事件响应起点，如果，Activity把事件拦截了，辣么将为导致整个屏幕都无法点击 View作为事件响应的最末端，要么消费事件，要么不处理回传，没必要拦截事件 事件分发流程&emsp;&emsp;先给出一张图 &emsp;&emsp;这里，我们看到多了两个东西，一个是PhoneWindow，一个是DecorView，我们平时写的布局，最外层的父布局就是这里的RootView，有过几个app开发经验的程序员都应该知道，app的状态栏颜色的修改，还有那个主题的内容修改，修改后显示在哪呢？没错，就是DecorView里面。 &emsp;&emsp;再有就是phoneWindow，其实，知不知道没什么用，phonewindow是Window的唯一实现类，Window是干嘛的呢？Window是一个抽象类，所有的视图，事件传递都归它管理，所以，phonewindow管理视图，上面说的DecorView就是phonewindow的一个内部实现类，除了自己的功能外，还负责消息传递。 &emsp;&emsp;说了这么多，该来讲讲事件传递的流程了。android的view是树形结构的，基于这样的结构，我们的事件可以有序的分发。事件收集之后，起点是Activity，然后有序的向下传递，大致如下： Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View 如果这个事件没有对象处理，辣么，它会依次往回传递，如果还是没有人处理，辣么就会被Activity抛弃掉 Activity &lt;－ PhoneWindow &lt;－ DecorView &lt;－ ViewGroup &lt;－ ... &lt;－ View 这就是文章开头我们提到的，责任链模式 下面我给出ViewGroup的事件分发机制的伪代码： 12345678910111213public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean result = false; // 默认状态为没有消费过 if (!onInterceptTouchEvent(ev)) &#123; // 如果没有拦截交给子View result = child.dispatchTouchEvent(ev); &#125; if (!result) &#123; // 如果事件没有被消费,询问自身onTouchEvent result = onTouchEvent(ev); &#125; return result;&#125; &emsp;&emsp;情景：老板: 我看公司最近业务不咋地，准备发展一下电商业务，下周之前做个淘宝出来试试怎么样。&emsp;&emsp;事件顺序，老板(MainActivity)要做淘宝，这个事件通过各个部门(ViewGroup)一层一层的往下传，传到最底层的时候，码农小王(View1)发现做不了，于是消息又一层一层的回传到老板那里。&emsp;&emsp;可以看到整个事件传递路线非常有序。从Activity开始，最后回传给Activity结束(由于我们无法操作Phone Window和DecorView，所以没有它们的信息)。 1234567891011MainActivity [老板]: dispatchTouchEvent 经理,我准备发展一下电商业务,下周之前做一个淘宝出来.RootView [经理]: dispatchTouchEvent 呼叫技术部,老板要做淘宝,下周上线.RootView [经理]: onInterceptTouchEvent (老板可能疯了,但又不是我做.)ViewGroupA [组长]: dispatchTouchEvent 老板要做淘宝,下周上线?ViewGroupA [组长]: onInterceptTouchEvent (看着不太靠谱,先问问小王怎么看)View1 [码农]: dispatchTouchEvent 做淘宝???View1 [码农]: onTouchEvent 这个真心做不了啊.ViewGroupA [组长]: onTouchEvent 小王说做不了.RootView [经理]: onTouchEvent 报告老板, 技术部说做不了.MainActivity [老板]: onTouchEvent 这么简单都做不了,你们都是干啥的(愤怒). 总结事件分发机制设计到到情形非常多，这里就不一一列举了，记住以下几条原则就行了。 如果事件被消费，就意味着事件信息传递终止。 如果事件一直没有被消费，最后会传给Activity，如果Activity也不需要就被抛弃。 判断事件是否被消费是根据返回值，而不是根据你是否使用了事件。]]></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View]]></title>
    <url>%2F2018%2F02%2F08%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android -自定义view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVP+Dagger+RxJava+Retrofit+OkHttp的简单框架]]></title>
    <url>%2F2018%2F02%2F08%2FMVP-Dagger-RxJava-Retrofit-OkHttp%E7%9A%84%E7%AE%80%E5%8D%95%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android -框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Netty的简单使用，实现socket通讯]]></title>
    <url>%2F2018%2F02%2F08%2FNetty%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[自从用了netty框架，妈妈再也不用担心我的socket通讯了&emsp;&emsp;题外话，很多人都把JDK1.4提供的NIO称之为异步非阻塞I/O；其实，并不然，从严格意义上面讲，它只能称为非阻塞I/O。在JDK1.7提供的NIO 2.0，新增了异步的套接字通道Channel，它才是真正的异步非阻塞I/O。下表是不同I/O模型的对比： 表1-1 几种I/O模型和同能对比 同步阻塞I/O(BIO) 伪异步I/O 非阻塞I/O(NIO) 异步I/O(AIO) 客户端个数：I/O线程 1:1 M:N(M可以大于N) M:1(1个I/O线程处理多个客户端连接) M:0(不需要启动额外的I/O线程，被动回调) I/O类型(阻塞) 阻塞I/O 阻塞I/O 非阻塞I/O 非阻塞I/O I/O类型(同步) 同步I/O 同步I/O 同步I/O(I/O多路复用) 异步I/O API使用难度 简单 简单 非常复杂 复杂 调试难度 简单 简单 复杂 复杂 可靠性 非常差 差 高 高 吞吐量 低 中 高 高 简介&emsp;&emsp;Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 &emsp;&emsp;也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。 &emsp;&emsp;“快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。——百度百科 优点 API使用简单，开发门槛低 功能强大，预置了多种编解码功能，支持多种主流协议 性能高，通过与业界其他主流NIO框架相比，netty的综合性能最高 成熟，稳定，Netty已经修复了已经发现的所有的JDK NIO BUG，业务开发人员不用再为NIO的bug而烦恼 社区活跃，版本迭代周期短，发现bug可以及时被修复，同时有更多的新功能加入 经历了大规模的商界业务考验，只能得到了验证 粘包、拆包概念&emsp;&emsp;TCP是一个流协议，所谓的流，就是没有界限的一串数据。可以考虑河里的流水，他们并没有界限。tcp底层并不了解业务层数据的具体含义，他会根据tcp缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被tcp拆分成多个包进行发送，也可能把多个小包封装成一个大数据一起发送，这就是所谓的tcp粘包，拆包问题 产生原因 应用程序write写入的字节大小大于套接口发送缓冲区的大小 进行MSS大小的tcp分段 以太网帧的payload大于MTU进行IP分片 解决办法 消息定长，每个报文大小固定长度，不够的补0 包尾增加回车换行符进行分割。例如：FTP协议 将消息分为消息头和消息体。消息头中包含消息的总长度字段 更复杂的应用层协议 Netty框架的解决办法&emsp;&emsp;LineBasedFrameDecoder和StringDecoder两个类 LineBasedFrameDecoder&emsp;&emsp;LineBasedFrameDecoder的工作原理是依次遍历ByteBuf中的可读字节，判断看是否有”\r”或者”\r\n”，如果有就以此为结束位置，从可读索引位置到结束区间的字节就组成了一行。他是以换行符为结束标志的解码器，支持携带结束符和不带结束符两种解码方式。同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读取的异常流 StringDecoder&emsp;&emsp;StringDecoder的功能就非常简单，就是将接收到的对象换成字符串，然后继续调用后面的handler，LineBasedFrameDecoder+StringDecoder组合就是按换行符切换文本解码器，他被设计用来支持TCP粘包和拆包。Netty支持其他其他符号的解码器(DelimiterBasedFrameDecode) &emsp;&emsp;说了这么多，代码来了，就是用Netty实现的心跳。对于懒癌晚期，已经风装好，可以直接拿过去用，注释也写的很清楚 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import android.util.Log;import io.netty.bootstrap.Bootstrap;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import io.netty.util.CharsetUtil;/** * @author 海晨忆 * @date 2018/2/6 * @desc */public class SocketTcp &#123; private static SocketTcp socketTcp = new SocketTcp(); private Channel channel = null; private EventLoopGroup group; private int port; private String host; public static SocketTcp getInstance() &#123; return socketTcp; &#125; public SocketTcp setPort(int port) &#123; this.port = port; return this; &#125; public SocketTcp setHost(String host) &#123; this.host = host; return this; &#125; public void connect() &#123; if (channel != null) return; if (group == null) &#123; //NIO线程组 group = new NioEventLoopGroup(); &#125; try &#123;//配置Bootstrap Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; //以换行符为结束标记 ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); pipeline.addLast(new LineBasedFrameDecoder(Integer.MAX_VALUE)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket()); //以&quot;$_&quot;作为分隔符 /*ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8)); String s = &quot;$_&quot;; ByteBuf byteBuf = Unpooled.copiedBuffer(s.getBytes()); pipeline.addLast(new DelimiterBasedFrameDecoder(Integer.MAX_VALUE,byteBuf)); pipeline.addLast(new StringDecoder()); pipeline.addLast(new MyHeartSocket());*/ &#125; &#125;); //发起异步连接操作 ChannelFuture channelFuture = bootstrap.connect(host, port).sync(); channel = channelFuture.channel(); //等待服务端监听端口关闭 channel.closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; disConnect(); &#125; &#125; /** * 断开tcp连接. */ private void disConnect() &#123; if (null != group) &#123; group.shutdownGracefully(); &#125; group = null; channel = null; &#125; public void sendMessage(String msg) &#123;//连接成功后，通过Channel提供的接口进行IO操作 try &#123; if (channel != null &amp;&amp; channel.isOpen()) &#123; channel.writeAndFlush(msg).sync(); Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg); &#125; else &#123; reConnect(); throw new Exception(&quot;channel is null | closed&quot;); &#125; &#125; catch (Exception e) &#123; reConnect(); e.printStackTrace(); &#125; &#125; /** * 重连. */ private void reConnect() &#123; new Thread(this::connect); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.example.zwang.myapplication.socket;import android.os.SystemClock;import android.util.Log;import java.util.concurrent.TimeUnit;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.EventLoop;import io.netty.channel.SimpleChannelInboundHandler;public class MyHeartSocket extends SimpleChannelInboundHandler&lt;Object&gt; &#123; private ChannelHandlerContext ctx; private boolean isConnect = false; @Override protected void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception &#123; Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;); ByteBuf msg1 = (ByteBuf) msg; byte[] bytes = new byte[msg1.readableBytes()]; msg1.readBytes(bytes); String s = new String(bytes, &quot;UTF-8&quot;); Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;); isConnect = true; if (this.ctx == null) &#123; synchronized (MyHeartSocket.class) &#123; if (this.ctx == null) &#123; this.ctx = ctx; MyAppHeart(); &#125; &#125; &#125; &#125; private void MyAppHeart() &#123; new Thread(() -&gt; &#123; while (ctx != null &amp;&amp; isConnect) &#123; String data = &quot;123&quot;; byte[] bytes = data.getBytes(); if (isConnect) &#123; ctx.writeAndFlush(Unpooled.buffer(bytes.length).writeBytes(bytes)); SystemClock.sleep(3000); &#125; &#125; &#125;).start(); &#125; @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; EventLoop loop = ctx.channel().eventLoop(); loop.schedule(() -&gt; SocketTcp.getInstance().connect(), 5, TimeUnit.SECONDS); super.channelInactive(ctx); Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;); isConnect = false; &#125; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; super.userEventTriggered(ctx, evt); Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; super.exceptionCaught(ctx, cause); Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;); this.ctx.close(); this.ctx = null; &#125;&#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO编程和NIO编程简介]]></title>
    <url>%2F2018%2F02%2F07%2FIO%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;传统的同步阻塞I/O通讯模型，导致的结果就是只要有一方处理数据缓慢，都会影响另外一方的处理性能。按照故障设计原则，一方的处理出现问题，不应该影响到另外一方才对。但是，在同步阻塞的模式下面，这样的情况是无法避免的，很难通过业务层去解决。既然同步无法避免，为了避免就产生了异步。Netty框架就一个完全异步非阻塞的I/O通讯方式 同步阻塞式I/O编程&emsp;&emsp;简单的来说，传统同步阻塞的I/O通讯模式，服务器端处理的方式是，每当有一个新用户接入的时候，就new一个新的线程，一个线程只能处理一个客户端的连接，在高性能方面，并发高的情景下无法满足。伪代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; public void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); while (true) &#123; socket = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; new TimerServerHandler(socket).run(); &#125; &#125;).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //释放资源 if (server != null) &#123; try &#123; server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; server = null; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimerServerHandler implements Runnable &#123; private Socket socket; public TimerServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; BufferedReader in = null; PrintWriter out = null; try &#123; in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); out = new PrintWriter(this.socket.getOutputStream(), true); String currentTime = null; String body = null; while (true) &#123; body = in.readLine(); if (body == null) break; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); //释放in，out，socket资源 &#125; &#125;&#125; &emsp;&emsp;上面这个就是最原始的服务端IO的代码，这里我就给出的是最简化的，当有新的客户端接入的时候，服务端是怎么处理线程的，可以看出，每当有新的客户端接入的时候，总是回新创建一个线程去服务这个新的客户端 伪异步式编程&emsp;&emsp;后来慢慢演化出一个版本“伪异步”模型，新增加一个线程池或者消息队列，满足一个线程或者多个线程满足N个客户端，通过线程池可以灵活的调用线程资源。通过设置线程池的最大值，防止海量并发接入造成的线程耗尽，它的底层实现依然是同步阻塞模型，伪代码如下：1234567891011121314151617181920212223242526272829303132333435import com.example.zwang.mysocket.server.TimerServerHandler;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class SocketServer &#123; private int port = 8080; private Socket socket = null; public SocketServer(int port) &#123; this.port = port; &#125; private void connect() &#123; ServerSocket server = null; try &#123; server = new ServerSocket(port); TimeServerHandlerExecutePool executePool = new TimeServerHandlerExecutePool(50, 1000); while (true) &#123; socket = server.accept(); executePool.execute(new TimerServerHandler(socket)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //释放资源 &#125; &#125;&#125; 12345678910111213141516171819202122import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author 海晨忆 * @date 2018/2/9 * @desc */public class TimeServerHandlerExecutePool &#123; private ExecutorService executor; public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123; executor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize, 120L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize)); &#125; public void execute(Runnable task) &#123; executor.execute(task); &#125;&#125; &emsp;&emsp;“伪异步”的代码和传统同步的唯一区别就是在于，首先先创建了一个时间服务处理类的线程池，当有新的客户端接入的时候，先将socket请求封装成task，然后调用线程池的execute方法执行，从而避免了每一个新请求创建一个新线程。由于线程池和消息队列都是有限的，因此，无论客户端的并发量多大，它都不会导致线程个数过于大，而造成的内存溢出。相对于传统的同步阻塞，是一种改良。 &emsp;&emsp;但是他没有从更本上解决同步的问题，伪异步的问题在于，他还是有一方处理出现问题还是会影响到另一方。因为： &emsp;&emsp;当对socket的输入流进行读取操作的时候，它会一直阻塞直到一下三种方式发生： 有数据可读 可读数据已经读取完 发生空指针或者I/O异常。 这意味者，当读取inputstream方处理速度缓慢(不管是什么原因造成的速度缓慢)，另一方会一直同步阻塞，直到这一方把数据处理完. &emsp;&emsp;当调用outputstream的write方法写输出流的时候，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。学过TCP/IP相关知识的人都直到，当消息的接收方处理消息缓慢，不能及时的从TCP缓冲区读取数据，这将会导致发送方的TCP缓冲区的size一直减少，直到0.缓冲区为0，那么发消息的一方将无法将消息写入缓冲区，直到缓冲区的size大于0 &emsp;&emsp;通过以上。我们了解到读和写的操作都是同步阻塞的，阻塞的时间取决于对方的I/O线程的处理速度和网络I/O的传送速度。从本质上面看，我们无法保证对方的处理速度和网络传送速度。如果，我们的程序依靠与对方的处理速度，那么，他的可靠性将会非常差。 NIO编程&emsp;&emsp;官方叫法new I/O，也就是新的IO编程，更多的人喜欢称它为：Non-block IO即非阻塞IO。 &emsp;&emsp;与Socket和serverSocket类对应，NIO提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现，这两种都支持阻塞式编程和非阻塞式编程。开发人员可以根据自己的需求选择合适的编程模式。一般低负载，低并发的应用程序选择同步阻塞的方式以降低编程的复杂度。高负载，高并发的不用想了，非阻塞就是为了解决这个问题的 缓冲区Buffer &emsp;&emsp;Buffer是一个对象，它包含一些写入或者读出的数据。再NIO中加入buffer对象，体现了新库和旧库的一个重要区别。在面向流的io中，可以直接把数据读取或者写入到stream对象中。在NIO库中，所有数据操作都是通过缓冲区处理的。 &emsp;&emsp;缓冲区实质上是一个数组，通常是一个字节数组（ByteBuffer），基本数据类型除了boolean没有，其他都有，如ShortBuffer,CharBuffer等等 通道Channel &emsp;&emsp;Channel是一个通道，双向通道，网络数据都是通过Channel读取，写入的。是的，没错，Channel它既可以进行读操作，也可以进行写操作。而流只能是一个方向。只能读操作或者只能写操作，而channel是全双工，读写可以同时进行。channel可以分为两大类：网络读写的SelectableChannel和文件操作的FileChannel。我们前面提到的SocketChannel和ServerSocketChannel都是SelectableChannel的子类。 多路复用器Selector &emsp;&emsp;selector多路复用器，他是java NIO编程的基础，熟练的掌握selector对于NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单的讲就是他会不断的轮询注册的channel，如果一个Channel发生了读写操作，这个Chnnel就会处于就绪状态，会被selector轮询出来，通过SelectorKey获取就绪Channel集合，进行后续的IO操作。一个selector对应多个Channel &emsp;&emsp;由于原生NIO编码比较麻烦和复杂，我这里就给出了思路的伪代码。下一篇我们将用NIO中的Netty框架实现Socket通信，编码简单，一行代码解决烦人粘包、拆包问题。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 服务端nio过程的伪代码 * * @param port 端口号 * @throws IOException IOException */ private void init(int port) throws IOException &#123; //第一步：打开ServerSocketChannel，用于监听客户端连接，它是所有客户端连接的父管道 ServerSocketChannel socketChannel = ServerSocketChannel.open(); //第二步：监听绑定端口，设置连接模式为非阻塞模式， socketChannel.socket().bind(new InetSocketAddress(InetAddress.getByName(&quot;IP&quot;), port)); socketChannel.configureBlocking(false); //第三步：创建Reactor线程，创建多路复用器，并启动线程。 Selector selector = Selector.open(); new Thread().start(); //第四步：将ServerSocketChannel注册到Reactor线程的多路复用器上，监听accept事件 SelectionKey key = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第五步：多路复用器在线程run方法的无线循环体内轮询准备就绪的key int num = selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator(); while (it.hasNext()) &#123; SelectionKey next = it.next(); //deal with io event... &#125; //第六步：多路复用器检测到有新客户端接入，处理新的接入请求，完成TCP三次握手，建立物理链路 SocketChannel channel = socketChannel.accept(); //第七步：设置客户端为非阻塞模式 channel.configureBlocking(false); channel.socket().setReuseAddress(true); //第八步：将新接入的客户端注册到reactor线程的多路复用器上，监听读操作，读取客户端发送的消息 SelectionKey key1 = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/); //第九步：异步读取客户端消息到缓冲区， /*int readNumber = channel.read(&quot;receivebuff&quot;);*/ //第十步：对byteBuffer进行编解码，如果有半包信息指针reset，继续读取到后续的报文，将解码成功消息封装成task，投递到业务线程池，进行业务逻辑编排 Object massage = null; while (buff.hasRemain()) &#123; buff.mark(); Object massage1 = decode(btyeBuffer); if (massage1 == null) &#123; byteBuffer.reset(); break; &#125; massageList.add(massage1); &#125; if (!byteBuffer.hasRemain()) &#123; byteBuffer.clean(); &#125; else &#123; byteBuffer.compact(); &#125; if (massageList != null &amp;&amp; !massageList.isEmpty()) &#123; for (Object massage3 : massageList)&#123; handlerTask(massage3); &#125; &#125; //第十一步：将POJO对象encode成ByteBuff，调用SocketChannel的异步write接口，将异步消息发送到客户端 socketChannel.write(buffer); &#125;]]></content>
      <categories>
        <category>Android -Socket</category>
      </categories>
  </entry>
</search>
