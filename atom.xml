<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haichenyi.com/"/>
  <updated>2018-05-13T14:36:43.726Z</updated>
  <id>http://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android——MQTT推送</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E2%80%94%E2%80%94MQTT%E6%8E%A8%E9%80%81/"/>
    <id>http://haichenyi.com/2018/05/13/Android——MQTT推送/</id>
    <published>2018-05-13T14:28:22.000Z</published>
    <updated>2018-05-13T14:36:43.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h3><p>&emsp;&emsp;最近公司用到的推送MQTT。不想过多的介绍背景什么的，我就直接讲怎么实现这个功能。</p><p>&emsp;&emsp;他这个原理长连接，这个不用多讲，用法类似于EventBus，需要先订阅，然后通过topic再发送消息。topic是什么呢？我先来讲讲整体流程：</p> <a id="more"></a><ol><li><p>先连接服务器，要先建立长连接</p></li><li><p>然后需要订阅topic，连接之后才能订阅topic</p></li><li><p>最后就是通过topic推送消息，接收消息</p></li></ol><p>一步一步讲：</p><h3 id="第一步，与服务器建立连接"><a href="#第一步，与服务器建立连接" class="headerlink" title="第一步，与服务器建立连接"></a>第一步，与服务器建立连接</h3><p>&emsp;&emsp;先丢代码，然后看注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void initPush() &#123;</span><br><span class="line">        // 服务器地址（协议+地址+端口号）</span><br><span class="line">        String uri = host;</span><br><span class="line">        client = new MqttAndroidClient(this, uri, clientId);</span><br><span class="line">        // 设置MQTT监听并且接受消息</span><br><span class="line">        client.setCallback(mqttCallback);</span><br><span class="line">        //Mqtt的一些设置</span><br><span class="line">        conOpt = new MqttConnectOptions();</span><br><span class="line">        conOpt.setAutomaticReconnect(true);</span><br><span class="line">        // 清除缓存</span><br><span class="line">        conOpt.setCleanSession(true);</span><br><span class="line">        // 设置超时时间，单位：秒</span><br><span class="line">        conOpt.setConnectionTimeout(10);</span><br><span class="line">        // 心跳包发送间隔，单位：秒</span><br><span class="line">        conOpt.setKeepAliveInterval(20);</span><br><span class="line">        myTopic = String.format(TOPIC_SUB, mDeviceId);</span><br><span class="line">        Log.e(TAG,&quot;myTopic_________&quot;+myTopic);</span><br><span class="line">        doClientConnection();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><ol><li>第一个问题，与服务器建立连接，你得先有一个服务器吧？我根据网上的步骤，创建了一个apache-apollo服务器，并且启动了，也启动成功了，我建立连接的时候，总是失败。然后，找啊找，找啊找。问题没有解决，但是，我找到了一个可以用的服务器，也就是这里的uri，不要设置MqttConnectOptions的用户名和密码，设置了他会拒绝</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private String host = &quot;tcp://test.mosquitto.org:1883&quot;;</span><br></pre></td></tr></table></figure><ol><li>第二个问题，我连接成功之后，不一会，他就会自动断开连接，或者，推送完消息之后，他就会断开连接。然后，网上搜原因，找啊找，诶，我找到了。MqttAndroidClient的构造方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructor - create an MqttAndroidClient that can be used to communicate with an MQTT server on android</span><br><span class="line"> * </span><br><span class="line"> * @param context </span><br><span class="line"> *            object used to pass context to the callback. </span><br><span class="line"> * @param serverURI</span><br><span class="line"> *            specifies the protocol, host name and port to be used to</span><br><span class="line"> *            connect to an MQTT server</span><br><span class="line"> * @param clientId</span><br><span class="line"> *            specifies the name by which this connection should be</span><br><span class="line"> *            identified to the server</span><br><span class="line"> */</span><br><span class="line">public MqttAndroidClient(Context context, String serverURI,</span><br><span class="line">String clientId) &#123;</span><br><span class="line">this(context, serverURI, clientId, null, Ack.AUTO_ACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看第三个参数，clientId，指定一个名字，用来连接服务器的身份标识。就是说，你设置的这个值，是你在服务器的唯一标识，不能跟其他用户的相同。我把这个clientId直接用uuid生成，就没问题了。</p><h3 id="第二步，订阅topic"><a href="#第二步，订阅topic" class="headerlink" title="第二步，订阅topic"></a>第二步，订阅topic</h3><p>&emsp;&emsp;回到上面，接着往下面走，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 连接MQTT服务器</span><br><span class="line">     */</span><br><span class="line">    private void doClientConnection() &#123;</span><br><span class="line">        if (!client.isConnected() &amp;&amp; isConnectIsNormal()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                client.connect(conOpt, null, iMqttActionListener);</span><br><span class="line">            &#125; catch (MqttException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 判断网络是否连接</span><br><span class="line">     */</span><br><span class="line">    private boolean isConnectIsNormal() &#123;</span><br><span class="line">        ConnectivityManager connectivityManager = (ConnectivityManager) this.getApplicationContext()</span><br><span class="line">                .getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        if (connectivityManager != null) &#123;</span><br><span class="line">            NetworkInfo info = connectivityManager.getActiveNetworkInfo();</span><br><span class="line">            if (info != null &amp;&amp; info.isAvailable()) &#123;</span><br><span class="line">                String name = info.getTypeName();</span><br><span class="line">                Log.e(TAG, &quot;MQTT当前网络名称：&quot; + name);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.e(TAG, &quot;MQTT 没有可用网络&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法就是用来连接服务器的，首先判断是否正在连接，后面那个是判断当前有没有网络。再就是这个iMqttActionListener监听了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// MQTT是否连接成功</span><br><span class="line">    private IMqttActionListener iMqttActionListener = new IMqttActionListener() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onSuccess(IMqttToken arg0) &#123;</span><br><span class="line">            Log.e(TAG, &quot;连接成功 &quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 订阅myTopic话题</span><br><span class="line">                client.subscribe(myTopic, 0);</span><br><span class="line">            &#125; catch (MqttException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onFailure(IMqttToken arg0, Throwable arg1) &#123;</span><br><span class="line">            Log.e(TAG, &quot;连接失败&quot;);</span><br><span class="line">            arg1.printStackTrace();</span><br><span class="line">            // 连接失败，重连</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讷，就是这里，你如果服务器有问题，他一直走onFailure方法。服务器连接成功之后，就是订阅topic。我来说说这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.subscribe(myTopic, 0);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先，这个主题，是你自己跟服务器商量好的，随便什么都可以。为什么要订阅主题呢？我提前给你瞅瞅推送消息是怎么推送的</p><p>&emsp;&emsp;第二个参数，消息的类型qos，有三种：0、1、2</p><ol><li>0代表“至多一次”，消息发布完全依赖底层 TCP/IP 协议。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送</li><li>1代表“至少一次”，确保消息到达，但消息重复可能会发生</li><li>2代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。</li></ol><p>&emsp;&emsp;简单说明下，如果发送的是临时的消息，例如给某topic所有在线的设备发送一条消息，丢失的话也无所谓，0就可以了。如果需要客户端保证能接收消息，需要指定QoS为1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.publish(topic, new MqttMessage(msg.getBytes()));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讷，推送消息，是根据topic推送的，第二个参数，就是你要推送的具体消息。我个人认为，你可以理解成就类似于键值对的形式，</p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p>&emsp;&emsp;这个就是跟其他长连接不同的地方，底层，其实都一样，虽然我没有看底层的代码。想也想的到，服务器肯定是根据这个主题，去找对应的用户，然后推送消息。而其他的长连接就是直接指定用户。跑题了，跑题了。</p><h3 id="第三步，推送、接收消息"><a href="#第三步，推送、接收消息" class="headerlink" title="第三步，推送、接收消息"></a>第三步，推送、接收消息</h3><p>&emsp;&emsp;当你连接服务器成功之后，就要推送消息了，我用的EventBus发的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void publishData(String msg) &#123;</span><br><span class="line">        String topic = myTopic;</span><br><span class="line">        try &#123;</span><br><span class="line">            Log.e(TAG,&quot;给__&quot;+topic+&quot;__topic发送的消息为：&quot;+msg);</span><br><span class="line">            client.publish(topic, new MqttMessage(msg.getBytes()));</span><br><span class="line">        &#125; catch (MqttException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // MQTT监听并且接受消息</span><br><span class="line">    private MqttCallback mqttCallback = new MqttCallback() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void messageArrived(String topic, MqttMessage message) throws Exception &#123;</span><br><span class="line">            Log.e(TAG,&quot;接受到__&quot;+topic+&quot;__topic的消息为：&quot;+new String(message.getPayload()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void deliveryComplete(IMqttDeliveryToken arg0) &#123;</span><br><span class="line">            Log.e(TAG,&quot;deliveryComplete&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void connectionLost(Throwable arg0) &#123;</span><br><span class="line">            // 失去连接，重连</span><br><span class="line">            Log.e(TAG,&quot;失去连接&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当你的clientId重复的时候，他就会一直走connectionLost方法。到这里，基本上就讲完了，要注意的是，退出的时候，记得要释放资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (client != null &amp;&amp; client.isConnected()) &#123;</span><br><span class="line">                client.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (MqttException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        EventBus.getDefault().unregister(this);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>网上很多都是直接讲整体流程，重来不讲中间碰到的问题。难受</p><p><a href="https://download.csdn.net/download/qq_27634797/10408420" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;整体介绍&quot;&gt;&lt;a href=&quot;#整体介绍&quot; class=&quot;headerlink&quot; title=&quot;整体介绍&quot;&gt;&lt;/a&gt;整体介绍&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近公司用到的推送MQTT。不想过多的介绍背景什么的，我就直接讲怎么实现这个功能。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;他这个原理长连接，这个不用多讲，用法类似于EventBus，需要先订阅，然后通过topic再发送消息。topic是什么呢？我先来讲讲整体流程：&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android—React Native编程</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E2%80%94React-Native%E7%BC%96%E7%A8%8B/"/>
    <id>http://haichenyi.com/2018/05/13/Android—React-Native编程/</id>
    <published>2018-05-13T14:28:07.000Z</published>
    <updated>2018-05-13T14:32:04.667Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人博客：haichenyi.com。感谢关注</strong></p><h2 id="新公司，新的开始，新的技术"><a href="#新公司，新的开始，新的技术" class="headerlink" title="新公司，新的开始，新的技术"></a>新公司，新的开始，新的技术</h2><p>&emsp;&emsp;新公司的项目，用到的RN编程，之前完全没有碰到过，遇到新技术，之前完全没有碰到过怎么办？google、百度咯。通过不屑的努力，找到了<a href="https://www.jianshu.com/u/6e613846e1ea" target="_blank" rel="noopener">恋猫月亮 </a>的三篇关于RN的文章。我感觉还是很不错的。</p> <a id="more"></a><p><a href="https://www.jianshu.com/p/97692b1c451d" target="_blank" rel="noopener">从Android到React Native开发（一、入门）</a></p><p><a href="https://www.jianshu.com/p/bec040926db8" target="_blank" rel="noopener">从Android到React Native开发（二、通信与模块实现）</a></p><p><a href="https://www.jianshu.com/p/a488674d55b3" target="_blank" rel="noopener">从Android到React Native开发（三、自定义原生控件支持）</a></p><p>&emsp;&emsp;可以先浏览上面的第一篇入门，再过来看我这篇文章，我这篇文章就是讲怎么运行一个RN，我只是针对我的项目，把RN的部分提取了出来，上面大佬讲的比较全面。</p><h2 id="React-Native环境配置"><a href="#React-Native环境配置" class="headerlink" title="React Native环境配置"></a>React Native环境配置</h2><p><strong>开发工具</strong>：android studio。我不知道为什么要换开发工具。AS不好吗？环境还是跟你之前开发的一样配置，不用变</p><p><strong>python安装</strong>：python官网，下载安装。记得配置环境变量。不用非要按照他那个上面说的去安装。安装完成之后cmd里面敲python然后回车，看到如下界面:</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-a4af2b0fc841a608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="python.png"></p><p><strong>node.js安装</strong>：node也是一样，百度安装,配置完环境变量。cmd里面敲 npm -v然后回车，看到如下界面</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-62ea02b1913843e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="node.png"></p><p>最后，跑如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。</span><br><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br><span class="line">//React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</span><br><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，RN的配置就完成了。记得配置NDK环境，然后就是上你们公司的svn，或者git去down项目下来,应该还会有一个错误，那就是找不到<strong>react.gradle</strong>的路径，找到你添加依赖的那个gradle，在最上面添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: &quot;../../node_modules/react-native/react.gradle&quot;</span><br></pre></td></tr></table></figure><p>这个配置应该是添加greenDao那个是一样的，这样就能找到了<strong>react.gradle</strong></p><p>项目结构如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-86b8e4e093e337da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="project.png"></p><p>&emsp;&emsp;我用箭头标记了，你down下来的项目，应该是没有node_modules文件夹的，这个文件夹是怎么产生的呢？你在cmd进入你down的项目，就是图片上面的文件目录，跑如下命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>当命令运行完，就可以跑项目了。</p><h2 id="React-Native项目搭建"><a href="#React-Native项目搭建" class="headerlink" title="React Native项目搭建"></a>React Native项目搭建</h2><p>&emsp;&emsp;同鞋，你有freeStyle吗？有没有用过WebView？WebView就是在你的xml里面新增了一个WebView控件，RN也一样，他的这个控件就是ReactRootView。所以，这个控件哪里来？当然是添加依赖了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//版本号你自己找</span><br><span class="line">compile &apos;com.facebook.react:react-native:0.50.3&apos;</span><br></pre></td></tr></table></figure><p>最终的作用代码就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mReactRootView.startReactApplication(mReactInstanceManager, &quot;XXX&quot;, null);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个ReacRootView对象，你可以new出来，也可以写在xml里面findViewById。只要你能获取到这个对象就可以了，然后就是这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName, @Nullable Bundle initialProperties)</span><br></pre></td></tr></table></figure><p>三个参数</p><ol><li>ReactInstanceManager reactInstanceManager</li><li>String moduleName</li><li>@Nullable Bundle initialProperties</li></ol><h3 id="第一个参数：ReactInstanceManager"><a href="#第一个参数：ReactInstanceManager" class="headerlink" title="第一个参数：ReactInstanceManager"></a>第一个参数：<strong>ReactInstanceManager</strong></h3><p>就像配置WebView的参数，那些什么配置client允许js弹窗啊，新的页面直接覆盖原来的页面，并不是新建一个页面之类的参数，对应的这里，就是配置<strong>ReactInstanceManager</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReactInstanceManagerBuilder builder = ReactInstanceManager.builder();</span><br><span class="line">        builder = builder</span><br><span class="line">                .setApplication(getApplication())</span><br><span class="line">                .setBundleAssetName(&quot;index.android.bundle&quot;)</span><br><span class="line">                .setJSMainModulePath(&quot;index.android&quot;);</span><br><span class="line"></span><br><span class="line">        mReactInstanceManager = builder</span><br><span class="line">                .addPackage(new MainReactPackage())</span><br><span class="line">                .addPackage(new YzgHDReactPackage())</span><br><span class="line">//                .setUseDeveloperSupport(!Global.ISPRD)</span><br><span class="line">                .setUseDeveloperSupport(true)</span><br><span class="line">              .setInitialLifecycleState(LifecycleState.RESUMED)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;前面的builder的初始化是必须要写的，setApplication，如果你没有自己写application，那就直接getApplication，如果，你有自己实现application那就传你的application对象。</p><p>&emsp;&emsp;setBundleAssetName和setJSMainModulePath都是写死的，后面的名字也是写死的。</p><p>&emsp;&emsp;然后就是添加package，在package里面添加module。这里就是JS和Android相互调用的地方。package里面要实现ReactPackage，在createNativeModules里面去添加moudle</p><h3 id="第二个参数：String-moduleName"><a href="#第二个参数：String-moduleName" class="headerlink" title="第二个参数：String moduleName"></a>第二个参数：<strong>String moduleName</strong></h3><p>这个moudleName是怎么来的？就是我们前面设置的MoudlePath那个JS里面的。这里的路径应该是<strong>index.android.js</strong>，是一个js文件，打开之后，最下面有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppRegistry.registerComponent(&apos;zzz&apos;, () =&gt; XXX);</span><br></pre></td></tr></table></figure><p>这里的zzz就是我们这里需要传的名字</p><h3 id="第三个参数：Bundle-initialProperties"><a href="#第三个参数：Bundle-initialProperties" class="headerlink" title="第三个参数：Bundle initialProperties"></a>第三个参数：<strong>Bundle initialProperties</strong></h3><p>这里应该是传一个bundle，传输的数据，传个null就可以了</p><h2 id="React-Native流程"><a href="#React-Native流程" class="headerlink" title="React Native流程"></a>React Native流程</h2><p>&emsp;&emsp;前面的整个配置都配置完成之后，Android这边只用新建方法，给RN调用就可以了。新建的方法要用@ReactMethod标记。辣么，这个方法新建在哪呢？————Module，就是对应我们前面package里面添加的module。都说RN每个模块是独立的，怎么独立呢？就是这样独立的。每个模块功能对应一个module，每个都有该功能对应的方法。我就拿我这里的UserModule来举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class UserModule extends IModule implements NoticeListener&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static final String MODULE_NAME = &quot;User_Module&quot;;</span><br><span class="line"></span><br><span class="line">    private ReactApplicationContext mContext;</span><br><span class="line"></span><br><span class="line">    public UserModule(ReactApplicationContext reactContext) &#123;</span><br><span class="line">        super(reactContext);</span><br><span class="line">        this.mContext = reactContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return MODULE_NAME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户登录接口</span><br><span class="line">     * @param params</span><br><span class="line">     * @param callback</span><br><span class="line">     */</span><br><span class="line">    @ReactMethod</span><br><span class="line">    public void doLogin(String params, final Callback callback)&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,String&gt; map = GsonTool.gson2Map(params);</span><br><span class="line"></span><br><span class="line">        if(map == null || map.size() &lt;= 0)&#123;</span><br><span class="line">            callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;参数异常&quot;)));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final String userName = map.get(&quot;userName&quot;);</span><br><span class="line">        final String password = map.get(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">        if(TextUtils.isEmpty(userName) || TextUtils.isEmpty(password))&#123;</span><br><span class="line">            callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;用户名或密码不能为空&quot;)));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //登录</span><br><span class="line">        new Handler().post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                String result = new UserBridge().doLogin(userName,password, Global.DEVICE_ID,Global.APP_VERSION_NAME);</span><br><span class="line">                callback.invoke(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我就粘贴出来了部分代码，module要继承IModule，这个是一个抽象类，他继承ReactContextBaseJavaModule，最主要就是继承它，继承之后，我像说的就是这两个方法，getName()和注解的方法doLogin()。</p><p>&emsp;&emsp;我们可以看到，这个getName最终返回的是一个User_Module，这个字符串是怎么确定的呢？这个登录的方法名称是怎么确定的呢？</p><p>&emsp;&emsp;这些东西都是在js里面定义好的，这里是一个登录方法，我们打开登录的js。</p><p><strong>PS:</strong> 这里应该是通过js去确定我们这边的方法名，并不是通过这里的名称去确定js的。</p><p>&emsp;&emsp;我就不把JS代码，贴出来了，只贴出伪代码，打开js之后，搜索NativeModules。你应该会搜到类似的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; User_Module, Shop_Module &#125; = NativeModules;</span><br></pre></td></tr></table></figure><p>这里有两个Module，没错，就是两个。我们这里现在只关注User_Module，然后，我们搜索 User_Module，你会看到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">_onLogIn = () =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        const &#123; username, password &#125; = this.userInfo;</span><br><span class="line">        if (username.length &lt;= 0) return this._modal.Alert(&apos;请输入用户名&apos;);</span><br><span class="line">        if (password.length &lt;= 0) return this._modal.Alert(&apos;请输入密码&apos;);</span><br><span class="line">        this._button.setButton(false, &apos;正在登录...&apos;);</span><br><span class="line">        const params = &#123; userName: username, password &#125;;</span><br><span class="line">        // 登录</span><br><span class="line">        const _dologin = () =&gt; &#123;</span><br><span class="line">            return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123;</span><br><span class="line">                    const data = Other.callHandle(values) || &#123;&#125;;</span><br><span class="line">                    if (data.status) &#123;</span><br><span class="line">                        resolve(&apos;登录成功&apos;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        reject(data.message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>其他的一切，我们都不用管，我们在意的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123;</span><br><span class="line">                    const data = Other.callHandle(values) || &#123;&#125;;</span><br><span class="line">                    if (data.status) &#123;</span><br><span class="line">                        resolve(&apos;登录成功&apos;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        reject(data.message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个是我的项目里面的js，你们搜到的肯定跟我的不一样，我这里要说的是，怎么确定name的返回值，和注解方法。我们看到了，name就是这里的User_Module，方法就是这里的doLogin，android里面写用@ReactMethod标记，然后就是参数了，这里两个参数，一个是String，json格式的。用ArrayMap存储好key—value之后，转成字符串即可。第二个参数就是callback。android与JS通信，发送数据，就是一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback.invoke(&quot;data&quot;)</span><br></pre></td></tr></table></figure><p>他需要什么，你就发送什么。上面是RN主动调用Android方法，辣么，Android怎么主动调用RN方法呢？其实也很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//发送给RN</span><br><span class="line">        if (mReactInstanceManager.getCurrentReactContext() != null) &#123;</span><br><span class="line">            mReactInstanceManager.getCurrentReactContext()</span><br><span class="line">                    .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)</span><br><span class="line">                    .emit(PUSH_DATA_RN, mqttBean.info);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>就是获取ReactContext对象，通过调用getJSModule方法，参数传DeviceEventManagerModule.RCTDeviceEventEmitter.class这个类就可以了，然后通过调用emit方法，第一个参数，就是RN规定的方法名称，第二个参数就是需要传给RN的数据。为什么这样写呢？我们再来看看RN那边是怎么写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DeviceEventEmitter.addListener(&quot;push_data_rn&quot;,(data)=&gt;&#123;</span><br><span class="line">            alert(data)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>他就是通过这DeviceEventEmitter类添加addListener方法，传两个参数，第一个参数就是我们规定的名称，第二个参数就是一个回调，有一个参数，就是用来接收我们的数据，最后做的处理就是简单的弹窗，当然，这是我自己测试用的，最后RN要怎么坐，就是我要担心的问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;个人博客：haichenyi.com。感谢关注&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;新公司，新的开始，新的技术&quot;&gt;&lt;a href=&quot;#新公司，新的开始，新的技术&quot; class=&quot;headerlink&quot; title=&quot;新公司，新的开始，新的技术&quot;&gt;&lt;/a&gt;新公司，新的开始，新的技术&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;新公司的项目，用到的RN编程，之前完全没有碰到过，遇到新技术，之前完全没有碰到过怎么办？google、百度咯。通过不屑的努力，找到了&lt;a href=&quot;https://www.jianshu.com/u/6e613846e1ea&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;恋猫月亮 &lt;/a&gt;的三篇关于RN的文章。我感觉还是很不错的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android转场动画——共享元素</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0/"/>
    <id>http://haichenyi.com/2018/05/13/Android转场动画——共享元素/</id>
    <published>2018-05-13T14:27:52.000Z</published>
    <updated>2018-05-13T14:33:04.328Z</updated>
    
    <content type="html"><![CDATA[<p>这个东西其实很简单，我这里只是做一个简单的记录。</p> <a id="more"></a><p>XML代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--第一个Activity的xml布局，需要共享的元素，加上transitionName属性。至于名字，你随便定义，要保持相同--&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:gravity=&quot;bottom&quot;</span><br><span class="line">    tools:context=&quot;com.haichenyi.activitytransitionanimation.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/img&quot;</span><br><span class="line">        android:layout_width=&quot;300dp&quot;</span><br><span class="line">        android:layout_height=&quot;200dp&quot;</span><br><span class="line">        android:transitionName=&quot;wang&quot;</span><br><span class="line">        android:src=&quot;@mipmap/bg&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/btn&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;跳转&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--第二个activity的xml布局--&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/img&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;300dp&quot;</span><br><span class="line">        android:src=&quot;@mipmap/bg&quot;</span><br><span class="line">        android:transitionName=&quot;wang&quot;/&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/btn&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;back&quot;/&gt;</span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><p>java代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/3/29</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onClick(View v) &#123;</span><br><span class="line">      //共享元素转场动画，只支持android 5.0，所以加一个判断</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">          startActivity(new Intent(MainActivity.this, Step1Activity.class),</span><br><span class="line">              ActivityOptions.makeSceneTransitionAnimation(MainActivity.this,</span><br><span class="line">                  findViewById(R.id.img), &quot;wang&quot;).toBundle());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          startActivity(new Intent(MainActivity.this, Step1Activity.class));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，就是一个Button点击跳转。这个共享元素的核型代码，就是一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions.makeSceneTransitionAnimation(Activity activity,</span><br><span class="line">            View sharedElement, String sharedElementName)</span><br></pre></td></tr></table></figure><p>三个参数：</p><ol><li>Activity activity：activity对象，这个不用多说了</li><li>View sharedElement：共享元素的那个控件</li><li>String sharedElementName：共享元素控件的那个transitionName属性的值。前面xml里面的注释讲过要相同，有三个位置用到这个：跳转activity的xml里面，跳转的目标activity的xml里面，再就是这里，跳转的代码这里需要设置。</li></ol><p>就这么简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个东西其实很简单，我这里只是做一个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android——PorterDuffXfermode</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E2%80%94%E2%80%94PorterDuffXfermode/"/>
    <id>http://haichenyi.com/2018/05/13/Android——PorterDuffXfermode/</id>
    <published>2018-05-13T14:27:36.000Z</published>
    <updated>2018-05-13T14:35:37.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;PorterDuffXfermode是什么鬼？个人理解，简单的来讲就是做两个Bitmap操作的，什么操作呢？有裁剪，合并等等，有16种图形混合模式。先举一个简单的例子，我们在慢慢讲：</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/28</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MyCustomView extends View &#123;</span><br><span class="line">  private int width = 300;</span><br><span class="line">  private int height = 300;</span><br><span class="line">  private Bitmap dstBmp;</span><br><span class="line">  private Bitmap srcBmp;</span><br><span class="line">  private Paint mPaint;</span><br><span class="line"></span><br><span class="line">  public MyCustomView(Context context) &#123;</span><br><span class="line">    this(context, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">    super(context, attrs, defStyleAttr);</span><br><span class="line">    initView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void initView() &#123;</span><br><span class="line">    setLayerType(View.LAYER_TYPE_SOFTWARE, null);</span><br><span class="line">    srcBmp = makeSrc(width, height);</span><br><span class="line">    dstBmp = makeDst(width, height);</span><br><span class="line">    mPaint = new Paint();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2);</span><br><span class="line">    canvas.drawColor(Color.BLUE);</span><br><span class="line">    int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG);</span><br><span class="line">    canvas.drawBitmap(dstBmp, 0, 0, mPaint);</span><br><span class="line">    @SuppressLint(&quot;DrawAllocation&quot;) PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);</span><br><span class="line">    mPaint.setXfermode(xfermode);</span><br><span class="line">    canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint);</span><br><span class="line">    mPaint.setXfermode(null);</span><br><span class="line">    canvas.restoreToCount(layerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Bitmap makeDst(int w, int h) &#123;</span><br><span class="line">    Bitmap dst = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas mCanvas = new Canvas(dst);</span><br><span class="line">    Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(Color.RED);</span><br><span class="line">    mCanvas.drawOval(new RectF(0, 0, w, h), mPaint);</span><br><span class="line">    return dst;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Bitmap makeSrc(int w, int h) &#123;</span><br><span class="line">    Bitmap src = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas mCanvas = new Canvas(src);</span><br><span class="line">    Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(Color.YELLOW);</span><br><span class="line">    mCanvas.drawRect(0, 0, w, h, mPaint);</span><br><span class="line">    return src;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/7041675-a473668793539882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="简介demo图.png"></p><p>&emsp;&emsp;上面画了一个圆形bitmap，画了一个矩形bitmap，设置了一个模式 <strong><em>PorterDuff.Mode.SRC_IN</em></strong> 就变成了上面的形状，这是怎么做到的呢？带着我们的问题，进入我们的主题。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong><em>注意点</em></strong></h2><p>&emsp;&emsp;为什么我要拿一个大标题来写这个呢？因为，我当时卡在这里很久，然后踩着巨人的肩膀，我才踏过去的。</p><ol><li><p>首先，两个图形必须都是Bitmap，直接用Canvas画形状，做操作，是达不到效果的。重要的事情说三遍：<strong><em>两个图形必须都是Bitmap。两个图形必须都是Bitmap。两个图形必须都是Bitmap</em></strong></p></li><li><p>其次，避免不必要的麻烦，请先关闭硬件加速。重要的事情说三遍：<strong><em>请先关闭硬件加速。请先关闭硬件加速。请先关闭硬件加速</em></strong></p></li><li><p>然后，两个bitmap的大小最好一样。</p></li><li><p>最后，我要强调的是：<strong><em>先绘制的是目标图，后绘制的是源图。</em></strong></p></li></ol><p>&emsp;&emsp;这里一直说bitmap，辣么，怎么生成这个bitmap，生成这个bitmap之后怎么画图形呢？如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//第一步，我们先创建一个bitmap对象</span><br><span class="line">Bitmap dst = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line">//第二步，我们通过这个bitmap对象创建一个画布，</span><br><span class="line">//说白了，就是new 一个画布，把bitmap放到画布的构造方法里面</span><br><span class="line">    Canvas mCanvas = new Canvas(dst);</span><br><span class="line">    Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(Color.RED);</span><br><span class="line">//最后，在这个画布上面的所有操作，最后都是呈现在bitmap上面。</span><br><span class="line">//就像这里的，在这个画布上面画了一个椭圆，其实，最后我们的bitmap就是一个椭圆</span><br><span class="line">    mCanvas.drawOval(new RectF(0, 0, w, h), mPaint);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以，bitmap会创建了，再就是我们前面说的两个bitmap，<strong><em>先绘制的是目标图，后绘制的是源图</em></strong>，一个是dst（目标图片，下层，先画），一个是src（源图片，上层，后画）。就是我们上面的自定view里面的onDraw()方法里面，用onDraw的canvas画的东西。</p><p>&emsp;&emsp;我们如果不用这个xfermode模式，我们的代码应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2);</span><br><span class="line">    canvas.drawColor(Color.BLUE);</span><br><span class="line">    canvas.drawBitmap(dstBmp, 0, 0, mPaint);</span><br><span class="line">    canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很简单的几行代码，把画布移到正中间，给画布加一个背景蓝色，先画dst，后画src，跑出来的效果图应该是下面这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-eae7b8c745ec218e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意点1.png"></p><p>&emsp;&emsp;我们如果加上这个xfermode模式里面的 <strong><em>PorterDuff.Mode.SRC_IN</em></strong>模式，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2);</span><br><span class="line">    canvas.drawColor(Color.BLUE);</span><br><span class="line">    int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG);</span><br><span class="line">    canvas.drawBitmap(dstBmp, 0, 0, mPaint);</span><br><span class="line">    @SuppressLint(&quot;DrawAllocation&quot;) PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);</span><br><span class="line">    mPaint.setXfermode(xfermode);</span><br><span class="line">    canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint);</span><br><span class="line">    mPaint.setXfermode(null);</span><br><span class="line">    canvas.restoreToCount(layerID);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比上面的代码，就多加了一个xfermode模式，他们要是同一个画笔，用完之后，记得要把这个模式置null这个saveLayer等会讲，先不说。跑出来的效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-f1b34b7fb8df357e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意点2.png"></p><p>&emsp;&emsp;前面，我们一直都在强调dst先画，src后画，如果调换一下，会是什么样的结果呢？代码我就不贴出来了，就把那两个drawBitmap调换一个位置，跑出来的效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-e8ad2cf4229095fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意点3.png"></p><p>&emsp;&emsp;很明显，跟我们的预期结果不一样。这是为什么呢？带着我们的问题进入下一节。</p><h2 id="十六种模式和saveLayer"><a href="#十六种模式和saveLayer" class="headerlink" title="十六种模式和saveLayer()"></a>十六种模式和saveLayer()</h2><h3 id="十六种模式"><a href="#十六种模式" class="headerlink" title="十六种模式"></a>十六种模式</h3><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">含义</th><th style="text-align:center">名字</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">CLEAR</td><td style="text-align:center">清除模式［0，0］，即最终所有点的像素的alpha 和color 都为 0，所以画出来的效果只有白色背景</td><td style="text-align:center">SRC</td><td style="text-align:center">显示上层绘制图片</td></tr><tr><td style="text-align:center">DST</td><td style="text-align:center">显示下层绘制图片</td><td style="text-align:center">SRC_OVER</td><td style="text-align:center">正常绘制显示，上下层绘制叠盖</td></tr><tr><td style="text-align:center">DST_OVER</td><td style="text-align:center">上下层都显示，下层居上显示</td><td style="text-align:center">SRC_IN</td><td style="text-align:center">取两层绘制交集。显示上层</td></tr><tr><td style="text-align:center">DST_IN</td><td style="text-align:center">取两层绘制交集，显示下层</td><td style="text-align:center">SRC_OUT</td><td style="text-align:center">取上层绘制非交集部分</td></tr><tr><td style="text-align:center">DST_OUT</td><td style="text-align:center">取下层绘制非交集部分</td><td style="text-align:center">SRC_ATOP</td><td style="text-align:center">取下层非交集部分与上层交集部分</td></tr><tr><td style="text-align:center">DST_ATOP</td><td style="text-align:center">取上层非交集部分与下层交集部分</td><td style="text-align:center">XOR</td><td style="text-align:center">异或：去除两图层交集部分</td></tr><tr><td style="text-align:center">DARKEN</td><td style="text-align:center">取两图层全部区域，交集部分颜色加深</td><td style="text-align:center">LIGHTEN</td><td style="text-align:center">取两图层全部，点亮交集部分颜色</td></tr><tr><td style="text-align:center">MULTIPLY</td><td style="text-align:center">取两图层交集部分叠加后颜色</td><td style="text-align:center">SCREEN</td><td style="text-align:center">取两图层全部区域，交集部分变为透明色</td></tr></tbody></table><p>PS：名称前面都应该有：<strong><em>PorterDuff.Mode</em></strong> ，例如：PorterDuff.Mode.CLEAR</p><p>&emsp;&emsp;什么？有的看不懂什么意思？没关系，我也没指望你一次就看懂，我们先来说一说saveLayer()，且听我娓娓道来。</p><h3 id="saveLayer"><a href="#saveLayer" class="headerlink" title="saveLayer()"></a>saveLayer()</h3><p>&emsp;&emsp;这个方法是干嘛用的？保存指定区域内画布的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public int saveLayer(RectF bounds, Paint paint, int saveFlags)  </span><br><span class="line">public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;后面的saveFlags，有6个值，我们这里用到的 <strong><em>Canvas.ALL_SAVE_FLAG</em></strong>，很明显，表示保存所有内容。我们这里如果把这个方法去掉，会是什么样的结果呢？代码就不贴出来了，就直接注释掉saveLayer的两行代码。还是先画dst，后画src，跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-85a4080bc042c63c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="去掉saveLayer().png"></p><p>我们先规定两点：</p><ol><li>先画dst，也就是目标图像，是一个圆形。</li><li>后画src，也就是源图像，是一个矩形。</li></ol><table><thead><tr><th style="text-align:center">代码名称1</th><th style="text-align:center">顺序</th><th style="text-align:center">中文名称</th><th style="text-align:center">形状</th></tr></thead><tbody><tr><td style="text-align:center">dst</td><td style="text-align:center">先画</td><td style="text-align:center">目标图像</td><td style="text-align:center">红色圆形</td></tr><tr><td style="text-align:center">src</td><td style="text-align:center">后画</td><td style="text-align:center">源图像</td><td style="text-align:center">黄色矩形</td></tr></tbody></table><p>&emsp;&emsp;规定好之后，我们再来说一说这个 <strong><em>SRC_IN</em></strong>，我们前面说了：取两层绘制交集。显示上层。首先IN是取交集部分，OUT是取非交集部分。这个就是说最后显示的图形，他们的交集部分，显示src，也就是矩形的颜色，也就是黄色。先画的dst，他自然在src的上层。所以，显示dst的形状，两者交集部分显示src的颜色。可以看下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-0b1c817304fec954.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="saveLayer.png"></p><p>&emsp;&emsp;我们再来说说saveLayer的绘制流程：如上图所示，它会创建一个全新图名的bitmap，大小跟你前面指定的保存区域相同，然后，绘制的图形会保存在这个全新透明的bitmap上面，最后把这个透明的bitmap画在画布上面。</p><p>&emsp;&emsp;辣么，没有savelayer()方法的绘制流程呢？如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-38b1242793a0807b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="no_saveLayer.png"></p><p>他是直接作用在画布上面的。</p><h2 id="常用的PorterDuffXfermode模式介绍"><a href="#常用的PorterDuffXfermode模式介绍" class="headerlink" title="常用的PorterDuffXfermode模式介绍"></a>常用的PorterDuffXfermode模式介绍</h2><h3 id="SRC模式"><a href="#SRC模式" class="headerlink" title="SRC模式"></a>SRC模式</h3><p>&emsp;&emsp;只保留源图像的 alpha 和 color ，所以绘制出来只有源图，有时候会感觉分不清先绘制的是源图还是后绘制的是源图，这个时候可以这么记，先绘制的是目标图，不管任何时候，一定要做一个有目标的人，目标在前！（未达到我们的预期效果，感觉有问题）</p><h3 id="DST模式"><a href="#DST模式" class="headerlink" title="DST模式"></a>DST模式</h3><p>&emsp;&emsp;只显示目标图片，也就是只显示红色的圆形。</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-5a78edd1ea287820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST.png"></p><h3 id="SRC-OVER模式"><a href="#SRC-OVER模式" class="headerlink" title="SRC_OVER模式"></a>SRC_OVER模式</h3><p>&emsp;&emsp;在目标图片顶部绘制源图像,从命名上也可以看出来就是把源图像绘制在上方，也就是把黄色长方形，画在红色圆形的上面。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-efa828311c86ebcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SRC_OVER.png"></p><h3 id="DST-OVER模式"><a href="#DST-OVER模式" class="headerlink" title="DST_OVER模式"></a>DST_OVER模式</h3><p>&emsp;&emsp;把目标图像绘制在上方。与前一个相反，把红色圆形画在长方形上面。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d715a0025e2c1baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST_OVER.png"></p><h3 id="SRC-IN模式"><a href="#SRC-IN模式" class="headerlink" title="SRC_IN模式"></a>SRC_IN模式</h3><p>&emsp;&emsp;在两者相交的地方绘制源图像，并且绘制的效果会受到目标图像对应地方透明度的影响。</p><p>&emsp;&emsp;有点绕，我分成几段讲出来：</p><p>&emsp;&emsp;也就是说，两者相交的位置，显示源图像，也就是黄色的矩形，目标图像的透明度为0，然后，&emsp;源图像的其他位置的透明度&emsp;&emsp;会跟源图像与目标图像相交的地方&emsp;&emsp;的目标图像的透明度一样。</p><p>&emsp;&emsp;有点绕。其实，就是说源图像的其他地方隐藏，就显示相交的位置。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-7e2826c64c63d907.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SRC_IN.png"></p><h3 id="DST-IN模式"><a href="#DST-IN模式" class="headerlink" title="DST_IN模式"></a>DST_IN模式</h3><p>&emsp;&emsp;跟前面刚好对应，在两者相交的地方绘制目标图像，并且，绘制效果会受到源图像对应地方透明度的影响。我们最是绘制目标图像。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-4bea3004d59f8260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST_IN.png"></p><h3 id="SRC-OUT模式"><a href="#SRC-OUT模式" class="headerlink" title="SRC_OUT模式"></a>SRC_OUT模式</h3><p>&emsp;&emsp;在不相交的地方绘制源图像，相交处根据目标alpha进行过滤，目标色完全不透明时则完全过滤，完全透明则不过滤；</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-306477eebd6a23d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SRC_OUT.png"></p><h3 id="DST-OUT模式"><a href="#DST-OUT模式" class="headerlink" title="DST_OUT模式"></a>DST_OUT模式</h3><p>&emsp;&emsp;同样，可以类比SRC_OUT , 在不相交的地方绘制目标图像，相交处根据源图像alpha进行过滤，完全不透明处则完全过滤，完全透明则不过滤；</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-05650d7d10021591.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST_OUT.png"></p><p>太多了，后面就不写了，用的也比较少。</p><p>用途，加上上一篇的贝赛尔曲线的水波纹。很明显，我就想做如下效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-dcdb3859d8e4fbf8.gif?imageMogr2/auto-orient/strip" alt="圆形水波纹.gif"></p><p>这个圆只是一种，这只是一个demo，这个圆，你可以换成任意的形状。你知道水波纹用贝赛尔曲线怎么做，知道了，PorterDuffXfermode这个模式，两张图片是怎么切割。像这样的，还不就是一个道理。随手拈来。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-946eca2d7f94cdcf.gif?imageMogr2/auto-orient/strip" alt="自定义背景.gif"></p><p>这个水波纹的，已经全部封装好了。任意改变背景图片。<a href="https://download.csdn.net/download/qq_27634797/10314335" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;PorterDuffXfermode是什么鬼？个人理解，简单的来讲就是做两个Bitmap操作的，什么操作呢？有裁剪，合并等等，有16种图形混合模式。先举一个简单的例子，我们在慢慢讲：&lt;/p&gt;
    
    </summary>
    
      <category term="Android -自定义view" scheme="http://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>Android自定义View——贝赛尔曲线</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E8%87%AA%E5%AE%9A%E4%B9%89View%E2%80%94%E2%80%94%E8%B4%9D%E8%B5%9B%E5%B0%94%E6%9B%B2%E7%BA%BF/"/>
    <id>http://haichenyi.com/2018/05/13/Android自定义View——贝赛尔曲线/</id>
    <published>2018-05-13T14:27:18.000Z</published>
    <updated>2018-05-13T14:35:32.961Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文针对有一定自定义View的童鞋，最好对贝赛尔曲线有辣么一丢丢了解，不了解也没关系。花5分钟看一下 <strong><em>GcsSloop</em></strong>的 <a href="http://www.gcssloop.com/customview/Path_Bezier" target="_blank" rel="noopener">安卓自定义View进阶-Path之贝塞尔曲线</a>。</p><p>本文的最终效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-bb761f08bb5704c5.gif?imageMogr2/auto-orient/strip" alt="最终效果图.gif"></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>首先他是一个只有上半部分的正弦形状的水波纹，很规则。</li><li>其次，他这个正弦图左右在移动。</li><li>然后，就是它这个自定义View，上下也在移动，是慢慢增加的</li><li>最后，优化点：一开始刚出来的时候，它那个水波纹的角度，更达到一定角度后，最后面，快要完成的时候的角度是不一样的。</li></ol><h2 id="第一步：画正弦形状的水波纹"><a href="#第一步：画正弦形状的水波纹" class="headerlink" title="第一步：画正弦形状的水波纹"></a>第一步：画正弦形状的水波纹</h2><p>&emsp;&emsp;有一定自定义View基础的童鞋都知道，一阶贝赛尔画直线，这里的正弦图形是用二阶贝赛尔曲线。至于三阶，四阶，五阶用的都比较少。</p><p>&emsp;&emsp;我们这里知道了，这是用的二阶贝赛尔曲线，辣么，方法呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)</span><br><span class="line">mPath.rQuadTo(dx1, dy1, dx2, dy2);</span><br><span class="line">//mPath.quadTo(dx1, dy1, dx2, dy2);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Path调用该方法，这里就是传的两个点，也就是四个值，参数的含义：第一个点是控制点，第二个点是终点。前面还有一个起点，通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPath.moveTo(x,y);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法是确定起点。不懂的童鞋，看一下文章开头推荐的文章。我们效果的是一排波浪线，我们上面这个方法只是一个。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//构造方法里面初始化</span><br><span class="line">private void initView() &#123;</span><br><span class="line">    path = new Path();</span><br><span class="line">    paint = new Paint();</span><br><span class="line">    paint1 = new Paint();</span><br><span class="line">    paint.setColor(Color.GREEN);</span><br><span class="line">    paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    paint.setStrokeWidth(10);</span><br><span class="line">    paint1.set(paint);</span><br><span class="line">    paint1.setColor(Color.RED);</span><br><span class="line">  &#125;</span><br><span class="line">//onDraw里面去画出来</span><br><span class="line">    @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.moveTo(0,300);</span><br><span class="line">    path.quadTo(150, 150, 300, 300);</span><br><span class="line">    path.quadTo(450, 450, 600, 300);</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line"></span><br><span class="line">    canvas.drawCircle(0,300,5,paint1);</span><br><span class="line">    canvas.drawCircle(150,150,5,paint1);</span><br><span class="line">    canvas.drawCircle(300,300,5,paint1);</span><br><span class="line">    canvas.drawCircle(450,450,5,paint1);</span><br><span class="line">    canvas.drawCircle(600,300,5,paint1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面就是简单的初始化paint，和path，然后画出path，另外，我还画出了5个点，帮助理解。跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-9343cb6e4066e3ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个水波纹效果图.png"></p><p>&emsp;&emsp;转换成对应的坐标系，手画的，有点丑，知道是这个意思就行了。如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8215466464df72f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个水波纹放入坐标系中.png"></p><p><strong>画一个正弦图的思路：</strong></p><ol><li><p>首先，把path移动到起点，对应的也就是moveTo(0,300)</p></li><li><p>然后，确定终点，也就是我们前面说的quadTo()方法的第二个点(300,300)</p></li><li><p>最后，我们确定控制点，也就是我们前面说的quadTo()方法的第一个点。 <strong><em>辣么，这个控制点是怎么确定的呢？问题就在这里。敲黑板</em></strong> 因为我们画的是一个规则的正弦图，所以，控制点的x坐标肯定是终点x坐标300的一半，也就是150。再就是他的y坐标，其实y坐标是随便定义的。y坐标只是约束这个正弦图形的坡度，对坡度。你把y坐标定义的离终点的y坐标远一点，他的坡度就大一点。离他近一点，坡度就小一点。你如果定义控制点是（150,100），他相对于控制点是(150,150)的坡度就会大一点。因为100距300相差200，150距300相差150。200大于150。对，就是这样。辣么，怎么控制是上半部分的正弦图还是下半部分的正弦图呢？ <strong><em>|y控|&gt;|y终|，上半部分；相反，则是下半部分。</em></strong></p></li></ol><p>&emsp;&emsp;对了，这里我需要说明的是，上面我们调用了两次quadTo()方法，第二次调用的起点，就是第一次的终点。</p><p>&emsp;&emsp;上面效果是调用quadTo()方法，我们再来说一说rQuadTo()方法。上面的注释里面，我们也标明了两者的区别。 <strong><em>辣么，什么叫相对于原点的坐标系？什么叫相对于当前点的坐标系呢？</em></strong> 我们知道android的坐标系原点是左上角，你可以这样理解，第一种，不带r的方法quadTo()，他的坐标原点(0,0)点始终在左上角，第二种带r的方法rQuadTo()，我们第一次移动到起点(0,300)的时候，这个时候的原点就是(0,300)，所以说此时的终点应该是(300,0),然后确定我们的控制点(150,-150)。辣么，我们调用第二次的时候，此时的终点就是(300,0)，这个时候的终点就是(300,0)，在确定此时的控制点(150,150)。两次的终点都是(300,0)，但是，意义是不一样的。有点绕，但是你理解了相对于原点坐标系，和相对于当前点的坐标系，就很简单了。理解一下，思考5分钟。辣么，上面用带r的怎么写呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">path.moveTo(0,300);</span><br><span class="line">//    path.quadTo(150, 150, 300, 300);</span><br><span class="line">//    path.quadTo(450, 450, 600, 300);</span><br><span class="line">    path.rQuadTo(150,-150,300,0);</span><br><span class="line">    path.rQuadTo(150,150,300,0);</span><br><span class="line">    canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，怎么换一个正弦图，以及，两个方法的区别，已经讲完了，我觉得已经讲的非常清楚了。感觉，没有谁比我讲的还要清楚了。手把手教学。我们这个效果，画一个，肯定不行。要画满一个屏幕。怎么画呢？</p><p>&emsp;&emsp;找规律，一个正弦图，我们上面都是围绕这三个点，起点，控制点，终点。要想规则，控制点的x坐标是终点x坐标的一半。再就是，要画满一个屏幕，要在屏幕内部，所以，终点x坐标要小于屏幕宽度。综上所述。</p><ol><li><p>三个点：起点，终点，控制点</p></li><li><p>控制点的x坐标是终点x坐标的一半</p></li><li><p>终点x坐标要小于屏幕宽度</p></li></ol><p>我们就开始写代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  private int startY = 300;//定义起始点的y坐标</span><br><span class="line"></span><br><span class="line">  private int endX = 300;//定义终点的x坐标</span><br><span class="line"></span><br><span class="line">  private int controlY = 150;//定义控制点的y坐标</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.moveTo(0, 300);</span><br><span class="line">    path.moveTo(0, startY);</span><br><span class="line">//    path.quadTo(150, 150, 300, 300);</span><br><span class="line">//    path.quadTo(450, 450, 600, 300);</span><br><span class="line">//这里的for循环为什么每次要加2倍的终点x坐标呢？</span><br><span class="line">    //你想一想，我们一次for循环，画的图的终点x坐标在哪？</span><br><span class="line">    for (int i = 0; i &lt; getWidth(); i += 2*endX) &#123;</span><br><span class="line">//      path.rQuadTo(150, -150, 300, 0);</span><br><span class="line">//      path.rQuadTo(150, 150, 300, 0);</span><br><span class="line">      path.rQuadTo(endX/2, -controlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX/2, controlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d302f33c39805efe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整个屏幕的水波纹效果图.png"></p><p>&emsp;&emsp;好，到这里，第一步完成了，满屏的水波纹出来了。</p><h2 id="第二步，正弦图左右在移动"><a href="#第二步，正弦图左右在移动" class="headerlink" title="第二步，正弦图左右在移动"></a>第二步，正弦图左右在移动</h2><p>&emsp;&emsp;想一想，这个动画，想一想，想一想，像不像水平位移动画？像不像？越想越像。辣么，我们就去验证一下。写一个动画，这种，明显就是属性动画。既然是左右移动，辣么就肯定是改变x轴的坐标值，改变谁的呢？肯定是起点的啊，只有改变起点的x左边的值，水波纹才会有动的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void startAnimation()&#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofFloat(0, 1);</span><br><span class="line">    animator.setDuration(1000);</span><br><span class="line">    animator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">        Float animatedValue = (Float) animation.getAnimatedValue();</span><br><span class="line">        currentStartX = (int) (endX * animatedValue);</span><br><span class="line">        postInvalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();//不加会有重影，不是我们想要的</span><br><span class="line">//    path.moveTo(0, 300);</span><br><span class="line">//    path.moveTo(0, startY);</span><br><span class="line">    path.moveTo(currentStartX, startY);</span><br><span class="line">      ...//其他的不变</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d38f9817410a015c.gif?imageMogr2/auto-orient/strip" alt="移动有空白.gif"></p><p>&emsp;&emsp;尼玛，什么鬼？动是动起来了，为啥左边还有一段空白？不要急，想一想为什么？我们之前是从Y轴开始画的，我们这个动画是从左向又移动一个endx的值，所以，我们设置起点的时候，也向左偏移一个endx的值不就好了么？我们再试一试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();</span><br><span class="line">//    path.moveTo(0, 300);</span><br><span class="line">//    path.moveTo(0, startY);</span><br><span class="line">    path.moveTo(-endX + currentStartX, startY);</span><br><span class="line">//    path.quadTo(150, 150, 300, 300);</span><br><span class="line">//    path.quadTo(450, 450, 600, 300);</span><br><span class="line">    //这里的for循环为什么每次要加2倍的终点x坐标呢？</span><br><span class="line">    //你想一想，我们一次for循环，画的图的终点x坐标在哪？</span><br><span class="line">    for (int i = -endX; i &lt; getWidth() + endX; i += 2 * endX) &#123;</span><br><span class="line">//      path.rQuadTo(150, -150, 300, 0);</span><br><span class="line">//      path.rQuadTo(150, 150, 300, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, -controlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, controlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-f84524374a6c4273.gif?imageMogr2/auto-orient/strip" alt="移动会闪一下.gif"></p><p>&emsp;&emsp;咦，满脸的嫌弃，这是什么东西啊，空白虽然没了，为什么会卡一下，并且这个也不是我们想要的效果。我们再想一想，我们这个无线循环的动画的原理是什么？ <strong><em>敲黑板，其实，我们就是多画了一个正弦波形，我们移动之后，跟移动之前一样，也就是位移了两个正弦图，结束后的图形，跟结束前的图形重合，然后一直重复动画，从而让用户感觉是无线循环的动画。</em></strong> 辣么，哪里出问题呢？想一想，为什么达不到我们的效果，肯定是我们水平移动距离的有问题啊。找啊找啊找，找到了，我们这里的endx坐标，是一个完整正弦图形的一半。所以，我们动画移动的距离要乘以2。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">currentStartX = (int) (2 * endX * animatedValue);//动画里面的</span><br><span class="line">//动画还要加上插值器，从而达到平滑的效果</span><br><span class="line">animator.setInterpolator(new LinearInterpolator());</span><br><span class="line"></span><br><span class="line">辣么，这里距离变了，我们起始点的距离，循环的距离也要变。要不然会有空白</span><br><span class="line">path.moveTo(-endX*2 + currentStartX, startY);</span><br><span class="line"></span><br><span class="line">for (int i = -endX*2; i &lt; getWidth() + endX*2; i += 2 * endX) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;综上所述，去除无关代码之后的完整代码，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/27</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class WaveView1 extends View &#123;</span><br><span class="line">  private Path path;</span><br><span class="line">  private Paint paint;</span><br><span class="line">  private Paint paint1;</span><br><span class="line"></span><br><span class="line">  private int startY = 300;</span><br><span class="line"></span><br><span class="line">  private int endX = 300;</span><br><span class="line"></span><br><span class="line">  private int controlY = 150;</span><br><span class="line"></span><br><span class="line">  private int currentStartX;</span><br><span class="line"></span><br><span class="line">  public WaveView1(Context context) &#123;</span><br><span class="line">    this(context, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public WaveView1(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public WaveView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">    super(context, attrs, defStyleAttr);</span><br><span class="line">    initView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void initView() &#123;</span><br><span class="line">    path = new Path();</span><br><span class="line">    paint = new Paint();</span><br><span class="line">    paint1 = new Paint();</span><br><span class="line">    paint.setColor(Color.GREEN);</span><br><span class="line">    paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    paint.setStrokeWidth(10);</span><br><span class="line">    paint1.set(paint);</span><br><span class="line">    paint1.setColor(Color.RED);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();</span><br><span class="line">    path.moveTo(-endX*2 + currentStartX, startY);</span><br><span class="line">    for (int i = -endX*2; i &lt; getWidth() + endX*2; i += 2 * endX) &#123;</span><br><span class="line">      path.rQuadTo(endX / 2, -controlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, controlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void startAnimation() &#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofFloat(0, 1);</span><br><span class="line">    animator.setDuration(1000);</span><br><span class="line">    animator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">    animator.setInterpolator(new LinearInterpolator());</span><br><span class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">        Float animatedValue = (Float) animation.getAnimatedValue();</span><br><span class="line">        currentStartX = (int) (2 * endX * animatedValue);</span><br><span class="line">        postInvalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-aefa92a1ca8a1026.gif?imageMogr2/auto-orient/strip" alt="移动水波纹.gif"></p><p>完美达到了我们的预期效果。</p><h2 id="第三步：自定义View上下移动"><a href="#第三步：自定义View上下移动" class="headerlink" title="第三步：自定义View上下移动"></a>第三步：自定义View上下移动</h2><p>&emsp;&emsp;经过上面的左右动画，现在这个上下移动的动画就很简单了，很明显是改变起始点y坐标的值，当然，肯定是属性动画。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void startAnimation() &#123;</span><br><span class="line">    </span><br><span class="line">    ...//这是我们的左移动画，没写上来</span><br><span class="line">    </span><br><span class="line">    //这就是我们的竖着移动的动画</span><br><span class="line">    ValueAnimator animator1 = ValueAnimator.ofFloat(0, 1);</span><br><span class="line">    animator1.setDuration(5000);</span><br><span class="line">    animator1.setInterpolator(new LinearInterpolator());</span><br><span class="line">    animator1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">        Float animatedValue = (Float) animation.getAnimatedValue();</span><br><span class="line">        currentStartY = (int) (getHeight() * animatedValue);</span><br><span class="line">        postInvalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator1.start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //改变我们的初始点的y坐标。不要只写个currentStartY，</span><br><span class="line">  //光写这个是从下往上移动，你要的是从上往下移动</span><br><span class="line">  path.moveTo(-endX*2 + currentStartX, getHeight()-currentStartY);</span><br><span class="line">  </span><br><span class="line">  //再就是修改画笔为填充</span><br><span class="line">  paint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">  </span><br><span class="line">  //并且把path连接成一个闭合图形</span><br><span class="line">  ...//这里是onDraw里面的for循环画正弦图形</span><br><span class="line">  path.lineTo(getWidth(),getHeight());</span><br><span class="line">    path.lineTo(0,getHeight());</span><br><span class="line">    path.close();</span><br><span class="line">    canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure><p>跑出来的效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-54f3ea96e5dc33a5.gif?imageMogr2/auto-orient/strip" alt="上下移动有bug.gif"></p><p>&emsp;&emsp;到这个位置，基本上已经完成了百分之九十了。我们可以看到开始会有一个问题，结束的时候也有一个问题，这个问题是怎么产生的呢？</p><h2 id="第四步：优化开始和结束的动画"><a href="#第四步：优化开始和结束的动画" class="headerlink" title="第四步：优化开始和结束的动画"></a>第四步：优化开始和结束的动画</h2><p>&emsp;&emsp;其实，我们可以想一想，一开始，我们这个控制点的Y值，不应该一出来就是写死的，显得太突兀了，一开始，我们应该是慢慢涨，涨到我们规定的值，然后快结束的时候，我们应该是慢慢减，减到0为止。应该是这样才对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();</span><br><span class="line">    int currentControlY = 0;</span><br><span class="line">    if (currentStartY &lt; controlY) &#123;</span><br><span class="line">      currentControlY = currentStartY;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      currentControlY = controlY;</span><br><span class="line">    &#125;</span><br><span class="line">    if (getHeight() - currentStartY &lt; controlY) &#123;</span><br><span class="line">      currentControlY = getHeight() - currentStartY;</span><br><span class="line">    &#125;</span><br><span class="line">    path.moveTo(-endX * 2 + currentStartX, getHeight() - currentStartY);</span><br><span class="line">    for (int i = -endX * 2; i &lt; getWidth() + endX * 2; i += 2 * endX) &#123;</span><br><span class="line">      path.rQuadTo(endX / 2, -currentControlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, currentControlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    path.lineTo(getWidth(), getHeight());</span><br><span class="line">    path.lineTo(0, getHeight());</span><br><span class="line">    path.close();</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-bb761f08bb5704c5.gif?imageMogr2/auto-orient/strip" alt="最终效果图.gif"></p><p>经过上面的操作，就完美的达到了我们的预期效果。(PS：把画笔的宽度去掉)</p><p>把这个自定义View优化一下，把方法封装好了。<a href="https://download.csdn.net/download/qq_27634797/10312090" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本文针对有一定自定义View的童鞋，最好对贝赛尔曲线有辣么一丢丢了解，不了解也没关系。花5分钟看一下 &lt;strong&gt;&lt;em&gt;GcsSloop&lt;/em&gt;&lt;/strong&gt;的 &lt;a href=&quot;http://www.gcssloop.com/customview/Path_Bezier&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安卓自定义View进阶-Path之贝塞尔曲线&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文的最终效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7041675-bb761f08bb5704c5.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;最终效果图.gif&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -自定义view" scheme="http://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>Android自定义刷新布局——Ultra-Pull-To-Refresh-With-Load-More（二））</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%B7%E6%96%B0%E5%B8%83%E5%B1%80%E2%80%94%E2%80%94Ultra-Pull-To-Refresh-With-Load-More%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/05/13/Android自定义刷新布局——Ultra-Pull-To-Refresh-With-Load-More（二））/</id>
    <published>2018-05-13T14:26:56.000Z</published>
    <updated>2018-05-13T14:37:02.365Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人博客：haichenyi.com。感谢关注</strong></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>上一篇，我们讲到了Ultra-Pull-To-Refresh的基本用法。分成四步：</p><ol><li><p>xml里面定义控件PtrFrameLayout</p></li><li><p>设置相关属性</p></li><li><p>添加Header，Footer，并监听</p></li><li><p>监听刷新过程</p><a id="more"></a></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&emsp;&emsp;<strong>目的：</strong> 做一个我们自己的自定义刷新的动画（我们先不管动画是什么，不同的需求，动画都不一样）</p><p>&emsp;&emsp;我们前面讲到的主要类无非就是两个： <strong><em>PtrFrameLayout</em></strong>，<strong><em>Header（Footer）</em></strong>，前者是刷新控件，监听刷新过程，后者是头布局（脚布局），以添加头布局为例：我们这里首先就会想到重写这个布局。辣么？怎么重写这个头布局呢？我们先来看看怎么添加这个头布局的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setHeaderView(View header) &#123;</span><br><span class="line">        if (mHeaderView != null &amp;&amp; header != null &amp;&amp; mHeaderView != header) &#123;</span><br><span class="line">            removeView(mHeaderView);</span><br><span class="line">        &#125;</span><br><span class="line">        ViewGroup.LayoutParams lp = header.getLayoutParams();</span><br><span class="line">        if (lp == null) &#123;</span><br><span class="line">            lp = new LayoutParams(-1, -2);</span><br><span class="line">            header.setLayoutParams(lp);</span><br><span class="line">        &#125;</span><br><span class="line">        mHeaderView = header;</span><br><span class="line">        addView(header);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它这里实际上就是添加了一个View，所以，我们随便写一个自定义View，继承View就可以传进来</p><p>&emsp;&emsp;我们，再来看看另一个方法，就是监听的方法，这里好像也是传的View对象，因为，我们前面写的时候就是传的header：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void addPtrUIHandler(PtrUIHandler ptrUIHandler) &#123;</span><br><span class="line">        PtrUIHandlerHolder.addHandler(mPtrUIHandlerHolder, ptrUIHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;咦，不对啊，这里不是应该传的View对象么？怎么是PtrUIHandler类型的。其实，你看名字就应该看的出来，他这里传的是一个PtrUIHandler对象，点进去看，他就是一个接口。里面是下拉刷新的回调。讲到这里，我们就应该明了了，就是一个自定义View，继承View，实现PtrUIHandler接口。辣么，就开始撸了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MyCustomHeader extends FrameLayout implements PtrUIHandler &#123;</span><br><span class="line">  public MyCustomHeader(@NonNull Context context) &#123;</span><br><span class="line">    this(context, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomHeader(@NonNull Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomHeader(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">    super(context, attrs, defStyleAttr);</span><br><span class="line">    initView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void initView() &#123;</span><br><span class="line">    LayoutInflater.from(getContext()).inflate(R.layout.header_layout, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIReset(PtrFrameLayout frame) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshPrepare(PtrFrameLayout frame) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshBegin(PtrFrameLayout frame) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshComplete(PtrFrameLayout frame, boolean isHeader) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIPositionChange(PtrFrameLayout frame, boolean isUnderTouch, byte status,</span><br><span class="line">                                 PtrIndicator ptrIndicator) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，我这里面什么都没有，就是继承了FrameLayout布局，实现了PtrUIHandler接口，然后在构造方法里面加载了一个布局，添加进来，布局也很简单，里面就只有一个ImageView。布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;200dp&quot;</span><br><span class="line">        android:src=&quot;@drawable/psb17&quot;/&gt;</span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再就是调用了，跟上一篇的调用方式一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final PtrFrameLayout ptrFrameLayout = findViewById(R.id.ptr_frame_layout);</span><br><span class="line">    MyCustomHeader myCustomHeader = new MyCustomHeader(this);</span><br><span class="line">    ptrFrameLayout.setHeaderView(myCustomHeader);</span><br><span class="line">    ptrFrameLayout.addPtrUIHandler(myCustomHeader);</span><br><span class="line">    ptrFrameLayout.setPtrHandler(new PtrDefaultHandler2() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onRefreshBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">        frame.postDelayed(ptrFrameLayout::refreshComplete, 2000);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onLoadMoreBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">        frame.postDelayed(ptrFrameLayout::refreshComplete, 2000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后运行，你就会看到，刷新的header就是你的自定义view。到此，自定义刷新布局就完成了，脚布局方式类似。</p><p>&emsp;&emsp;什么鬼？这就没了？刷新布局就一个ImageView就没了？这么敷衍。好歹你也加个动画啊。可以可以，那就加个动画。</p><p>&emsp;&emsp;如你所愿，我加了一个帧动画。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/refresh1&quot; android:duration=&quot;100&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/refresh2&quot; android:duration=&quot;100&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/refresh3&quot; android:duration=&quot;100&quot;/&gt;</span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure><p>header里面的改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void initView() &#123;</span><br><span class="line">    LayoutInflater.from(getContext()).inflate(R.layout.header_layout, this);</span><br><span class="line">    imageView = findViewById(R.id.img);</span><br><span class="line">    animationDrawable = (AnimationDrawable) imageView.getDrawable();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   @Override</span><br><span class="line">  public void onUIRefreshBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">    imageView.setImageDrawable(animationDrawable);</span><br><span class="line">    animationDrawable.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshComplete(PtrFrameLayout frame, boolean isHeader) &#123;</span><br><span class="line">    animationDrawable.stop();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在初始化的时候，把动画获取到，然后在刷新的时候开始动画，在刷新完成的时候停止动画。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;个人博客：haichenyi.com。感谢关注&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;上一篇，我们讲到了Ultra-Pull-To-Refresh的基本用法。分成四步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;xml里面定义控件PtrFrameLayout&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置相关属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加Header，Footer，并监听&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监听刷新过程&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android下拉刷新，上拉加载——Ultra-Pull-To-Refresh-With-Load-More（一）</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E2%80%94%E2%80%94Ultra-Pull-To-Refresh-With-Load-More%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/05/13/Android下拉刷新，上拉加载——Ultra-Pull-To-Refresh-With-Load-More（一）/</id>
    <published>2018-05-13T14:26:34.000Z</published>
    <updated>2018-05-13T14:37:49.782Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人博客：haichenyi.com。感谢关注</strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Android里面刷新和分页加载是常见的，刷新有Google的SwipeRefreshLayout，但是UI不同意，非要跟IOS一样，那就没办法了。</p> <a id="more"></a><p>开源框架链接：<a href="https://github.com/captainbupt/android-Ultra-Pull-To-Refresh-With-Load-More" target="_blank" rel="noopener">Ultra-Pull-To-Refresh-With-Load-More</a>。这个开源框架是基于<a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh" target="_blank" rel="noopener">Ultra-Pull-To-Refresh</a>拓展了一个上拉加载功能。</p><p>作者：<a href="https://github.com/liaohuqiu" target="_blank" rel="noopener">廖祜秋</a></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">implementation &apos;in.srain.cube:ptr-load-more:1.0.6&apos;</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>整个项目就只有一个核心类：PtrFrameLayout，继承ViewGroup。步骤：</p><ol><li><p>xml里面定义控件PtrFrameLayout</p></li><li><p>设置相关属性</p></li><li><p>添加Header，Footer，并监听</p></li><li><p>监听刷新过程</p></li></ol><h3 id="第一步：xml里面定义控件PtrFrameLayout"><a href="#第一步：xml里面定义控件PtrFrameLayout" class="headerlink" title="第一步：xml里面定义控件PtrFrameLayout"></a>第一步：xml里面定义控件PtrFrameLayout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;in.srain.cube.views.ptr.PtrFrameLayout</span><br><span class="line">    android:id=&quot;@+id/ptr_frame_layout&quot;</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    xmlns:cube_ptr=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line"></span><br><span class="line">    cube_ptr:ptr_resistance_header=&quot;1.7&quot;</span><br><span class="line">    cube_ptr:ptr_ratio_of_header_height_to_refresh=&quot;1.2&quot;</span><br><span class="line">    cube_ptr:ptr_duration_to_back_header=&quot;300&quot;</span><br><span class="line">    cube_ptr:ptr_duration_to_close_header=&quot;2000&quot;</span><br><span class="line">    cube_ptr:ptr_keep_header_when_refresh=&quot;true&quot;</span><br><span class="line">    cube_ptr:ptr_pull_to_fresh=&quot;false&quot;</span><br><span class="line"></span><br><span class="line">    cube_ptr:ptr_resistance_footer=&quot;1.3&quot;</span><br><span class="line">    cube_ptr:ptr_duration_to_back_footer=&quot;300&quot;</span><br><span class="line">    cube_ptr:ptr_duration_to_close_footer=&quot;2000&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:background=&quot;@color/colorAccent&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;</span><br><span class="line">            android:text=&quot;textView&quot;/&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/in.srain.cube.views.ptr.PtrFrameLayout&gt;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的布局，根布局是 <strong><em>PtrFrameLayout</em></strong> ，他的子View可以是任意view。</p><h3 id="第二步：设置相关属性"><a href="#第二步：设置相关属性" class="headerlink" title="第二步：设置相关属性"></a>第二步：设置相关属性</h3><p>我们也看到了，他的布局里面有一些自定义属性，可以在布局里面设置，也可以在java代码里面设置，相关属性含义如下：</p><ol><li><p>Resistence：阻尼系数，可以分别设置header和footer。默认: 1.7f，越大，感觉下拉刷新时越吃力。上拉加载也是一样的</p></li><li><p>Ratio of the Height of the Header to Refresh：触发刷新时移动的位置比例。<br>默认，1.2f，移动达到头部高度1.2倍时可触发刷新操作。下拉刷新，上拉加载都一样。</p></li><li><p>Duration to Close back：回弹延时。默认 200ms，回弹到刷新或者高度所用时间，可以跟上面一样分开设置，也可以设置一个</p></li><li><p>Duration to Close Header：刷新完成之后隐藏头部的时间。默认1000ms<strong><em>cube_ptr:ptr_duration_to_close_either=”2000”</em></strong></p></li><li><p>Keep Header while Refreshing：刷新是保持头部，也就是显示头部。默认值 true。false：隐藏头部</p></li><li><p>Pull to Refresh / Release to Refresh：下拉刷新 / 释放刷新。<br>默认为释放的时候刷新</p></li></ol><p>在java代码中设置方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final PtrFrameLayout ptrFrameLayout = findViewById(R.id.ptr_frame_layout);</span><br><span class="line">//配置头部参数,可以在xml中设置</span><br><span class="line">// the following are default settings</span><br><span class="line">    ptrFrameLayout.setResistance(1.7f);</span><br><span class="line">    ptrFrameLayout.setRatioOfHeaderHeightToRefresh(1.2f);</span><br><span class="line">    ptrFrameLayout.setDurationToClose(200);</span><br><span class="line">    ptrFrameLayout.setDurationToCloseHeader(1000);</span><br><span class="line">// default is false</span><br><span class="line">    ptrFrameLayout.setPullToRefresh(false);</span><br><span class="line">// default is true</span><br><span class="line">    ptrFrameLayout.setKeepHeaderWhenRefresh(true);</span><br></pre></td></tr></table></figure><h2 id="第三步：添加Header，Footer，并监听"><a href="#第三步：添加Header，Footer，并监听" class="headerlink" title="第三步：添加Header，Footer，并监听"></a>第三步：添加Header，Footer，并监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//第一种头部,StoreHouse风格的头部实现</span><br><span class="line">    /*StoreHouseHeader storeHouseHeader = new StoreHouseHeader(this);</span><br><span class="line">    storeHouseHeader.setPadding(0,100,0,0);</span><br><span class="line">    storeHouseHeader.setBackgroundColor(Color.BLACK);</span><br><span class="line">    storeHouseHeader.setTextColor(Color.WHITE);</span><br><span class="line">    storeHouseHeader.initWithString(&quot;haichenyi&quot;);//只可英文，中文不可运行(添加时间)</span><br><span class="line">    ptrFrameLayout.setHeaderView(storeHouseHeader);</span><br><span class="line">    ptrFrameLayout.addPtrUIHandler(storeHouseHeader);*/</span><br><span class="line"></span><br><span class="line">    //第二种头部,Material Design风格的头部实现,类似SwipeRefreshLayout</span><br><span class="line">    /*MaterialHeader materialHeader = new MaterialHeader(this);</span><br><span class="line">    materialHeader.setColorSchemeColors(new int[]&#123;Color.RED, Color.GREEN, Color.BLUE&#125;);</span><br><span class="line">    ptrFrameLayout.setHeaderView(materialHeader);</span><br><span class="line">    ptrFrameLayout.addPtrUIHandler(materialHeader);*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //第三种头部,经典 风格的头部实现，下拉箭头+时间</span><br><span class="line">    PtrClassicDefaultHeader ptrClassicDefaultHeader = new PtrClassicDefaultHeader(this);</span><br><span class="line">    ptrFrameLayout.setHeaderView(ptrClassicDefaultHeader);</span><br><span class="line"></span><br><span class="line">    PtrClassicDefaultFooter ptrClassicDefaultFooter = new PtrClassicDefaultFooter(this);</span><br><span class="line">    ptrFrameLayout.setFooterView(ptrClassicDefaultFooter);</span><br><span class="line"></span><br><span class="line">    ptrFrameLayout.addPtrUIHandler(ptrClassicDefaultHeader);</span><br><span class="line">    ptrFrameLayout.addPtrUIHandler(ptrClassicDefaultFooter);</span><br></pre></td></tr></table></figure><p>如上面代码所示，Header，Footer的种类是一样的，Header有三种，Footer也有三种，定义好之后，通过 <strong>setHeaderView()</strong>, <strong>setFooterView()</strong> 添加到 <strong>ptrFrameLayout</strong> 中，然后通过调用 <strong>addPtrUIHandler</strong> 监听两者的状态即可。不监听会显示空白，看不到具体内容</p><h2 id="第四步：监听刷新过程"><a href="#第四步：监听刷新过程" class="headerlink" title="第四步：监听刷新过程"></a>第四步：监听刷新过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ptrFrameLayout.setPtrHandler(new PtrDefaultHandler2() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onLoadMoreBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">        frame.postDelayed(ptrFrameLayout::refreshComplete, 2000);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onRefreshBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">        frame.postDelayed(ptrFrameLayout::refreshComplete, 2000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ptrFrameLayout.setMode(PtrFrameLayout.Mode.LOAD_MORE);</span><br></pre></td></tr></table></figure><p>通过设置 <strong>setPtrHandler()</strong> 方法监听刷新过程。默认的是 <strong>PtrDefaultHandler2()</strong>,它是后来加的，包括刷新和加载。<strong>PtrDefaultHandler()</strong> 只包含刷新功能。通过setMode()方法设置：只要下拉刷新，或者只要上拉加载，或者两者都要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;个人博客：haichenyi.com。感谢关注&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Android里面刷新和分页加载是常见的，刷新有Google的SwipeRefreshLayout，但是UI不同意，非要跟IOS一样，那就没办法了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>**个人博客：haichenyi.com。感谢关注**</title>
    <link href="http://haichenyi.com/2018/05/13/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9Ahaichenyi-com%E3%80%82%E6%84%9F%E8%B0%A2%E5%85%B3%E6%B3%A8/"/>
    <id>http://haichenyi.com/2018/05/13/个人博客：haichenyi-com。感谢关注/</id>
    <published>2018-05-13T14:26:00.000Z</published>
    <updated>2018-05-13T14:26:00.843Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 加密算法（二）</title>
    <link href="http://haichenyi.com/2018/05/13/Java-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/05/13/Java-加密算法（二）/</id>
    <published>2018-05-13T14:22:11.000Z</published>
    <updated>2018-05-13T14:24:05.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="补充知识点："><a href="#补充知识点：" class="headerlink" title="补充知识点："></a>补充知识点：</h2><p><strong><em>密钥：</em></strong> 加密方用公钥，解密方用私钥</p><p><strong>重要的事情强调六遍：</strong></p><p><strong><em>不用自己写加密算法</em></strong></p><p><strong><em>不用自己写加密算法</em></strong></p><p><strong><em>不用自己写加密算法</em></strong></p><p><strong><em>不用自己写加密算法</em></strong></p><p><strong><em>不用自己写加密算法</em></strong></p><p><strong><em>不用自己写加密算法</em></strong></p><a id="more"></a><h3 id="Cipher类"><a href="#Cipher类" class="headerlink" title="Cipher类"></a>Cipher类</h3><p>&emsp;&emsp;Android有专门用来加密的工具类Cipher类，他里面封装了几种常用的加密算法，本篇介绍两种AES，RSA。</p><p><strong><em>用法</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">分三步：以AES举例说明</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 加密方式：AES</span><br><span class="line">   * 工作模式：ECB,CBC,CTR,OFB,CFB</span><br><span class="line">   * 填充模式：PKCS5Padding，PKCS7Padding，ZEROPadding等等</span><br><span class="line">   */</span><br><span class="line">String CBC_PKCS5_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;//AES是加密方式 CBC是工作模式 PKCS5Padding是填充模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第一步：获取对象</span><br><span class="line">Cipher cipher = Cipher.getInstance(String transformation);//传 CBC_PKCS5_PADDING</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二步：设置初始化参数</span><br><span class="line">    /**</span><br><span class="line">     * 第一个参数：传类型，是加密Cipher.ENCRYPT_MODE，还是解密Cipher.DECRYPT_MODE</span><br><span class="line">     * 第二个参数：传密钥key，我们这里传的是SecretKeySpec，它实现SecretKey，SecretKey实现Key接口。</span><br><span class="line">     *             SecretKeySpec keySpec = new SecretKeySpec(raw, AES);//第一个参数传密钥byte数组，第二个参数传加密类型也就是&quot;AES&quot;字符串即可</span><br><span class="line">     * 第三个参数：传偏移量AlgorithmParameterSpec，我们这里传的IvParameterSpec，他实现AlgorithmParameterSpec接口，iv偏移量传默认的16个0的字节数组</span><br><span class="line">     *              new IvParameterSpec(new byte[cipher.getBlockSize()])，这里是传的默认的16个0的byte数组，也是常用的方式</span><br><span class="line">     */</span><br><span class="line">cipher.init(int opmode, Key key, AlgorithmParameterSpec params)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三步：加密。传需要加密的字符串的byte数组</span><br><span class="line">cipher.doFinal(byte[] input)</span><br><span class="line"></span><br><span class="line">经过以上三步：AES加密就算完成了，加密之后就需要解密，辣么，怎么解密呢？</span><br><span class="line"></span><br><span class="line">    草鸡简单，第二步初始化的时候，第一个参数传解密即可，其他都是一样的。</span><br></pre></td></tr></table></figure><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>出自百度百科</p><p>&emsp;&emsp;需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。</p><p>&emsp;&emsp;所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。</p><p>&emsp;&emsp;因此，加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。</p><p>&emsp;&emsp;说了这么多废话，要我说，就一句话公钥，私钥 <strong><em>相同</em></strong> 的加密方式称之为对称加密</p><h2 id="用法——AES"><a href="#用法——AES" class="headerlink" title="用法——AES"></a>用法——AES</h2><p>&emsp;&emsp;申明：我这里并不是说对称加密就只有AES这一种方式，相反，对称加密有很多种，我这里只讲我用到的对称加密中的一种方式——AES</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  private static final String CBC_PKCS5_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;//AES是加密方式 CBC是工作模式 PKCS5Padding是填充模式</span><br><span class="line">  private static final String AES = &quot;AES&quot;;//AES 加密</span><br><span class="line">  private static final String SHA1PRNG = &quot;SHA1PRNG&quot;;// SHA1PRNG 强随机种子算法, 要区别4.2以上版本的调用方法</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * 随机生成密钥，传同一个字符串，每次都生成的不一样</span><br><span class="line">   * @param seed 一般传用户的密码</span><br><span class="line">   * @return 返回密钥的byte数组</span><br><span class="line">   * @throws Exception 异常</span><br><span class="line">   */</span><br><span class="line">  private static byte[] getRawKey(String seed) throws Exception &#123;</span><br><span class="line">    SecureRandom sr = null;</span><br><span class="line">    // 在4.2以上版本中，SecureRandom获取方式发生了改变</span><br><span class="line">    if (android.os.Build.VERSION.SDK_INT &gt;= 17) &#123;</span><br><span class="line">      sr = SecureRandom.getInstance(SHA1PRNG, &quot;Crypto&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      sr = SecureRandom.getInstance(&quot;SHA1PRNG&quot;); // 获得一个随机数，传入的参数为默认方式。</span><br><span class="line">    &#125;</span><br><span class="line">    sr.setSeed(seed.getBytes());  // 设置一个种子，这个种子一般是用户设定的密码。也可以是其它某个固定的字符串</span><br><span class="line">    KeyGenerator keyGen = KeyGenerator.getInstance(&quot;AES&quot;);  // 获得一个key生成器（AES加密模式）</span><br><span class="line">    //AES中128位密钥版本有10个加密循环，192比特密钥版本有12个加密循环，256比特密钥版本则有14个加密循环。</span><br><span class="line">    keyGen.init(128, sr);      // 设置密匙长度128位</span><br><span class="line">    SecretKey key = keyGen.generateKey();  // 获得密匙</span><br><span class="line">    return key.getEncoded();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 加密过程</span><br><span class="line">   * @param raw 密钥的数组</span><br><span class="line">   * @param clear 需要加密的byte数组</span><br><span class="line">   * @return 加密后的byte数组</span><br><span class="line">   * @throws Exception 异常</span><br><span class="line">   */</span><br><span class="line">  private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception &#123;</span><br><span class="line">    SecretKeySpec keySpec = new SecretKeySpec(raw, AES);</span><br><span class="line">    Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING);</span><br><span class="line">    //iv偏移量传默认的16个0的字节数组</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(new byte[cipher.getBlockSize()]));</span><br><span class="line">    return cipher.doFinal(clear);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">   * 解密</span><br><span class="line">   */</span><br><span class="line">  private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception &#123;</span><br><span class="line">    SecretKeySpec keySpec = new SecretKeySpec(raw, AES);</span><br><span class="line">    Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING);</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(new byte[cipher.getBlockSize()]));</span><br><span class="line">    return cipher.doFinal(encrypted);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面给的三个方法，一个获取密钥，一个加密，一个解密，注释写的很清楚，我就不用再讲了，转16进制的方法，我前一篇讲加密的时候就给出来了，不知道的可以去前一篇看一下，我下面给出调用方式和结果截图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">       byte[] rawKey = getRawKey(key);</span><br><span class="line">       Log.v(&quot;wz&quot;, rawKey.length + &quot;&quot;);</span><br><span class="line">       String s = bytesToHexFun1(rawKey);</span><br><span class="line">       Log.v(&quot;wz&quot;,&quot;密钥16进制--&gt;&quot;+s);</span><br><span class="line">       byte[] encrypt = encrypt(rawKey, data.getBytes());</span><br><span class="line">       String after = Base64.encodeToString(encrypt, Base64.NO_WRAP);</span><br><span class="line">       Log.v(&quot;wz&quot;,&quot;加密后--&gt;&quot;+after);</span><br><span class="line">       byte[] decode = Base64.decode(after, Base64.NO_WRAP);</span><br><span class="line">       byte[] before = decrypt(rawKey, decode);</span><br><span class="line">       Log.v(&quot;wz&quot;,&quot;解密后--&gt;&quot;+new String(before));</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>出自百度百科</p><p>&emsp;&emsp;1976年，美国学者Dime和Henman为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。</p><p>&emsp;&emsp;与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p><p>&emsp;&emsp;说了这么多废话，要我说，就一句话公钥，私钥 <strong><em>不相同</em></strong> 的加密方式称之为对称加密</p><h2 id="用法——RSA"><a href="#用法——RSA" class="headerlink" title="用法——RSA"></a>用法——RSA</h2><p>&emsp;&emsp;申明：我这里并不是说非对称加密就只有RSA这一种方式，相反，对非称加密有很多种，我这里只讲我用到的非对称加密中的一种方式——RSA</p><p>&emsp;&emsp;辣么，成对公钥，私钥怎么来呢？难道我们自己去写吗？你要是会写，那你很棒棒哦，反正我不会(爱咋咋)，我是<a href="http://web.chacuo.net/netrsakeypair" target="_blank" rel="noopener">在线生成公钥，私钥对</a>。用法跟上面讲的AES是类似的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 我们之前拿到的是公钥，我们还要把公钥转成Key</span><br><span class="line">   * 因为cipher.init()初始化的时候，第二个参数需要传Key类型的，并不是String</span><br><span class="line">   * 获取Key，我这里返回的是PublicKey，它实现的Key接口</span><br><span class="line">   * @param pubKey 生成的公钥</span><br><span class="line">   * @return 最后需要的key</span><br><span class="line">   * @throws Exception 异常</span><br><span class="line">   */</span><br><span class="line">  public static PublicKey loadPublicKey(String pubKey) throws Exception &#123;</span><br><span class="line">    byte[] buffer = Base64.decode(pubKey, Base64.DEFAULT);</span><br><span class="line">    KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer);</span><br><span class="line">    return keyFactory.generatePublic(keySpec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 加密</span><br><span class="line">   * @param data 需要加密的数据</span><br><span class="line">   * @param publicKey key</span><br><span class="line">   * @return 返回加密后的byte，需要转成字符串</span><br><span class="line">   * @throws Exception 异常</span><br><span class="line">   */</span><br><span class="line">  private static byte[] encryptRSA(String data,PublicKey publicKey) throws Exception &#123;</span><br><span class="line">    Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE,publicKey);</span><br><span class="line">    return cipher.doFinal(data.getBytes());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 解密（我们需要注意的是，我们解密的是私钥加密的数据，不能解密公钥加密的数据）</span><br><span class="line">   * @param data 需要解密的数据</span><br><span class="line">   * @param publicKey key</span><br><span class="line">   * @return 返回解密后的数组</span><br><span class="line">   * @throws Exception 异常</span><br><span class="line">   */</span><br><span class="line">  private static byte[] decryptRSA(String data,PublicKey publicKey) throws Exception &#123;</span><br><span class="line">    Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE,publicKey);</span><br><span class="line">    return cipher.doFinal(data.getBytes());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里，注释说的很清楚，看懂了前面的AES，辣么，这个RSA应该不是问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;补充知识点：&quot;&gt;&lt;a href=&quot;#补充知识点：&quot; class=&quot;headerlink&quot; title=&quot;补充知识点：&quot;&gt;&lt;/a&gt;补充知识点：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;密钥：&lt;/em&gt;&lt;/strong&gt; 加密方用公钥，解密方用私钥&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要的事情强调六遍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -加密算法" scheme="http://haichenyi.com/categories/Android-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 加密算法（一）</title>
    <link href="http://haichenyi.com/2018/03/08/Java-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/03/08/Java-加密算法（一）/</id>
    <published>2018-03-08T12:06:32.000Z</published>
    <updated>2018-03-08T12:08:30.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="补充知识点："><a href="#补充知识点：" class="headerlink" title="补充知识点："></a>补充知识点：</h2><p><strong><em>字节</em></strong>：也就是 <strong>byte</strong> 是一种统计单位，表示数量的多少</p><p><strong><em>字符</em></strong>：是指计算机中使用的文字和符号，比如：1、2、3、A、S、D、$、%等等符号</p> <a id="more"></a><p><strong><em>字节与字符的对应关系</em></strong>：它们完全不是一个概念，所以，没有什么有没有区别这个说法。不同的编码，两者的对应关系是不相同的，我这里就说常用的两种编码：</p><ol><li>ASCII码中，一个英文字母（不区分大小写）占一个字节，一个中文汉字占两个字节</li><li>UTF-8中，一个英文字母占一个字节，一个中文汉字占三个字节</li></ol><p>&emsp;&emsp;我们加密最终常常操作的是bit，而我们加密首先得到的是byte数组的，byte的取值范围-128~127，中间包括0，刚好256个。也就是2^8=256。并且，<strong><em>1  byte = 8 bit</em></strong>（1kb = 1024 byte = 8^1024 bit等等）</p><p>&emsp;&emsp;我们获得了byte之后，要把byte数组转成String字符串，String其实就是char数组，我们java有一个<strong><em>new String(char[] chars)</em></strong>，应该都用过。我们转成字符串的前提是转成char数组，由于，<strong><em>1 char = 2 byte</em></strong>，所以，我们byte转成char长度扩大了1倍。</p><h2 id="四种分类"><a href="#四种分类" class="headerlink" title="四种分类"></a>四种分类</h2><ol><li>MD5加密</li><li>Base64加密</li><li>对称加密</li><li>非对称加密</li></ol><h2 id="MD5加密——不可逆"><a href="#MD5加密——不可逆" class="headerlink" title="MD5加密——不可逆"></a>MD5加密——不可逆</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>&emsp;&emsp;MD5加密是我们常见的加密算法，是不可逆的，也就是说加密完成之后，无法解密转成原来的内容。MD5加密算法其实是一种散列函数，使用的是hash算法。MD5的原文是无线多个，但是MD5的值是有限的。所以一个MD5的值可能对应多个原文。SHA算法跟MD5是差不多的，只是MD5是128位，SHA是160位，多32位</p><p>&emsp;&emsp;为什么MD5的值是有限多个呢？主流的MD5使用的是将任意长度的字节串映射为一个128bit的大整数。也就是一共有2^128种可能，所以说这个数字是有限的，而，我们的原文则是无限多个。发现两段原文对应同一个MD5的值概率非常小，也就忽略不记了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String name1 = &quot;haichenyi&quot;;</span><br><span class="line">   String name2 = &quot;海晨忆&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">      MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">      byte[] digest1 = md5.digest(name1.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">      Log.v(&quot;WZ&quot;,&quot;length1:&quot;+digest1.length);</span><br><span class="line"></span><br><span class="line">      byte[] digest2 = md5.digest(name2.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">      Log.v(&quot;WZ&quot;,&quot;length1:&quot;+digest2.length);</span><br><span class="line">    &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们通过MD5，得到的是一个byte数组（这个byte数组的长度跟我们的1byte=8bit没有直接关系），我们需要做的就是对这个byte数组进行操作，我们习惯上就是把这个btye转成16进制数存进数据库，当然，你也可以转成其他的类型存到数据库。这里给出几个byte数组转16进制字符串的方法，亲测可用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">private static final char[] HEX_CHAR = &#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;,</span><br><span class="line">      &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 方法一：</span><br><span class="line">   * byte[] to hex string</span><br><span class="line">   *</span><br><span class="line">   * @param bytes</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public String bytesToHexFun1(byte[] bytes) &#123;</span><br><span class="line">    // 一个byte为8位，可用两个十六进制位标识</span><br><span class="line">    char[] buf = new char[bytes.length * 2];</span><br><span class="line">    int a = 0;</span><br><span class="line">    int index = 0;</span><br><span class="line">    for (byte b : bytes) &#123; // 使用除与取余进行转换</span><br><span class="line">      if (b &lt; 0) &#123;</span><br><span class="line">        a = 256 + b;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        a = b;</span><br><span class="line">      &#125;</span><br><span class="line">      buf[index++] = HEX_CHAR[a / 16];</span><br><span class="line">      buf[index++] = HEX_CHAR[a % 16];</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 方法二：</span><br><span class="line">   * byte[] to hex string</span><br><span class="line">   *</span><br><span class="line">   * @param bytes</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public String bytesToHexFun2(byte[] bytes) &#123;</span><br><span class="line">    char[] buf = new char[bytes.length * 2];</span><br><span class="line">    int index = 0;</span><br><span class="line">    for(byte b : bytes) &#123; // 利用位运算进行转换，可以看作方法一的变种</span><br><span class="line">      buf[index++] = HEX_CHAR[b &gt;&gt;&gt; 4 &amp; 0xf];</span><br><span class="line">      buf[index++] = HEX_CHAR[b &amp; 0xf];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new String(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 方法三：</span><br><span class="line">   * byte[] to hex string</span><br><span class="line">   *</span><br><span class="line">   * @param bytes</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public String bytesToHexFun3(byte[] bytes) &#123;</span><br><span class="line">    StringBuilder buf = new StringBuilder(bytes.length * 2);</span><br><span class="line">    for(byte b : bytes) &#123; // 使用String的format方法进行转换</span><br><span class="line">      buf.append(String.format(&quot;%02x&quot;, new Integer(b &amp; 0xff)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return buf.toString();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 将16进制字符串转换为byte[]</span><br><span class="line">   *</span><br><span class="line">   * @param str</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public byte[] toBytes(String str) &#123;</span><br><span class="line">    if(str == null || str.trim().equals(&quot;&quot;)) &#123;</span><br><span class="line">      return new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    byte[] bytes = new byte[str.length() / 2];</span><br><span class="line">    for(int i = 0; i &lt; str.length() / 2; i++) &#123;</span><br><span class="line">      String subStr = str.substring(i * 2, i * 2 + 2);</span><br><span class="line">      bytes[i] = (byte) Integer.parseInt(subStr, 16);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bytes;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Base64加密——可逆"><a href="#Base64加密——可逆" class="headerlink" title="Base64加密——可逆"></a>Base64加密——可逆</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>要知道的是有一个64个数的表，也称Base64编码表。可以字节定义，不过都是用的一样的。</li><li>Base64是按照字符长度，以3个字符为一组</li><li>接着增对每组的每个字符，取<a href="http://ascii.911cha.com/" target="_blank" rel="noopener">ASCII编码</a></li><li>然后将获得的编码转换成8bit的二进制，就会得到3*8=24bit的字节</li><li>然后将这24bit的字节以6个bit为一组，分成4组</li><li>接着在每组前面填两个高位0，凑成每组8bit</li><li>最后将这每组8bit的二进制转成十进制，对应下面的Base64编码表</li></ol><p><strong><em>Base64 编码表</em></strong></p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">char</th><th style="text-align:center">value</th><th style="text-align:center">char</th><th style="text-align:center">value</th><th style="text-align:center">char</th><th style="text-align:center">value</th><th style="text-align:center">char</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">A</td><td style="text-align:center">16</td><td style="text-align:center">Q</td><td style="text-align:center">32</td><td style="text-align:center">g</td><td style="text-align:center">48</td><td style="text-align:center">w</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">B</td><td style="text-align:center">17</td><td style="text-align:center">R</td><td style="text-align:center">33</td><td style="text-align:center">h</td><td style="text-align:center">49</td><td style="text-align:center">x</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">C</td><td style="text-align:center">18</td><td style="text-align:center">S</td><td style="text-align:center">34</td><td style="text-align:center">i</td><td style="text-align:center">50</td><td style="text-align:center">y</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D</td><td style="text-align:center">19</td><td style="text-align:center">T</td><td style="text-align:center">35</td><td style="text-align:center">j</td><td style="text-align:center">51</td><td style="text-align:center">z</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">E</td><td style="text-align:center">20</td><td style="text-align:center">U</td><td style="text-align:center">36</td><td style="text-align:center">k</td><td style="text-align:center">52</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">F</td><td style="text-align:center">21</td><td style="text-align:center">V</td><td style="text-align:center">37</td><td style="text-align:center">l</td><td style="text-align:center">53</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">G</td><td style="text-align:center">22</td><td style="text-align:center">U</td><td style="text-align:center">38</td><td style="text-align:center">m</td><td style="text-align:center">54</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">H</td><td style="text-align:center">23</td><td style="text-align:center">X</td><td style="text-align:center">39</td><td style="text-align:center">n</td><td style="text-align:center">55</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">I</td><td style="text-align:center">24</td><td style="text-align:center">Y</td><td style="text-align:center">40</td><td style="text-align:center">o</td><td style="text-align:center">56</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">J</td><td style="text-align:center">25</td><td style="text-align:center">Z</td><td style="text-align:center">41</td><td style="text-align:center">p</td><td style="text-align:center">57</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">K</td><td style="text-align:center">26</td><td style="text-align:center">a</td><td style="text-align:center">42</td><td style="text-align:center">q</td><td style="text-align:center">58</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">L</td><td style="text-align:center">27</td><td style="text-align:center">b</td><td style="text-align:center">43</td><td style="text-align:center">r</td><td style="text-align:center">59</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">M</td><td style="text-align:center">28</td><td style="text-align:center">c</td><td style="text-align:center">44</td><td style="text-align:center">s</td><td style="text-align:center">60</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">N</td><td style="text-align:center">29</td><td style="text-align:center">d</td><td style="text-align:center">45</td><td style="text-align:center">t</td><td style="text-align:center">61</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">O</td><td style="text-align:center">30</td><td style="text-align:center">e</td><td style="text-align:center">46</td><td style="text-align:center">u</td><td style="text-align:center">62</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">P</td><td style="text-align:center">31</td><td style="text-align:center">f</td><td style="text-align:center">47</td><td style="text-align:center">v</td><td style="text-align:center">63</td><td style="text-align:center">/</td></tr></tbody></table><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;hai&quot;;</span><br><span class="line">    byte[] encode = Base64.encode(str.getBytes(), Base64.NO_WRAP);</span><br><span class="line">    try &#123;</span><br><span class="line">      String a = new String(encode,&quot;UTF-8&quot;);</span><br><span class="line">      String a1 = new String(encode,&quot;US-ASCII&quot;);</span><br><span class="line">      Log.v(&quot;wz&quot;,a);</span><br><span class="line">    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    String after = Base64.encodeToString(str.getBytes(), Base64.NO_WRAP);</span><br><span class="line">    Log.v(&quot;wz&quot;,&quot;after--&gt;&quot;+after);</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>&emsp;&emsp;这里，我要使用Base64加密”hai”这个字符串，根据上面的流程：</p><table><thead><tr><th style="text-align:center">待加密字符串</th><th style="text-align:center">h</th><th style="text-align:center">a</th><th style="text-align:center">i</th></tr></thead><tbody><tr><td style="text-align:center">ASCII编码</td><td style="text-align:center">104</td><td style="text-align:center">97</td><td style="text-align:center">105</td></tr><tr><td style="text-align:center">二进制</td><td style="text-align:center">01101000</td><td style="text-align:center">01100001</td><td style="text-align:center">01101001</td></tr></tbody></table><p>下面，上面的表不好表示，我再换一个表，下一步，该6位分一组了</p><p>现在的字符串：01101000 01100001 01101001</p><table><thead><tr><th style="text-align:center">六位分一组</th><th style="text-align:center">011010</th><th style="text-align:center">000110</th><th style="text-align:center">000101</th><th style="text-align:center">101001</th></tr></thead><tbody><tr><td style="text-align:center">每组前面补0</td><td style="text-align:center">00011010</td><td style="text-align:center">00000110</td><td style="text-align:center">00000101</td><td style="text-align:center">00101001</td></tr><tr><td style="text-align:center">转成10进制</td><td style="text-align:center">26</td><td style="text-align:center">6</td><td style="text-align:center">5</td><td style="text-align:center">41</td></tr><tr><td style="text-align:center">Base64编码</td><td style="text-align:center">a</td><td style="text-align:center">G</td><td style="text-align:center">F</td><td style="text-align:center">p</td></tr></tbody></table><p><strong>结果图：</strong></p><p><strong><em>PS：</em></strong></p><ol><li>Base64.encodeToString()方法直接转成加密后的字符串</li><li>Base64.encode()方法返回的byte数组是16进制的，不用手动在去转一遍16进制</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;补充知识点：&quot;&gt;&lt;a href=&quot;#补充知识点：&quot; class=&quot;headerlink&quot; title=&quot;补充知识点：&quot;&gt;&lt;/a&gt;补充知识点：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;字节&lt;/em&gt;&lt;/strong&gt;：也就是 &lt;strong&gt;byte&lt;/strong&gt; 是一种统计单位，表示数量的多少&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;字符&lt;/em&gt;&lt;/strong&gt;：是指计算机中使用的文字和符号，比如：1、2、3、A、S、D、$、%等等符号&lt;/p&gt;
    
    </summary>
    
      <category term="Android -加密算法" scheme="http://haichenyi.com/categories/Android-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>EventBus源码解析(二)——注册</title>
    <link href="http://haichenyi.com/2018/03/07/EventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C/"/>
    <id>http://haichenyi.com/2018/03/07/EventBus源码解析-二-——注册/</id>
    <published>2018-03-07T12:24:37.000Z</published>
    <updated>2018-03-07T12:29:18.134Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前我们讲过<a href="http://haichenyi.com/2018/03/06/EventBus源码解析-一-——获取EventBus对象/">获取EventBus对象的源码</a>，这一篇，我们来讲讲注册的源码。推荐<a href="https://www.jianshu.com/p/bda4ed3017ba" target="_blank" rel="noopener">EventBus 3.0进阶：源码及其设计模式 完全解析</a></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they</span><br><span class="line">     * are no longer interested in receiving events.</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;.</span><br><span class="line">     * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link</span><br><span class="line">     * ThreadMode&#125; and priority.</span><br><span class="line">     */</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; <strong>翻译：</strong> 注册给订阅方去接收事件，订阅者一旦对接收事件不感兴趣了，就要unregister，订阅者必须要有用Subscribe注解的方法，注解也可以设置线程和优先级</p><p>&emsp;&emsp; <strong>白话文：</strong> 订阅者要是想接收消息，必须要先注册。当页面退出，或者不想接收消息的时候必须要反注册，不然他会一直处于接收消息的状态，页面退出会内存泄漏。订阅者的接收方法必须要用Subscribe注解，这个注解的后面可以设置接收这个消息的线程和优先级。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode = ThreadMode.MAIN,priority = 100,sticky = true)</span><br><span class="line">  public void handleMsg(DataBean dataBean)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就像上面这样写，我一个一个来讲。我们先来说说这个<strong><em>ThreadMode</em></strong>类，点进去，我们可以看到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 每个订阅的方法都有一个线程，决定那个线程的方法被叫做EventBus</span><br><span class="line">   * EventBus的线程可以跟Post事件的那个线程不相同</span><br><span class="line">   */</span><br><span class="line">public enum ThreadMode &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   *订阅者将在跟Post事件的那个线程的同一个线程中被调用，这是默认值，</span><br><span class="line">   * 因为，他没有线程切换，所以开销最少，所以也是推荐模式。需要注意的是</span><br><span class="line">   * post事件的线程可能是UI线程，也可能是其他线程，所以，这里的操作要做判断，</span><br><span class="line">   * 如果是UI操作，你必须要在UI线程中完成，如果是耗时操作，你必须要新开线程</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    POSTING,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 在Android上面，订阅者将会在UI线程中调用，如果post事件的线程是UI线程，</span><br><span class="line">   * 辣么，这个订阅方法将直接被调用，如果不是UI线程，辣么，它将要排队交付，</span><br><span class="line">   * 所以，这里可能阻塞线程，订阅者使用这个模式必须要快速返回，避免阻塞UI线程，</span><br><span class="line">   * 就是不要在这里做耗时操作。谢谢。</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    MAIN,</span><br><span class="line">    </span><br><span class="line">  /**</span><br><span class="line">   *这一个，跟上面的刚好对应，就是不管怎么样，都要排队交付，</span><br><span class="line">   * 不论post事件是不是处于UI线程发送的</span><br><span class="line">   */</span><br><span class="line">    </span><br><span class="line">    MAIN_ORDERED,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 在android上面，订阅方法将在子线程中调用。如果post事件处于子线程，</span><br><span class="line">   * 辣么，订阅方法将直接被调用。如果post事件处于UI线程，辣么，eventBus</span><br><span class="line">   * 就会新开线程，按照顺序处理事件，当然，也要注意，避免阻塞子线程</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    BACKGROUND,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 订阅方法将会在独立的线程中调用，这个线程总是独立语post事件</span><br><span class="line">   * 所处的线程和主线程。如果post事件是耗时操作：例如网络请求，</span><br><span class="line">   * 订阅方法调用的时候，不会等待。我们不用考虑线程数量的问题，</span><br><span class="line">   * EventBus已经限制了并发线程，并使用线程池高效的重用线程</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    ASYNC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他就是一个枚举类，几个值的意义，我说的很清楚了。</p><p>&emsp;&emsp;我们再来讲讲另外两个： <strong><em>sticky</em></strong>，默认值是false，如果设置成true，辣么，这个事件将会是粘性事件。发送事件的方式从<strong>post</strong>变成了<strong>postSticky</strong>，其他都没变。</p><p>&emsp;&emsp;再来讲讲 <strong><em>priority</em></strong> ，默认值是0，在同一个线程中值越大，优先级越高。优先级高的比优先级低的先收到消息。</p><p>好，终于准备工作做完了，我们来看看 <strong><em>register()</em></strong> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注册方法。首先，他通过反射的方式获得当前类名，然后通过当前类名，找到订阅方法，存到list里面。我们来看看 <strong><em>findSubscriberMethods()</em></strong>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">//首先从缓存中读取当前类的订阅方法，如果不等于null，就直接返回从缓存中读取到的list</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">        if (subscriberMethods != null) &#123;</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">//ignoreGeneratedIndex的值，从Builder可知，一般为false。</span><br><span class="line">        if (ignoreGeneratedIndex) &#123;</span><br><span class="line">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                    + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //将获取的subscriberMeyhods放入缓存中</span><br><span class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的注释写的很清楚，ignoreGeneratedIndex为false，辣么就会走<strong><em>findUsingInfo()</em></strong> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">//首先新建了一个FindState，FindState是一个静态内部类，保存订阅者的信息</span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line">        //初始化FindState</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line">        while (findState.clazz != null) &#123;</span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            //初始化的findState获得的订阅者信息，一般都是null</span><br><span class="line">            if (findState.subscriberInfo != null) &#123;</span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            //就会跳到这里</span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            //移动到父类继续查找</span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        return getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面，我们提到了<strong><em>FindState</em></strong>类，我们来看看这个类的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static class FindState &#123;</span><br><span class="line">//订阅方法的列表</span><br><span class="line">        final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;();</span><br><span class="line">//以class的名称为key，以方法为value</span><br><span class="line">        final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;();</span><br><span class="line">//以方法名称为key，订阅者类为value</span><br><span class="line">        final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;();</span><br><span class="line">        final StringBuilder methodKeyBuilder = new StringBuilder(128);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; subscriberClass;</span><br><span class="line">        Class&lt;?&gt; clazz;</span><br><span class="line">        boolean skipSuperClasses;</span><br><span class="line">        SubscriberInfo subscriberInfo;</span><br><span class="line">//初始化</span><br><span class="line">        void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">            this.subscriberClass = clazz = subscriberClass;</span><br><span class="line">            skipSuperClasses = false;</span><br><span class="line">            subscriberInfo = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不难看出，这里的几个map包括了，类名找方法，方法名找类，我们后面都用的到，然后就是初始化方法，前面我们注释里面写了，初始化之后一般信息都是null，这里我们也可以看到。所以，它会走 <strong><em>findUsingReflectionInSingleClass</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">        Method[] methods;</span><br><span class="line">        try &#123;</span><br><span class="line">            // This is faster than getMethods, especially when subscribers are fat classes like Activities</span><br><span class="line">            methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; catch (Throwable th) &#123;</span><br><span class="line">            // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses = true;</span><br><span class="line">        &#125;</span><br><span class="line">        /*------------------------------上面就是获取方法，重要的是在下面------------------------------------*/</span><br><span class="line">        //这里我强调的是我们前面的用法里面有说过注意点</span><br><span class="line">        //1.必须是public修饰</span><br><span class="line">        //2.必须是void类型</span><br><span class="line">        //3.必须是一个参数</span><br><span class="line">        //4.必须用Subscribe注解</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">        //获取方法的修饰符</span><br><span class="line">            int modifiers = method.getModifiers();</span><br><span class="line">            if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123;</span><br><span class="line">            //获取方法参数类型</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                //如果参数个数等于1</span><br><span class="line">                if (parameterTypes.length == 1) &#123;</span><br><span class="line">                //获取方法注解名称</span><br><span class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                    if (subscribeAnnotation != null) &#123;</span><br><span class="line">                    //参数类型 即为事件类型</span><br><span class="line">                        Class&lt;?&gt; eventType = parameterTypes[0];</span><br><span class="line">                        //调用checkAdd方法判断是否添加过</span><br><span class="line">                        if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        //从注解里面获取线程模式</span><br><span class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                            //新建一个SubscriberMethod对象，并添加到findState的subscriberMethods这个集合内</span><br><span class="line">                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                   //如果开启了严格验证，同时当前方法又有@Subscribe注解，对不符合要求的方法会抛出异常</span><br><span class="line">                &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                    String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                    throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</span><br><span class="line">                            &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                throw new EventBusException(methodName +</span><br><span class="line">                        &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法非常重要！！！在这个方法内部，利用反射的方式，对订阅者类进行扫描判断，是否满足条件从而找出订阅方法，并用上面的容器进行保存。辣么，上面提到的 <strong><em>checkAdd()</em></strong> 方法是怎么检查的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">            // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.</span><br><span class="line">            // Usually a subscriber doesn&apos;t have methods listening to the same event type.</span><br><span class="line">            Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">            if (existing == null) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (existing instanceof Method) &#123;</span><br><span class="line">                    if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</span><br><span class="line">                        // Paranoia check</span><br><span class="line">                        throw new IllegalStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Put any non-Method object to &quot;consume&quot; the existing Method</span><br><span class="line">                    anyMethodByEventType.put(eventType, this);</span><br><span class="line">                &#125;</span><br><span class="line">                return checkAddWithMethodSignature(method, eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个注释写的很清楚，两层检验，第一层是检测事件类型，第二次检验则是检验判断方法的完整，首先以eventType为键，方法为值，存到map中（这个map是在FindState类初始化的），put方法会有一个返回值，返回value，这个value是这个key对应的上一个值，所以说，如果是第一次存放，那么就会返回null。否则，之前存放过，辣么就会进入下一个判断 <strong><em>checkAddWithMethodSignature</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">            methodKeyBuilder.setLength(0);</span><br><span class="line">            methodKeyBuilder.append(method.getName());</span><br><span class="line">            methodKeyBuilder.append(&apos;&gt;&apos;).append(eventType.getName());</span><br><span class="line"></span><br><span class="line">            String methodKey = methodKeyBuilder.toString();</span><br><span class="line">            Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">            Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">            if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">                // Only add if not already found in a sub class</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Revert the put, old class is further down the class hierarchy</span><br><span class="line">                subscriberClassByMethodKey.put(methodKey, methodClassOld);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法就是用来判断方法签名是否相同的，方法签名是什么呢？就是修饰符+返回类型+方法名+参数list是否相同。如果方法签名相同，辣么，就把旧值赋值给methodClassOld，判断这个值不是为null，第一次调用，没有旧值，就肯定为null，所以，if前面的一个条件是满足的，后面一个条件<strong>methodClassOld.isAssignableFrom(methodClass)</strong> 的意思是判断旧值是否是methodClass或者同一个类，如果两个条件都不满足，辣么当前方法就不会添加为订阅方法。</p><p>&emsp;&emsp;那么，说了一大堆关于checkAdd和checkAddWithMethodSignature方法的源码，那么这两个方法到底有什么作用呢？从这两个方法的逻辑来看，第一层判断根据eventType来判断是否有多个方法订阅该事件，而第二层判断根据完整的方法签名(包括方法名字以及参数名字)来判断。下面是笔者的理解：</p><p>&emsp;&emsp;第一种情况：比如一个类有多个订阅方法，方法名不同，但它们的参数类型都是相同的(虽然一般不这样写，但不排除这样的可能)，那么遍历这些方法的时候，会多次调用到checkAdd方法，由于existing不为null，那么会进而调用checkAddWithMethodSignature方法，但是由于每个方法的名字都不同，因此methodClassOld会一直为null，因此都会返回true。也就是说，<strong>允许一个类有多个参数相同的订阅方法。</strong></p><p>&emsp;&emsp;第二种情况：类B继承自类A，而每个类都是有相同订阅方法，换句话说，类B的订阅方法继承并重写自类A，它们都有着一样的方法签名。方法的遍历会从子类开始，即B类，在checkAddWithMethodSignature方法中，methodClassOld为null，那么B类的订阅方法会被添加到列表中。接着，向上找到类A的订阅方法，由于methodClassOld不为null而且显然类B不是类A的父类，methodClassOld.isAssignableFrom(methodClass)也会返回false，那么会返回false。也就是说，<strong>子类继承并重写了父类的订阅方法，那么只会把子类的订阅方法添加到订阅者列表，父类的方法会忽略。</strong></p><p>&emsp;&emsp;让我们回到findUsingReflectionInSingleClass方法，当遍历完当前类的所有方法后，会回到findUsingInfo方法，接着会执行最后一行代码，即return getMethodsAndRelease(findState);那么我们继续 <strong><em>getMethodsAndRelease</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123;</span><br><span class="line">        //从findState获取subscriberMethods，放进新的ArrayList</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">        //把findState回收</span><br><span class="line">        findState.recycle();</span><br><span class="line">        synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">            for (int i = 0; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">                if (FIND_STATE_POOL[i] == null) &#123;</span><br><span class="line">                    FIND_STATE_POOL[i] = findState;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过该方法，把subscriberMethods不断逐层返回，直到返回EventBus#register()方法，最后开始遍历每一个订阅方法，并调用subscribe(subscriber, subscriberMethod)方法，那么，我们继续来看<strong><em>subscribe</em></strong>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// Must be called in synchronized block</span><br><span class="line">    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">        //将subscriber和subscriberMethod封装成 Subscription</span><br><span class="line">        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</span><br><span class="line">        //根据事件类型获取特定的 Subscription</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        //如果为null，说明该subscriber尚未注册该事件</span><br><span class="line">        if (subscriptions == null) &#123;</span><br><span class="line">            subscriptions = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //如果不为null，并且包含了这个subscription 那么说明该subscriber已经注册了该事件，抛出异常</span><br><span class="line">            if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //根据优先级来设置放进subscriptions的位置，优先级高的会先被通知</span><br><span class="line">        int size = subscriptions.size();</span><br><span class="line">        for (int i = 0; i &lt;= size; i++) &#123;</span><br><span class="line">            if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //根据subscriber(订阅者)来获取它的所有订阅事件</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">        if (subscribedEvents == null) &#123;</span><br><span class="line">            subscribedEvents = new ArrayList&lt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line">        </span><br><span class="line">//下面是对粘性事件的处理</span><br><span class="line">        if (subscriberMethod.sticky) &#123;</span><br><span class="line">        //从EventBusBuilder可知，eventInheritance默认为true</span><br><span class="line">            if (eventInheritance) &#123;</span><br><span class="line">                // Existing sticky events of all subclasses of eventType have to be considered.</span><br><span class="line">                // Note: Iterating over all events may be inefficient with lots of sticky events,</span><br><span class="line">                // thus data structure should be changed to allow a more efficient lookup</span><br><span class="line">                // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent = entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">             //根据eventType，从stickyEvents列表中获取特定的事件</span><br><span class="line">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                //分发事件</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到目前为止，注册流程基本分析完毕，丢一张流程图</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-2b90513e16f84c03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注册流程图.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前我们讲过&lt;a href=&quot;http://haichenyi.com/2018/03/06/EventBus源码解析-一-——获取EventBus对象/&quot;&gt;获取EventBus对象的源码&lt;/a&gt;，这一篇，我们来讲讲注册的源码。推荐&lt;a href=&quot;https://www.jianshu.com/p/bda4ed3017ba&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EventBus 3.0进阶：源码及其设计模式 完全解析&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="http://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 设计模式（Design Patterns）（三）</title>
    <link href="http://haichenyi.com/2018/03/07/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/03/07/Java-设计模式（Design-Patterns）（三）/</id>
    <published>2018-03-07T12:24:11.000Z</published>
    <updated>2018-03-07T12:26:37.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="十三、策略模式"><a href="#十三、策略模式" class="headerlink" title="十三、策略模式"></a>十三、策略模式</h2><p>顾名思义:不同的策略，对应我们项目中用到的地方就是，同一个功能，不同的实现方法。就比方说登录功能：我们有帐号密码登录，QQ第三方登录，微信第三方登录等等。其实我个人认为最典型的就是：同一个接口方法，不同的实现方式。</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface LoginInterface&#123;</span><br><span class="line">    void login();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PhoneLogin implements LoginInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void login()&#123;</span><br><span class="line">    //具体的逻辑</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;帐号密码登录&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class QqLogin implements LoginInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void login()&#123;</span><br><span class="line">    //具体的逻辑</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;QQ第三方登录&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像上面这样，同一个登录功能，不同的实现。</p><h2 id="十四、责任链模式"><a href="#十四、责任链模式" class="headerlink" title="十四、责任链模式"></a>十四、责任链模式</h2><p>责任链模式，我项目里面用的比较少，但是我知道一个android里面绝对常用的东西用的是责任连模式，那就是——<a href="http://haichenyi.com/2018/02/22/Android事件分发机制原理/">andoid事件分发</a></p><h2 id="十五、状态模式"><a href="#十五、状态模式" class="headerlink" title="十五、状态模式"></a>十五、状态模式</h2><p>状态模式，我项目里面用的比较少，但是我知道的是游戏里面用的很多。就是那种存档功能，遇到自己感觉过不去的地方，把当前进度存起来，过不去了之后，死了，游戏结束了，再读当前的存档。</p><p>PS：其他的设计模式等用到了再补充</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;十三、策略模式&quot;&gt;&lt;a href=&quot;#十三、策略模式&quot; class=&quot;headerlink&quot; title=&quot;十三、策略模式&quot;&gt;&lt;/a&gt;十三、策略模式&lt;/h2&gt;&lt;p&gt;顾名思义:不同的策略，对应我们项目中用到的地方就是，同一个功能，不同的实现方法。就比方说登录功能：我们有帐号密码登录，QQ第三方登录，微信第三方登录等等。其实我个人认为最典型的就是：同一个接口方法，不同的实现方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -设计模式" scheme="http://haichenyi.com/categories/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 设计模式（Design Patterns）（二）</title>
    <link href="http://haichenyi.com/2018/03/07/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/03/07/Java-设计模式（Design-Patterns）（二）/</id>
    <published>2018-03-07T12:23:53.000Z</published>
    <updated>2018-03-07T12:26:04.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六、适配器模式"><a href="#六、适配器模式" class="headerlink" title="六、适配器模式"></a>六、适配器模式</h2><p>分类有三种：类的适配器模式，对象的适配器模式，接口的适配器模式，我印象最深刻的是<strong><em>接口适配器模式</em></strong></p> <a id="more"></a><p><strong>接口适配器模式</strong></p><p>&emsp;&emsp;有的时候，我们写的一个接口，会有很多种方法。而，我们的实现类只需要实现某一种，或者某几种，所以，我们这里会借助一个抽象类，去实现接口的所有方法。我们的具体实现类跟这个抽象类去打交道，而不是跟原始的接口去打交道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123;</span><br><span class="line">  private BaseView baseView;</span><br><span class="line">  private boolean showLoading;</span><br><span class="line"></span><br><span class="line">  public MySubscriber(BaseView baseView) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MySubscriber(BaseView baseView, boolean showLoading) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">    this.showLoading = showLoading;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onStart() &#123;</span><br><span class="line">    super.onStart();</span><br><span class="line">    if (null != baseView &amp;&amp; showLoading) &#123;</span><br><span class="line">      baseView.showLoading();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onError(Throwable t) &#123;</span><br><span class="line">    if (null == baseView) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    baseView.hideLoading();</span><br><span class="line">    if (t instanceof ApiException) &#123;</span><br><span class="line">      ApiException apiException = (ApiException) t;</span><br><span class="line">      switch (apiException.getCode()) &#123;</span><br><span class="line">        case HttpCode.NO_PARAMETER:</span><br><span class="line">          baseView.showTipMsg(&quot;参数为空&quot;);</span><br><span class="line">          break;</span><br><span class="line">        case HttpCode.SERVER_ERR:</span><br><span class="line">          baseView.showTipMsg(&quot;服务器错误&quot;);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onComplete() &#123;</span><br><span class="line">    if (null != baseView) &#123;</span><br><span class="line">      baseView.hideLoading();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addSubscribe(helper.selectBrandList()</span><br><span class="line">        .compose(RxUtil.handleHttp())</span><br><span class="line">        .subscribeWith(new MySubscriber&lt;List&lt;String&gt;&gt;(baseView, true) &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onNext(List&lt;String&gt; dataList) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;,&quot;111&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个代码，就是我之前写的<a href="http://haichenyi.com/categories/Android-框架/">从零开始搭建一个主流项目框架</a>系列里面的网络请求，处理返回结果的回调方法，我的返回结果，不可能每个去实现onStart，onError，onNext，onCompleted方法。我的实现类只用去继承这个类，实现某一个，或者某几个方法。更直接的就是，我之前写的框架，BaseActivity，实现BaseView接口，然后，我其他的Activity去继承BaseActivity，选择实现BaseView的方法。</p><p>如果上面这样，你还无法认同，那我们看看下面这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//success动画结束监听</span><br><span class="line">    successAnim.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">        super.onAnimationEnd(animation);</span><br><span class="line">        if (null != myAnimotionInterface) &#123;</span><br><span class="line">          myAnimotionInterface.AnimationEnd();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>动画监听，我这里只想监听动画结束，在动画结束的时候，我做我的逻辑处理，但是，他的接口有开始，结束，暂停，重复等等监听，我不要这么，你们可以点 <strong>AnimatorListenerAdapter()</strong> 这个类，去看一下他是什么，他就是一个抽象类，实现了动画监听的那个接口，这个是官方封装好的一个类。</p><h2 id="七、装饰器模式"><a href="#七、装饰器模式" class="headerlink" title="七、装饰器模式"></a>七、装饰器模式</h2><p>这个模式就是我之前写<a href="http://haichenyi.com/categories/Android-框架/">从零开始搭建一个主流项目框架</a>系列里面网络请求，SP的操作，Socket的操作，关于他们的封装都是用的装饰者模式。说的官方一点：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。项目中的应用就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public interface HttpHelper &#123;</span><br><span class="line">  Flowable&lt;WeatherBean&gt; getWeather(String city);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 登录时获取验证码.</span><br><span class="line">   *</span><br><span class="line">   * @param phone 手机号</span><br><span class="line">   * @return &#123;&quot;code&quot;:0&#125;</span><br><span class="line">   */</span><br><span class="line">  Flowable&lt;HttpNoResult&gt; loginCode(String phone);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个就是装饰对象和被装饰对象实现的同一个接口，他们一开始就只有一个功能，那就是获取天气，后来他们又新加了一个功能，必须登录之后才能获取天气，那就多了一个登录功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class DataHelper implements HttpHelper, PreferencesHelper, SqlHelper &#123;</span><br><span class="line">  private SqlHelper sqlHelper;</span><br><span class="line">  private HttpHelper httpHelper;</span><br><span class="line">  private PreferencesHelper preferencesHelper;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 初始化数据帮助类.</span><br><span class="line">   *</span><br><span class="line">   * @param sqlHelper         &#123;@link SqlHelper&#125;</span><br><span class="line">   * @param httpHelper        &#123;@link HttpHelper&#125;</span><br><span class="line">   * @param preferencesHelper &#123;@link PreferencesHelper&#125;</span><br><span class="line">   */</span><br><span class="line">  public DataHelper(SqlHelper sqlHelper, HttpHelper httpHelper,</span><br><span class="line">                    PreferencesHelper preferencesHelper) &#123;</span><br><span class="line">    this.sqlHelper = sqlHelper;</span><br><span class="line">    this.httpHelper = httpHelper;</span><br><span class="line">    this.preferencesHelper = preferencesHelper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123;</span><br><span class="line">    return httpHelper.getWeather(city);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123;</span><br><span class="line">    return httpHelper.loginCode(phone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个就是装饰类，负责调用接口的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class RetrofitHttp implements HttpHelper &#123;</span><br><span class="line">  private WardrobeApi wardrobeApi;</span><br><span class="line">  private WeatherApi weatherApi;</span><br><span class="line"></span><br><span class="line">  @Inject</span><br><span class="line">  RetrofitHttp(WardrobeApi wardrobeApi, WeatherApi weatherApi) &#123;</span><br><span class="line">    this.wardrobeApi = wardrobeApi;</span><br><span class="line">    this.weatherApi = weatherApi;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123;</span><br><span class="line">    return weatherApi.getWeather(city, &quot;c41d9ca568d449e2802244d8eeb3d3c6&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123;</span><br><span class="line">    return wardrobeApi.loginCode(phone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个就是被装饰类，负责具体的实现，这里是retrofit网络请求。以上都是伪代码。具体就是为了说明这个装饰者模式的中心思想，以及我在项目中的运用，不保证一定完全正确，都是按照自己的理解写的。</p><p>PS：其他的设计模式等用到了再补充</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;六、适配器模式&quot;&gt;&lt;a href=&quot;#六、适配器模式&quot; class=&quot;headerlink&quot; title=&quot;六、适配器模式&quot;&gt;&lt;/a&gt;六、适配器模式&lt;/h2&gt;&lt;p&gt;分类有三种：类的适配器模式，对象的适配器模式，接口的适配器模式，我印象最深刻的是&lt;strong&gt;&lt;em&gt;接口适配器模式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -设计模式" scheme="http://haichenyi.com/categories/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 设计模式（Design Patterns）（一）</title>
    <link href="http://haichenyi.com/2018/03/06/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/03/06/Java-设计模式（Design-Patterns）（一）/</id>
    <published>2018-03-06T13:02:20.000Z</published>
    <updated>2018-03-06T13:06:53.893Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>设计模式的分类</em></strong></p><ol><li>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><a id="more"></a><p><strong>我只讲我用的多的，用的多的印象深刻，知道怎么讲，用的少的，不知道怎么讲。只讲我熟练的。</strong></p></li></ol><h2 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h2><p>单例模式，我想应该做过开发的人都用过。</p><h3 id="懒汉式（用的时候初始化，延迟加载）"><a href="#懒汉式（用的时候初始化，延迟加载）" class="headerlink" title="懒汉式（用的时候初始化，延迟加载）"></a>懒汉式（用的时候初始化，延迟加载）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MySocket&#123;</span><br><span class="line">    private static MySocket instance;</span><br><span class="line">    private MySocket()&#123;&#125;</span><br><span class="line">    public static synchronized MySocket getInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">            instance = new MySocket();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里在懒汉式的单例模式中加上了同步锁synchronized，所以，这是线程安全的，但是，也是因为锁，所以造成的效率低，可以根据不同实际情况判断是否需要加同步锁。</p><h3 id="饿汉式（加载类的时候直接初始化）"><a href="#饿汉式（加载类的时候直接初始化）" class="headerlink" title="饿汉式（加载类的时候直接初始化）"></a>饿汉式（加载类的时候直接初始化）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MySocket&#123;</span><br><span class="line">    private static MySocket instance = new MySocket();</span><br><span class="line">    private MySocket()&#123;&#125;</span><br><span class="line">    public static MySocket getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MySocket&#123;</span><br><span class="line">    private static MySocket instance;</span><br><span class="line">    private MySocket()&#123;&#125;</span><br><span class="line">    public static MySocket getInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">            synchronized(MySocket.class)&#123;</span><br><span class="line">                if(null == instance)&#123;</span><br><span class="line">                    instance = new MySocket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的双重校验锁，其实就是我这里的线程安全懒汉式的升级版本，双重校验锁很多开源框架都是用的这种单例，比方说：EventBus。关于单例模式的其他变种我就不说了。单例模式的最终目的，就是全局单例，一个项目不论哪里调用这个类都是引用的同一个对象。</p><h2 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class FragmentFactory &#123;</span><br><span class="line">  public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz) &#123;</span><br><span class="line">    return createFragment(clz, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz, Bundle bundle) &#123;</span><br><span class="line">    if (HomeFragment.class == clz) &#123;</span><br><span class="line">      return new HomeFragment();</span><br><span class="line">    &#125; else if (MyClothesFragment.class == clz) &#123;</span><br><span class="line">      return new MyClothesFragment();</span><br><span class="line">    &#125; else if (WardrobeStructureFragment.class == clz) &#123;</span><br><span class="line">      return new WardrobeStructureFragment();</span><br><span class="line">    &#125; else if (WifiFragment.class == clz) &#123;</span><br><span class="line">      return new WifiFragment();</span><br><span class="line">    &#125; else if (WardrobeConfigFragment.class == clz) &#123;</span><br><span class="line">      return new WardrobeConfigFragment();</span><br><span class="line">    &#125; else if (ShowFragment.class == clz) &#123;</span><br><span class="line">      return new ShowFragment();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new NullPointerException(&quot;not found fragment&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz) &#123;</span><br><span class="line">    return createDialogFragment(clz, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  private static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz, Bundle bundle) &#123;</span><br><span class="line">    if (clz == IconDialogFragment.class) &#123;</span><br><span class="line">      return (T) new IconDialogFragment();</span><br><span class="line">    &#125; else if (clz == PasswordDialogFragment.class) &#123;</span><br><span class="line">      return (T) PasswordDialogFragment.newInstance();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new NullPointerException(&quot;not found fragment&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个fragment工厂类，就是我项目里面用到的。常用的工厂模式就是静态工厂，利用static方法，我这里的工厂就是静态工厂。我们常说的工厂方法对应的这里是什么呢？其实，工厂方法也是一个普通的方法，对应的这里就是<strong><em>createFragment(Class&lt;? extends BaseFragment&gt; clz)</em></strong>。工厂模式什么时候用呢？在需要大量类似的数据的时候（个人观点），Android里面，工厂方法用的最多的就是创建Fragment。</p><h2 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface IFragmentFactory&#123;</span><br><span class="line">    BaseFragment createFragment();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HomeFactory implements IFragmentFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public BaseFragment createFragment()&#123;</span><br><span class="line">        return new HomeFragment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WifiFragment implements IFragmentFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public BaseFragment createFragment()&#123;</span><br><span class="line">        return new WifiFragment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我把上面的静态工厂类，改成了抽象工厂类，就是上面的代码。就是有一个工厂接口或者抽象的工厂类，然后创建不同的工厂类去实现这个接口，实现对应的类，返回你需要的东西</p><h2 id="四、建造者模式"><a href="#四、建造者模式" class="headerlink" title="四、建造者模式"></a>四、建造者模式</h2><p>我之前写Luban源码解析的时候就讲过建造者模式，可以去看一下，就在源码解析的一开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.mytakephoto;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/6</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class DataBean &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  private int age;</span><br><span class="line">  private String sex;</span><br><span class="line"></span><br><span class="line">  public DataBean(Builder builder) &#123;</span><br><span class="line">    this.name = builder.name;</span><br><span class="line">    this.age = builder.age;</span><br><span class="line">    this.sex = builder.sex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age = 20;</span><br><span class="line">    private String sex = &quot;男&quot;;</span><br><span class="line"></span><br><span class="line">    public Builder setName(String name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setAge(int age) &#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setSex(String sex) &#123;</span><br><span class="line">      this.sex = sex;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DataBean build() &#123;</span><br><span class="line">      return new DataBean(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码就是一个DataBean类，用建造者模式创建。要是还是不懂，你可以理解成，我们常常在写bean类的时候，往往要写set方法，你可以理解成，把set方法写在Builder里面，在Builder里面赋好值之后，在我们bean类的构造方法里面传递过来就可以了。</p><h2 id="五、原型模式"><a href="#五、原型模式" class="headerlink" title="五、原型模式"></a>五、原型模式</h2><p>这个模式，我没用到过，网上搜的是，类似于拷贝功能。可以自行搜索。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;设计模式的分类&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。&lt;/li&gt;
&lt;li&gt;结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -设计模式" scheme="http://haichenyi.com/categories/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://haichenyi.com/2018/03/06/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://haichenyi.com/2018/03/06/Java反射机制/</id>
    <published>2018-03-06T13:01:58.000Z</published>
    <updated>2018-03-06T13:07:08.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;在运行过程中，对任意一个类，都能知道这个类的所有属性和方法。对于任一个对象，都能调用他的任意一个方法和属性。这种动态获取信息以及动态调用对象的方法称为java语言的反射机制</p><a id="more"></a><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>我这里就列出我常用的两个方法私有类和变量</p><h3 id="方法Methods"><a href="#方法Methods" class="headerlink" title="方法Methods"></a>方法Methods</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">getDeclaredMethods()</td><td style="text-align:center">获取当前类的所有方法，包括public/private/protected/default修饰的方法</td></tr><tr><td style="text-align:center">getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td style="text-align:center">获取当前类的某一个方法,包括public/private/protected/default修饰的方法</td></tr><tr><td style="text-align:center">getMethods()</td><td style="text-align:center">获取当前类和所继承父类的public标识的所有方法，仅仅包括public</td></tr><tr><td style="text-align:center">getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td style="text-align:center">获取当前类和所继承父类的public标识的某一个方法，仅仅包括public</td></tr></tbody></table><p>&emsp;&emsp;上面就是两个类型的方法，一个是只获取当前类的方法，获取当前类的方法，包括所有类型的方法：public/private/protected/default。还有一个是获取当前类和所继承的父类的方法，仅仅包括public修饰的方法。</p><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在TakePhotoActivity.class类中有两个重载方法，一个无参，一个有一个String类型的参数</span><br><span class="line">private void myTest()&#123;</span><br><span class="line">    Log.v(&quot;WZ&quot;,&quot;myTest无参&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">private void myTest(String msg)&#123;</span><br><span class="line">    Log.v(&quot;WZ&quot;,&quot;myTest有参&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="调用无参的方法"><a href="#调用无参的方法" class="headerlink" title="调用无参的方法"></a>调用无参的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象</span><br><span class="line">try &#123;</span><br><span class="line">Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象</span><br><span class="line">//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象</span><br><span class="line">Method myTest = aClass1.getDeclaredMethod(&quot;myTest&quot;);</span><br><span class="line">myTest.setAccessible(true);//参数值为true，禁止访问控制检查</span><br><span class="line">myTest.invoke(takePhotoActivity);//执行私有方法</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      Log.v(&quot;WZ&quot;, e.getMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="调用有参的方法"><a href="#调用有参的方法" class="headerlink" title="调用有参的方法"></a>调用有参的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象</span><br><span class="line">Class[] arr = new Class[]&#123;String.class&#125;;</span><br><span class="line">try &#123;</span><br><span class="line">Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象</span><br><span class="line">//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象</span><br><span class="line">Method myTest = aClass1.getDeclaredMethod(&quot;myTest&quot;,arr);</span><br><span class="line">myTest.setAccessible(true);//参数值为true，禁止访问控制检查</span><br><span class="line">myTest.invoke(takePhotoActivity,&quot;s&quot;);//执行私有方法</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      Log.v(&quot;WZ&quot;, e.getMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有参的方法，在获取方法的时候，传一个Class[]数组，里面的值就是参数类型的类。或者还有另一种传的方法，前面获取方法的时候：</p><ol><li>获取方法的时候，无参的传一个空的Class[]，有参就传有值的Class[]数组</li><li>执行方法的时候，无参的传一个空的Object[]，有参就传有值的Object[]数组,至于传的值随便写，类型一样就行</li></ol><h3 id="变量Field"><a href="#变量Field" class="headerlink" title="变量Field"></a>变量Field</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">getDeclaredFields()</td><td style="text-align:center">获取当前类的所有类型的全局变量,包括public/private/protected/default修饰的变量</td></tr><tr><td style="text-align:center">getDeclaredField(String name)</td><td style="text-align:center">获取当前类的某一个类型的全局变量,包括public/private/protected/default修饰的变量</td></tr><tr><td style="text-align:center">getFields()</td><td style="text-align:center">获取当前类和继承父类的所有用public修饰的变量</td></tr><tr><td style="text-align:center">getField(String name)</td><td style="text-align:center">获取当前类和继承父类的某一个用public修饰的变量</td></tr></tbody></table><h4 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在TakePhotoActivity里面定义</span><br><span class="line">private int flag;</span><br></pre></td></tr></table></figure><h5 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象</span><br><span class="line">try &#123;</span><br><span class="line">Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象</span><br><span class="line">//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象</span><br><span class="line">Field flag = aClass.getDeclaredField(&quot;flag&quot;);</span><br><span class="line">flag.setAccessible(true);</span><br><span class="line">Object o = flag.get(takePhotoActivity);//这里就获取到了对象</span><br><span class="line">...//做你自己的逻辑处理</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      Log.v(&quot;WZ&quot;, e.getMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="设置变量的值"><a href="#设置变量的值" class="headerlink" title="设置变量的值"></a>设置变量的值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取变量的值跟上面一样</span><br><span class="line">flag.set(takePhotoActivity,10);//这样写会改变TakePhotoActivity中flag的值</span><br></pre></td></tr></table></figure><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/3/6</span><br><span class="line"> * Desc: 反射工具类</span><br><span class="line"> */</span><br><span class="line">public class ReflectionUtil &#123;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 获取私有成员变量的值</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public static Object getValue(Object instance, String fieldName)</span><br><span class="line">            throws IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">        Field field = instance.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true); // 参数值为true，禁止访问控制检查</span><br><span class="line"></span><br><span class="line">        return field.get(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 设置私有成员变量的值</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public static void setValue(Object instance, String fileName, Object value)</span><br><span class="line">            throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        Field field = instance.getClass().getDeclaredField(fileName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(instance, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 访问私有方法</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public static Object callMethod(Object instance, String methodName, Class[] classes, Object[] objects)</span><br><span class="line">            throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException,</span><br><span class="line">            InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        Method method = instance.getClass().getDeclaredMethod(methodName, classes);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        return method.invoke(instance, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在运行过程中，对任意一个类，都能知道这个类的所有属性和方法。对于任一个对象，都能调用他的任意一个方法和属性。这种动态获取信息以及动态调用对象的方法称为java语言的反射机制&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>EventBus源码解析(一)——获取EventBus对象</title>
    <link href="http://haichenyi.com/2018/03/06/EventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96EventBus%E5%AF%B9%E8%B1%A1/"/>
    <id>http://haichenyi.com/2018/03/06/EventBus源码解析-一-——获取EventBus对象/</id>
    <published>2018-03-06T13:01:41.000Z</published>
    <updated>2018-03-06T13:04:32.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>我们先来看一下他的类注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * EventBus is a central publish/subscribe event system for Android. Events are posted (&#123;@link #post(Object)&#125;) to the</span><br><span class="line"> * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events,</span><br><span class="line"> * subscribers must register themselves to the bus using &#123;@link #register(Object)&#125;. Once registered, subscribers</span><br><span class="line"> * receive events until &#123;@link #unregister(Object)&#125; is called. Event handling methods must be annotated by</span><br><span class="line"> * &#123;@link Subscribe&#125;, must be public, return nothing (void), and have exactly one parameter</span><br><span class="line"> * (the event).</span><br><span class="line"> *</span><br><span class="line"> * @author Markus Junginger, greenrobot</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><a id="more"></a><p>&emsp;&emsp;英语不是很好，大致讲一下这段话是什么意思：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a><strong>是重要的发布/订阅的Android事件系统。事件被发布给总线，这个总线将这个事件传递给跟他匹配类型的订阅者。接收事件必须在总线使用的时候注册他们。一旦注册，订阅者就会一直接收事件，直到他们被取消注册。这个接收方法必须增加注解Subscribe标识，必须是public，返回类型是void，并且只有一个参数。</strong> 简单的来说，<strong><em>就是用之前必须先注册，然后接收方法必须有Subscribe注解，必须是public，返回类型是void并且只有一个参数</em></strong></p><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><h4 id="第一步：依赖"><a href="#第一步：依赖" class="headerlink" title="第一步：依赖"></a>第一步：依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br></pre></td></tr></table></figure><h4 id="第二步：注册与反注册"><a href="#第二步：注册与反注册" class="headerlink" title="第二步：注册与反注册"></a>第二步：注册与反注册</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//注册，在onCrate里面</span><br><span class="line">EventBus.getDefault().register(this)</span><br><span class="line">//反注册，在onDestory里面</span><br><span class="line">EventBus.getDefault().unregister(this)</span><br></pre></td></tr></table></figure><h4 id="第三步：接收方法"><a href="#第三步：接收方法" class="headerlink" title="第三步：接收方法"></a>第三步：接收方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe</span><br><span class="line">public void handle(MyClothes myClothes)&#123;</span><br><span class="line">    //你的具体逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第四步：发送"><a href="#第四步：发送" class="headerlink" title="第四步：发送"></a>第四步：发送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(new MyClothes())</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过上面三步，你就可以正常使用EventBus了，前面两步要在一个类里面，因为接收之前，必须要注册，可以在任意的地方post</p><h3 id="源码解析—getDefault"><a href="#源码解析—getDefault" class="headerlink" title="源码解析—getDefault()"></a>源码解析—getDefault()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">        if (defaultInstance == null) &#123;</span><br><span class="line">            synchronized (EventBus.class) &#123;</span><br><span class="line">                if (defaultInstance == null) &#123;</span><br><span class="line">                    defaultInstance = new EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return defaultInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到这里使用的是双重校验锁的单例模式，保证不同的线程调用该方法得到的都是同一个EventBus实例。</p><h4 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus()"></a>EventBus()</h4><p>看到上面的单例模式之后，我们再来瞅瞅单例模式里面调用的构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public EventBus() &#123;</span><br><span class="line">        this(DEFAULT_BUILDER);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里他的空参数的构造方法里面调用的是一个参数的构造方法，我们来看看这个参数是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();</span><br></pre></td></tr></table></figure><h3 id="EventBusBuilder"><a href="#EventBusBuilder" class="headerlink" title="EventBusBuilder()"></a>EventBusBuilder()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventBusBuilder() &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个builder的构造方法里面什么都没有，也就是说没有初始化任何变量，那我们看一看他的变量，这里我就说一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;</span><br></pre></td></tr></table></figure><p><strong><em>Executors.newCachedThreadPool()</em></strong> 创建的是一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空线程池，若无回收，可新建线程。</p><p>接下来，我们再来看看只有EventBusBuilder参数的构造方法</p><h3 id="EventBus-EventBusBuilder-builder"><a href="#EventBus-EventBusBuilder-builder" class="headerlink" title="EventBus(EventBusBuilder builder)"></a>EventBus(EventBusBuilder builder)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">        subscriptionsByEventType = new HashMap&lt;&gt;();</span><br><span class="line">        typesBySubscriber = new HashMap&lt;&gt;();</span><br><span class="line">        stickyEvents = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;</span><br><span class="line">        backgroundPoster = new BackgroundPoster(this);</span><br><span class="line">        asyncPoster = new AsyncPoster(this);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讲到这里，很明显，他这里用的是建造者模式，跟我们之前讲的Luban的模式是一样的，这个建造者模式，我就不讲了。讲Luban的时候讲过的</p><p>&emsp;&emsp;这里我列出来的6个变量，其他变量并没有列出来，因为，其他变量都是builder里面的赋值，没有啥好讲的。我们来看看这6个成员变量的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line">private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line">private final Poster mainThreadPoster;</span><br><span class="line">private final BackgroundPoster backgroundPoster;</span><br><span class="line">private final AsyncPoster asyncPoster;</span><br></pre></td></tr></table></figure><p><strong>意义：</strong></p><ol><li>subscriptionsByEventType：可以看到这是一个是以event的class为key，以subscribe的list为value的map，有的人可能不知道CopyOnWriteArrayList，这是ArrayList的一个线程安全变种。（这里，有人会点到Subscription里面去看一下，可以看到就是一个类，封装了订阅者和订阅方法，重写了hashcode和equal方法）</li><li>typesBySubscriber：这是以订阅者类为key，以event的list为value的map，在注册和反注册的时候用的到</li><li>stickyEvents：粘性事件，以event的class为key，订阅者为value的map</li><li>后面这三个Poster都是用来处理粘性事件的</li></ol><p>&emsp;&emsp;我们说了这么多成员变量。我们知道这里的EventBusBuilder就是给EventBus初始化成员变量的，辣么，我们可不可以不用getDefault，获取eventBus对象呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventBus build1 = EventBus.getDefault();</span><br><span class="line"></span><br><span class="line">EventBus build2 = EventBus.builder().build();</span><br></pre></td></tr></table></figure><p>这两个build的区别是什么呢？我们可以点到build()方法里面去看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public EventBus build() &#123;</span><br><span class="line">        return new EventBus(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>他这里是直接new出来的，并没有单例，所以每次使用的都是new一个新的对象，而通过getDefault，获得是同一个对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;我们先来看一下他的类注释&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * EventBus is a central publish/subscribe event system for Android. Events are posted (&amp;#123;@link #post(Object)&amp;#125;) to the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * subscribers must register themselves to the bus using &amp;#123;@link #register(Object)&amp;#125;. Once registered, subscribers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * receive events until &amp;#123;@link #unregister(Object)&amp;#125; is called. Event handling methods must be annotated by&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;#123;@link Subscribe&amp;#125;, must be public, return nothing (void), and have exactly one parameter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * (the event).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @author Markus Junginger, greenrobot&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="http://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Android二维码扫描——BGAQRCode-Android</title>
    <link href="http://haichenyi.com/2018/03/05/Android%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E2%80%94%E2%80%94BGAQRCode-Android/"/>
    <id>http://haichenyi.com/2018/03/05/Android二维码扫描——BGAQRCode-Android/</id>
    <published>2018-03-05T12:14:02.000Z</published>
    <updated>2018-03-06T12:58:53.565Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;做过二维码扫描的童鞋都知道，要用Zxing，可是google官方推的Zxing，我们集成扫描的时候很慢，有时候就直接扫不出来，体验太差了。因为他适配了太多东西，我们只要一个扫描功能，然后就去网上搜索，怎么使zxing扫描变的很快，zxing的优化，然后跟着网上的博客，一步一步走，即使最终做完了，感觉体验还是不够好。我这里推荐一个二维码扫描的开源框架——<a href="https://github.com/bingoogolapple/BGAQRCode-Android" target="_blank" rel="noopener">BGAQRCode-Android</a></p><a id="more"></a><p>&emsp;&emsp;QRCode 扫描二维码、扫描条形码、相册获取图片后识别、生成带 Logo 二维码、支持微博微信、QQ 二维码扫描样式。他把Zbar和Zxing，都做了优化，扫描速度非常快，用户体验很好，用起来也非常方便</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;cn.bingoogolapple:bga-qrcode-zbar:1.2.1&apos;</span><br><span class="line">或者</span><br><span class="line">implementation &apos;cn.bingoogolapple:bga-qrcode-zxing:1.2.1&apos;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>以Zbar为例（Zxing类似）</p><h4 id="第一步：XML文件"><a href="#第一步：XML文件" class="headerlink" title="第一步：XML文件"></a>第一步：XML文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;cn.bingoogolapple.qrcode.zbar.ZBarView</span><br><span class="line">        android:id=&quot;@+id/zbarview&quot;</span><br><span class="line">        style=&quot;@style/MatchMatch&quot;</span><br><span class="line">        app:qrcv_animTime=&quot;1000&quot;</span><br><span class="line">        app:qrcv_borderColor=&quot;@android:color/white&quot;</span><br><span class="line">        app:qrcv_borderSize=&quot;1dp&quot;</span><br><span class="line">        app:qrcv_cornerColor=&quot;@color/colorPrimaryDark&quot;</span><br><span class="line">        app:qrcv_cornerLength=&quot;20dp&quot;</span><br><span class="line">        app:qrcv_cornerSize=&quot;3dp&quot;</span><br><span class="line">        app:qrcv_isShowDefaultScanLineDrawable=&quot;true&quot;</span><br><span class="line">        app:qrcv_maskColor=&quot;#33FFFFFF&quot;</span><br><span class="line">        app:qrcv_rectWidth=&quot;200dp&quot;</span><br><span class="line">        app:qrcv_scanLineColor=&quot;@color/colorPrimaryDark&quot;</span><br><span class="line">        app:qrcv_topOffset=&quot;90dp&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong><em>自定义属性说明</em></strong></p><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">说明</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">qrcv_topOffset</td><td style="text-align:center">扫描框距离 toolbar 底部的距离</td><td style="text-align:center">90dp</td></tr><tr><td style="text-align:center">qrcv_cornerSize</td><td style="text-align:center">扫描框边角线的宽度</td><td style="text-align:center">3dp</td></tr><tr><td style="text-align:center">qrcv_cornerLength</td><td style="text-align:center">扫描框边角线的长度</td><td style="text-align:center">20dp</td></tr><tr><td style="text-align:center">qrcv_cornerColor</td><td style="text-align:center">扫描框边角线的颜色</td><td style="text-align:center">@android:color/white</td></tr><tr><td style="text-align:center">qrcv_rectWidth</td><td style="text-align:center">扫描框的宽度</td><td style="text-align:center">200dp</td></tr><tr><td style="text-align:center">qrcv_barcodeRectHeight</td><td style="text-align:center">条码扫样式描框的高度</td><td style="text-align:center">140dp</td></tr><tr><td style="text-align:center">qrcv_maskColor</td><td style="text-align:center">除去扫描框，其余部分阴影颜色</td><td style="text-align:center">#33FFFFFF</td></tr><tr><td style="text-align:center">qrcv_scanLineSize</td><td style="text-align:center">扫描线的宽度</td><td style="text-align:center">1dp</td></tr><tr><td style="text-align:center">qrcv_scanLineColor</td><td style="text-align:center">扫描线的颜色「扫描线和默认的扫描线图片的颜色」</td><td style="text-align:center">@android:color/white</td></tr><tr><td style="text-align:center">qrcv_scanLineMargin</td><td style="text-align:center">扫描线距离上下或者左右边框的间距</td><td style="text-align:center">0dp</td></tr><tr><td style="text-align:center">qrcv_isShowDefaultScanLineDrawable</td><td style="text-align:center">是否显示默认的图片扫描线「设置该属性后 qrcv_scanLineSize 将失效，可以通过 qrcv_scanLineColor 设置扫描线的颜色，避免让你公司的UI单独给你出特定颜色的扫描线图片」</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_customScanLineDrawable</td><td style="text-align:center">扫描线的图片资源「默认的扫描线图片样式不能满足你的需求时使用，设置该属性后 qrcv_isShowDefaultScanLineDrawable、qrcv_scanLineSize、qrcv_scanLineColor 将失效」</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">qrcv_borderSize</td><td style="text-align:center">扫描边框的宽度</td><td style="text-align:center">1dp</td></tr><tr><td style="text-align:center">qrcv_borderColor</td><td style="text-align:center">扫描边框的颜色</td><td style="text-align:center">@android:color/white</td></tr><tr><td style="text-align:center">qrcv_animTime</td><td style="text-align:center">扫描线从顶部移动到底部的动画时间「单位为毫秒」</td><td style="text-align:center">1000</td></tr><tr><td style="text-align:center">qrcv_isCenterVertical</td><td style="text-align:center">扫描框是否垂直居中，该属性为true时会忽略 qrcv_topOffset 属性</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_toolbarHeight</td><td style="text-align:center">Toolbar 的高度，通过该属性来修正由 Toolbar 导致扫描框在垂直方向上的偏差</td><td style="text-align:center">0dp</td></tr><tr><td style="text-align:center">qrcv_isBarcode</td><td style="text-align:center">是否是扫条形码</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_tipText</td><td style="text-align:center">提示文案</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">qrcv_tipTextSize</td><td style="text-align:center">提示文案字体大小</td><td style="text-align:center">14sp</td></tr><tr><td style="text-align:center">qrcv_tipTextColor</td><td style="text-align:center">提示文案颜色</td><td style="text-align:center">@android:color/white</td></tr><tr><td style="text-align:center">qrcv_isTipTextBelowRect</td><td style="text-align:center">提示文案是否在扫描框的底部</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_tipTextMargin</td><td style="text-align:center">提示文案与扫描框之间的间距</td><td style="text-align:center">20dp</td></tr><tr><td style="text-align:center">qrcv_isShowTipTextAsSingleLine</td><td style="text-align:center">是否把提示文案作为单行显示</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_isShowTipBackground</td><td style="text-align:center">是否显示提示文案的背景</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_tipBackgroundColor</td><td style="text-align:center">提示文案的背景色</td><td style="text-align:center">#22000000</td></tr><tr><td style="text-align:center">qrcv_isScanLineReverse</td><td style="text-align:center">扫描线是否来回移动</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">qrcv_isShowDefaultGridScanLineDrawable</td><td style="text-align:center">是否显示默认的网格图片扫描线</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_customGridScanLineDrawable</td><td style="text-align:center">扫描线的网格图片资源</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">qrcv_isOnlyDecodeScanBoxArea</td><td style="text-align:center">是否只识别扫描框区域的二维码</td><td style="text-align:center">false</td></tr></tbody></table><h4 id="第二步：获取控件，并实现QRCodeView-Delegate接口"><a href="#第二步：获取控件，并实现QRCodeView-Delegate接口" class="headerlink" title="第二步：获取控件，并实现QRCodeView.Delegate接口"></a>第二步：获取控件，并实现QRCodeView.Delegate接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QRCodeView mQRCodeView = (ZBarView) findViewById(R.id.zbarview);</span><br><span class="line">mQRCodeView.setDelegate(this);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">  public void onScanQRCodeSuccess(String result) &#123;</span><br><span class="line">    vibrate();</span><br><span class="line">    Toast.makeText(this,result,Toast.LENGTH_SHORT).show();</span><br><span class="line">    mQRCodeView.startSpot();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onScanQRCodeOpenCameraError() &#123;</span><br><span class="line">    Toast.makeText(this,&quot;错误&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="第四步：实现onStart，onStop，onDestroy方法"><a href="#第四步：实现onStart，onStop，onDestroy方法" class="headerlink" title="第四步：实现onStart，onStop，onDestroy方法"></a>第四步：实现onStart，onStop，onDestroy方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onStart() &#123;</span><br><span class="line">    super.onStart();</span><br><span class="line">    mQRCodeView.startCamera();//打开相机</span><br><span class="line">    mQRCodeView.showScanRect();//显示扫描框</span><br><span class="line">    mQRCodeView.startSpot();//开始识别二维码</span><br><span class="line">    //mQRCodeView.openFlashlight();//开灯</span><br><span class="line">    //mQRCodeView.closeFlashlight();//关灯</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onStop() &#123;</span><br><span class="line">    mQRCodeView.stopCamera();</span><br><span class="line">    super.onStop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDestroy() &#123;</span><br><span class="line">    mQRCodeView.onDestroy();</span><br><span class="line">    super.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void vibrate() &#123;</span><br><span class="line">    Vibrator vibrator = (Vibrator) getSystemService(VIBRATOR_SERVICE);</span><br><span class="line">    vibrator.vibrate(200);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="第五步：添加权限"><a href="#第五步：添加权限" class="headerlink" title="第五步：添加权限"></a>第五步：添加权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt;</span><br></pre></td></tr></table></figure><p>经过上面5步，扫描功能就已经出来了，Zbar扫描比Zxing快，Zbar是基于C实现的，Zxing是基于C++。有个问题就是Zbar无法生成二维码，如果你是集成的BGA的Zxing可以生成二维码。Zxing生成二维码的方式如下：</p><p><strong><em>耗时操作，新开线程</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//中文</span><br><span class="line">Bitmap bitmap = QRCodeEncoder.syncEncodeQRCode(&quot;海晨忆&quot;, BGAQRCodeUtil.dp2px(this, 150));</span><br><span class="line"></span><br><span class="line">//带logo</span><br><span class="line">Bitmap logoBitmap = BitmapFactory.decodeResource(TestGeneratectivity.this.getResources(), R.mipmap.logo);</span><br><span class="line">QRCodeEncoder.syncEncodeQRCode(&quot;海晨忆&quot;, BGAQRCodeUtil.dp2px(TestGeneratectivity.this, 150), Color.parseColor(&quot;#ff0000&quot;), logoBitmap);</span><br></pre></td></tr></table></figure><p><strong><em>解析图片二维码</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//mEnglishLogoIv：显示二维码的控件</span><br><span class="line">mEnglishLogoIv.setDrawingCacheEnabled(true);</span><br><span class="line">Bitmap bitmap = mEnglishLogoIv.getDrawingCache();</span><br><span class="line"></span><br><span class="line">//返回二维码图片里的内容 或 null</span><br><span class="line">String result = QRCodeDecoder.syncDecodeQRCode(bitmap);</span><br><span class="line">String result = QRCodeDecoder.syncDecodeQRCode(picturePath);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;做过二维码扫描的童鞋都知道，要用Zxing，可是google官方推的Zxing，我们集成扫描的时候很慢，有时候就直接扫不出来，体验太差了。因为他适配了太多东西，我们只要一个扫描功能，然后就去网上搜索，怎么使zxing扫描变的很快，zxing的优化，然后跟着网上的博客，一步一步走，即使最终做完了，感觉体验还是不够好。我这里推荐一个二维码扫描的开源框架——&lt;a href=&quot;https://github.com/bingoogolapple/BGAQRCode-Android&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BGAQRCode-Android&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android WIFI功能——WifiManager</title>
    <link href="http://haichenyi.com/2018/03/05/Android-WIFI%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94WifiManager/"/>
    <id>http://haichenyi.com/2018/03/05/Android-WIFI功能——WifiManager/</id>
    <published>2018-03-05T12:13:31.000Z</published>
    <updated>2018-03-06T12:59:02.079Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前做了关于Android wifi的相关功能，这里做一个记录</p><a id="more"></a><h3 id="第一步：获取WifiManager"><a href="#第一步：获取WifiManager" class="headerlink" title="第一步：获取WifiManager"></a>第一步：获取WifiManager</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WifiManager wifiMgr = (WifiManager)Context.getSystemService(Context.WIFI_SERVICE);</span><br></pre></td></tr></table></figure><h3 id="第二步：获取周围热点信息和已连接wifi信息"><a href="#第二步：获取周围热点信息和已连接wifi信息" class="headerlink" title="第二步：获取周围热点信息和已连接wifi信息"></a>第二步：获取周围热点信息和已连接wifi信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ScanResult&gt; scanResults = wifiMgr.getScanResults();//扫描到的周围热点信息</span><br><span class="line">WifiInfo info = wifiMgr.getConnectionInfo();//已连接wifi信息</span><br></pre></td></tr></table></figure><p>这里我说一下几个字段的意思：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String name;//ssid对应的wifi名字</span><br><span class="line">public String capabilities;//用来判断是否有密码</span><br><span class="line">public int level;//信号等级，这里是负数</span><br><span class="line">public String BSSID;//macid</span><br></pre></td></tr></table></figure><p>这里我需要强调的就是level，是负数，<strong><em>负数越大，信号越好</em></strong></p><h3 id="第三步：检测wifi信息，这里我给出几个工具类"><a href="#第三步：检测wifi信息，这里我给出几个工具类" class="headerlink" title="第三步：检测wifi信息，这里我给出几个工具类"></a>第三步：检测wifi信息，这里我给出几个工具类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 连接有密码的wifi.</span><br><span class="line">   *</span><br><span class="line">   * @param SSID     ssid</span><br><span class="line">   * @param Password Password</span><br><span class="line">   * @return apConfig</span><br><span class="line">   */</span><br><span class="line">  private WifiConfiguration setWifiParamsPassword(String SSID, String Password) &#123;</span><br><span class="line">    WifiConfiguration apConfig = new WifiConfiguration();</span><br><span class="line">    apConfig.SSID = &quot;\&quot;&quot; + SSID + &quot;\&quot;&quot;;</span><br><span class="line">    apConfig.preSharedKey = &quot;\&quot;&quot; + Password + &quot;\&quot;&quot;;</span><br><span class="line">    //不广播其SSID的网络</span><br><span class="line">    apConfig.hiddenSSID = true;</span><br><span class="line">    apConfig.status = WifiConfiguration.Status.ENABLED;</span><br><span class="line">    //公认的IEEE 802.11验证算法。</span><br><span class="line">    apConfig.allowedAuthAlgorithms.clear();</span><br><span class="line">    apConfig.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);</span><br><span class="line">    //公认的的公共组密码</span><br><span class="line">    apConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);</span><br><span class="line">    apConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);</span><br><span class="line">    //公认的密钥管理方案</span><br><span class="line">    apConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);</span><br><span class="line">    //密码为WPA。</span><br><span class="line">    apConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);</span><br><span class="line">    apConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);</span><br><span class="line">    //公认的安全协议。</span><br><span class="line">    apConfig.allowedProtocols.set(WifiConfiguration.Protocol.RSN);</span><br><span class="line">    return apConfig;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 连接没有密码wifi.</span><br><span class="line">   *</span><br><span class="line">   * @param ssid ssid</span><br><span class="line">   * @return configuration</span><br><span class="line">   */</span><br><span class="line">  private WifiConfiguration setWifiParamsNoPassword(String ssid) &#123;</span><br><span class="line">    WifiConfiguration configuration = new WifiConfiguration();</span><br><span class="line">    configuration.SSID = &quot;\&quot;&quot; + ssid + &quot;\&quot;&quot;;</span><br><span class="line">    configuration.status = WifiConfiguration.Status.ENABLED;</span><br><span class="line">    configuration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);</span><br><span class="line">    configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);</span><br><span class="line">    configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);</span><br><span class="line">    configuration.allowedPairwiseCiphers</span><br><span class="line">        .set(WifiConfiguration.PairwiseCipher.TKIP);</span><br><span class="line">    configuration.allowedPairwiseCiphers</span><br><span class="line">        .set(WifiConfiguration.PairwiseCipher.CCMP);</span><br><span class="line">    configuration.allowedProtocols.set(WifiConfiguration.Protocol.RSN);</span><br><span class="line">    return configuration;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static final int WIFI_NO_PASS = 0;</span><br><span class="line">  private static final int WIFI_WEP = 1;</span><br><span class="line">  private static final int WIFI_PSK = 2;</span><br><span class="line">  private static final int WIFI_EAP = 3;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 判断是否有密码.</span><br><span class="line">   *</span><br><span class="line">   * @param result ScanResult</span><br><span class="line">   * @return 0</span><br><span class="line">   */</span><br><span class="line">  public static int getSecurity(MyScanResult result) &#123;</span><br><span class="line">    if (null != result &amp;&amp; null != result.capabilities) &#123;</span><br><span class="line">      if (result.capabilities.contains(&quot;WEP&quot;)) &#123;</span><br><span class="line">        return WIFI_WEP;</span><br><span class="line">      &#125; else if (result.capabilities.contains(&quot;PSK&quot;)) &#123;</span><br><span class="line">        return WIFI_PSK;</span><br><span class="line">      &#125; else if (result.capabilities.contains(&quot;EAP&quot;)) &#123;</span><br><span class="line">        return WIFI_EAP;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return WIFI_NO_PASS;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面三个工具类，一个用来判断是否需要密码，另外两个用来连接wifi</p><h3 id="连接wifi"><a href="#连接wifi" class="headerlink" title="连接wifi"></a>连接wifi</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//需要密码</span><br><span class="line">wifiMgr.enableNetwork(wifiMgr.addNetwork(</span><br><span class="line">                    setWifiParamsPassword(mClickResult.name, password)), true);</span><br><span class="line">//不需要密码</span><br><span class="line">wifiMgr.enableNetwork(wifiMgr.addNetwork(setWifiParamsNoPassword(mClickResult.name)),</span><br><span class="line">              true);</span><br></pre></td></tr></table></figure><h3 id="wifi监听"><a href="#wifi监听" class="headerlink" title="wifi监听"></a>wifi监听</h3><p>PS：关于wifi状态的监听，就是监听你当前的网络状态即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.receiver.NetworkReceiver&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.net.wifi.WIFI_STATE_CHANGED&quot;/&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.net.wifi.STATE_CHANGE&quot;/&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.net.wifi.supplicant.STATE_CHANGE&quot;/&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.net.wifi.NETWORK_IDS_CHANGED&quot;/&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/receiver&gt;</span><br></pre></td></tr></table></figure><p>首先在你的清单文件注册这四种action的广播，这里给出我的网络监听广播</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/1/10</span><br><span class="line"> * Desc: 网络广播监听</span><br><span class="line"> */</span><br><span class="line">public class NetworkReceiver extends BroadcastReceiver &#123;</span><br><span class="line">  public static final int STATE1 = 1;//密码错误</span><br><span class="line">  public static final int STATE2 = 2;//连接成功</span><br><span class="line">  public static final int STATE3 = 3;//连接失败</span><br><span class="line">  public static final int STATE4 = 4;//正在获取ip地址</span><br><span class="line">  public static final int STATE5 = 5;//正在连接</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">    if (WifiManager.SUPPLICANT_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123;</span><br><span class="line">      //密码错误广播,是不是正在获得IP地址</span><br><span class="line">      int linkWifiResult = intent.getIntExtra(WifiManager.EXTRA_SUPPLICANT_ERROR, -1);</span><br><span class="line">      if (linkWifiResult == WifiManager.ERROR_AUTHENTICATING) &#123;</span><br><span class="line">        //密码错误</span><br><span class="line">        ToastUtils.showTipMsg(R.string.password_wrong);</span><br><span class="line">        sendNetworkStateChange(new NetWorkInfo().setState(STATE1));</span><br><span class="line">      &#125;</span><br><span class="line">      SupplicantState supplicantState = intent.getParcelableExtra(WifiManager.EXTRA_NEW_STATE);</span><br><span class="line">      NetworkInfo.DetailedState state = WifiInfo.getDetailedStateOf(supplicantState);</span><br><span class="line">      Log.v(Constants.HTTP_WZ, state.name());</span><br><span class="line">      if (state == NetworkInfo.DetailedState.CONNECTING) &#123;</span><br><span class="line">        //正在连接</span><br><span class="line">        ToastUtils.showTipMsg(R.string.linking);</span><br><span class="line">        sendNetworkStateChange(new NetWorkInfo().setState(STATE5));</span><br><span class="line">      &#125; else if (state == NetworkInfo.DetailedState.FAILED</span><br><span class="line">          || state == NetworkInfo.DetailedState.DISCONNECTING) &#123;</span><br><span class="line">        //连接失败</span><br><span class="line">        sendNetworkStateChange(new NetWorkInfo().setState(STATE3));</span><br><span class="line">        ToastUtils.showTipMsg(R.string.linked_failed);</span><br><span class="line">      &#125; else if (state == NetworkInfo.DetailedState.CONNECTED) &#123;</span><br><span class="line">        //连接成功</span><br><span class="line">        ToastUtils.showTipMsg(R.string.linked_success);</span><br><span class="line">      &#125; else if (state == NetworkInfo.DetailedState.OBTAINING_IPADDR) &#123;</span><br><span class="line">        //正在获取ip地址</span><br><span class="line">        sendNetworkStateChange(new NetWorkInfo().setState(STATE4));</span><br><span class="line">      &#125; else if (state == NetworkInfo.DetailedState.IDLE) &#123;</span><br><span class="line">        //闲置的</span><br><span class="line">        ConnectivityManager connectManager = (ConnectivityManager) BaseApplication.getInstance()</span><br><span class="line">            .getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        NetworkInfo activeNetworkInfo = null;</span><br><span class="line">        if (connectManager != null) &#123;</span><br><span class="line">          activeNetworkInfo = connectManager.getActiveNetworkInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        if (activeNetworkInfo == null) &#123;</span><br><span class="line">          sendNetworkStateChange(new NetWorkInfo().setState(STATE3));</span><br><span class="line">          ToastUtils.showTipMsg(R.string.linked_failed);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (WifiManager.WIFI_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123;</span><br><span class="line">      // 监听wifi的打开与关闭，与wifi的连接无关</span><br><span class="line">      int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, 0);</span><br><span class="line">      Log.v(Constants.HTTP_WZ, &quot;wifiState:&quot; + wifiState);</span><br><span class="line">      switch (wifiState) &#123;</span><br><span class="line">        case WifiManager.WIFI_STATE_DISABLING://正在停止0</span><br><span class="line">          ToastUtils.showTipMsg(R.string.close_wifi);</span><br><span class="line">          break;</span><br><span class="line">        case WifiManager.WIFI_STATE_DISABLED://已停止1</span><br><span class="line">          break;</span><br><span class="line">        case WifiManager.WIFI_STATE_UNKNOWN://未知4</span><br><span class="line">          break;</span><br><span class="line">        case WifiManager.WIFI_STATE_ENABLING://正在打开2</span><br><span class="line">          ToastUtils.showTipMsg(R.string.opening_wifi);</span><br><span class="line">          break;</span><br><span class="line">        case WifiManager.WIFI_STATE_ENABLED://已开启3</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (WifiManager.NETWORK_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123;</span><br><span class="line">      // 监听wifi的连接状态即是否连上了一个有效无线路由</span><br><span class="line">      Parcelable parcelableExtra = intent</span><br><span class="line">          .getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);</span><br><span class="line">      if (null != parcelableExtra) &#123;</span><br><span class="line">        // 获取联网状态的NetWorkInfo对象</span><br><span class="line">        NetworkInfo networkInfo = (NetworkInfo) parcelableExtra;</span><br><span class="line">        //获取的State对象则代表着连接成功与否等状态</span><br><span class="line">        NetworkInfo.State state = networkInfo.getState();</span><br><span class="line">        //判断网络是否已经连接</span><br><span class="line">        boolean isConnected = state == NetworkInfo.State.CONNECTED;</span><br><span class="line">        Log.v(Constants.HTTP_WZ, &quot;isConnected:&quot; + isConnected);</span><br><span class="line">        if (isConnected) &#123;</span><br><span class="line">          ToastUtils.showTipMsg(R.string.linked_success);</span><br><span class="line">          sendNetworkStateChange(new NetWorkInfo().setState(STATE2));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 发送网络状态eventBus.</span><br><span class="line">   *</span><br><span class="line">   * @param info info</span><br><span class="line">   */</span><br><span class="line">  private void sendNetworkStateChange(NetWorkInfo info) &#123;</span><br><span class="line">    EventBus.getDefault().post(info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">  private String getConnectionType(int type) &#123;</span><br><span class="line">    String connType = &quot;&quot;;</span><br><span class="line">    if (type == ConnectivityManager.TYPE_MOBILE) &#123;</span><br><span class="line">      connType = &quot;移动网络&quot;;</span><br><span class="line">    &#125; else if (type == ConnectivityManager.TYPE_WIFI) &#123;</span><br><span class="line">      connType = &quot;WIFI网络&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return connType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static class NetWorkInfo &#123;</span><br><span class="line">    public int state;//1密码错误，2:连接成功，3:连接失败</span><br><span class="line"></span><br><span class="line">    private NetWorkInfo setState(int state) &#123;</span><br><span class="line">      this.state = state;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释应该写的很清楚，我就不做过多的解释了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前做了关于Android wifi的相关功能，这里做一个记录&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>简单的蓝牙通信</title>
    <link href="http://haichenyi.com/2018/03/05/%E7%AE%80%E5%8D%95%E7%9A%84%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/"/>
    <id>http://haichenyi.com/2018/03/05/简单的蓝牙通信/</id>
    <published>2018-03-05T12:12:58.000Z</published>
    <updated>2018-03-06T12:59:29.265Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前公司做智能家居类型，其中做了一个智能衣柜项目，与衣柜通信就是用的蓝牙通信。一些操作一些简单的开关指令，蓝牙通信与socket是类似的。</p><a id="more"></a><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>清单文件注册权限</li><li>启动蓝牙服务（记得在清单文件中静态注册服务）</li><li>注册蓝牙广播（在蓝牙服务中动态注册蓝牙广播）</li><li>搜索，绑定，完成</li><li>退出app，停止服务，并在蓝牙服务的onDestory方法中取消注册蓝牙广播</li></ol><p>不想写说明，只想贴代码</p><h4 id="第一步：注册权限"><a href="#第一步：注册权限" class="headerlink" title="第一步：注册权限"></a>第一步：注册权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--获取蓝牙信息状态权限--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="第二步、第三步、第五步：启动蓝牙服务，注册蓝牙广播，停止服务"><a href="#第二步、第三步、第五步：启动蓝牙服务，注册蓝牙广播，停止服务" class="headerlink" title="第二步、第三步、第五步：启动蓝牙服务，注册蓝牙广播，停止服务"></a>第二步、第三步、第五步：启动蓝牙服务，注册蓝牙广播，停止服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/1/4</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class BluetoothService extends Service &#123;</span><br><span class="line">  //得到蓝牙适配器</span><br><span class="line">  private BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();</span><br><span class="line">  private BluetoothReceiver mReceiver;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    EventBus.getDefault().register(this);</span><br><span class="line">    if (mBluetoothAdapter != null) &#123;</span><br><span class="line">      mReceiver = new BluetoothReceiver().setBluetoothAdapter(mBluetoothAdapter);</span><br><span class="line">      //注册设备被发现时的广播</span><br><span class="line">      IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);</span><br><span class="line">      registerReceiver(mReceiver, filter);</span><br><span class="line">      //注册一个搜索结束时的广播</span><br><span class="line">      IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);</span><br><span class="line">      registerReceiver(mReceiver, filter2);</span><br><span class="line">      startLinkBluetooth();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Nullable</span><br><span class="line">  @Override</span><br><span class="line">  public IBinder onBind(Intent intent) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 开始连接蓝牙设备.</span><br><span class="line">   */</span><br><span class="line">  private void startLinkBluetooth() &#123;</span><br><span class="line">    if (null != mBluetoothAdapter) &#123;</span><br><span class="line">      //判断蓝牙是否打开</span><br><span class="line">      if (!mBluetoothAdapter.isEnabled()) &#123;</span><br><span class="line">        //若没打开则打开蓝牙</span><br><span class="line">        mBluetoothAdapter.enable();</span><br><span class="line">      &#125;</span><br><span class="line">      mBluetoothAdapter.startDiscovery();</span><br><span class="line">      Log.v(Constants.HTTP_WZ, &quot;正在扫描&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Subscribe</span><br><span class="line">  @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">  public void handleMsg(BluetoothInfo bluetoothInfo) &#123;</span><br><span class="line">    if (bluetoothInfo.isLink) &#123;</span><br><span class="line">      startLinkBluetooth();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static class BluetoothInfo &#123;</span><br><span class="line">    private boolean isLink = false;</span><br><span class="line"></span><br><span class="line">    public BluetoothInfo setLink(boolean link) &#123;</span><br><span class="line">      this.isLink = link;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    EventBus.getDefault().unregister(this);</span><br><span class="line">    if (mReceiver != null) &#123;</span><br><span class="line">      mReceiver.unRegister();</span><br><span class="line">      unregisterReceiver(mReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是我的蓝牙服务类，这个类的逻辑怎么走的呢？</p><ol><li><p>EventBus的东西我就不说了</p></li><li><p>首先获取蓝牙适配器</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();</span><br></pre></td></tr></table></figure><ol><li>初始化蓝牙广播，注册蓝牙广播</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (mBluetoothAdapter != null) &#123;</span><br><span class="line">      mReceiver = new BluetoothReceiver().setBluetoothAdapter(mBluetoothAdapter);</span><br><span class="line">      //注册设备被发现时的广播</span><br><span class="line">      IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);</span><br><span class="line">      registerReceiver(mReceiver, filter);</span><br><span class="line">      //注册一个搜索结束时的广播</span><br><span class="line">      IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);</span><br><span class="line">      registerReceiver(mReceiver, filter2);</span><br><span class="line">      startLinkBluetooth();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>开始准备连接蓝牙设备</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 开始连接蓝牙设备.</span><br><span class="line">   */</span><br><span class="line">  private void startLinkBluetooth() &#123;</span><br><span class="line">    if (null != mBluetoothAdapter) &#123;</span><br><span class="line">      //判断蓝牙是否打开</span><br><span class="line">      if (!mBluetoothAdapter.isEnabled()) &#123;</span><br><span class="line">        //若没打开则打开蓝牙</span><br><span class="line">        mBluetoothAdapter.enable();</span><br><span class="line">      &#125;</span><br><span class="line">      mBluetoothAdapter.startDiscovery();</span><br><span class="line">      Log.v(Constants.HTTP_WZ, &quot;正在扫描&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>上面4步蓝牙扫描就完成了，这里我还要说的是，在服务的onDestory方法里面，记得停止服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    EventBus.getDefault().unregister(this);</span><br><span class="line">    if (mReceiver != null) &#123;</span><br><span class="line">      mReceiver.unRegister();</span><br><span class="line">      unregisterReceiver(mReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>再就是在清单文件里面静态注册蓝牙服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;.service.BluetoothService&quot;/&gt;</span><br></pre></td></tr></table></figure><ol><li>启动服务的方式，我用的是非绑定的方式，同样，记得停止服务。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent bluetoothService = new Intent(this, BluetoothService.class);</span><br><span class="line">startService(bluetoothService);//启动蓝牙服务</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopService(bluetoothService);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">  @Override</span><br><span class="line">  public IBinder onBind(Intent intent) &#123;</span><br><span class="line">  //非绑定方式，返回值为null</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="第四步：搜索，绑定，完成搜索"><a href="#第四步：搜索，绑定，完成搜索" class="headerlink" title="第四步：搜索，绑定，完成搜索"></a>第四步：搜索，绑定，完成搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/1/4</span><br><span class="line"> * Desc: 蓝牙广播监听</span><br><span class="line"> */</span><br><span class="line">public class BluetoothReceiver extends BroadcastReceiver &#123;</span><br><span class="line">  //衣柜的蓝牙名称</span><br><span class="line">  private static final String WARDROBE_NAME = &quot;WARDROBE&quot;;</span><br><span class="line">  // 固定的UUID</span><br><span class="line">  private static final String SPP_UUID = &quot;00001101-0000-1000-8000-00805F9B34FB&quot;;</span><br><span class="line">  private BluetoothSocket bluetoothSocket;</span><br><span class="line">  private BluetoothAdapter bluetoothAdapter;</span><br><span class="line">  private InputStream mInputStream;</span><br><span class="line">  private OutputStream outputStream;</span><br><span class="line">  private boolean isRunning = false;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">    String action = intent.getAction();</span><br><span class="line">    if (action != null) &#123;</span><br><span class="line">      if (action.equals(BluetoothDevice.ACTION_FOUND)) &#123;</span><br><span class="line">        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</span><br><span class="line">        Log.v(Constants.HTTP_WZ, device.getName() + device.getAddress());</span><br><span class="line">        if (device.getBondState() == BluetoothDevice.BOND_BONDED</span><br><span class="line">            &amp;&amp; device.getName().equals(WARDROBE_NAME)) &#123;</span><br><span class="line">          UUID uuid = UUID.fromString(SPP_UUID);</span><br><span class="line">          try &#123;</span><br><span class="line">            bluetoothSocket = device.createRfcommSocketToServiceRecord(uuid);</span><br><span class="line">            Log.v(Constants.HTTP_WZ, &quot;准备连接&quot;);</span><br><span class="line">            connect();</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) &#123;</span><br><span class="line">        if (!EventBus.getDefault().isRegistered(this))</span><br><span class="line">          EventBus.getDefault().register(this);</span><br><span class="line">        Observable.timer(2, TimeUnit.SECONDS)</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(aLong -&gt; &#123;</span><br><span class="line">              if (null == bluetoothSocket || !bluetoothSocket.isConnected())</span><br><span class="line">                ToastUtils.showTipMsg(R.string.no_wardrobe);</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void connect() &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      if (bluetoothSocket != null) &#123;</span><br><span class="line">        bluetoothAdapter.cancelDiscovery();</span><br><span class="line">        try &#123;</span><br><span class="line">          bluetoothSocket.connect();</span><br><span class="line">          Observable.just(1)</span><br><span class="line">              .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">              .subscribe(integer -&gt; ToastUtils.showTipMsg(R.string.link_wardrobe));</span><br><span class="line">          Log.v(Constants.HTTP_WZ, &quot;连接成功&quot;);</span><br><span class="line">          mInputStream = bluetoothSocket.getInputStream();</span><br><span class="line">          Log.v(Constants.HTTP_WZ, &quot;mInputSream:&quot; + mInputStream.toString());</span><br><span class="line">          isRunning = true;</span><br><span class="line">          outputStream = bluetoothSocket.getOutputStream();</span><br><span class="line">          Log.v(Constants.HTTP_WZ, &quot;outputStream:&quot; + outputStream.toString());</span><br><span class="line">          BufferedReader br;</span><br><span class="line">          while (isRunning) &#123;</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(mInputStream, &quot;utf-8&quot;));</span><br><span class="line">            String s = br.readLine();</span><br><span class="line">            //acceptReply(s);</span><br><span class="line">            Log.v(Constants.HTTP_WZ, &quot;收到的数据:&quot; + s);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          try &#123;</span><br><span class="line">            if (mInputStream != null) &#123;</span><br><span class="line">              mInputStream.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;mInputSream.close()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (outputStream != null) &#123;</span><br><span class="line">              outputStream.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;outputStream.close()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bluetoothSocket != null) &#123;</span><br><span class="line">              bluetoothSocket.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;socket.close()&quot;);</span><br><span class="line">              bluetoothSocket = null;</span><br><span class="line">            &#125;</span><br><span class="line">            isRunning = false;</span><br><span class="line">          &#125; catch (Exception e2) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BluetoothReceiver setBluetoothAdapter(BluetoothAdapter adapter) &#123;</span><br><span class="line">    this.bluetoothAdapter = adapter;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 反注册eventBus.</span><br><span class="line">   */</span><br><span class="line">  public void unRegister() &#123;</span><br><span class="line">    EventBus.getDefault().unregister(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是我的蓝牙广播类，这个逻辑又是怎么走的呢？</p><ol><li>前面服务里面注册的两个action，一个<strong><em>BluetoothDevice.ACTION_FOUND</em></strong>，还有一个<strong><em>BluetoothAdapter.ACTION_DISCOVERY_FINISHED</em></strong>，做了一个if判断，是发现了设备还是已经完成了扫描设备</li><li>发现设备之后，获取蓝牙信息，<strong>他这里是获取到一个蓝牙信息就会走一遍这个方法，并不是说一次获取一个列表</strong>。</li><li>找到了蓝牙设备之后就是连接了，伪代码讲解：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 固定的UUID连接的时候需要uuid</span><br><span class="line">  private static final String SPP_UUID = &quot;00001101-0000-1000-8000-00805F9B34FB&quot;;</span><br><span class="line">  </span><br><span class="line">//获取socket</span><br><span class="line">BluetoothSocket bluetoothSocket =device.createRfcommSocketToServiceRecord(uuid);</span><br><span class="line"></span><br><span class="line">//连接之前取消扫描，注意非空判断。adapter是在服务里面申明的，通过setBluetoothAdapter方法传过来的</span><br><span class="line">bluetoothAdapter.cancelDiscovery();</span><br><span class="line"></span><br><span class="line">//连接，这里是阻塞的方式，注意要新开线程连接</span><br><span class="line">bluetoothSocket.connect();</span><br><span class="line"></span><br><span class="line">//获取输入流对象和输出流对象</span><br><span class="line">InputStream mInputStream = bluetoothSocket.getInputStream();</span><br><span class="line">OutputStream outputStream = bluetoothSocket.getOutputStream();</span><br><span class="line"></span><br><span class="line">//发送消息</span><br><span class="line">private void sendInstruct(String msg) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (null == bluetoothSocket || !bluetoothSocket.isConnected()) &#123;</span><br><span class="line">        SocketUtils.reLinkBluetooth();</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      Log.v(Constants.HTTP_WZ, &quot;发送的数据--&gt;&quot; + msg + BluetoothInstruct.FINISH);</span><br><span class="line">      outputStream.write(msg.getBytes());</span><br><span class="line">      outputStream.flush();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//接收消息，一次读一行，简单的蓝牙通信换行符作为结束标记</span><br><span class="line">BufferedReader br;</span><br><span class="line">while (isRunning) &#123;</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(mInputStream, &quot;utf-8&quot;));</span><br><span class="line">            String s = br.readLine();</span><br><span class="line">            acceptReply(s);</span><br><span class="line">            Log.v(Constants.HTTP_WZ, &quot;收到的数据:&quot; + s);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">//异常的时候释放资源</span><br><span class="line">try &#123;</span><br><span class="line">            if (mInputStream != null) &#123;</span><br><span class="line">              mInputStream.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;mInputSream.close()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (outputStream != null) &#123;</span><br><span class="line">              outputStream.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;outputStream.close()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bluetoothSocket != null) &#123;</span><br><span class="line">              bluetoothSocket.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;socket.close()&quot;);</span><br><span class="line">              bluetoothSocket = null;</span><br><span class="line">            &#125;</span><br><span class="line">            isRunning = false;</span><br><span class="line">          &#125; catch (Exception e2) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前公司做智能家居类型，其中做了一个智能衣柜项目，与衣柜通信就是用的蓝牙通信。一些操作一些简单的开关指令，蓝牙通信与socket是类似的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android拍照功能——TakePhoto</title>
    <link href="http://haichenyi.com/2018/03/05/Android%E6%8B%8D%E7%85%A7%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94TakePhoto/"/>
    <id>http://haichenyi.com/2018/03/05/Android拍照功能——TakePhoto/</id>
    <published>2018-03-05T12:12:03.000Z</published>
    <updated>2018-03-06T12:58:23.128Z</updated>
    
    <content type="html"><![CDATA[<p>之前在写项目框架Andoroid 6.0，动态获取权限的时候就提到过<a href="https://github.com/crazycodeboy/TakePhoto" target="_blank" rel="noopener">TakePhoto开源框架</a></p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.jph.takephoto:takephoto_library:4.0.3&apos;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>我这里就说拍照，选择相册的功能。其他功能请移步<a href="https://github.com/crazycodeboy/TakePhoto" target="_blank" rel="noopener">TakePhoto开源框架</a>看说明文档，写的很清楚。最后会给出一个工具类，拷贝过去就可以直接用。</p><ol><li>定义两个变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private TakePhoto takePhoto;</span><br><span class="line">private InvokeParam invokeParam;</span><br></pre></td></tr></table></figure><ol><li>添加如下代码获取TakePhoto实例</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public TakePhoto getTakePhoto()&#123;</span><br><span class="line">    if (takePhoto==null)&#123;</span><br><span class="line">      takePhoto= (TakePhoto) TakePhotoInvocationHandler.of(this).bind(new TakePhotoImpl(this,this));</span><br><span class="line">    &#125;</span><br><span class="line">    //设置压缩规则，最大500kb</span><br><span class="line">    takePhoto.onEnableCompress(new CompressConfig.Builder().setMaxSize(500 * 1024).create(), true);</span><br><span class="line">    return takePhoto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>实现两个接口：TakePhoto.TakeResultListener,InvokeListener</li><li>在 onCreate,onActivityResult,onSaveInstanceState方法中调用TakePhoto对用的方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    getTakePhoto().onCreate(savedInstanceState);</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    getTakePhoto().onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    super.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">    getTakePhoto().onSaveInstanceState(outState);</span><br><span class="line">    super.onSaveInstanceState(outState);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>重写TPermissionType invoke(InvokeParam invokeParam)方法，添加如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;</span><br><span class="line">    super.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    //以下代码为处理Android6.0、7.0动态权限所需</span><br><span class="line">    PermissionManager.TPermissionType type=PermissionManager.onRequestPermissionsResult(requestCode,permissions,grantResults);</span><br><span class="line">    PermissionManager.handlePermissionsResult(this,type,invokeParam,this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public PermissionManager.TPermissionType invoke(InvokeParam invokeParam) &#123;</span><br><span class="line">    PermissionManager.TPermissionType type=PermissionManager.checkPermission(TContextWrap.of(this),invokeParam.getMethod());</span><br><span class="line">    if(PermissionManager.TPermissionType.WAIT.equals(type))&#123;</span><br><span class="line">      this.invokeParam=invokeParam;</span><br><span class="line">    &#125;</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;到这里，根据他官方的介绍就已经全部写完了，然后怎么分调用相机，相册还是文件夹呢？</p><ol><li>调用不同的方法，常用的：相机，相册，多选</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    flag = getIntent().getIntExtra(&quot;flag&quot;, 0);</span><br><span class="line">    File file = new File(getExternalCacheDir(), System.currentTimeMillis() + &quot;.png&quot;);</span><br><span class="line">    Uri uri = Uri.fromFile(file);</span><br><span class="line">    int size = Math.min(getResources().getDisplayMetrics().widthPixels, getResources().getDisplayMetrics().heightPixels);</span><br><span class="line">    CropOptions cropOptions = new CropOptions.Builder().setOutputX(size).setOutputX(size).setWithOwnCrop(false).create();</span><br><span class="line">    if (flag == 1) &#123;</span><br><span class="line">      //相机获取照片并剪裁</span><br><span class="line">      takePhoto.onPickFromCaptureWithCrop(uri, cropOptions);</span><br><span class="line">      //相机获取不剪裁</span><br><span class="line">      //takePhoto.onPickFromCapture(uri);</span><br><span class="line">    &#125; else if (flag == 2) &#123;</span><br><span class="line">      //相册获取照片并剪裁</span><br><span class="line">      takePhoto.onPickFromGalleryWithCrop(uri, cropOptions);</span><br><span class="line">      //相册获取不剪裁</span><br><span class="line">//      takePhoto.onPickFromGallery();</span><br><span class="line">    &#125; else if (flag == 3) &#123;</span><br><span class="line">      //多选，并剪裁</span><br><span class="line">      takePhoto.onPickMultipleWithCrop(9, cropOptions);</span><br><span class="line">      //多选，不剪裁</span><br><span class="line">//      takePhoto.onPickMultiple(9);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面一个页面调用startActivityForResult，传一个标记过来，用来判断调用不同的方式。</p><p>&emsp;&emsp;我这里还想多说的是，一般我们这个拍照功能，都有三个选项，拍照，相册，取消，从底部弹出。这个我估计还是大部分人写的动画实现的。我想说的是<strong><em>BottomSheetDialog</em></strong>，这个是MD推出的一个控件，现在微信用的就是这个，用起来也非常方便，简单。</p><p>&emsp;&emsp;至于，工具类，直接下载项目，把对应的TakePhotoActivity文件拷贝过去就可以了。</p><p><a href="http://download.csdn.net/download/qq_27634797/10272409" target="_blank" rel="noopener">资源链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在写项目框架Andoroid 6.0，动态获取权限的时候就提到过&lt;a href=&quot;https://github.com/crazycodeboy/TakePhoto&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TakePhoto开源框架&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
</feed>
