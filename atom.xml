<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haichenyi.com/"/>
  <updated>2018-03-02T12:16:22.942Z</updated>
  <id>http://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android图片压缩——Luban鲁班压缩</title>
    <link href="http://haichenyi.com/2018/03/02/Android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E2%80%94%E2%80%94Luban%E9%B2%81%E7%8F%AD%E5%8E%8B%E7%BC%A9/"/>
    <id>http://haichenyi.com/2018/03/02/Android图片压缩——Luban鲁班压缩/</id>
    <published>2018-03-02T12:14:04.000Z</published>
    <updated>2018-03-02T12:16:22.942Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Android让人头疼的OOM，造成OOM的原因之一就是图片，现在的手机像素越来越高，随便一张图片都是好几M，甚至几十M，这样的照片加载到app，可想而知，随便加载几张图片，手机内存就不够用了，自然而然就造成了OOM，所以，Android的图片压缩异常重要。这里，我推荐一款开源框架——<a href="https://github.com/Curzibn/Luban" target="_blank" rel="noopener">Luban</a></p><a id="more"></a><h2 id="效果与对比"><a href="#效果与对比" class="headerlink" title="效果与对比"></a>效果与对比</h2><p>&emsp;&emsp;这里就不放效果图了，我拷贝了鲁班github上面的介绍——Android图片压缩工具，仿微信朋友圈压缩策略，因为是逆向推算，效果还没法跟微信一模一样，但是已经很接近微信朋友圈压缩后的效果，具体看以下对比！</p><table><thead><tr><th style="text-align:center">内容</th><th style="text-align:center">原图</th><th style="text-align:center">Luban</th><th style="text-align:center">Wechat</th></tr></thead><tbody><tr><td style="text-align:center">截屏 720P</td><td style="text-align:center">720*1280,390k</td><td style="text-align:center">720*1280,87k</td><td style="text-align:center">720*1280,56k</td></tr><tr><td style="text-align:center">截屏 1080P</td><td style="text-align:center">1080*1920,2.21M</td><td style="text-align:center">1080*1920,104k</td><td style="text-align:center">1080*1920,112k</td></tr><tr><td style="text-align:center">拍照 13M(4:3)</td><td style="text-align:center">3096*4128,3.12M</td><td style="text-align:center">1548*2064,141k</td><td style="text-align:center">1548*2064,147k</td></tr><tr><td style="text-align:center">拍照 9.6M(16:9)</td><td style="text-align:center">4128*2322,4.64M</td><td style="text-align:center">1032*581,97k</td><td style="text-align:center">1032*581,74k</td></tr><tr><td style="text-align:center">滚动截屏</td><td style="text-align:center">1080*6433,1.56M</td><td style="text-align:center">1080*6433,351k</td><td style="text-align:center">1080*6433,482k</td></tr></tbody></table><p>从这里就能看出，效果还是非常不错的</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;top.zibin:Luban:1.1.3&apos;</span><br></pre></td></tr></table></figure><h2 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h2><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>&emsp;&emsp;Luban内部采用IO线程进行图片压缩，外部调用只需设置好结果监听即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Luban.with(this)</span><br><span class="line">        .load(photos)                                   // 传人要压缩的图片列表</span><br><span class="line">        .ignoreBy(100)                                  // 忽略不压缩图片的大小</span><br><span class="line">        .setTargetDir(getPath())                        // 设置压缩后文件存储位置</span><br><span class="line">        .setCompressListener(new OnCompressListener() &#123; //设置回调</span><br><span class="line">          @Override</span><br><span class="line">          public void onStart() &#123;</span><br><span class="line">            // TODO 压缩开始前调用，可以在方法内启动 loading UI</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onSuccess(File file) &#123;</span><br><span class="line">            // TODO 压缩成功后调用，返回压缩后的图片文件</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onError(Throwable e) &#123;</span><br><span class="line">            // TODO 当压缩过程出现问题时调用</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).launch();    //启动压缩</span><br></pre></td></tr></table></figure><h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>&emsp;&emsp;同步方法请尽量避免在主线程调用以免阻塞主线程，下面以rxJava调用为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(photos)</span><br><span class="line">    .observeOn(Schedulers.io())</span><br><span class="line">    .map(new Function&lt;List&lt;String&gt;, List&lt;File&gt;&gt;() &#123;</span><br><span class="line">      @Override public List&lt;File&gt; apply(@NonNull List&lt;String&gt; list) throws Exception &#123;</span><br><span class="line">        // 同步方法直接返回压缩后的文件</span><br><span class="line">        return Luban.with(MainActivity.this).load(list).get();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上，均是它github上面说明都有的，我这里就是copy过来了而已。重点要说的是，他是怎么实现的，源码分析。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="第一步：Luban-with"><a href="#第一步：Luban-with" class="headerlink" title="第一步：Luban.with()"></a>第一步：<strong><em>Luban.with()</em></strong></h3><p>点击去看到源码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Builder with(Context context) &#123;</span><br><span class="line">    return new Builder(context);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里是一个静态的with方法，返回值是Builder，一般对设计模式比较熟悉的人，看到这里就应该懂了，他这里使用的是建造者模式。什么是建造者模式呢？建造者模式和工厂模式很相似，比工厂模式多了一个控制类，其实说白了，就是在创建对象的时候，减少初始化数据的代码，怎么理解呢？我们接着往下看。我们点到Builder里面看到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static class Builder &#123;</span><br><span class="line">    private Context context;//上下文对象</span><br><span class="line">    private String mTargetDir;//压缩后图片存放位置</span><br><span class="line">    private List&lt;String&gt; mPaths;//多个文件的list</span><br><span class="line">    private int mLeastCompressSize = 100;//忽略100kb以下的图片，不压缩</span><br><span class="line">    private OnCompressListener mCompressListener;//回调方法</span><br><span class="line"></span><br><span class="line">    Builder(Context context) &#123;</span><br><span class="line">      this.context = context;</span><br><span class="line">      this.mPaths = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Luban build() &#123;</span><br><span class="line">      return new Luban(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看到了是一个静态的内部类Builder，我们这里看到了有5个变量，上面我们说道了，为了减少初始化数据的代码，就拿这个举例子说明，我如果有4个地方调用这个鲁班压缩，其中这4个地方，mTargetDir，mLeastCompressSize这2个变量的值都是一样的，其他3个不一样，按照我们以往的写法都得一个一个的赋值，要写4遍，那如果使用建造者模式了，这里就只用写一遍赋值，这2个变量。其他3个不一样，就得写多遍。当然，这是我个人对于建造者模式的理解。</p><p>&emsp;&emsp;我上面多粘贴了一个<strong><em>build()</em></strong>方法，为什么会多粘贴一个呢？就是为了更好的说明建造者模式，我们可以看到他这个方法，返回的是Luban对象，调用的是需要传Builder的构造方法，我们点进去看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Luban(Builder builder) &#123;</span><br><span class="line">    this.mPaths = builder.mPaths;</span><br><span class="line">    this.mTargetDir = builder.mTargetDir;</span><br><span class="line">    this.mCompressListener = builder.mCompressListener;</span><br><span class="line">    this.mLeastCompressSize = builder.mLeastCompressSize;</span><br><span class="line">    mHandler = new Handler(Looper.getMainLooper(), this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;他这里就是赋值，他这个值就是Builder里面默认的，我们不论在哪里调用这个方法，都不用去一个一个赋值，因为，他已经处理好了。</p><h3 id="第二步：load"><a href="#第二步：load" class="headerlink" title="第二步：load()"></a>第二步：<strong><em>load()</em></strong></h3><p>点击去看到源码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Builder load(File file) &#123;</span><br><span class="line">      this.mPaths.add(file.getAbsolutePath());</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder load(String string) &#123;</span><br><span class="line">      this.mPaths.add(string);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder load(List&lt;String&gt; list) &#123;</span><br><span class="line">      this.mPaths.addAll(list);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里，我们会看到三个重载方法，一个传文件，他会获取到文件的绝对路径存进去，实际上还是存的字符串，中间那个存的是字符串，最后面那个传String类型的list，它调用的addAll方法，最后还是存的String在mPaths里面。我们点击mPaths，他就是一个String类型的list，在Builder的构造方法里面初始化的。他就是存放你的图片路径的集合</p><h3 id="第三步：ignoreBy-和-setTargetDir"><a href="#第三步：ignoreBy-和-setTargetDir" class="headerlink" title="第三步：ignoreBy() 和 setTargetDir()"></a>第三步：<strong><em>ignoreBy()</em></strong> 和 <strong><em>setTargetDir()</em></strong></h3><p>点击去看到源码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * do not compress when the origin image file size less than one value</span><br><span class="line"> *</span><br><span class="line"> * @param size</span><br><span class="line"> *     the value of file size, unit KB, default 100K</span><br><span class="line"> */</span><br><span class="line">public Builder ignoreBy(int size) &#123;</span><br><span class="line">  this.mLeastCompressSize = size;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Builder setTargetDir(String targetDir) &#123;</span><br><span class="line">  this.mTargetDir = targetDir;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这两个我为啥要放在一起讲呢？因为这两个没啥好说的，都是设置值，跟我们平时写的set方法的作用是一样的。没啥好说的</p><h3 id="第四步：setCompressListener-OnCompressListener-listener"><a href="#第四步：setCompressListener-OnCompressListener-listener" class="headerlink" title="第四步：setCompressListener(OnCompressListener listener)"></a>第四步：<strong><em>setCompressListener(OnCompressListener listener)</em></strong></h3><p>点击去看到源码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Builder setCompressListener(OnCompressListener listener) &#123;</span><br><span class="line">      this.mCompressListener = listener;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个就是我们平时写自定义view的时候，要写回调方法，是一样的道理，他这里就是压缩方法的回调</p><h3 id="第五步：launch"><a href="#第五步：launch" class="headerlink" title="第五步：launch()"></a>第五步：<strong><em>launch()</em></strong></h3><p>点击去看到源码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * begin compress image with asynchronous</span><br><span class="line"> */</span><br><span class="line">public void launch() &#123;</span><br><span class="line">  build().launch(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里，我们看到他先调用了build(),我们前面讲了，他这个方法就是赋值，然后调用了launch(context)方法，我们点进去看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * start asynchronous compress thread</span><br><span class="line">   */</span><br><span class="line">  @UiThread private void launch(final Context context) &#123;</span><br><span class="line">    if (mPaths == null || mPaths.size() == 0 &amp;&amp; mCompressListener != null) &#123;</span><br><span class="line">      mCompressListener.onError(new NullPointerException(&quot;image file cannot be null&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = mPaths.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">      final String path = iterator.next();</span><br><span class="line">      if (Checker.isImage(path)) &#123;</span><br><span class="line">        AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() &#123;</span><br><span class="line">          @Override public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_START));</span><br><span class="line"></span><br><span class="line">              File result = Checker.isNeedCompress(mLeastCompressSize, path) ?</span><br><span class="line">                  new Engine(path, getImageCacheFile(context, Checker.checkSuffix(path))).compress() :</span><br><span class="line">                  new File(path);</span><br><span class="line"></span><br><span class="line">              mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_SUCCESS, result));</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">              mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_ERROR, e));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Log.e(TAG, &quot;can not read the path : &quot; + path);</span><br><span class="line">      &#125;</span><br><span class="line">      iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法就是最后，执行压缩的方法，前面都是初始化，我们可以看到，他这个方法是在主线程调用的，所以，我们不用考虑切换线程的问题，直接可以操作UI变化。我一步一步的讲：</p><ol><li>首先，他这个是用的迭代器，循环遍历，遍历一个就移除一个</li><li>然后就是通过handler发消息调用</li><li>具体压缩代码。最重要的就是第三点，我把第三点，提到下面讲</li></ol><p>接着上面的第三点，具体压缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File result = Checker.isNeedCompress(mLeastCompressSize, path) ?</span><br><span class="line">                  new Engine(path, getImageCacheFile(context, Checker.checkSuffix(path))).compress() :</span><br><span class="line">                  new File(path);</span><br></pre></td></tr></table></figure><p>首先，他整体是一个三目运算符，我们点isNeedCompress()方法看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static boolean isNeedCompress(int leastCompressSize, String path) &#123;</span><br><span class="line">    if (leastCompressSize &gt; 0) &#123;</span><br><span class="line">      File source = new File(path);</span><br><span class="line">      if (!source.exists()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (source.length() &lt;= (leastCompressSize &lt;&lt; 10)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法就是用来判断，你给定路径的图片大小和你规定的忽略文件大小比较，他这里先做了你给定的最小值判断，要大于0，不大于0就返回ture。然后做了文件是否存在的判断，如果文件不存在，就返回fals。最后，给定文件大小是不是小于等于最小值左移10位的值，小于就返回false。</p><p>然后，如果返回的是true，就去压缩，如果，返回的是false，就直接返回file文件。压缩的方法点进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Engine(String srcImg, File tagImg) throws IOException &#123;</span><br><span class="line">    if (Checker.isJPG(srcImg)) &#123;</span><br><span class="line">      this.srcExif = new ExifInterface(srcImg);</span><br><span class="line">    &#125;</span><br><span class="line">    this.tagImg = tagImg;</span><br><span class="line">    this.srcImg = srcImg;</span><br><span class="line"></span><br><span class="line">    BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = true;</span><br><span class="line">    options.inSampleSize = 1;</span><br><span class="line"></span><br><span class="line">    BitmapFactory.decodeFile(srcImg, options);</span><br><span class="line">    this.srcWidth = options.outWidth;</span><br><span class="line">    this.srcHeight = options.outHeight;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这就又要说道另一个类了Engine类，它的类注释就是：用于操作，开始压缩，管理活动，缓存资源的类。他这里传原文件，也就是你需要压缩的图片，还有一个就是目标文件，也就是你压缩之后，要保存的文件。</p><p>&emsp;&emsp;我们先看第二个参数是什么怎么传的，有的人看不懂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Returns a mFile with a cache audio name in the private cache directory.</span><br><span class="line">   *</span><br><span class="line">   * @param context</span><br><span class="line">   *     A context.</span><br><span class="line">   */</span><br><span class="line">  private File getImageCacheFile(Context context, String suffix) &#123;</span><br><span class="line">    if (TextUtils.isEmpty(mTargetDir)) &#123;</span><br><span class="line">      mTargetDir = getImageCacheDir(context).getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String cacheBuilder = mTargetDir + &quot;/&quot; +</span><br><span class="line">        System.currentTimeMillis() +</span><br><span class="line">        (int) (Math.random() * 1000) +</span><br><span class="line">        (TextUtils.isEmpty(suffix) ? &quot;.jpg&quot; : suffix);</span><br><span class="line"></span><br><span class="line">    return new File(cacheBuilder);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;他这里就是新建一个文件，设置路径，设置名称，然后返回文件</p><p>&emsp;&emsp;再掉回去看Engine的构造方法，我们这里获取到了源文件和目标文件，我们只用把压缩后的流存到目标文件就行了。我之前写过一篇关于图片压缩的博客。它这里的option就是设置压缩的参数，不懂的可以看一下我之前的博客，或者用google百度一下就知道了。具体压缩就是用的bitmap的工厂类，调用的decodeFile方法。没错就是这一句 <strong><em>BitmapFactory.decodeFile(srcImg, options);</em></strong></p><p>最后，辣么一切都准备就绪了，怎么样开始压缩呢？<strong><em>compress()</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">File compress() throws IOException &#123;</span><br><span class="line">    BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">    options.inSampleSize = computeSize();</span><br><span class="line"></span><br><span class="line">    Bitmap tagBitmap = BitmapFactory.decodeFile(srcImg, options);</span><br><span class="line">    ByteArrayOutputStream stream = new ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">    tagBitmap = rotatingImage(tagBitmap);</span><br><span class="line">    tagBitmap.compress(Bitmap.CompressFormat.JPEG, 60, stream);</span><br><span class="line">    tagBitmap.recycle();</span><br><span class="line"></span><br><span class="line">    FileOutputStream fos = new FileOutputStream(tagImg);</span><br><span class="line">    fos.write(stream.toByteArray());</span><br><span class="line">    fos.flush();</span><br><span class="line">    fos.close();</span><br><span class="line">    stream.close();</span><br><span class="line"></span><br><span class="line">    return tagImg;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里面就是常规的压缩，存储的逻辑了，最最重要的压缩算法呢？就是这里的<strong><em>computeSize()</em></strong>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private int computeSize() &#123;</span><br><span class="line">    srcWidth = srcWidth % 2 == 1 ? srcWidth + 1 : srcWidth;</span><br><span class="line">    srcHeight = srcHeight % 2 == 1 ? srcHeight + 1 : srcHeight;</span><br><span class="line"></span><br><span class="line">    int longSide = Math.max(srcWidth, srcHeight);</span><br><span class="line">    int shortSide = Math.min(srcWidth, srcHeight);</span><br><span class="line"></span><br><span class="line">    float scale = ((float) shortSide / longSide);</span><br><span class="line">    if (scale &lt;= 1 &amp;&amp; scale &gt; 0.5625) &#123;</span><br><span class="line">      if (longSide &lt; 1664) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">      &#125; else if (longSide &gt;= 1664 &amp;&amp; longSide &lt; 4990) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">      &#125; else if (longSide &gt; 4990 &amp;&amp; longSide &lt; 10240) &#123;</span><br><span class="line">        return 4;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return longSide / 1280 == 0 ? 1 : longSide / 1280;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (scale &lt;= 0.5625 &amp;&amp; scale &gt; 0.5) &#123;</span><br><span class="line">      return longSide / 1280 == 0 ? 1 : longSide / 1280;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return (int) Math.ceil(longSide / (1280.0 / scale));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Bitmap rotatingImage(Bitmap bitmap) &#123;</span><br><span class="line">    if (srcExif == null) return bitmap;</span><br><span class="line"></span><br><span class="line">    Matrix matrix = new Matrix();</span><br><span class="line">    int angle = 0;</span><br><span class="line">    int orientation = srcExif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);</span><br><span class="line">    switch (orientation) &#123;</span><br><span class="line">      case ExifInterface.ORIENTATION_ROTATE_90:</span><br><span class="line">        angle = 90;</span><br><span class="line">        break;</span><br><span class="line">      case ExifInterface.ORIENTATION_ROTATE_180:</span><br><span class="line">        angle = 180;</span><br><span class="line">        break;</span><br><span class="line">      case ExifInterface.ORIENTATION_ROTATE_270:</span><br><span class="line">        angle = 270;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix.postRotate(angle);</span><br><span class="line"></span><br><span class="line">    return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;你以为我会一步一步给你讲<a href="https://github.com/Curzibn/Luban/blob/master/DESCRIPTION.md" target="_blank" rel="noopener">Luban算法逻辑</a>吗？那是不可能的，我特么都不会，怎么给你讲。我直接把他github上算法逻辑的介绍拷贝过来了：</p><ol><li>判断图片比例值，是否处于以下区间内；</li></ol><ul><li>[1, 0.5625) 即图片处于 [1:1 ~ 9:16) 比例范围内</li><li>[0.5625, 0.5) 即图片处于 [9:16 ~ 1:2) 比例范围内</li><li>[0.5, 0) 即图片处于 [1:2 ~ 1:∞) 比例范围内</li></ul><ol><li>判断图片最长边是否过边界值；</li></ol><ul><li>[1, 0.5625) 边界值为：1664 <em> n（n=1）, 4990 </em> n（n=2）, 1280 * pow(2, n-1)（n≥3）</li><li>[0.5625, 0.5) 边界值为：1280 * pow(2, n-1)（n≥1）</li><li>[0.5, 0) 边界值为：1280 * pow(2, n-1)（n≥1）</li></ul><ol><li>计算压缩图片实际边长值，以第2步计算结果为准，超过某个边界值则：width / pow(2, n-1)，height/pow(2, n-1)</li><li>计算压缩图片的实际文件大小，以第2、3步结果为准，图片比例越大则文件越大。<br>size = (newW <em> newH) / (width </em> height) * m；</li></ol><ul><li>[1, 0.5625) 则 width &amp; height 对应 1664，4990，1280 * n（n≥3），m 对应 150，300，300；</li><li>[0.5625, 0.5) 则 width = 1440，height = 2560, m = 200；</li><li>[0.5, 0) 则 width = 1280，height = 1280 / scale，m = 500；注：scale为比例值</li></ul><ol><li>判断第4步的size是否过小</li></ol><ul><li>[1, 0.5625) 则最小 size 对应 60，60，100</li><li>[0.5625, 0.5) 则最小 size 都为 100</li><li>[0.5, 0) 则最小 size 都为 100</li></ul><ol><li>将前面求到的值压缩图片 width, height, size 传入压缩流程，压缩图片直到满足以上数值</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Android让人头疼的OOM，造成OOM的原因之一就是图片，现在的手机像素越来越高，随便一张图片都是好几M，甚至几十M，这样的照片加载到app，可想而知，随便加载几张图片，手机内存就不够用了，自然而然就造成了OOM，所以，Android的图片压缩异常重要。这里，我推荐一款开源框架——&lt;a href=&quot;https://github.com/Curzibn/Luban&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Luban&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="http://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>从从零开始搭建一个主流项目框架（八）—— 私有目录被限制访问(Android 7.0)</title>
    <link href="http://haichenyi.com/2018/03/01/%E4%BB%8E%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E7%A7%81%E6%9C%89%E7%9B%AE%E5%BD%95%E8%A2%AB%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE-Android7.0/"/>
    <id>http://haichenyi.com/2018/03/01/从从零开始搭建一个主流项目框架（八）—私有目录被限制访问-Android7.0/</id>
    <published>2018-03-01T15:22:01.000Z</published>
    <updated>2018-03-01T15:29:41.854Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;我这里只说我关心的问题，并不是说Android 7.0只增加了一个“私有目录被限制访问”，当然还有其他的变化。android 7.0的新特性中，对程序员开发造成最直接的变化就是<strong>FileUriExposedException</strong>异常，这个异常的产生就是由<strong>私有目录被限制访问</strong>造成的</p><a id="more"></a><p>&emsp;&emsp;Andoird 7.0中为了提高文件的安全性，面向Android N或者更高版本的应用私有目录将会被禁止访问，常见最直接的bug就是：<strong>你的应用给其他应用传递file:// URI类型的Uri时，可能导致接受者无法访问该路径</strong>会造成我们前面说的文件uri异常。</p><h3 id="调用系统相机"><a href="#调用系统相机" class="headerlink" title="调用系统相机"></a>调用系统相机</h3><p>最直接的就是我们常用的拍照功能,我们自己的应用启动手机相机，这里手机相机就是其他应用，按照我们以前的写法就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);</span><br><span class="line">if (!file.getParentFile().exists())file.getParentFile().mkdirs();</span><br><span class="line">Uri imageUri = Uri.fromFile(file);</span><br><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);//设置Action为拍照</span><br><span class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);//将拍取的照片保存到指定URI</span><br><span class="line">startActivityForResult(intent,986);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;先创建一个存放我们拍照图片的存放file，参数就是路径+文件名称，当我们还是按之前的写法，跑在android N及以上的机型的时候，会报如下异常：</p><p>FileUriExposedException.png</p><p>&emsp;&emsp;这就是由于Android 7.0执行了“StrictMode API 政策禁”对我们广大程序员造成的最常见，最直接的结果。辣么，怎么解决呢？</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h4><p>使用FileProvider解决上面的问题，步骤如下：</p><h5 id="第一步：在清单文件里面申请provider"><a href="#第一步：在清单文件里面申请provider" class="headerlink" title="第一步：在清单文件里面申请provider"></a>第一步：在清单文件里面申请provider</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name=&quot;android.support.v4.content.FileProvider&quot;</span><br><span class="line">    android:authorities=&quot;com.haichenyi.myproject.fileprovider&quot;</span><br><span class="line">    android:grantUriPermissions=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;false&quot;&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;</span><br><span class="line">        android:resource=&quot;@xml/file_paths&quot; /&gt;</span><br><span class="line">&lt;/provider&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;FileProvider是V4包下面的类，这里exproted属性必须给false，不然也会报异常，grantUriPermissions的值给true，表示授予临时URI访问权限，下面meta-data就是指定共享目录，authorities属性后面讲</p><h4 id="第二步：指定共享目录"><a href="#第二步：指定共享目录" class="headerlink" title="第二步：指定共享目录"></a>第二步：指定共享目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;path&gt;</span><br><span class="line">        &lt;external-path</span><br><span class="line">            name=&quot;camera_photos&quot;</span><br><span class="line">            path=&quot;&quot;/&gt;</span><br><span class="line">    &lt;/path&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有点android开发基础的人就知道，这个@xml目录是位于res根目录，跟layout目录平级的。所以，你得先创建xml文件夹，然后新建file_paths文件，添加上面的代码在文件中。这里的path路径，我们先瞅瞅下面的表：</p><table><thead><tr><th style="text-align:center">物理路径</th><th style="text-align:center">写法</th></tr></thead><tbody><tr><td style="text-align:center">Context.getFilesDir() + /path/</td><td style="text-align:center"><strong><files-path name="name" path="path"></files-path></strong></td></tr><tr><td style="text-align:center">Context.getCacheDir() + /path/</td><td style="text-align:center"><strong><cache-path name="name" path="path"></cache-path></strong></td></tr><tr><td style="text-align:center">Environment.getExternalStorageDirectory() + /path/</td><td style="text-align:center"><strong><external-path name="name" path="path"></external-path></strong></td></tr><tr><td style="text-align:center">Context.getExternalFilesDir(String) + /path/</td><td style="text-align:center"><strong><external-files-path name="name" path="path"></external-files-path></strong></td></tr><tr><td style="text-align:center">Context.getExternalCacheDir() + /path/</td><td style="text-align:center"><strong><external-cache-path name="name" path="path"></external-cache-path></strong></td></tr></tbody></table><p>&emsp;&emsp;辣么，我们代码中path=””，是有特殊意义的，它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为path=”pictures”， 那么它代表着根目录下的pictures目录(eg:/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的</p><h4 id="第三步：使用FileProvider"><a href="#第三步：使用FileProvider" class="headerlink" title="第三步：使用FileProvider"></a>第三步：使用FileProvider</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val file = File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot; + System.currentTimeMillis() + &quot;.jpg&quot;)</span><br><span class="line">        if (!file.parentFile.exists()) file.parentFile.mkdirs()</span><br><span class="line">        //变化</span><br><span class="line">        val imageUri = FileProvider.getUriForFile(this, &quot;com.haichenyi.myproject.fileprovider&quot;, file)//通过FileProvider创建一个content类型的Uri</span><br><span class="line">        val intent = Intent()</span><br><span class="line">        //变化</span><br><span class="line">        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION) //添加这一句表示对目标应用临时授权该Uri所代表的文件</span><br><span class="line">        intent.action = MediaStore.ACTION_IMAGE_CAPTURE//设置Action为拍照</span><br><span class="line">        intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri)//将拍取的照片保存到指定URI</span><br><span class="line">        startActivityForResult(intent, 986)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们调用系统相机的代码发生了变化，变化的位置，我都注明了获取imageUri的方式发生了变化，其中，第二个参数就是我们在前面说放在后面讲的authorities属性的内容，再就是增加了一个flag，表示临时授权。加上如上代码，我们就可以正常调用系统相机了。</p><p>&emsp;&emsp;经过如上步骤之后，我们就能拍照了，拍完照片之后的存放路径在哪里呢？我们前面说了，这里我打印出了路径，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file!!.absolutePath:/storage/emulated/0/temp/1519896174785.jpg</span><br><span class="line"></span><br><span class="line">imageUri:content://com.haichenyi.myproject.fileprovider/camera_photos/temp/1519896174785.jpg</span><br></pre></td></tr></table></figure><h3 id="照片裁剪"><a href="#照片裁剪" class="headerlink" title="照片裁剪"></a>照片裁剪</h3><p>Android 7.0之前，我们裁剪照片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);</span><br><span class="line">if (!file.getParentFile().exists())file.getParentFile().mkdirs();</span><br><span class="line">Uri outputUri = Uri.fromFile(file);</span><br><span class="line">Uri imageUri=Uri.fromFile(new File(&quot;/storage/emulated/0/temp/1519896174785.jpg&quot;));</span><br><span class="line">Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);</span><br><span class="line">intent.setDataAndType(imageUri, &quot;image/*&quot;);</span><br><span class="line">intent.putExtra(&quot;crop&quot;, &quot;true&quot;);</span><br><span class="line">intent.putExtra(&quot;aspectX&quot;, 1);</span><br><span class="line">intent.putExtra(&quot;aspectY&quot;, 1);</span><br><span class="line">intent.putExtra(&quot;scale&quot;, true);</span><br><span class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri);</span><br><span class="line">intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());</span><br><span class="line">intent.putExtra(&quot;noFaceDetection&quot;, true); // no face detection</span><br><span class="line">startActivityForResult(intent,987);</span><br></pre></td></tr></table></figure><p>Android 7.0之后，我们裁剪照片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);</span><br><span class="line">if (!file.getParentFile().exists())file.getParentFile().mkdirs();</span><br><span class="line">Uri outputUri = FileProvider.getUriForFile(context, &quot;com.haichenyi.myproject.fileprovider&quot;,file);</span><br><span class="line">Uri imageUri=FileProvider.getUriForFile(context, &quot;com.haichenyi.myproject.fileprovider&quot;, new File(&quot;/storage/emulated/0/temp/1519896174785.jpg&quot;);//通过FileProvider创建一个content类型的Uri</span><br><span class="line">Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);</span><br><span class="line">intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">intent.setDataAndType(imageUri, &quot;image/*&quot;);</span><br><span class="line">intent.putExtra(&quot;crop&quot;, &quot;true&quot;);</span><br><span class="line">intent.putExtra(&quot;aspectX&quot;, 1);</span><br><span class="line">intent.putExtra(&quot;aspectY&quot;, 1);</span><br><span class="line">intent.putExtra(&quot;scale&quot;, true);</span><br><span class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri);</span><br><span class="line">intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());</span><br><span class="line">intent.putExtra(&quot;noFaceDetection&quot;, true); // no face detection</span><br><span class="line">startActivityForResult(intent,987);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;拍照裁剪这是一个很常用的功能，很早之前就写过一篇，封装的不是很好。最近，又做了一遍这个功能，发现了一个好用的框架——<a href="https://github.com/crazycodeboy/TakePhoto" target="_blank" rel="noopener">TakePhoto</a></p><p><a href="http://download.csdn.net/download/qq_27634797/10265743" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;我这里只说我关心的问题，并不是说Android 7.0只增加了一个“私有目录被限制访问”，当然还有其他的变化。android 7.0的新特性中，对程序员开发造成最直接的变化就是&lt;strong&gt;FileUriExposedException&lt;/strong&gt;异常，这个异常的产生就是由&lt;strong&gt;私有目录被限制访问&lt;/strong&gt;造成的&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（七）—— 权限申请(Android 6.0)</title>
    <link href="http://haichenyi.com/2018/03/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7-Android6.0/"/>
    <id>http://haichenyi.com/2018/03/01/从零开始搭建一个主流项目框架（七）—权限申请-Android6.0/</id>
    <published>2018-03-01T15:21:35.000Z</published>
    <updated>2018-03-01T15:30:26.841Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;总所周知，Android 6.0以上的版本，google对权限做了更严格的限制，不能app自动给权限，必须要让用户选择是否给权限。如果，用户不给权限，辣么，用这个功能的时候，app会造成崩溃，所以，最简单的办法就是，用户不给权限，不让用户用这个功能，也就是页面不做跳转。</p><a id="more"></a><p>&emsp;&emsp;当时，刚出来这个权限问题的时候，本人用原生的写，写了封装，搞了好长时间，总感觉各种不爽，各种不舒服，后来好了，大牛封装了一个开源框架——<a href="https://github.com/tbruyelle/RxPermissions" target="_blank" rel="noopener">RxPermission</a>，一行代码解决动态申请权限问题。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar&apos;</span><br></pre></td></tr></table></figure><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.utils</span><br><span class="line"></span><br><span class="line">import android.app.Activity</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.net.Uri</span><br><span class="line">import android.os.Build</span><br><span class="line">import android.os.Environment</span><br><span class="line">import android.provider.Settings</span><br><span class="line">import android.support.v7.app.AlertDialog</span><br><span class="line">import com.haichenyi.myproject.R</span><br><span class="line">import com.tbruyelle.rxpermissions2.RxPermissions</span><br><span class="line">import java.io.File</span><br><span class="line">import java.io.FileInputStream</span><br><span class="line">import java.io.IOException</span><br><span class="line">import java.util.*</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/28</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">object RxPerUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 请求权限的获取方法</span><br><span class="line">     * activity：Activity对象</span><br><span class="line">     * permissions：需要获取的权限，可以传多个</span><br><span class="line">     * aloe: (b: Boolean)：一个参数的回调方法，b为true，表示用户给了权限，false，表示没有给权限</span><br><span class="line">     */</span><br><span class="line">    fun requestPermission(activity: Activity, vararg permissions: String, aloe: (b: Boolean) -&gt; Unit) &#123;</span><br><span class="line">        RxPermissions(activity).request(*permissions)</span><br><span class="line">                .subscribe &#123; aBoolean -&gt; aloe(aBoolean) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 当用户拒绝给权限的时候调用，跳转权限设置页面，让用户手动给权限</span><br><span class="line">     * activity：Activity对象</span><br><span class="line">     * permissionName：权限名称</span><br><span class="line">     * msg：提示信息</span><br><span class="line">     */</span><br><span class="line">    fun setupPermission(activity: Activity, permissionName: String, msg: String,</span><br><span class="line">                        aloe: () -&gt; Unit) &#123;</span><br><span class="line">        AlertDialog.Builder(activity, R.style.Theme_AppCompat_Dialog).setTitle(&quot;权限申请&quot;)</span><br><span class="line">                .setMessage(String.format(Locale.getDefault(),</span><br><span class="line">                        &quot;请在“权限”中开启“%1s权限”，以正常使用%2s&quot;, permissionName, msg))</span><br><span class="line">                .setCancelable(false)</span><br><span class="line">                .setNegativeButton(android.R.string.cancel) &#123; dialog, which -&gt; aloe &#125;.setPositiveButton(&quot;去设置&quot;) &#123; dialog, which -&gt;</span><br><span class="line">            if (isMiUi()) &#123;</span><br><span class="line">                setMiUiPermissions(activity)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                activity.startActivityForResult(Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)</span><br><span class="line">                        .setData(Uri.fromParts(&quot;package&quot;, activity.packageName, null)), 1000)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.create().show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun setMiUiPermissions(activity: Activity) &#123;</span><br><span class="line">        if (isMiUi()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // MIUI 8</span><br><span class="line">                activity.startActivityForResult(Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;)</span><br><span class="line">                        .setClassName(&quot;com.miui.securitycenter&quot;,</span><br><span class="line">                                &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;)</span><br><span class="line">                        .putExtra(&quot;extra_pkgname&quot;, activity.packageName), 1000)</span><br><span class="line">            &#125; catch (e: Exception) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // MIUI 5/6/7</span><br><span class="line">                    activity.startActivityForResult(Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;)</span><br><span class="line">                            .setClassName(&quot;com.miui.securitycenter&quot;,</span><br><span class="line">                                    &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;)</span><br><span class="line">                            .putExtra(&quot;extra_pkgname&quot;, activity.packageName), 1000)</span><br><span class="line">                &#125; catch (e1: Exception) &#123;</span><br><span class="line">                    // 否则跳转到应用详情</span><br><span class="line">                    activity.startActivityForResult(Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)</span><br><span class="line">                            .setData(Uri.fromParts(&quot;package&quot;, activity.packageName,</span><br><span class="line">                                    null)), 1000)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun isMiUi(): Boolean &#123;</span><br><span class="line">        val device = Build.MANUFACTURER</span><br><span class="line">        if (device == &quot;Xiaomi&quot;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                val prop = Properties()</span><br><span class="line">                prop.load(FileInputStream(File(Environment.getRootDirectory(), &quot;build.prop&quot;)))</span><br><span class="line">                return (prop.getProperty(&quot;ro.miui.ui.version.code&quot;, null) != null</span><br><span class="line">                        || prop.getProperty(&quot;ro.miui.ui.version.name&quot;, null) != null</span><br><span class="line">                        || prop.getProperty(&quot;ro.miui.internal.storage&quot;, null) != null)</span><br><span class="line">            &#125; catch (e: IOException) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RxPerUtils.requestPermission(this, Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE) &#123;</span><br><span class="line">                if (it) &#123;</span><br><span class="line">                    //这里写你自己的逻辑，已经获得权限，做你自己的业务逻辑操作</span><br><span class="line">                    ToastUtils.showTipMsg(&quot;已经获得权限&quot;)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    RxPerUtils.setupPermission(this, &quot;相机和存储&quot;,</span><br><span class="line">                            &quot;相机功能&quot;) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;请求权限的整个过程就是：</p><ol><li>用RxPermission去请求权限，需要传activity对象,然后就是你需要获取的权限（可以传多个），再就是回调方法</li><li>在回调方法里面做判断，用户是否给了权限，如果给了，就走你正常的逻辑。如果没有给，就弹对话框提示用户，去设置页面给权限。</li></ol><p>&emsp;&emsp;就这么简单，方法都封装好了，如果，你嫌弃系统自带的对话框样式不好看，你也可以自己写一个样式。项目就不传了，如果你有之前的代码，就直接把我这几个方法拷贝过去用就可以了，没有之前的代码，就去瞅瞅之前的博客吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;总所周知，Android 6.0以上的版本，google对权限做了更严格的限制，不能app自动给权限，必须要让用户选择是否给权限。如果，用户不给权限，辣么，用这个功能的时候，app会造成崩溃，所以，最简单的办法就是，用户不给权限，不让用户用这个功能，也就是页面不做跳转。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（六）——Socket网络编程</title>
    <link href="http://haichenyi.com/2018/02/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://haichenyi.com/2018/02/26/从零开始搭建一个主流项目框架（六）—Socket网络编程/</id>
    <published>2018-02-26T14:02:22.000Z</published>
    <updated>2018-02-26T14:03:53.771Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Android中常用的网络编程方式：Http和Socket，Http通讯方式，我们在前面已经加到框架里面了，用的是现在主流的RxJava+Retrofit+OkHttp的方式，用起来也很方便。今天，我们来说说Socket网络编程。前面已经有一篇讲过IO和NIO的区别，还有一篇讲过Netty了，今天这篇的目的就是把Netty加到我们这个框架里面。</p><a id="more"></a><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;io.netty:netty-all:5.0.0.Alpha2&apos;</span><br></pre></td></tr></table></figure><p>添加依赖，老生常谈的问题了，我就不多说了。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import android.util.Log</span><br><span class="line">import com.haichenyi.myproject.model.bean.SocketTcpBean</span><br><span class="line">import io.netty.bootstrap.Bootstrap</span><br><span class="line">import io.netty.channel.Channel</span><br><span class="line">import io.netty.channel.ChannelInitializer</span><br><span class="line">import io.netty.channel.ChannelOption</span><br><span class="line">import io.netty.channel.EventLoopGroup</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup</span><br><span class="line">import io.netty.channel.socket.SocketChannel</span><br><span class="line">import io.netty.channel.socket.nio.NioSocketChannel</span><br><span class="line">import io.netty.handler.codec.LineBasedFrameDecoder</span><br><span class="line">import io.netty.handler.codec.string.StringDecoder</span><br><span class="line">import io.netty.handler.codec.string.StringEncoder</span><br><span class="line">import io.netty.util.CharsetUtil</span><br><span class="line">import org.greenrobot.eventbus.EventBus</span><br><span class="line">import org.greenrobot.eventbus.Subscribe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/26</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">class SocketTcp &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private val socket = SocketTcp()</span><br><span class="line">        fun getInstance(): SocketTcp = socket</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private var port: Int = 0</span><br><span class="line">    private var host: String = &quot;&quot;</span><br><span class="line">    private var channel: Channel? = null</span><br><span class="line">    private var group: EventLoopGroup? = null</span><br><span class="line">    fun setPort(port: Int): SocketTcp &#123;</span><br><span class="line">        this.port = port</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun setHost(host: String): SocketTcp &#123;</span><br><span class="line">        this.host = host</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun connect() &#123;</span><br><span class="line">        if (null != channel) return</span><br><span class="line">        if (null == group) &#123;</span><br><span class="line">            if (!EventBus.getDefault().isRegistered(this))</span><br><span class="line">                EventBus.getDefault().register(this)</span><br><span class="line">            group = NioEventLoopGroup()</span><br><span class="line">        &#125;</span><br><span class="line">        val bootstrap = Bootstrap()</span><br><span class="line">        try &#123;</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel::class.java)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                    .handler(object : ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        override fun initChannel(ch: SocketChannel?) &#123;</span><br><span class="line">                            //以换行符为结束标记</span><br><span class="line">                            val pipeline = ch!!.pipeline()</span><br><span class="line">                            pipeline.addLast(&quot;encoder&quot;, StringEncoder(CharsetUtil.UTF_8))</span><br><span class="line">                            pipeline.addLast(LineBasedFrameDecoder(Integer.MAX_VALUE))</span><br><span class="line">                            pipeline.addLast(StringDecoder())</span><br><span class="line">                            pipeline.addLast(HeartTcp())</span><br><span class="line"></span><br><span class="line">                            //以&quot;#_&quot;作为分隔符</span><br><span class="line">                            /*val pipeline = ch!!.pipeline()</span><br><span class="line">                            pipeline.addLast(&quot;encoder&quot;, StringEncoder(CharsetUtil.UTF_8))</span><br><span class="line">                            val s = &quot;#_&quot;</span><br><span class="line">                            val byteBuf = Unpooled.copiedBuffer(s.toByteArray())</span><br><span class="line">                            pipeline.addLast(DelimiterBasedFrameDecoder(Integer.MAX_VALUE, byteBuf))</span><br><span class="line">                            pipeline.addLast(StringDecoder())*/</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            //发起异步连接操作</span><br><span class="line">            val channelFuture = bootstrap.connect(host, port).sync()</span><br><span class="line">            channel = channelFuture.channel()</span><br><span class="line">            //等待服务端监听端口关闭</span><br><span class="line">            channel!!.closeFuture().sync()</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            disConnect()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //连接成功后，通过Channel提供的接口进行IO操作</span><br><span class="line">    fun sendMessage(msg: String) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (channel != null &amp;&amp; channel!!.isOpen) &#123;</span><br><span class="line">                channel!!.writeAndFlush(msg).sync()</span><br><span class="line">                Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw Exception(&quot;channel is null | closed&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            reConnect()</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 断开tcp连接.</span><br><span class="line">     */</span><br><span class="line">    private fun disConnect() &#123;</span><br><span class="line">        if (null != group) &#123;</span><br><span class="line">            group!!.shutdownGracefully()</span><br><span class="line">        &#125;</span><br><span class="line">//        EventBus.getDefault().unregister(this)</span><br><span class="line">        group = null</span><br><span class="line">        channel = null</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;disConnect&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Subscribe</span><br><span class="line">    fun handle(socketTcpBean: SocketTcpBean) &#123;</span><br><span class="line">        sendMessage(socketTcpBean.msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重连.</span><br><span class="line">     */</span><br><span class="line">    private fun reConnect() &#123;</span><br><span class="line">        Thread(Runnable &#123; this.connect() &#125;).start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import android.os.SystemClock</span><br><span class="line">import android.util.Log</span><br><span class="line">import io.netty.buffer.Unpooled</span><br><span class="line">import io.netty.channel.ChannelHandlerContext</span><br><span class="line">import io.netty.channel.SimpleChannelInboundHandler</span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HeartTcp : SimpleChannelInboundHandler&lt;Any&gt;() &#123;</span><br><span class="line">    private var ctx: ChannelHandlerContext? = null</span><br><span class="line">    private var isConnect = false</span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun channelActive(ctx: ChannelHandlerContext) &#123;</span><br><span class="line">        super.channelActive(ctx)</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;)</span><br><span class="line">        isConnect = true</span><br><span class="line">        if (this.ctx == null) &#123;</span><br><span class="line">            synchronized(HeartTcp::class.java) &#123;</span><br><span class="line">                if (this.ctx == null) &#123;</span><br><span class="line">                    this.ctx = ctx</span><br><span class="line">                    myAppHeart()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun myAppHeart() &#123;</span><br><span class="line">        Thread &#123;</span><br><span class="line">            while (ctx != null &amp;&amp; isConnect) &#123;</span><br><span class="line">                val data = &quot;123&quot;</span><br><span class="line">                val bytes = data.toByteArray()</span><br><span class="line">                if (isConnect) &#123;</span><br><span class="line">                    ctx!!.writeAndFlush(Unpooled.buffer(bytes.size).writeBytes(bytes))</span><br><span class="line">                    SystemClock.sleep(3000)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun channelInactive(ctx: ChannelHandlerContext) &#123;</span><br><span class="line">        val loop = ctx.channel().eventLoop()</span><br><span class="line">        loop.schedule(&#123; SocketTcp.getInstance().connect() &#125;, 5, TimeUnit.SECONDS)</span><br><span class="line">        super.channelInactive(ctx)</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;)</span><br><span class="line">        isConnect = false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun userEventTriggered(ctx: ChannelHandlerContext, evt: Any) &#123;</span><br><span class="line">        super.userEventTriggered(ctx, evt)</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun exceptionCaught(ctx: ChannelHandlerContext, cause: Throwable) &#123;</span><br><span class="line">        super.exceptionCaught(ctx, cause)</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;)</span><br><span class="line">        this.ctx = null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun messageReceived(ctx: ChannelHandlerContext, msg: Any) &#123;</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;)</span><br><span class="line">        /*val msg1 = msg</span><br><span class="line">        val bytes = ByteArray(msg1.readableBytes())</span><br><span class="line">        msg1.readBytes(bytes)</span><br><span class="line">        val s = String(bytes*//*, &quot;UTF-8&quot;*//*)*/</span><br><span class="line">        val s = msg.toString()</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我这里就是把我前面那个讲Netty创建Socket连接的代码拷贝过来转成了kotlin代码，这里我就不做过多的解释了。</p><p>&emsp;&emsp;一般，我们都是后台新开一个服务去启动socket，所以，我们还要创建一个Service，去处理socket。我这里就是非绑定启动这个服务。在oncreate方法里面去连接服务器即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import android.app.Service</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.os.IBinder</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/26</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">class SocketService : Service() &#123;</span><br><span class="line">    override fun onBind(intent: Intent?): IBinder? &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">        Thread(Runnable &#123; SocketTcp.getInstance().setPort(8080).setHost(&quot;192.168.0.235&quot;).connect() &#125;).start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之所以要新建一个服务，就是可能你在连接socket的时候，可能要做一些其他信息的初始化，而这些信息初始化也是只有在连接socket服务器之前才需要的，写在这里方便一起管理，要是写在activity里面不便于管理。上面都是扯淡，最主要的是我们在最初学Android的时候，教你们的老师应该讲过，什么时候需要用到服务，就是不需要页面，用户并不关心它长什么样子，需要长连接的任务，都放在服务里面。正好，socket连接正好满足这些条件。</p><p>&emsp;&emsp;细心的同学可能注意了，我在Tcp类里面有一个EventBus，我这里是把发TCP消息给拿出来了，便于管理。我这边还新建了一个SocketUtils类，就是处理Socket请求的方法，我们发消息之类的方法，都是调用SocketUtils类里面的方法，不用去改Tcp类。这样做就只有一个目的，就是便于统一管理，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.model.bean.SocketTcpBean</span><br><span class="line">import org.greenrobot.eventbus.EventBus</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/26</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">object SocketUtils &#123;</span><br><span class="line">    fun sendTcpMsg(msg: String) &#123;</span><br><span class="line">        sendTcpMsg(SocketTcpBean(msg))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun sendTcpMsg(socketTcpBean: SocketTcpBean) &#123;</span><br><span class="line">        EventBus.getDefault().post(socketTcpBean)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至于这个SocketTcpBean类，就是一个普通的java bean类，里面就只有一个参数msg，你需要发的消息</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>我先给出来代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import android.util.Log</span><br><span class="line">import com.haichenyi.myproject.model.bean.SocketUdpBean</span><br><span class="line">import io.netty.bootstrap.Bootstrap</span><br><span class="line">import io.netty.buffer.Unpooled</span><br><span class="line">import io.netty.channel.Channel</span><br><span class="line">import io.netty.channel.ChannelOption</span><br><span class="line">import io.netty.channel.EventLoopGroup</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup</span><br><span class="line">import io.netty.channel.socket.DatagramPacket</span><br><span class="line">import io.netty.channel.socket.nio.NioDatagramChannel</span><br><span class="line">import org.greenrobot.eventbus.EventBus</span><br><span class="line">import org.greenrobot.eventbus.Subscribe</span><br><span class="line">import java.net.InetSocketAddress</span><br><span class="line">import java.nio.charset.Charset</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/26</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">class SocketUdp &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private val socket = SocketUdp()</span><br><span class="line">        fun getInstance(): SocketUdp = socket</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private var port: Int = 0</span><br><span class="line">    private var channel: Channel? = null</span><br><span class="line">    private var group: EventLoopGroup? = null</span><br><span class="line"></span><br><span class="line">    fun setPort(port: Int): SocketUdp &#123;</span><br><span class="line">        this.port = port</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun connect() &#123;</span><br><span class="line">        if (null != channel) return</span><br><span class="line">        if (null == group) &#123;</span><br><span class="line">            if (!EventBus.getDefault().isRegistered(this))</span><br><span class="line">                EventBus.getDefault().register(this)</span><br><span class="line">            group = NioEventLoopGroup()</span><br><span class="line">        &#125;</span><br><span class="line">        val bootstrap = Bootstrap()</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioDatagramChannel::class.java)</span><br><span class="line">                .option(ChannelOption.SO_BROADCAST, true)</span><br><span class="line">                .handler(UdpHandler())</span><br><span class="line">        try &#123;</span><br><span class="line">            channel = bootstrap.bind(port).sync().channel()</span><br><span class="line">            channel!!.closeFuture().sync()</span><br><span class="line">        &#125; catch (e: InterruptedException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            disConnect()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 断开tcp连接.</span><br><span class="line">     */</span><br><span class="line">    private fun disConnect() &#123;</span><br><span class="line">        if (null != group) &#123;</span><br><span class="line">            group!!.shutdownGracefully()</span><br><span class="line">        &#125;</span><br><span class="line">//        EventBus.getDefault().unregister(this)</span><br><span class="line">        group = null</span><br><span class="line">        channel = null</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;disConnect&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //连接成功后，通过Channel提供的接口进行IO操作</span><br><span class="line">    private fun sendMessage(host: String, port: Int, data: ByteArray) &#123;</span><br><span class="line">        val packet = DatagramPacket(Unpooled.copiedBuffer(data),</span><br><span class="line">                InetSocketAddress(host, port))</span><br><span class="line">        channel?.let &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                it.writeAndFlush(packet).sync()</span><br><span class="line">                Log.d(&quot;wz&quot;, &quot;send succeed &quot; + String(data, Charset.forName(&quot;UTF-8&quot;)))</span><br><span class="line">            &#125; catch (e: Exception) &#123;</span><br><span class="line">                reConnect()</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Subscribe</span><br><span class="line">    fun handle(socketUdpBean: SocketUdpBean) &#123;</span><br><span class="line">        sendMessage(socketUdpBean.host,socketUdpBean.port,socketUdpBean.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重连.</span><br><span class="line">     */</span><br><span class="line">    private fun reConnect() &#123;</span><br><span class="line">        Thread(Runnable &#123; this.connect() &#125;).start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import android.util.Log</span><br><span class="line">import io.netty.channel.ChannelHandlerContext</span><br><span class="line">import io.netty.channel.SimpleChannelInboundHandler</span><br><span class="line">import io.netty.channel.socket.DatagramPacket</span><br><span class="line">import java.nio.charset.Charset</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/26</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">class UdpHandler : SimpleChannelInboundHandler&lt;DatagramPacket&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    override fun messageReceived(ctx: ChannelHandlerContext?, msg: DatagramPacket?) &#123;</span><br><span class="line">        val byteBuf = msg!!.content()</span><br><span class="line">        val bytes = ByteArray(byteBuf.readableBytes())</span><br><span class="line">        byteBuf.readBytes(bytes)</span><br><span class="line">        val s = String(bytes, Charset.forName(&quot;UTF-8&quot;))</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;UDP收到的消息是--&gt;$s&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的代码跟TCP类似，我想说的就只有三点：</p><ol><li>首先你客户端开启UDP的时候，需要bind一个端口号，这个端口号是服务器给你发消息的时候，需要的端口号。</li><li>它的管道里面的handle类型DatagramPacket</li><li>再有就是给目标主机发消息，UDP需要传目标地址，端口号，还有消息。这里的目标地址就是服务器的地址，端口号就是服务器跟你通信的端口号，消息就是你需要发送给服务器的信息</li></ol><p>&emsp;&emsp;其实，这里的区别就是TCP与UDP的区别，TCP和UDP什么区别呢？</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">TCP</th><th style="text-align:center">UDP</th></tr></thead><tbody><tr><td style="text-align:center">是否连接</td><td style="text-align:center">面向连接</td><td style="text-align:center">面向非连接</td></tr><tr><td style="text-align:center">传输效率</td><td style="text-align:center">慢</td><td style="text-align:center">快</td></tr><tr><td style="text-align:center">数据是否有序</td><td style="text-align:center">有序</td><td style="text-align:center">无序</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">安全</td><td style="text-align:center">不安全</td></tr><tr><td style="text-align:center">模式</td><td style="text-align:center">流模式</td><td style="text-align:center">报文模式</td></tr><tr><td style="text-align:center">系统资源</td><td style="text-align:center">多</td><td style="text-align:center">少</td></tr></tbody></table><p>区别的总结：最典型的对比就是打电话（TCP）和发短信（UDP）的区别</p><ol><li>是否连接方面，TCP是1对1，UDP可以1对N</li><li>传输效率：TCP必须等到一个消息全部传完了才能传下一个，UDP可以一直发</li><li>数据是否有序：TCP是按顺序一条一条的发，当然是有序的。UDP则是无序的</li><li>安全性方面：TCP有3次握手机制，采用的全双工的可靠信道，保证了数据的安全，UDP则没有3次握手机制，采用的是不可靠信道</li><li>模式方面：TCP是面向字节流，实际上TCP把数据看成了一连串无结构的字节流，UDP则是面向报文的</li><li>系统资源方面：TCP首部开销20个字节，UDP首部开销8个字节</li></ol><p><a href="http://download.csdn.net/download/qq_27634797/10260329" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Android中常用的网络编程方式：Http和Socket，Http通讯方式，我们在前面已经加到框架里面了，用的是现在主流的RxJava+Retrofit+OkHttp的方式，用起来也很方便。今天，我们来说说Socket网络编程。前面已经有一篇讲过IO和NIO的区别，还有一篇讲过Netty了，今天这篇的目的就是把Netty加到我们这个框架里面。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（五）—GreenDao的增删改查</title>
    <link href="http://haichenyi.com/2018/02/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94GreenDao%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>http://haichenyi.com/2018/02/24/从零开始搭建一个主流项目框架（五）—GreenDao的增删改查/</id>
    <published>2018-02-24T13:17:55.000Z</published>
    <updated>2018-02-24T13:20:09.619Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇我们讲了GreenDao的数据库的依赖和创建，这一篇，我们来讲常用的增删改查四种方法。我们操作数据库都是Dao层，不同的表，有不懂的Dao层对象。我们上一篇的数据库接口的实现类里面，我们定义了UserDao，我们这一篇讲的就是操作我们昨天创建的user表。</p><a id="more"></a><p>&emsp;&emsp;在写下面几个方法之前，我还是先把MVP的用法先讲一遍吧，防止有人不知道，以增操作为例，另外三个就不再讲了：</p><ol><li><p>点击页面的增按钮，我们要调用P层的方法去做增操作。效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-8b4f3073de1af3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增1.png"></p></li><li><p>P层的方法从哪来呢？P层实现的接口来撒，所以，我们只用在接口定义对应的方法，在P层去实现，效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-0d7bc09082e64fa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增2.png"></p></li><li><p>辣么，具体实现代码怎么写呢？既不记得，我们的装饰者模式，我们P层里面有一个DataHelper对象，通过它去调用对应的方法就可以了，效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-85447db350c369a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增3.png"></p></li><li><p>接下来，datahelper的方法又是从哪里来呢？我们的DataHelper是不是实现了SqlHelper接口，所以，直接在SqlHelper定义方法，在datahelper实现即可，效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-58575c3a7edb7ebc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增4.png"></p></li><li><p>最后，前面只是调用了，具体实现在哪里呢？我之前有没有讲过装饰者模式，一个接口，两个实现方法，对，没错，就是在SqlImpl方法里面实现，效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-70f33a5a63a304fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增5.png"></p></li></ol><p>&emsp;&emsp;通过以上5步，就完成我们的增操作。有同鞋就会问，那参数怎么传？我特么怎么知道需要传什么传输，你这个方法是干什么的，调用这个方法需要什么数据，你就丢在参数里面传过去，即可。</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//插入单个对象</span><br><span class="line">userDao.insert(user);</span><br><span class="line"></span><br><span class="line">//插入一个list</span><br><span class="line">userDao.insertInTx(users);</span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//basePresenter.onAdd(User(&quot;小红&quot;, 1, 165, &quot;50KG&quot;, 18))</span><br><span class="line">val dataList = mutableListOf&lt;User&gt;()</span><br><span class="line">dataList.add(User(&quot;小刚&quot;, 2, 175, &quot;60KG&quot;, 28))</span><br><span class="line">dataList.add(User(&quot;小东&quot;, 2, 185, &quot;65KG&quot;, 25))</span><br><span class="line">basePresenter.onAddList(dataList)</span><br></pre></td></tr></table></figure><p>效果图我就不贴出来了，如果，你的效果出不来，就肯定是你的代码写的有问题，我写这个博客都是边写代码，边写博客，我这边肯定是没问题的。</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查询单个对象</span><br><span class="line">userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();</span><br><span class="line">//查询一个list</span><br><span class="line">userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list();</span><br></pre></td></tr></table></figure><h4 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val user = basePresenter.onSelect(&quot;小红&quot;)</span><br><span class="line">println(user.name)</span><br><span class="line">val users = basePresenter.onSelectList(&quot;小东&quot;)</span><br><span class="line"> users.forEach &#123;</span><br><span class="line">     println(it.name)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里，我需要做一点说明，那就是手动能力强的宝宝，看见有两个查询方法，一个查询一个对象，一个查询list，这两个方法没问题，查询肯定是查询的一个，list里面也是只有一个对象，就有宝宝想着多插入几条数据，这个时候，项目就可能崩掉，因为，你插入的名字是相同的，我们这里名字是作为主键，表里面主键是不能相同的，所以就崩掉了，所以，你就得改表结构，正好测试我们之前说的版本更新问题，我这里亲测可用，数据也不会丢失。步骤如下：</p><ol><li>修改数据库版本，把1改成2</li><li>User bean里面增加一个字段id Long类型，递增即可，clean，build项目</li><li>在你的Activity里面会报错，因为，你User的构造方法里面新增了一个参数，辣么这里你用的时候参数个数都不对，肯定报错，你把id字段对应的参数传null即可，他自己递增。这里也只有Long类型可以传null</li><li>重新运行项目，没有问题</li></ol><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*//通过主键删除一个对象，删除满足条件的第一个对象</span><br><span class="line">    User user1 = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();</span><br><span class="line">    //一定要记得做非空判断</span><br><span class="line">    if (user1 != null) &#123;</span><br><span class="line">      userDao.deleteByKey(user1.getId());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;);</span><br><span class="line">    &#125;*/</span><br><span class="line"></span><br><span class="line">    //通过主键删除一个满足条件的List</span><br><span class="line">    List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list();</span><br><span class="line">    if (list.size() &gt; 0) &#123;</span><br><span class="line">      List&lt;Long&gt; keys = new ArrayList&lt;&gt;();</span><br><span class="line">      for (User user : list) &#123;</span><br><span class="line">        keys.add(user.getId());</span><br><span class="line">      &#125;</span><br><span class="line">      userDao.deleteByKeyInTx(keys);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="调用-2"><a href="#调用-2" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//basePresenter.onDelete(&quot;小红&quot;)</span><br><span class="line">basePresenter.onDelete(&quot;小东&quot;)</span><br></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(oldName)).build().list();</span><br><span class="line">    if (list.size() &gt; 0) &#123;</span><br><span class="line">      for (User user : list) &#123;</span><br><span class="line">        user.setName(newName);</span><br><span class="line">      &#125;</span><br><span class="line">//      userDao.update(user1);</span><br><span class="line">      userDao.updateInTx(list);</span><br><span class="line">      ToastUtils.Companion.showTipMsg(&quot;修改成功&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ToastUtils.Companion.showTipMsg(&quot;未查询到相关数据&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="调用-3"><a href="#调用-3" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basePresenter.onUpdate(&quot;小刚&quot;, &quot;小贝&quot;)</span><br></pre></td></tr></table></figure><p>完了，数据库的简单的增删改查</p><p><a href="http://download.csdn.net/download/qq_27634797/10257729" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇我们讲了GreenDao的数据库的依赖和创建，这一篇，我们来讲常用的增删改查四种方法。我们操作数据库都是Dao层，不同的表，有不懂的Dao层对象。我们上一篇的数据库接口的实现类里面，我们定义了UserDao，我们这一篇讲的就是操作我们昨天创建的user表。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（四）—Kotlin+GreenDao3.2</title>
    <link href="http://haichenyi.com/2018/02/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94Kotlin-GreenDao3-2/"/>
    <id>http://haichenyi.com/2018/02/24/从零开始搭建一个主流项目框架（四）—Kotlin-GreenDao3-2/</id>
    <published>2018-02-24T13:16:34.000Z</published>
    <updated>2018-02-24T13:19:17.773Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本篇介绍android常用的数据库之一<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">GreenDao</a>的简单用法，增删改查。基于前面搭的框架，当然，你也可以选择不用。看懂用法之后，用起来很方便。GreenDao数据库升级到3.0版本之后api用起来更加方便了，便于让开发人员专注于业务逻辑。我需要额外说明的是，我把之前的项目框架转成了<a href="http://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">kotlin</a>，不会<a href="http://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">kotlin</a>语法的同学，可以去研究一下。</p><a id="more"></a><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>最终，我们要添加如下代码，效果图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-a6b08f6861b1e514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化数据库.png"></p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>&emsp;&emsp;打开的你根目录下面的build.gradle文件，也就是项目下面的，并不是app目录下面的build.gradle。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// In your root build.gradle file:</span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        ...//其他你自己的</span><br><span class="line">        mavenCentral() // add repository</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.0.0&apos;</span><br><span class="line">        ...//其他你自己的</span><br><span class="line">        classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>&emsp;&emsp;打开你的项目下面的build.gradle文件，也就是你的app目录下面的，之前我们添加依赖的时候的那个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// In your app projects build.gradle file:</span><br><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.greenrobot:greendao:3.2.2&apos; // add library</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;完成上面两步，辣么，关于greendao的依赖我们就添加完成了</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>&emsp;&emsp;我们首先得有一个bean类，这个bean类对应的就是数据库表的表结构。我这里想说明的是（敲黑板了），<strong>看到了很多网上说的什么主键id必须用Long类型，这种说法是不准确的，准确的说，你的主键字段名称，如果是“id”，辣么，你这个字段“id”，必须用Long类型，如果你换一个名称，比方说“myId”，辣么，你就不必用Long类型</strong>，这个问题，说大不大，说小，又困扰了我有一会。我这里新建用户表，就需要一个User的java bean类。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.bean;</span><br><span class="line"></span><br><span class="line">import org.greenrobot.greendao.annotation.Entity;</span><br><span class="line">import org.greenrobot.greendao.annotation.Id;</span><br><span class="line">import org.greenrobot.greendao.annotation.NotNull;</span><br><span class="line">import org.greenrobot.greendao.annotation.Property;</span><br><span class="line">import org.greenrobot.greendao.annotation.Transient;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc: 用户表的bean类</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class User &#123;</span><br><span class="line">  @Id</span><br><span class="line">  private String name;</span><br><span class="line">  private int sex;</span><br><span class="line">  @Property(nameInDb = &quot;Height&quot;)</span><br><span class="line">  private int height;</span><br><span class="line">  private String weight;</span><br><span class="line">  @NotNull</span><br><span class="line">  private int age;</span><br><span class="line">  @Transient</span><br><span class="line">  private String character;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我把几个常用的注解都写出来了，说一下这几个注解是什么意思</p><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">@Entity</td><td style="text-align:center">用于标识这是一个需要Greendao帮我们生成代码的bean</td></tr><tr><td style="text-align:center">@Id</td><td style="text-align:center">标明主键，括号里可以指定是否自增</td></tr><tr><td style="text-align:center">@Property</td><td style="text-align:center">用于设置属性在数据库中的列名（默认不写就是保持一致）</td></tr><tr><td style="text-align:center">@NotNull</td><td style="text-align:center">非空</td></tr><tr><td style="text-align:center">@Transient</td><td style="text-align:center">标识这个字段是自定义的不会创建到数据库表里</td></tr></tbody></table><p>简单的讲一下：</p><ol><li><p>@Entity：标识的bean类，我们在运行的时候，greendao会自动帮我们生成对应的表</p></li><li><p>@Id：标识的字段就是这个表对应的主键</p></li><li><p>@Property：标识的字段在表中对应的那一栏的名称是后面括号里面的，这个表height字段对应表中的Height，一般我们直接设置成默认就可以了</p></li><li><p>@NotNull：标识的字段，这个字段在表中不能为空，不然就出错，所以，在添加数据的时候设置默认值</p></li><li><p>@Transient：标识的字段，在生成表的时候不会生成对应的字段。这个什么时候用呢？这个，我一般用作标记flag，比方说，从数据库拿数据，又不想重新写一个bean类，就用这个bean类，RecyclerView，填充完数据，item点击的时候，状态发生变化，我们要有一个flag，就通过修改这个字段的值，页面做出相应的变化。</p></li></ol><p>&emsp;&emsp;写到这里，我们的bean类也有了，要怎么生成数据库呢？在生成数据库之前，我们先把项目重新clean一遍，再build一遍，看到你刚写的需要生成表的bean类变成了如下样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.bean;</span><br><span class="line"></span><br><span class="line">import org.greenrobot.greendao.annotation.Entity;</span><br><span class="line">import org.greenrobot.greendao.annotation.Id;</span><br><span class="line">import org.greenrobot.greendao.annotation.NotNull;</span><br><span class="line">import org.greenrobot.greendao.annotation.Property;</span><br><span class="line">import org.greenrobot.greendao.annotation.Transient;</span><br><span class="line">import org.greenrobot.greendao.annotation.Generated;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc: 用户表的bean类</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class User &#123;</span><br><span class="line">  @Id</span><br><span class="line">  private String name;</span><br><span class="line">  private int sex;</span><br><span class="line">  @Property(nameInDb = &quot;Height&quot;)</span><br><span class="line">  private int height;</span><br><span class="line">  private String weight;</span><br><span class="line">  @NotNull</span><br><span class="line">  private int age;</span><br><span class="line">  @Transient</span><br><span class="line">  private String character;</span><br><span class="line">  @Generated(hash = 717717955)</span><br><span class="line">  public User(String name, int sex, int height, String weight, int age) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.sex = sex;</span><br><span class="line">      this.height = height;</span><br><span class="line">      this.weight = weight;</span><br><span class="line">      this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  @Generated(hash = 586692638)</span><br><span class="line">  public User() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getName() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setName(String name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  public int getSex() &#123;</span><br><span class="line">      return this.sex;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setSex(int sex) &#123;</span><br><span class="line">      this.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  public int getHeight() &#123;</span><br><span class="line">      return this.height;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setHeight(int height) &#123;</span><br><span class="line">      this.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getWeight() &#123;</span><br><span class="line">      return this.weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setWeight(String weight) &#123;</span><br><span class="line">      this.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public int getAge() &#123;</span><br><span class="line">      return this.age;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setAge(int age) &#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，greendao通过注解的方式帮我们自动生成了set/get方法，还有构造方法，这就对了，我们不用关，之后我们再执行如下代码生成数据库和表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(getApplicationContext(), &quot;haichenyi.db&quot;, null);</span><br><span class="line">DaoMaster daoMaster = new DaoMaster(devOpenHelper.getWritableDb());</span><br><span class="line">DaoSession daoSession = daoMaster.newSession();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。注意：默认的 DaoMaster.DevOpenHelper会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。升级的问题，我们在后面讲，这里我们先把数据库和表先创建了。</p><p>&emsp;&emsp;上面这个方式是java格式的，由于，我昨天写完框架之后，我把项目转成了kotlin代码，所以这里有点不一样，项目我后面会上传。这里我要说明的是（敲黑板）<strong>我用kotlin的时候，碰到了一个问题，当我使用greendao的时候，他提示我，无法引入用注解方式生成的类，dagger2也是一样的，我用java代码写就没有问题</strong>，我写这篇博客的时候，目前还没有找到解决的办法。</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-57cbd658b027825f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="greendao的问题.png"></p><p>&emsp;&emsp;我用了另外一种方式，采用跟之前网络请求一样的设计模式——装饰者模式。我这里就不多做说明了。我贴出我的代码。</p><p>SqlHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.sql;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public interface SqlHelper &#123;</span><br><span class="line">  void onAdd();</span><br><span class="line"></span><br><span class="line">  void onDelete();</span><br><span class="line"></span><br><span class="line">  void onUpdate();</span><br><span class="line"></span><br><span class="line">  void onSelect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里定义增删改查4个方法，用于测试这4个功能</p><p>SqlImpl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.sql;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.MyApplication;</span><br><span class="line">import com.haichenyi.myproject.model.bean.DaoMaster;</span><br><span class="line">import com.haichenyi.myproject.model.bean.DaoSession;</span><br><span class="line">import com.haichenyi.myproject.model.bean.UserDao;</span><br><span class="line">import com.haichenyi.myproject.utils.ToastUtils;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class SqlImpl implements SqlHelper &#123;</span><br><span class="line">  private final UserDao userDao;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 初始化Sql Dao.</span><br><span class="line">   *</span><br><span class="line">   * @param application &#123;@link MyApplication&#125;</span><br><span class="line">   */</span><br><span class="line">  public SqlImpl(MyApplication application) &#123;</span><br><span class="line">    SqlOpenHelper helper = new SqlOpenHelper(application, &quot;haichenyi.db&quot;);</span><br><span class="line">    DaoSession daoSession = new DaoMaster(helper.getWritableDb()).newSession();</span><br><span class="line">    userDao = daoSession.getUserDao();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onAdd() &#123;</span><br><span class="line">    ToastUtils.Companion.showTipMsg(&quot;增加数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onDelete() &#123;</span><br><span class="line">    ToastUtils.Companion.showTipMsg(&quot;删除数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUpdate() &#123;</span><br><span class="line">    ToastUtils.Companion.showTipMsg(&quot;更新数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onSelect() &#123;</span><br><span class="line">    ToastUtils.Companion.showTipMsg(&quot;查询数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;功能实现类，看到他的构造方法里面，第二个参数就是我们的数据库名称，后面通过getWritableDb()获取的是可写的数据库，可写就肯定可读。然后就是接口的实现类了，这里就是具体的增删改查功能的实现类，我这里在对应的方法里面就写了Toast，增删改查具体怎么写后面再说</p><p>SqlOpenHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.sql;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.model.bean.DaoMaster;</span><br><span class="line">import com.haichenyi.myproject.model.bean.UserDao;</span><br><span class="line"></span><br><span class="line">import org.greenrobot.greendao.database.Database;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class SqlOpenHelper extends DaoMaster.OpenHelper &#123;</span><br><span class="line">  public SqlOpenHelper(Context context, String name) &#123;</span><br><span class="line">    super(context, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  @Override</span><br><span class="line">  public void onUpgrade(Database db, int oldVersion, int newVersion) &#123;</span><br><span class="line">    super.onUpgrade(db, oldVersion, newVersion);</span><br><span class="line"></span><br><span class="line">    MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onCreateAllTables(Database db, boolean ifNotExists) &#123;</span><br><span class="line">        DaoMaster.createAllTables(db, ifNotExists);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onDropAllTables(Database db, boolean ifExists) &#123;</span><br><span class="line">        DaoMaster.dropAllTables(db, ifExists);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, UserDao.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个类用于管理数据库的表对应的字段发生变化的时候，数据库需要进行的版本更新，连上下面那个类，都是用于版本数据库版本更新的，防止数据丢失。怎么写呢？看到最后面的&emsp;<strong>UserDao.class</strong>&emsp;了吗？这个就是我们需要更新的表，你哪个表需要更新，直接写在后面就可以了，这个是可以一次传多个表的，并不是一次只能传一个</p><p>MigrationHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.sql;</span><br><span class="line"></span><br><span class="line">import android.database.Cursor;</span><br><span class="line">import android.database.SQLException;</span><br><span class="line">import android.database.sqlite.SQLiteDatabase;</span><br><span class="line">import android.support.annotation.NonNull;</span><br><span class="line">import android.text.TextUtils;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import org.greenrobot.greendao.AbstractDao;</span><br><span class="line">import org.greenrobot.greendao.database.Database;</span><br><span class="line">import org.greenrobot.greendao.database.StandardDatabase;</span><br><span class="line">import org.greenrobot.greendao.internal.DaoConfig;</span><br><span class="line"></span><br><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public final class MigrationHelper &#123;</span><br><span class="line">  public static boolean DEBUG = false;</span><br><span class="line">  private static String TAG = &quot;MigrationHelper&quot;;</span><br><span class="line">  private static final String SQLITE_MASTER = &quot;sqlite_master&quot;;</span><br><span class="line">  private static final String SQLITE_TEMP_MASTER = &quot;sqlite_temp_master&quot;;</span><br><span class="line"></span><br><span class="line">  private static WeakReference&lt;ReCreateAllTableListener&gt; weakListener;</span><br><span class="line"></span><br><span class="line">  public interface ReCreateAllTableListener &#123;</span><br><span class="line">    void onCreateAllTables(Database db, boolean ifNotExists);</span><br><span class="line"></span><br><span class="line">    void onDropAllTables(Database db, boolean ifExists);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void migrate(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    printLog(&quot;【The Old Database Version】&quot; + db.getVersion());</span><br><span class="line">    Database database = new StandardDatabase(db);</span><br><span class="line">    migrate(database, daoClasses);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void migrate(SQLiteDatabase db, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    weakListener = new WeakReference&lt;&gt;(listener);</span><br><span class="line">    migrate(db, daoClasses);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void migrate(Database database, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    weakListener = new WeakReference&lt;&gt;(listener);</span><br><span class="line">    migrate(database, daoClasses);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void migrate(Database database, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    printLog(&quot;【Generate temp table】start&quot;);</span><br><span class="line">    generateTempTables(database, daoClasses);</span><br><span class="line">    printLog(&quot;【Generate temp table】complete&quot;);</span><br><span class="line"></span><br><span class="line">    ReCreateAllTableListener listener = null;</span><br><span class="line">    if (weakListener != null) &#123;</span><br><span class="line">      listener = weakListener.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (listener != null) &#123;</span><br><span class="line">      listener.onDropAllTables(database, true);</span><br><span class="line">      printLog(&quot;【Drop all table by listener】&quot;);</span><br><span class="line">      listener.onCreateAllTables(database, false);</span><br><span class="line">      printLog(&quot;【Create all table by listener】&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dropAllTables(database, true, daoClasses);</span><br><span class="line">      createAllTables(database, false, daoClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    printLog(&quot;【Restore data】start&quot;);</span><br><span class="line">    restoreData(database, daoClasses);</span><br><span class="line">    printLog(&quot;【Restore data】complete&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static void generateTempTables(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    for (int i = 0; i &lt; daoClasses.length; i++) &#123;</span><br><span class="line">      String tempTableName = null;</span><br><span class="line"></span><br><span class="line">      DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]);</span><br><span class="line">      String tableName = daoConfig.tablename;</span><br><span class="line">      if (!isTableExists(db, false, tableName)) &#123;</span><br><span class="line">        printLog(&quot;【New Table】&quot; + tableName);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">        tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;);</span><br><span class="line">        StringBuilder dropTableStringBuilder = new StringBuilder();</span><br><span class="line">        dropTableStringBuilder.append(&quot;DROP TABLE IF EXISTS &quot;).append(tempTableName).append(&quot;;&quot;);</span><br><span class="line">        db.execSQL(dropTableStringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        StringBuilder insertTableStringBuilder = new StringBuilder();</span><br><span class="line">        insertTableStringBuilder.append(&quot;CREATE TEMPORARY TABLE &quot;).append(tempTableName);</span><br><span class="line">        insertTableStringBuilder.append(&quot; AS SELECT * FROM &quot;).append(tableName).append(&quot;;&quot;);</span><br><span class="line">        db.execSQL(insertTableStringBuilder.toString());</span><br><span class="line">        printLog(&quot;【Table】&quot; + tableName + &quot;\n ---Columns--&gt;&quot; + getColumnsStr(daoConfig));</span><br><span class="line">        printLog(&quot;【Generate temp table】&quot; + tempTableName);</span><br><span class="line">      &#125; catch (SQLException e) &#123;</span><br><span class="line">        Log.e(TAG, &quot;【Failed to generate temp table】&quot; + tempTableName, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static boolean isTableExists(Database db, boolean isTemp, String tableName) &#123;</span><br><span class="line">    if (db == null || TextUtils.isEmpty(tableName)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    String dbName = isTemp ? SQLITE_TEMP_MASTER : SQLITE_MASTER;</span><br><span class="line">    String sql = &quot;SELECT COUNT(*) FROM &quot; + dbName + &quot; WHERE type = ? AND name = ?&quot;;</span><br><span class="line">    Cursor cursor = null;</span><br><span class="line">    int count = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">      cursor = db.rawQuery(sql, new String[]&#123;&quot;table&quot;, tableName&#125;);</span><br><span class="line">      if (cursor == null || !cursor.moveToFirst()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      count = cursor.getInt(0);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (cursor != null)</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    return count &gt; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private static String getColumnsStr(DaoConfig daoConfig) &#123;</span><br><span class="line">    if (daoConfig == null) &#123;</span><br><span class="line">      return &quot;no columns&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder builder = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; daoConfig.allColumns.length; i++) &#123;</span><br><span class="line">      builder.append(daoConfig.allColumns[i]);</span><br><span class="line">      builder.append(&quot;,&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (builder.length() &gt; 0) &#123;</span><br><span class="line">      builder.deleteCharAt(builder.length() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return builder.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private static void dropAllTables(Database db, boolean ifExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    reflectMethod(db, &quot;dropTable&quot;, ifExists, daoClasses);</span><br><span class="line">    printLog(&quot;【Drop all table by reflect】&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static void createAllTables(Database db, boolean ifNotExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    reflectMethod(db, &quot;createTable&quot;, ifNotExists, daoClasses);</span><br><span class="line">    printLog(&quot;【Create all table by reflect】&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * dao class already define the sql exec method, so just invoke it</span><br><span class="line">   */</span><br><span class="line">  private static void reflectMethod(Database db, String methodName, boolean isExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    if (daoClasses.length &lt; 1) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      for (Class cls : daoClasses) &#123;</span><br><span class="line">        Method method = cls.getDeclaredMethod(methodName, Database.class, boolean.class);</span><br><span class="line">        method.invoke(null, db, isExists);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static void restoreData(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    for (int i = 0; i &lt; daoClasses.length; i++) &#123;</span><br><span class="line">      DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]);</span><br><span class="line">      String tableName = daoConfig.tablename;</span><br><span class="line">      String tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;);</span><br><span class="line"></span><br><span class="line">      if (!isTableExists(db, true, tempTableName)) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        // get all columns from tempTable, take careful to use the columns list</span><br><span class="line">        List&lt;String&gt; columns = getColumns(db, tempTableName);</span><br><span class="line">        ArrayList&lt;String&gt; properties = new ArrayList&lt;&gt;(columns.size());</span><br><span class="line">        for (int j = 0; j &lt; daoConfig.properties.length; j++) &#123;</span><br><span class="line">          String columnName = daoConfig.properties[j].columnName;</span><br><span class="line">          if (columns.contains(columnName)) &#123;</span><br><span class="line">            properties.add(&quot;`&quot; + columnName + &quot;`&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (properties.size() &gt; 0) &#123;</span><br><span class="line">          final String columnSQL = TextUtils.join(&quot;,&quot;, properties);</span><br><span class="line"></span><br><span class="line">          StringBuilder insertTableStringBuilder = new StringBuilder();</span><br><span class="line">          insertTableStringBuilder.append(&quot;REPLACE INTO &quot;).append(tableName).append(&quot; (&quot;);</span><br><span class="line">          insertTableStringBuilder.append(columnSQL);</span><br><span class="line">          insertTableStringBuilder.append(&quot;) SELECT &quot;);</span><br><span class="line">          insertTableStringBuilder.append(columnSQL);</span><br><span class="line">          insertTableStringBuilder.append(&quot; FROM &quot;).append(tempTableName).append(&quot;;&quot;);</span><br><span class="line">          db.execSQL(insertTableStringBuilder.toString());</span><br><span class="line">          printLog(&quot;【Restore data】 to &quot; + tableName);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder dropTableStringBuilder = new StringBuilder();</span><br><span class="line">        dropTableStringBuilder.append(&quot;DROP TABLE &quot;).append(tempTableName);</span><br><span class="line">        db.execSQL(dropTableStringBuilder.toString());</span><br><span class="line">        printLog(&quot;【Drop temp table】&quot; + tempTableName);</span><br><span class="line">      &#125; catch (SQLException e) &#123;</span><br><span class="line">        Log.e(TAG, &quot;【Failed to restore data from temp table 】&quot; + tempTableName, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static List&lt;String&gt; getColumns(Database db, String tableName) &#123;</span><br><span class="line">    List&lt;String&gt; columns = null;</span><br><span class="line">    Cursor cursor = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      cursor = db.rawQuery(&quot;SELECT * FROM &quot; + tableName + &quot; limit 0&quot;, null);</span><br><span class="line">      if (null != cursor &amp;&amp; cursor.getColumnCount() &gt; 0) &#123;</span><br><span class="line">        columns = Arrays.asList(cursor.getColumnNames());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (cursor != null)</span><br><span class="line">        cursor.close();</span><br><span class="line">      if (null == columns)</span><br><span class="line">        columns = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    return columns;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static void printLog(String info) &#123;</span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">      Log.d(TAG, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个类是工具类，拿过去用就好了，还有就是，应用怎么判断是否需要版本更新呢？打开你的app下面的build.grade，在根结点下面添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greendao &#123;</span><br><span class="line">    schemaVersion 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当你发布新版本的时候，把这个版本号+1即可。</p><p>&emsp;&emsp;当然，我门这里依然是用的dagger生成的全局单例，所以，你还需要在你的AppModule下面添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Provides</span><br><span class="line">@Singleton</span><br><span class="line">SqlHelper provideSqlHelper() &#123;</span><br><span class="line">  return new SqlImpl(application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;记得把项目重新clean一遍，build一遍，重新跑项目的时候，找到你的数据库。data-data-你的应用包名-databases-haichenyi.db，这个就是我们的数据库。找个Sqlite可视化工具打开，你会看到如下结构。</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-76d1c00d544ec20b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表结构.png"></p><p>&emsp;&emsp;太多了，不写了，下一篇写增删改查。</p><p><a href="http://download.csdn.net/download/qq_27634797/10257727" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本篇介绍android常用的数据库之一&lt;a href=&quot;https://github.com/greenrobot/greenDAO&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GreenDao&lt;/a&gt;的简单用法，增删改查。基于前面搭的框架，当然，你也可以选择不用。看懂用法之后，用起来很方便。GreenDao数据库升级到3.0版本之后api用起来更加方便了，便于让开发人员专注于业务逻辑。我需要额外说明的是，我把之前的项目框架转成了&lt;a href=&quot;http://kotlinlang.org/docs/reference/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kotlin&lt;/a&gt;，不会&lt;a href=&quot;http://kotlinlang.org/docs/reference/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kotlin&lt;/a&gt;语法的同学，可以去研究一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（三）—RxJava2.0+Retrofit2.0+OkHttp</title>
    <link href="http://haichenyi.com/2018/02/23/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94RxJava2-0-Retrofit2-0-OkHttp/"/>
    <id>http://haichenyi.com/2018/02/23/从零开始搭建一个主流项目框架（三）—RxJava2-0-Retrofit2-0-OkHttp/</id>
    <published>2018-02-23T12:40:26.000Z</published>
    <updated>2018-02-23T12:41:56.915Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇，我们把mvp+dagger加进去了，这一篇，我们把网络请求加上</p><p>&emsp;&emsp;我这里的网络请求是用的装饰者模式去写的，什么是装饰者模式呢？在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。我的理解就是一个接口，两个实现类，一个实现类负责调用接口的方法，另一个类负责功能的具体实现。本文中所提到的代码都是伪代码，最后会给出完整的，最初版本的项目框架。不包含任何业务逻辑</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/7041675-e4ef229beca589e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构.png"></p><p>&emsp;&emsp;容我一个一个来说，首先，我们一般请求网络的时候，会有统一的返回数据格式，一个是需要判断返回code码的，就比方说登录功能，那登录成功，还是失败，我们只用判断code码即可，这种类型，我们统一是HttpNoResult。还有一个是返回数据的，就比方说查一个列表数据。这里我们统一的是HttpResult。我先给出这两个类的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:没有解析数据的返回</span><br><span class="line"> */</span><br><span class="line">public class HttpNoResult &#123;</span><br><span class="line">  private int code;</span><br><span class="line">  private String msg;</span><br><span class="line"></span><br><span class="line">  public int getCode() &#123;</span><br><span class="line">    return code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpNoResult setCode(int code) &#123;</span><br><span class="line">    this.code = code;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getMsg() &#123;</span><br><span class="line">    return msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpNoResult setMsg(String msg) &#123;</span><br><span class="line">    this.msg = msg;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    return &quot;HttpNoResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &apos;&#125;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">import com.google.gson.annotations.SerializedName;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:有解析数据的返回</span><br><span class="line"> */</span><br><span class="line">public class HttpResult&lt;T&gt; &#123;</span><br><span class="line">  private int code;</span><br><span class="line">  private String msg;</span><br><span class="line">  @SerializedName(value = &quot;result&quot;)</span><br><span class="line">  private T data;</span><br><span class="line"></span><br><span class="line">  public int getCode() &#123;</span><br><span class="line">    return code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpResult setCode(int code) &#123;</span><br><span class="line">    this.code = code;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getMsg() &#123;</span><br><span class="line">    return msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpResult setMsg(String msg) &#123;</span><br><span class="line">    this.msg = msg;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public T getData() &#123;</span><br><span class="line">    return data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpResult setData(T data) &#123;</span><br><span class="line">    this.data = data;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    return &quot;HttpResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &quot;, data=&quot; + data + &apos;&#125;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我就需要说一点，有数据返回的时候，每个数据类型都是不一样的，所以，这里我用的泛型传递，不同的数据类型，传不同的bean对象</p><p>&emsp;&emsp;言归正传，我们来说说网络请求的一个接口，两个实现类。</p><p>一个接口—HttpHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">import io.reactivex.Flowable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:网络接口，接口参数Token统一处理，方法中不传Token</span><br><span class="line"> */</span><br><span class="line">public interface HttpHelper &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 登录时获取验证码.</span><br><span class="line">   *</span><br><span class="line">   * @param phone 手机号</span><br><span class="line">   * @return &#123;&quot;code&quot;:0&#125;</span><br><span class="line">   */</span><br><span class="line">  Flowable&lt;HttpNoResult&gt; loginCode(String phone);</span><br><span class="line">  /*Flowable&lt;HttpResult&lt;Login&gt;&gt; login(String phone, String code);</span><br><span class="line">  Flowable&lt;HttpResult&lt;List&lt;DiyBean&gt;&gt;&gt; diyKeys(String allId);*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Flowable是RxJava2.0新增的，所以说RxJava完美兼容Retrofit，泛型就是我们需要解析的数据</p><ol><li><p>loginCode方法是说返回数据，我们只用判断是否是成功还是失败，</p></li><li><p>login方法是说返回数据是一个Login对象，至于对象是什么内容，那就是和你们后台确认了</p></li><li><p>diyKeys方法就是说，返回数据是一个list对象，每个list的item是DiyBean对象</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.model.http.HttpHelper;</span><br><span class="line">import com.haichenyi.myproject.model.http.HttpNoResult;</span><br><span class="line"></span><br><span class="line">import io.reactivex.Flowable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:网络请求的实现类</span><br><span class="line"> */</span><br><span class="line">public class DataHelper implements HttpHelper &#123;</span><br><span class="line">  private HttpHelper http;</span><br><span class="line"></span><br><span class="line">  public DataHelper(HttpHelper http) &#123;</span><br><span class="line">    this.http = http;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123;</span><br><span class="line">    return http.loginCode(phone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;DataHelper是HttpHelper的实现类，他的唯一作用就是调用接口的方法即可，具体的功能实现是后面一个类，这里需要说明的是这个类的构造方法要public表示，因为他要dagger生成，用private或者protected表示无法生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.model.http.api.HttpApi;</span><br><span class="line"></span><br><span class="line">import io.reactivex.Flowable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc: 网络接口Retrofit实现</span><br><span class="line"> */</span><br><span class="line">public class RetrofitHelper implements HttpHelper&#123;</span><br><span class="line">  private HttpApi httpApi;</span><br><span class="line"></span><br><span class="line">  @Inject</span><br><span class="line">  RetrofitHelper(HttpApi httpApi) &#123;</span><br><span class="line">    this.httpApi = httpApi;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123;</span><br><span class="line">    return httpApi.loginCode(phone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;RetrofitHelper类作为HttpHelper接口的实现类，他是具体功能的实现类，为什么说他是具体功能的实现类呢？因为，他是调用HttpApi接口的方法。HttpApi接口是干什么用的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http.api;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.model.http.HttpNoResult;</span><br><span class="line">import com.haichenyi.myproject.model.http.ProtocolHttp;</span><br><span class="line"></span><br><span class="line">import io.reactivex.Flowable;</span><br><span class="line">import retrofit2.http.Field;</span><br><span class="line">import retrofit2.http.FormUrlEncoded;</span><br><span class="line">import retrofit2.http.POST;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:网络请求接口api</span><br><span class="line"> */</span><br><span class="line">public interface HttpApi &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 登录时获取验证码.</span><br><span class="line">   *</span><br><span class="line">   * @param phone 手机号</span><br><span class="line">   * @return &#123;&quot;code&quot;:0&#125;</span><br><span class="line">   */</span><br><span class="line">  @FormUrlEncoded</span><br><span class="line">  @POST(ProtocolHttp.METHOD_LOGIN_CODE)</span><br><span class="line">  Flowable&lt;HttpNoResult&gt; loginCode(@Field(&quot;phone&quot;) String phone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是Retrofit的网络请求的方式，看不懂？这个就是Retrofit的东西了<br>方法注解，包含@GET、@POST、@PUT、@DELETE、@PATH、@HEAD、@OPTIONS、@HTTP。<br>标记注解，包含@FormUrlEncoded、@Multipart、@Streaming。<br>参数注解，包含@Query、@QueryMap、@Body、@Field，@FieldMap、@Part，@PartMap。<br>其他注解，包含@Path、@Header、@Headers、@Url。</p><p>这里我们还差一个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public interface ProtocolHttp &#123;</span><br><span class="line">  String HTTP_HOST = &quot;http://xxx.xx.xxx.xxx:8080/app/con/&quot;;</span><br><span class="line">  String HTTP_COMMON = &quot;common/&quot;;</span><br><span class="line">  String METHOD_LOGIN_CODE = HTTP_COMMON + &quot;code&quot;;//登录发送验证码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，这里需要注意的是不能以”\”结尾，然后就是，跟你们后台商量，格式不要错了，尽量就只有接口名字不同，接口名字前面部分都是一样的。</p><p>&emsp;&emsp;到此，这里基本上就说完了，那么有同鞋就会问了，接口定义方法的时候，我们知道该如何写返回数据类型呢？这个我就不知道了，你得问你们后台，根据后台返回的数据类型去写对应的bean类。推荐一个功能PostMan。</p><p>&emsp;&emsp;到目前为止，我们都还没有初始化网络请求的参数，这些网络请求的参数在哪里初始化呢？这些参数，我们就只用初始化一次，我们就想到了dagger的全局单例模式，没错，就是这个，我们上一篇写了很多没有用的东西，里面有一个HttpModule</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.module;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.di.qualifier.ApiUrl;</span><br><span class="line">import com.haichenyi.myproject.model.http.ProtocolHttp;</span><br><span class="line">import com.haichenyi.myproject.model.http.api.HttpApi;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import javax.inject.Singleton;</span><br><span class="line"></span><br><span class="line">import dagger.Module;</span><br><span class="line">import dagger.Provides;</span><br><span class="line">import okhttp3.OkHttpClient;</span><br><span class="line">import retrofit2.Retrofit;</span><br><span class="line">import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;</span><br><span class="line">import retrofit2.converter.gson.GsonConverterFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:网络请求的参数初始化</span><br><span class="line"> */</span><br><span class="line">@Module</span><br><span class="line">public class HttpModule &#123;</span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  OkHttpClient.Builder providesOkHttpHelper() &#123;</span><br><span class="line">//请求读写超时时间</span><br><span class="line">    return new OkHttpClient.Builder()</span><br><span class="line">        .connectTimeout(10, TimeUnit.SECONDS)</span><br><span class="line">        .readTimeout(10, TimeUnit.SECONDS)</span><br><span class="line">        .writeTimeout(10, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  OkHttpClient provideClient(OkHttpClient.Builder builder) &#123;</span><br><span class="line">    return builder</span><br><span class="line">//        .addInterceptor(new MyHttpInterceptor())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  Retrofit.Builder providesRetrofitBuilder() &#123;</span><br><span class="line">    return new Retrofit.Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  HttpApi provideApi(@ApiUrl Retrofit retrofit) &#123;</span><br><span class="line">    return retrofit.create(HttpApi.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  @ApiUrl</span><br><span class="line">  Retrofit providesApiRetrofit(Retrofit.Builder builder, OkHttpClient client) &#123;</span><br><span class="line">    return createRetrofit(builder, client, ProtocolHttp.HTTP_HOST);//这里就是你的网络请求的url</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Retrofit createRetrofit(Retrofit.Builder builder, OkHttpClient client, String host) &#123;</span><br><span class="line">    return builder.client(client)</span><br><span class="line">        .baseUrl(host)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())//添加gson自动解析，我们不用关</span><br><span class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，注释写的都有，考过去用就行了</p><p>在AppModule里面添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.module;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.MyApplication;</span><br><span class="line">import com.haichenyi.myproject.model.DataHelper;</span><br><span class="line">import com.haichenyi.myproject.model.http.HttpHelper;</span><br><span class="line">import com.haichenyi.myproject.model.http.RetrofitHelper;</span><br><span class="line"></span><br><span class="line">import javax.inject.Singleton;</span><br><span class="line"></span><br><span class="line">import dagger.Module;</span><br><span class="line">import dagger.Provides;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Module</span><br><span class="line">public class AppModule &#123;</span><br><span class="line">  private MyApplication application;</span><br><span class="line"></span><br><span class="line">  public AppModule(MyApplication application) &#123;</span><br><span class="line">    this.application = application;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  DataHelper provideDataHelper(HttpHelper httpHelper) &#123;</span><br><span class="line">    return new DataHelper(httpHelper);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  HttpHelper provideHttpHelper(RetrofitHelper retrofitHelper) &#123;</span><br><span class="line">    return retrofitHelper;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里都是dagger了生成全局单例对象需要的东西</p><p>在AppComponent里面添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.component;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.di.module.AppModule;</span><br><span class="line">import com.haichenyi.myproject.di.module.HttpModule;</span><br><span class="line">import com.haichenyi.myproject.model.DataHelper;</span><br><span class="line"></span><br><span class="line">import javax.inject.Singleton;</span><br><span class="line"></span><br><span class="line">import dagger.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Singleton</span><br><span class="line">@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)</span><br><span class="line">public interface AppComponent &#123;</span><br><span class="line">  DataHelper getDataHelper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BaseMvpPresenter里面添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">import io.reactivex.disposables.CompositeDisposable;</span><br><span class="line">import io.reactivex.disposables.Disposable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123;</span><br><span class="line">  protected T baseView;</span><br><span class="line">  private CompositeDisposable disposables;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void attachView(T baseView) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected void addSubscribe(Disposable disposable) &#123;</span><br><span class="line">    if (null == disposables) &#123;</span><br><span class="line">      disposables = new CompositeDisposable();</span><br><span class="line">    &#125;</span><br><span class="line">    disposables.add(disposable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void detachView() &#123;</span><br><span class="line">    this.baseView = null;</span><br><span class="line">    unSubscribe();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void unSubscribe() &#123;</span><br><span class="line">    if (null != disposables) &#123;</span><br><span class="line">      disposables.clear();</span><br><span class="line">      disposables = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，就全部写完了，关于网络请求的内容。调用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.presenter;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BaseMvpPresenter;</span><br><span class="line">import com.haichenyi.myproject.base.MyApplication;</span><br><span class="line">import com.haichenyi.myproject.contract.MainContract;</span><br><span class="line">import com.haichenyi.myproject.model.DataHelper;</span><br><span class="line"></span><br><span class="line">import javax.inject.Inject;</span><br><span class="line"></span><br><span class="line">import io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line">import io.reactivex.schedulers.Schedulers;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt;</span><br><span class="line">    implements MainContract.Presenter &#123;</span><br><span class="line">  private DataHelper dataHelper;</span><br><span class="line">  @Inject</span><br><span class="line">  MainPresenter() &#123;</span><br><span class="line">    dataHelper = MyApplication.getAppComponent().getDataHelper();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void loadData() &#123;</span><br><span class="line">    addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe());</span><br><span class="line">//    baseView.showTipMsg(&quot;加载数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得在清单文件里面，加上网络权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure><p>网络请求，这样调用之后在哪处理呢？我给出我的几个处理的工具类。首先，按如下图设置1.8支持lambda表达式</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-cbecfbc473c7b512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置.png"></p><p>然后添加如下几个类</p><p>HttpCode </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc: 网络请求状态码</span><br><span class="line"> */</span><br><span class="line">public interface HttpCode &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 成功.</span><br><span class="line">   */</span><br><span class="line">  int SUCCESS = 0;</span><br><span class="line">  /**</span><br><span class="line">   * 参数为空.</span><br><span class="line">   */</span><br><span class="line">  int NO_PARAMETER = 1;</span><br><span class="line">  /**</span><br><span class="line">   * 服务器错误.</span><br><span class="line">   */</span><br><span class="line">  int SERVER_ERR = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApiException </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc: 接口异常判断处理</span><br><span class="line"> */</span><br><span class="line">public class ApiException extends Exception &#123;</span><br><span class="line">  private int code;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">  public ApiException(int code) &#123;</span><br><span class="line">    this.code = code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ApiException(int code, String message) &#123;</span><br><span class="line">    super(message);</span><br><span class="line">    this.code = code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getCode() &#123;</span><br><span class="line">    return code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ApiException setCode(int code) &#123;</span><br><span class="line">    this.code = code;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyRxUtils </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">import io.reactivex.BackpressureStrategy;</span><br><span class="line">import io.reactivex.Flowable;</span><br><span class="line">import io.reactivex.FlowableTransformer;</span><br><span class="line">import io.reactivex.Scheduler;</span><br><span class="line">import io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line">import io.reactivex.schedulers.Schedulers;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/27</span><br><span class="line"> * Desc:切换线程的工具类</span><br><span class="line"> */</span><br><span class="line">public class MyRxUtils &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 从其他线程转到主线程.</span><br><span class="line">   *</span><br><span class="line">   * @param scheduler Schedulers.io()等等</span><br><span class="line">   * @param &lt;T&gt;       t</span><br><span class="line">   * @return FlowableTransformer</span><br><span class="line">   */</span><br><span class="line">  public static &lt;T&gt; FlowableTransformer&lt;T, T&gt; toMain(Scheduler scheduler) &#123;</span><br><span class="line">    return upstream -&gt; upstream.subscribeOn(scheduler).observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; FlowableTransformer&lt;HttpResult&lt;T&gt;, T&gt; handResult() &#123;</span><br><span class="line">    return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .flatMap(tHttpResult -&gt; &#123;</span><br><span class="line">          if (tHttpResult.getCode() == HttpCode.SUCCESS) &#123;</span><br><span class="line">            return /*createData(tHttpResult.data)*/Flowable.just(tHttpResult.getData());</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            return Flowable.error(new ApiException(tHttpResult.getCode(), tHttpResult.getMsg()));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static &lt;T&gt; Flowable&lt;T&gt; createData(final T data) &#123;</span><br><span class="line">    return Flowable.create(e -&gt; &#123;</span><br><span class="line">      e.onNext(data);</span><br><span class="line">      e.onComplete();</span><br><span class="line">    &#125;, BackpressureStrategy.ERROR);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySubscriber</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BaseView;</span><br><span class="line">import io.reactivex.subscribers.ResourceSubscriber;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123;</span><br><span class="line">  private BaseView baseView;</span><br><span class="line">  private boolean showLoading;</span><br><span class="line"></span><br><span class="line">  public MySubscriber(BaseView baseView) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MySubscriber(BaseView baseView, boolean showLoading) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">    this.showLoading = showLoading;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onStart() &#123;</span><br><span class="line">    super.onStart();</span><br><span class="line">    if (null != baseView &amp;&amp; showLoading) &#123;</span><br><span class="line">      baseView.showLoading();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onError(Throwable t) &#123;</span><br><span class="line">    if (null == baseView) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    baseView.hideLoading();</span><br><span class="line">    if (t instanceof ApiException) &#123;</span><br><span class="line">      ApiException apiException = (ApiException) t;</span><br><span class="line">      switch (apiException.getCode()) &#123;</span><br><span class="line">        case HttpCode.NO_PARAMETER:</span><br><span class="line">          baseView.showTipMsg(&quot;参数为空&quot;);</span><br><span class="line">          break;</span><br><span class="line">        case HttpCode.SERVER_ERR:</span><br><span class="line">          baseView.showTipMsg(&quot;服务器错误&quot;);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onComplete() &#123;</span><br><span class="line">    if (null != baseView) &#123;</span><br><span class="line">      baseView.hideLoading();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个类不想多做解释，结合注释，仔细看几遍，就知道是干嘛用的了</p><p>加上这几个之后调用方式就变成了以下的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.presenter;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BaseMvpPresenter;</span><br><span class="line">import com.haichenyi.myproject.base.MyApplication;</span><br><span class="line">import com.haichenyi.myproject.contract.MainContract;</span><br><span class="line">import com.haichenyi.myproject.model.DataHelper;</span><br><span class="line">import com.haichenyi.myproject.model.http.HttpNoResult;</span><br><span class="line">import com.haichenyi.myproject.model.http.MyRxUtils;</span><br><span class="line">import com.haichenyi.myproject.model.http.MySubscriber;</span><br><span class="line"></span><br><span class="line">import javax.inject.Inject;</span><br><span class="line"></span><br><span class="line">import io.reactivex.schedulers.Schedulers;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt;</span><br><span class="line">    implements MainContract.Presenter &#123;</span><br><span class="line">  private DataHelper dataHelper;</span><br><span class="line"></span><br><span class="line">  @Inject</span><br><span class="line">  MainPresenter() &#123;</span><br><span class="line">    dataHelper = MyApplication.getAppComponent().getDataHelper();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void loadData() &#123;</span><br><span class="line">    addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;)</span><br><span class="line">        .compose(MyRxUtils.toMain(Schedulers.io()))</span><br><span class="line">        .subscribeWith(new MySubscriber&lt;HttpNoResult&gt;(baseView, true) &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onNext(HttpNoResult httpNoResult) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">//    baseView.showTipMsg(&quot;加载数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完了，完了，终于写完了。</p><p><a href="http://download.csdn.net/download/qq_27634797/10256152" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇，我们把mvp+dagger加进去了，这一篇，我们把网络请求加上&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我这里的网络请求是用的装饰者模式去写的，什么是装饰者模式呢？在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。我的理解就是一个接口，两个实现类，一个实现类负责调用接口的方法，另一个类负责功能的具体实现。本文中所提到的代码都是伪代码，最后会给出完整的，最初版本的项目框架。不包含任何业务逻辑&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（二）—MVP+dagger2</title>
    <link href="http://haichenyi.com/2018/02/23/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94MVP-dagger2/"/>
    <id>http://haichenyi.com/2018/02/23/从零开始搭建一个主流项目框架（二）—MVP-dagger2/</id>
    <published>2018-02-23T12:36:38.000Z</published>
    <updated>2018-02-23T12:38:17.053Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;接着上一篇简单的框架，没有看过的同鞋可以去喵一眼。上一篇我们搭好了简单的框架，初始化一次的内容丢在Application里面，所有的activity继承一个类BaseActivity，还有Fragment继承的一个类BaseFragment</p><a id="more"></a><p>&emsp;&emsp;现在我们来加上MVP，不懂MVP的同鞋可以看一下，我前面写过的三种主流框架的对比。我们先导入dagger2的两个包，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.google.dagger:dagger:2.14.1&apos;</span><br><span class="line">annotationProcessor &quot;com.google.dagger:dagger-compiler:2.14.1&quot;</span><br></pre></td></tr></table></figure><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>&emsp;&emsp;新建BasePresenter接口，BaseMvpPresenter类去实现BasePresenter接口，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.shfzwkeji.smartwardrobe.base;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc: 不带mvp的presenter的基类</span><br><span class="line"> */</span><br><span class="line">public interface BasePresenter&lt;T extends BaseView&gt; &#123;</span><br><span class="line">  void attachView(T baseView);</span><br><span class="line"></span><br><span class="line">  void detachView();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:带mvp的presenter的基类</span><br><span class="line"> */</span><br><span class="line">public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123;</span><br><span class="line">  protected T baseView;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void attachView(T baseView) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void detachView() &#123;</span><br><span class="line">    this.baseView = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里就只有两个方法，一个是绑定view，还有一个是在ondestory方法里面解除绑定的方法，用来保证P层的生命周期和V层同步，避免了，当V层销毁的时候，P层仍然存在造成的内存泄漏。</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>&emsp;&emsp;新建BaseMvpActivity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">import javax.inject.Inject;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:带MVP的Activity</span><br><span class="line"> */</span><br><span class="line">public abstract class BaseMvpActivity&lt;T extends BasePresenter&gt;  extends BaseActivity&#123;</span><br><span class="line">  @Inject</span><br><span class="line">  protected T basePresenter;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  protected void initView() &#123;</span><br><span class="line">    super.initView();</span><br><span class="line">    initInject();</span><br><span class="line">    if (null != basePresenter) &#123;</span><br><span class="line">      basePresenter.attachView(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void initInject();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDestroy() &#123;</span><br><span class="line">    if (null != basePresenter) &#123;</span><br><span class="line">      basePresenter.detachView();</span><br><span class="line">      basePresenter = null;</span><br><span class="line">    &#125;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运用dagger2注解的方式，生成P层，这里我们在用P层之前得先生成P层，所以initject方法一定要在basePresenter用之前调用，因为他就是生成P层的代码。</p><p>&emsp;&emsp;怎么生成呢？dagger我们一般都命名成di层，所以，我们先创建di层的package，项目结构图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-97ad0d5ba60d4af3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构图.png"></p><p>&emsp;&emsp;这里给出的是mvp+dagger加入之后的项目结构。我们重点看选中的di层，里面有4个package分别是component，module，qualifier，scope四个包，至于他们的作用分别是什么，请自行百度，google，dagger的用法。我这里先贴出这几个类，接口的代码：</p><p>ActivityComponent </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.component;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.MainActivity;</span><br><span class="line">import com.haichenyi.myproject.di.module.ActivityModule;</span><br><span class="line">import com.haichenyi.myproject.di.scope.ActivityScope;</span><br><span class="line"></span><br><span class="line">import dagger.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@ActivityScope</span><br><span class="line">@Component(dependencies = AppComponent.class, modules = ActivityModule.class)</span><br><span class="line">public interface ActivityComponent &#123;</span><br><span class="line">  void inject(MainActivity mainActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppComponent </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.component;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.di.module.AppModule;</span><br><span class="line">import com.haichenyi.myproject.di.module.HttpModule;</span><br><span class="line"></span><br><span class="line">import javax.inject.Singleton;</span><br><span class="line"></span><br><span class="line">import dagger.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Singleton</span><br><span class="line">@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)</span><br><span class="line">public interface AppComponent &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityModule </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.module;</span><br><span class="line"></span><br><span class="line">import dagger.Module;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Module</span><br><span class="line">public class ActivityModule &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppModule </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.module;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.MyApplication;</span><br><span class="line"></span><br><span class="line">import dagger.Module;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Module</span><br><span class="line">public class AppModule &#123;</span><br><span class="line">  private MyApplication application;</span><br><span class="line"></span><br><span class="line">  public AppModule(MyApplication application) &#123;</span><br><span class="line">    this.application = application;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpModule </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.module;</span><br><span class="line"></span><br><span class="line">import dagger.Module;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Module</span><br><span class="line">public class HttpModule &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityScope </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.scope;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line">import javax.inject.Scope;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Scope</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface ActivityScope &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这几个类，接口里面基本上都没有内容，因为这几个类都是后面才会用的到的，这里我直接贴出来，说起来方便一些。还需要加两个方法，在MyApplication里面加如下方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 获取AppComponent.</span><br><span class="line">   *</span><br><span class="line">   * @return AppComponent</span><br><span class="line">   */</span><br><span class="line">  public static synchronized AppComponent getAppComponent() &#123;</span><br><span class="line">    if (null == appComponent) &#123;</span><br><span class="line">      appComponent = DaggerAppComponent.builder()</span><br><span class="line">          .appModule(new AppModule(getInstance()))</span><br><span class="line">          .httpModule(new HttpModule())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line">    return appComponent;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在BaseActivity里面加如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected ActivityComponent getActivityComponent() &#123;</span><br><span class="line">    return DaggerActivityComponent.builder()</span><br><span class="line">        .appComponent(MyApplication.getAppComponent())</span><br><span class="line">        .activityModule(new ActivityModule())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;加完这两个方法之后，肯定会有错误提示，重新编译一遍项目就可以了，如果重新编译一遍，还是不行，请重新对比一下，哪里不一样。</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>&emsp;&emsp;就是关于mvp的了，从上面图应该看到了，有一个presenter包，和contract包，我们之前有一篇博客讲过，MVP就是多了很多个接口，这些接口写在哪呢？就在contract层</p><p>MainContract 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.contract;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BasePresenter;</span><br><span class="line">import com.haichenyi.myproject.base.BaseView;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public interface MainContract &#123;</span><br><span class="line">  interface IView extends BaseView&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  interface Presenter extends BasePresenter&lt;IView&gt;&#123;</span><br><span class="line">    void loadData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我需要说明的就是Presenter接口继承的是IVew，不是BaseView，页面变化的方法都是在IView接口里面定义，逻辑处理，网络请求方法都是在Presenter接口里面定义</p><p>MainPresenter 代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.presenter;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BaseMvpPresenter;</span><br><span class="line">import com.haichenyi.myproject.contract.MainContract;</span><br><span class="line"></span><br><span class="line">import javax.inject.Inject;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt;</span><br><span class="line">    implements MainContract.Presenter &#123;</span><br><span class="line">  @Inject</span><br><span class="line">  MainPresenter() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void loadData() &#123;</span><br><span class="line">    baseView.showTipMsg(&quot;加载数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我需要说明的是注意继承BaseMvpPresenter传的是MainContract.IView，不是BaseView，实现MainContract.Presenter接口，还有一点就是注意构造方法，上面有注解，这里的loadData里面应该是我们的网络请求逻辑，这里我放到后面一篇在说，这里我先就直接Toast，表示走了这个方法</p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>&emsp;&emsp;就是MainActivity，这里我贴出代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BaseMvpActivity;</span><br><span class="line">import com.haichenyi.myproject.contract.MainContract;</span><br><span class="line">import com.haichenyi.myproject.presenter.MainPresenter;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends BaseMvpActivity&lt;MainPresenter&gt; implements MainContract.IView &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected int getLayoutId(Bundle savedInstanceState) &#123;</span><br><span class="line">    return R.layout.activity_main;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void initData() &#123;</span><br><span class="line">    super.initData();</span><br><span class="line">    initToolbar(true, false, true).setMyTitle(&quot;主页&quot;).setMoreTitle(&quot;更多&quot;);</span><br><span class="line">    basePresenter.loadData();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void initInject() &#123;</span><br><span class="line">    getActivityComponent().inject(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我需要说明的是继承BaseMvpActivity，泛型直接传MainPresenter，然后，实现MainContract.IView接口，直接用basePresenter调用方法，需要实现initInject方法，只要是是继承BaseMvpActivity的activity，都需要在ActivityComponent()里面注册一边。比方说，LoginActivity也是继承的BaseMvpActivity，辣么，在di层的component包下面的ActivityComponent接口里面定义一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void inject(LoginActivity loginActivity);</span><br></pre></td></tr></table></figure><p>在LoginActivity的initInject方法里面写同样的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getActivityComponent().inject(this);</span><br></pre></td></tr></table></figure><p>就像这样写就可以了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;写到这里，mvp+dagger2基本上完成了，MVP的目的就是解藕，把业务逻辑，网络请求丢在P层，页面不发生变化，就只用改P层逻辑，从而达到了解藕的目的。dagger2简化了代码，并且，它有着全局单例模式，和局部单例模式，优化了我们的内存，减少了内存浪费。不用每次都去new一个P层对象出来。下一篇，我们就把网络请求加上</p><p><a href="http://download.csdn.net/download/qq_27634797/10256146" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;接着上一篇简单的框架，没有看过的同鞋可以去喵一眼。上一篇我们搭好了简单的框架，初始化一次的内容丢在Application里面，所有的activity继承一个类BaseActivity，还有Fragment继承的一个类BaseFragment&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（一）—简单的框架</title>
    <link href="http://haichenyi.com/2018/02/23/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E6%A1%86%E6%9E%B6/"/>
    <id>http://haichenyi.com/2018/02/23/从零开始搭建一个主流项目框架（一）—简单的框架/</id>
    <published>2018-02-23T12:30:11.000Z</published>
    <updated>2018-02-23T12:33:47.969Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>&emsp;&emsp;首先先说出，最终的目的是现在主流的MVP+RxJava+Retrofit+OkHttp框架。让大家心里有底</p><p>&emsp;&emsp;开发工具Android Studio3.0，还在用eclipse的同鞋，强烈推荐你跨出这一步，你会发现一个新的世界。android studio都出来这么久了，你还在远古时代做开发，说句不好听的，你完全与时代脱轨，你不适合做开发（纯属个人观点）</p><a id="more"></a><p>&emsp;&emsp;本篇就只有三部分，第一部分就是新建一个Application，第二部分就是BaseActivity，第三部分就是BaseFragment</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>&emsp;&emsp;首先你得有application类，去初始化应用只用初始化一次的内容，继承Application，然后在清单文件里面注册。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject;</span><br><span class="line"></span><br><span class="line">import android.app.Application;</span><br><span class="line"></span><br><span class="line">import com.squareup.leakcanary.LeakCanary;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line">  private static MyApplication instance;</span><br><span class="line"></span><br><span class="line">  public MyApplication getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void setInstance(MyApplication instance) &#123;</span><br><span class="line">    MyApplication.instance = instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    setInstance(this);</span><br><span class="line">    initLeakCanary();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 初始化内存检测工具</span><br><span class="line">   */</span><br><span class="line">  private void initLeakCanary() &#123;</span><br><span class="line">    if (LeakCanary.isInAnalyzerProcess(this)) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    LeakCanary.install(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上代码，我这里就初始化了一个全局application单例对象，还初始化square公司出品的一个内存检测工具，用于检测你项目中内存泄漏情况。便于你优化项目。</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-44c0f8e0ac459dbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="清单文件.png"></p><p>&emsp;&emsp;如上图所示，这个就是清单文件，在application结点下面，添加name标签，内容就是你创建的application的名字。这里你还需要添加两个内存检测的依赖。</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-6fb1ca45a82b3b14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构.png"></p><p>&emsp;&emsp;如上图所示，首先把你的项目结构视图切换到Project，打开你的app目录下的build.gradle文件，在dependencies结点下面（只要是添加开源库都是在该结点下面，后面就不说了），添加如下两行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">releaseImplementation &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;</span><br><span class="line">debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后的1.5.4是版本号，你可以在github上面搜索<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">leakcanary</a>，找最新的版本</p><h3 id="BaseActivity"><a href="#BaseActivity" class="headerlink" title="BaseActivity"></a>BaseActivity</h3><p>&emsp;&emsp;创建基类BaseActivity，也就是所有Activity的父类。还有一个基类的接口BaseView，BaseActivity继承刚才添加的依赖的SupportActivity类，实现BaseView接口，并且实现点击事件的接口（选择实现，你要是不乐意在基类里面写，你可以在你自己的子类里面重新实现一遍也是可以的）。代码如下：每个方法注释写的很清楚，就不用一一解释了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">import android.app.AlertDialog;</span><br><span class="line">import android.graphics.Color;</span><br><span class="line">import android.graphics.drawable.ColorDrawable;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.support.annotation.Nullable;</span><br><span class="line">import android.view.Window;</span><br><span class="line">import android.widget.ProgressBar;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.utils.ToastUtils;</span><br><span class="line"></span><br><span class="line">import me.yokeyword.fragmentation.SupportActivity;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public abstract class BaseActivity extends SupportActivity implements BaseView &#123;</span><br><span class="line">  private AlertDialog loadingDialog;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Toast 提示用户</span><br><span class="line">   * @param msg 提示内容String</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void showTipMsg(String msg) &#123;</span><br><span class="line">    ToastUtils.showTipMsg(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Toast 提示用户</span><br><span class="line">   * @param msg 提示内容res目录下面的String的int值</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void showTipMsg(int msg) &#123;</span><br><span class="line">    ToastUtils.showTipMsg(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 网络请求的时候显示正在加载的对话框</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void showLoading() &#123;</span><br><span class="line">    if (null == loadingDialog) &#123;</span><br><span class="line">      loadingDialog = new AlertDialog.Builder(this).setView(new ProgressBar(this)).create();</span><br><span class="line">      loadingDialog.setCanceledOnTouchOutside(false);</span><br><span class="line">      Window window = loadingDialog.getWindow();</span><br><span class="line">      if (null != window) &#123;</span><br><span class="line">        window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!loadingDialog.isShowing()) &#123;</span><br><span class="line">      loadingDialog.show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 网络请求完成时隐藏加载对话框</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void hideLoading() &#123;</span><br><span class="line">    if (null != loadingDialog) &#123;</span><br><span class="line">      if (loadingDialog.isShowing()) &#123;</span><br><span class="line">        loadingDialog.dismiss();</span><br><span class="line">      &#125;</span><br><span class="line">      loadingDialog = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void invalidToken() &#123;</span><br><span class="line">    //用于检测你当前用户的token是否有效，无效就返回登录界面，具体的业务逻辑你自己实现</span><br><span class="line">    //如果需要做到实时检测，推荐用socket长连接，每隔10秒发送一个验证当前登录用户token是否过期的请求</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Finish当前页面，最好实现onBackPressedSupport()，这个方法会有一个退栈操作，</span><br><span class="line">   * 开源框架实现的，我们不用管</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void myFinish() &#123;</span><br><span class="line">    onBackPressedSupport();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onBackPressedSupport() &#123;</span><br><span class="line">    super.onBackPressedSupport();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面是目前BaseActivity代码，注释写的很清楚，你会发现BaseView你并没有，下面我给出BaseView的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">import android.support.annotation.StringRes;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public interface BaseView &#123;</span><br><span class="line">  void showTipMsg(String msg);</span><br><span class="line"></span><br><span class="line">  void showTipMsg(@StringRes int msg);</span><br><span class="line"></span><br><span class="line">  void showLoading();</span><br><span class="line"></span><br><span class="line">  void hideLoading();</span><br><span class="line"></span><br><span class="line">  void invalidToken();</span><br><span class="line"></span><br><span class="line">  void myFinish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;BaseView就是一个接口，是所有V层的基类，代码很简单，Toast方法，显示隐藏加载的对话框方法，检验token是否过期的方法，finish当前页面的方法。什么？Toast方法你没有，下面我贴出来我的Toast的工具类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc: 实时更新的Toast工具类</span><br><span class="line"> */</span><br><span class="line">public final class ToastUtils &#123;</span><br><span class="line">  private static Toast toast;</span><br><span class="line"></span><br><span class="line">  private ToastUtils() &#123;</span><br><span class="line">    throw new RuntimeException(&quot;工具类不允许创建对象&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;all&quot;)</span><br><span class="line">  private static void init() &#123;</span><br><span class="line">    if (toast == null) &#123;</span><br><span class="line">      toast = Toast.makeText(MyApplication.getInstance(), &quot;&quot;, Toast.LENGTH_SHORT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void showTipMsg(String msg) &#123;</span><br><span class="line">    if (null == toast) &#123;</span><br><span class="line">      init();</span><br><span class="line">    &#125;</span><br><span class="line">    toast.setText(msg);</span><br><span class="line">    toast.show();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void showTipMsg(@StringRes int msg) &#123;</span><br><span class="line">    if (null == toast) &#123;</span><br><span class="line">      init();</span><br><span class="line">    &#125;</span><br><span class="line">    toast.setText(msg);</span><br><span class="line">    toast.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面我贴出了三个类，这里我要说明的是，我又创建了两个package，一个是base，一个是utils，我把BaseActivity,BaseView,MyApplication放在base包下面，Toast的工具类放在utils包下面</p><p>&emsp;&emsp;再就是添加一些常用的东西了，这里我没有用黄油刀，用过一段时间之后，感觉他的每个控件都是全局的，有点占内存，就放弃了。我下面贴出BaseActivity新增的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 保存当前activity对象，在OnCreate里面添加，记得在OnDestroy里面移除</span><br><span class="line">   * 有什么用呢？</span><br><span class="line">   * 比方说有一个需求，让你在任意位置弹出对话框，弹对话框又需要一个context对象，这个时候，</span><br><span class="line">   * 你就只用传当前list的最上层的activity对象就可以了</span><br><span class="line">   * 当然还有其他需求</span><br><span class="line">   */</span><br><span class="line">  public static List&lt;BaseActivity&gt; activities = new ArrayList&lt;&gt;();</span><br><span class="line">  private Toolbar toolbar;</span><br><span class="line">  private TextView tvToolbarTitle;</span><br><span class="line">  private TextView tvToolbarRight;</span><br><span class="line">  private TextView tvBack;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    activities.add(this);</span><br><span class="line">    //强制竖屏(不强制加)</span><br><span class="line">    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br><span class="line">    int layoutId = getLayoutId(savedInstanceState);</span><br><span class="line">    View inflate = getLayoutInflater().inflate(R.layout.activity_base, toolbar, false);</span><br><span class="line">    LinearLayout rootLinearLayout = inflate.findViewById(R.id.ll_layout_base_activity);</span><br><span class="line">    //没有布局的时候传0</span><br><span class="line">    if (0 == layoutId) &#123;</span><br><span class="line">      setContentView(rootLinearLayout);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      View rootView = getLayoutInflater().inflate(layoutId, rootLinearLayout, true);</span><br><span class="line">      setContentView(rootView);</span><br><span class="line">    &#125;</span><br><span class="line">    stateBar();</span><br><span class="line">    initView();</span><br><span class="line">    initData();</span><br><span class="line">    setOnClick(R.id.tv_back_base_activity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置点击事件.</span><br><span class="line">   *</span><br><span class="line">   * @param ids 被点击View的ID</span><br><span class="line">   * @return &#123;@link BaseActivity&#125;</span><br><span class="line">   */</span><br><span class="line">  public BaseActivity setOnClick(@IdRes int... ids) &#123;</span><br><span class="line">    View view;</span><br><span class="line">    for (int id : ids) &#123;</span><br><span class="line">      view = findViewById(id);</span><br><span class="line">      if (null != view) &#123;</span><br><span class="line">        view.setOnClickListener(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置点击事件.</span><br><span class="line">   *</span><br><span class="line">   * @param views 被点击View</span><br><span class="line">   * @return &#123;@link BaseActivity&#125;</span><br><span class="line">   */</span><br><span class="line">  public BaseActivity setOnClick(View... views) &#123;</span><br><span class="line">    for (View view : views) &#123;</span><br><span class="line">      view.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 获取当前布局对象</span><br><span class="line">   *</span><br><span class="line">   * @param savedInstanceState 这个是当前activity保存的数据，最常见的就是横竖屏切换的时候，</span><br><span class="line">   *                           数据丢失问题</span><br><span class="line">   * @return 当前布局的int值</span><br><span class="line">   */</span><br><span class="line">  protected abstract int getLayoutId(Bundle savedInstanceState);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDestroy() &#123;</span><br><span class="line">    activities.remove(this);</span><br><span class="line">    super.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected void initData() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected void initView() &#123;</span><br><span class="line">    toolbar = findViewById(R.id.toolbar_base_activity);</span><br><span class="line">    tvToolbarTitle = findViewById(R.id.tv_title_base_activity);</span><br><span class="line">    tvToolbarRight = findViewById(R.id.tv_right_base_activity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置状态栏背景颜色，不能改变状态栏内容的颜色</span><br><span class="line">   */</span><br><span class="line">  private void stateBar() &#123;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">    &#125;</span><br><span class="line">    SystemBarTintManager tintManager = new SystemBarTintManager(this);</span><br><span class="line">    tintManager.setStatusBarTintEnabled(true);</span><br><span class="line">    tintManager.setNavigationBarTintEnabled(true);</span><br><span class="line">    tintManager.setTintColor(Color.parseColor(&quot;#000000&quot;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">    switch (v.getId()) &#123;</span><br><span class="line">      case R.id.tv_back_base_activity:</span><br><span class="line">        onBackPressedSupport();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我需要说明的是，新增了一个开源框架，就是设置状态栏背景颜色的<a href="https://github.com/jgilfelt/SystemBarTint" target="_blank" rel="noopener">systembartint</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.readystatesoftware.systembartint:systembartint:1.0.3&apos;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再就是设置activity标题内容，左边，右边的内容，左边右边可能是文字，也可能是图片。所以，我在用的时候，都是用的TextView，ImageView，不能设置文字。方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public BaseActivity setTitles(CharSequence title) &#123;</span><br><span class="line">    tvToolbarTitle.setText(title);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 初始化toolbar的内容</span><br><span class="line">   * @param isShowToolbar 是否显示toolbar</span><br><span class="line">   * @param isShowBack 是否显示左边的TextView</span><br><span class="line">   * @param isShowMore 是否显示右边的TextView</span><br><span class="line">   * @return 当前activity对象，可以连点</span><br><span class="line">   */</span><br><span class="line">  protected BaseActivity initToolbar(boolean isShowToolbar, boolean isShowBack,</span><br><span class="line">                                     boolean isShowMore) &#123;</span><br><span class="line">    setSupportActionBar(toolbar);</span><br><span class="line">    ActionBar actionBar = getSupportActionBar();</span><br><span class="line">    if (null != actionBar) &#123;</span><br><span class="line">      if (isShowToolbar) &#123;</span><br><span class="line">        actionBar.show();</span><br><span class="line">        tvBack = findViewById(R.id.tv_back_base_activity);</span><br><span class="line">        TextView textView = findViewById(R.id.tv_right_base_activity);</span><br><span class="line">        if (null != tvBack &amp;&amp; null != textView) &#123;</span><br><span class="line">          tvBack.setVisibility(isShowBack ? View.VISIBLE : View.INVISIBLE);</span><br><span class="line">          textView.setVisibility(isShowMore ? View.VISIBLE : View.INVISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        actionBar.hide();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BaseActivity setToolbarBack(int colorId) &#123;</span><br><span class="line">    toolbar.setBackgroundColor(getResources().getColor(colorId));</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">  public BaseActivity setMyTitle(String title) &#123;</span><br><span class="line">    tvToolbarTitle.setText(title);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BaseActivity setMyTitle(@StringRes int stringId) &#123;</span><br><span class="line">    tvToolbarTitle.setText(stringId);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setMoreTitle(String moreTitle) &#123;</span><br><span class="line">    tvToolbarRight.setText(moreTitle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BaseActivity setMoreTitle(@StringRes int stringId) &#123;</span><br><span class="line">    tvToolbarRight.setText(stringId);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置左边内容.</span><br><span class="line">   *</span><br><span class="line">   * @param leftTitle 内容</span><br><span class="line">   * @return &#123;@link BaseActivity&#125;</span><br><span class="line">   */</span><br><span class="line">  public BaseActivity setLeftTitle(String leftTitle) &#123;</span><br><span class="line">    if (tvBack != null) &#123;</span><br><span class="line">      tvBack.setBackground(null);</span><br><span class="line">      tvBack.setText(leftTitle);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置左边内容.</span><br><span class="line">   *</span><br><span class="line">   * @param leftTitle 内容</span><br><span class="line">   */</span><br><span class="line">  public void setLeftTitle(@StringRes int leftTitle) &#123;</span><br><span class="line">    if (tvBack != null) &#123;</span><br><span class="line">      tvBack.setBackground(null);</span><br><span class="line">      tvBack.setText(leftTitle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">  protected BaseActivity setMoreBackground(int resId) &#123;</span><br><span class="line">    tvToolbarRight.setBackgroundResource(resId);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到上面的方法返回值都是BaseActivity，这样做的目的就只有一个，可以连点，写一个方法之后，可以接着点写下一个方法，不用写一个方法就要加分号，就换一行写下一个方法。</p><p>&emsp;&emsp;还要加一句，在你的app主题里面添加两个item，也就是你的res目录下面的style：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;</span><br><span class="line">&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我这里贴出我目前的style的图片</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-3d1615eeaef01d7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="style.png"></p><p>&emsp;&emsp;下面有一个LineHorizontal样式，就是你toolbar下面的那个横线</p><h3 id="BaseFragment"><a href="#BaseFragment" class="headerlink" title="BaseFragment"></a>BaseFragment</h3><p>&emsp;&emsp;BaseFragment跟BaseActivity的逻辑是差不多的，我这里就贴出代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.support.annotation.IdRes;</span><br><span class="line">import android.support.annotation.NonNull;</span><br><span class="line">import android.support.annotation.Nullable;</span><br><span class="line">import android.view.LayoutInflater;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.utils.ToastUtils;</span><br><span class="line"></span><br><span class="line">import me.yokeyword.fragmentation.SupportFragment;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public abstract class BaseFragment extends SupportFragment implements BaseView,</span><br><span class="line">    View.OnClickListener &#123;</span><br><span class="line">  protected boolean isInit;</span><br><span class="line">  private View rootView;</span><br><span class="line"></span><br><span class="line">  @Nullable</span><br><span class="line">  @Override</span><br><span class="line">  public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,</span><br><span class="line">                           @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    int layoutRes = layoutRes();</span><br><span class="line">    if (0 != layoutRes) &#123;</span><br><span class="line">      return inflater.inflate(layoutRes, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return super.onCreateView(inflater, container, savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onViewCreated(view, savedInstanceState);</span><br><span class="line">    rootView = view;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onLazyInitView(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onLazyInitView(savedInstanceState);</span><br><span class="line">    isInit = true;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected &lt;T extends View&gt; T findViewById(@IdRes int id) &#123;</span><br><span class="line">    return rootView.findViewById(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置点击事件.</span><br><span class="line">   *</span><br><span class="line">   * @param ids 被点击View的ID</span><br><span class="line">   * @return &#123;@link BaseFragment&#125;</span><br><span class="line">   */</span><br><span class="line">  public BaseFragment setOnClick(@IdRes int... ids) &#123;</span><br><span class="line">    for (int id : ids) &#123;</span><br><span class="line">      rootView.findViewById(id).setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置点击事件.</span><br><span class="line">   *</span><br><span class="line">   * @param views 被点击View的ID</span><br><span class="line">   * @return &#123;@link BaseFragment&#125;</span><br><span class="line">   */</span><br><span class="line">  public BaseFragment setOnClick(View... views) &#123;</span><br><span class="line">    for (View view : views) &#123;</span><br><span class="line">      view.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void init();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onDestroy() &#123;</span><br><span class="line">    rootView = null;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract int layoutRes();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void showTipMsg(String msg) &#123;</span><br><span class="line">    ToastUtils.showTipMsg(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void showTipMsg(int msg) &#123;</span><br><span class="line">    ToastUtils.showTipMsg(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void showLoading() &#123;</span><br><span class="line">    BaseActivity activity = (BaseActivity) getActivity();</span><br><span class="line">    /*if (activity instanceof BaseMvpActivity) &#123;</span><br><span class="line">      activity.showLoading();</span><br><span class="line">    &#125;*/</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void hideLoading() &#123;</span><br><span class="line">    BaseActivity activity = (BaseActivity) getActivity();</span><br><span class="line">    /*if (activity instanceof BaseMvpActivity) &#123;</span><br><span class="line">      activity.hideLoading();</span><br><span class="line">    &#125;*/</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void invalidToken() &#123;</span><br><span class="line">    BaseActivity activity = (BaseActivity) getActivity();</span><br><span class="line">    /*if (activity instanceof BaseMvpActivity) &#123;</span><br><span class="line">      activity.invalidToken();</span><br><span class="line">    &#125;*/</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void myFinish() &#123;</span><br><span class="line">    onBackPressedSupport();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;两者在布局抽象方法里面有一点区别，Activity的传了Boundle参数，Fragment没有传，因为Fragment可以通过getArguments()方法获取到这个对象，而Activity不能获取到。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;到此，一个简单的项目框架就出来了，目前还是框架的第一步，是一个雏形，还不包括MVP，dagger等等，下一篇就加上MVP，我这个人有个好习惯，就是喜欢写注释，我注释写的很清楚，是干什么用的，我也衷心的希望，你能写好注释。</p><p><a href="http://download.csdn.net/download/qq_27634797/10256144" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;首先先说出，最终的目的是现在主流的MVP+RxJava+Retrofit+OkHttp框架。让大家心里有底&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;开发工具Android Studio3.0，还在用eclipse的同鞋，强烈推荐你跨出这一步，你会发现一个新的世界。android studio都出来这么久了，你还在远古时代做开发，说句不好听的，你完全与时代脱轨，你不适合做开发（纯属个人观点）&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>MVC、MVP、MVVM比较</title>
    <link href="http://haichenyi.com/2018/02/22/MVC%E3%80%81MVP%E3%80%81MVVM%E6%AF%94%E8%BE%83/"/>
    <id>http://haichenyi.com/2018/02/22/MVC、MVP、MVVM比较/</id>
    <published>2018-02-22T13:43:00.000Z</published>
    <updated>2018-02-22T13:48:18.240Z</updated>
    
    <content type="html"><![CDATA[<p>Android框架的最终目的，也是体现一个项目好坏的唯一标准——<strong>高类聚，低耦合</strong></p><a id="more"></a><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>&emsp;&emsp;我们刚接触android写代码的时候基本上都是MVC架构。什么是MVC架构呢？</p><p>&emsp;&emsp;MVC：Model View Controller的简称。流程图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-e7fc3f5706296a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mvc流程图.png"></p><p>&emsp;&emsp;当用户发出事件的时候，首先通过V层，通知C层，然后C层通知Model层数据发生了变化，更新数据，M层直接显示数据到V层。</p><p>&emsp;&emsp;通俗的讲，xml可以理解层View层，你封装的网络请求的帮助类理解成model层，activity，fragment理解成Controller层。这么理解是可以的，但是，你不能说xml就是view层，这样说是不对的</p><p>&emsp;&emsp;举个例子，比方说一个登录的网络请求，首先，你需要点击按钮去触发网络请求的方法，你点击的这个button就是写在xml布局里面的，这就是V层。然后触发的网络请求帮助类去发送对应的登录请求方法，这就是model层。两者是怎么联系在一起的呢？就是我们在activity，fragment层里面写的onclick方法。activity，fragment就是Controller层。</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>&emsp;&emsp;所有的UI变化，网络请求等等业务逻辑之类的都写在Activity里面，Activity既要处理业务逻辑，又要处理UI变化，代码就显得非常臃肿。</p><p>&emsp;&emsp;这个时候，MVP就顺势而生，什么是MVP架构呢？</p><p>&emsp;&emsp;MVP：Model View Presenter的简称</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-a146abe4db80cdf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MVP流程图.png"></p><p>&emsp;&emsp;MVP作为MVC的演化版本，解决了MVC不少的缺点，对于Android来说，MVP的M层，相对于MVC来说是一样的，而不一样的就是activity不再是controller，而是纯粹的V层，所有关于用户事件的转发，全都由P层去处理</p><p>&emsp;&emsp;MVP和MVC最明显的差别就是，M层和V层完全解藕，两者的通信是通过P层，P层作为桥梁，用于操作View层发送的事件到P层，P层去操作M层，并且，讲数据返回给V层。整个过层M层和V层两者完全没有联系。辣么，就有好奇的宝宝就问了，这样做解决不了更本问题，你这样做P层和V层不一样耦合在一起了吗？我们并不能完全不耦合，只是尽可能减少耦合度。我们写程序最终目的就是高类聚，低耦合，不是说完全不耦合。并且，我们这里P层和V层是通过接口通信的，如果网络请求逻辑发生变化，直接修改P层里面的代码，就可以了。V层完全不用改。如果业务逻辑发生变化，我们直接重新定义接口也非常方便</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>&emsp;&emsp;由微软提出来的—MVVM。什么是MVVM架构呢？</p><p>&emsp;&emsp;MVVM：Model View ViewModel</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-b41a65879e0e8d11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MVVM流程图.png"></p><p>&emsp;&emsp;一眼看上去更MVP差不多，只是把P层换成了ViewModel层。还有一点就是View层和ViewModel层是相互绑定的关系，当你更新ViewMdel层数据的时候，View层的UI就要相应的发生变化。</p><p>&emsp;&emsp;不管怎么说，三种模式的出现，或者说所有的开发模式，或者说是架构的出现，他们都有一个最终的目的，那就体现是一个项目架构好坏的：<strong>高类聚，低耦合</strong></p><p>&emsp;&emsp;学习成本，MVC最简单，弊端也是最多的，学起来也是最快的。MVP和MVVM两者都是MVC的演化版本，两者没法评论优缺点，各有千秋。MVP是目前最火的架构（-.-）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;吹了这么多，MVP有没有什么缺点呢？答案是肯定的：有。本人认为，MVP是目前已知框架最好的</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><p>P层比较臃肿，所有的逻辑代码，网络请求都丢在P层</p></li><li><p>接口很多，一个功能，相对于MVC来讲，需要多写很多代码</p></li><li><p>V层P层耦合度过于高，一旦视图需要变更，P层就要相应的发生变化</p></li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>解藕，这个不用说了</p></li><li><p>结构清晰明了，不会过了一个月就变成别人的代码</p></li><li><p>提高了维护性，功能出了问题，直接定位到接口，修改接口就行了</p></li><li><p>容易进行单元测试，虽然会用单元测试的人比较少</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android框架的最终目的，也是体现一个项目好坏的唯一标准——&lt;strong&gt;高类聚，低耦合&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Android事件分发机制原理</title>
    <link href="http://haichenyi.com/2018/02/22/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://haichenyi.com/2018/02/22/Android事件分发机制原理/</id>
    <published>2018-02-22T13:30:11.000Z</published>
    <updated>2018-02-22T13:51:55.865Z</updated>
    
    <content type="html"><![CDATA[<p>推荐：<a href="http://www.gcssloop.com/#blog" target="_blank" rel="noopener">非著名程序员</a>的<a href="http://www.gcssloop.com/customview/CustomViewIndex" target="_blank" rel="noopener">安卓自定义View教程目录</a>，我的自定义view就是看他的这个系列学会的</p><p>&emsp;&emsp;首先，我们需要确认的是android的事件传递机制是<strong>责任链模式</strong>，如果自己能处理就拦截下来自己处理，如果自己处理不了或者不确定就传递给下一个对象</p><a id="more"></a><h2 id="事件的拦截、分发、消费"><a href="#事件的拦截、分发、消费" class="headerlink" title="事件的拦截、分发、消费"></a>事件的拦截、分发、消费</h2><p>&emsp;&emsp;我们要知道三个方法，控制事件反而拦截，分发与消费。如下表：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">相关方法</th><th style="text-align:center">Activity</th><th style="text-align:center">ViewGroup</th><th style="text-align:center">View</th></tr></thead><tbody><tr><td style="text-align:center">事件分发</td><td style="text-align:center">dispatchTouchEvent</td><td style="text-align:center">有</td><td style="text-align:center">有</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">事件拦截</td><td style="text-align:center">onInterceptTouchEvent</td><td style="text-align:center">无</td><td style="text-align:center">有</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">事件处理</td><td style="text-align:center">onTouchEvent</td><td style="text-align:center">有</td><td style="text-align:center">有</td><td style="text-align:center">有</td></tr></tbody></table><p>以上三个方法，均有boolean类型的返回值，通过设置true，false来控制事件传递的流程</p><p>Activity和View均没有事件拦截方法，是因为</p><ol><li><p>Activity作为事件响应起点，如果，Activity把事件拦截了，辣么将为导致整个屏幕都无法点击</p></li><li><p>View作为事件响应的最末端，要么消费事件，要么不处理回传，没必要拦截事件</p></li></ol><h2 id="事件分发流程"><a href="#事件分发流程" class="headerlink" title="事件分发流程"></a>事件分发流程</h2><p>&emsp;&emsp;先给出一张图<img src="http://upload-images.jianshu.io/upload_images/7041675-9b8401bc04e365de.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分发流程"></p><p>&emsp;&emsp;这里，我们看到多了两个东西，一个是PhoneWindow，一个是DecorView，我们平时写的布局，最外层的父布局就是这里的RootView，有过几个app开发经验的程序员都应该知道，app的状态栏颜色的修改，还有那个主题的内容修改，修改后显示在哪呢？没错，就是DecorView里面。</p><p>&emsp;&emsp;再有就是phoneWindow，其实，知不知道没什么用，phonewindow是Window的唯一实现类，Window是干嘛的呢？Window是一个抽象类，所有的视图，事件传递都归它管理，所以，phonewindow管理视图，上面说的DecorView就是phonewindow的一个内部实现类，除了自己的功能外，还负责消息传递。</p><p>&emsp;&emsp;说了这么多，该来讲讲事件传递的流程了。android的view是树形结构的，基于这样的结构，我们的事件可以有序的分发。事件收集之后，起点是Activity，然后有序的向下传递，大致如下：</p><p><code>Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View</code></p><p>如果这个事件没有对象处理，辣么，它会依次往回传递，如果还是没有人处理，辣么就会被Activity抛弃掉</p><p><code>Activity &lt;－ PhoneWindow &lt;－ DecorView &lt;－ ViewGroup &lt;－ ... &lt;－ View</code></p><p>这就是文章开头我们提到的，责任链模式</p><p>下面我给出ViewGroup的事件分发机制的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    boolean result = false;             // 默认状态为没有消费过</span><br><span class="line"></span><br><span class="line">    if (!onInterceptTouchEvent(ev)) &#123;   // 如果没有拦截交给子View</span><br><span class="line">        result = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!result) &#123;                      // 如果事件没有被消费,询问自身onTouchEvent</span><br><span class="line">        result = onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;情景：老板: 我看公司最近业务不咋地，准备发展一下电商业务，下周之前做个淘宝出来试试怎么样。<br>&emsp;&emsp;事件顺序，老板(MainActivity)要做淘宝，这个事件通过各个部门(ViewGroup)一层一层的往下传，传到最底层的时候，码农小王(View1)发现做不了，于是消息又一层一层的回传到老板那里。<br>&emsp;&emsp;可以看到整个事件传递路线非常有序。从Activity开始，最后回传给Activity结束(由于我们无法操作Phone Window和DecorView，所以没有它们的信息)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MainActivity [老板]: dispatchTouchEvent     经理,我准备发展一下电商业务,下周之前做一个淘宝出来.</span><br><span class="line">RootView     [经理]: dispatchTouchEvent     呼叫技术部,老板要做淘宝,下周上线.</span><br><span class="line">RootView     [经理]: onInterceptTouchEvent  (老板可能疯了,但又不是我做.)</span><br><span class="line">ViewGroupA   [组长]: dispatchTouchEvent     老板要做淘宝,下周上线?</span><br><span class="line">ViewGroupA   [组长]: onInterceptTouchEvent  (看着不太靠谱,先问问小王怎么看)</span><br><span class="line">View1        [码农]: dispatchTouchEvent     做淘宝???</span><br><span class="line">View1        [码农]: onTouchEvent           这个真心做不了啊.</span><br><span class="line">ViewGroupA   [组长]: onTouchEvent           小王说做不了.</span><br><span class="line">RootView     [经理]: onTouchEvent           报告老板, 技术部说做不了.</span><br><span class="line">MainActivity [老板]: onTouchEvent           这么简单都做不了,你们都是干啥的(愤怒).</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事件分发机制设计到到情形非常多，这里就不一一列举了，记住以下几条原则就行了。</p><ol><li><p>如果事件被消费，就意味着事件信息传递终止。</p></li><li><p>如果事件一直没有被消费，最后会传给Activity，如果Activity也不需要就被抛弃。</p></li><li><p>判断事件是否被消费是根据返回值，而不是根据你是否使用了事件。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐：&lt;a href=&quot;http://www.gcssloop.com/#blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;非著名程序员&lt;/a&gt;的&lt;a href=&quot;http://www.gcssloop.com/customview/CustomViewIndex&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安卓自定义View教程目录&lt;/a&gt;，我的自定义view就是看他的这个系列学会的&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先，我们需要确认的是android的事件传递机制是&lt;strong&gt;责任链模式&lt;/strong&gt;，如果自己能处理就拦截下来自己处理，如果自己处理不了或者不确定就传递给下一个对象&lt;/p&gt;
    
    </summary>
    
      <category term="Android -自定义view" scheme="http://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>Android自定义View</title>
    <link href="http://haichenyi.com/2018/02/08/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <id>http://haichenyi.com/2018/02/08/Android自定义View/</id>
    <published>2018-02-08T13:55:20.000Z</published>
    <updated>2018-02-08T13:56:33.180Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android -自定义view" scheme="http://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>Netty的简单使用，实现socket通讯</title>
    <link href="http://haichenyi.com/2018/02/08/Netty%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E8%AE%AF/"/>
    <id>http://haichenyi.com/2018/02/08/Netty的简单使用，实现socket通讯/</id>
    <published>2018-02-08T13:46:05.000Z</published>
    <updated>2018-02-22T12:59:18.347Z</updated>
    
    <content type="html"><![CDATA[<p>自从用了netty框架，妈妈再也不用担心我的socket通讯了<br><a id="more"></a><br>&emsp;&emsp;题外话，很多人都把JDK1.4提供的NIO称之为异步非阻塞I/O；其实，并不然，从严格意义上面讲，它只能称为非阻塞I/O。在JDK1.7提供的NIO 2.0，新增了异步的套接字通道Channel，它才是真正的异步非阻塞I/O。下表是不同I/O模型的对比：</p><p>表1-1 几种I/O模型和同能对比</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">同步阻塞I/O(BIO)</th><th style="text-align:center">伪异步I/O</th><th style="text-align:center">非阻塞I/O(NIO)</th><th style="text-align:center">异步I/O(AIO)</th></tr></thead><tbody><tr><td style="text-align:center">客户端个数：I/O线程</td><td style="text-align:center">1:1</td><td style="text-align:center">M:N(M可以大于N)</td><td style="text-align:center">M:1(1个I/O线程处理多个客户端连接)</td><td style="text-align:center">M:0(不需要启动额外的I/O线程，被动回调)</td></tr><tr><td style="text-align:center">I/O类型(阻塞)</td><td style="text-align:center">阻塞I/O</td><td style="text-align:center">阻塞I/O</td><td style="text-align:center">非阻塞I/O</td><td style="text-align:center">非阻塞I/O</td></tr><tr><td style="text-align:center">I/O类型(同步)</td><td style="text-align:center">同步I/O</td><td style="text-align:center">同步I/O</td><td style="text-align:center">同步I/O(I/O多路复用)</td><td style="text-align:center">异步I/O</td></tr><tr><td style="text-align:center">API使用难度</td><td style="text-align:center">简单</td><td style="text-align:center">简单</td><td style="text-align:center">非常复杂</td><td style="text-align:center">复杂</td></tr><tr><td style="text-align:center">调试难度</td><td style="text-align:center">简单</td><td style="text-align:center">简单</td><td style="text-align:center">复杂</td><td style="text-align:center">复杂</td></tr><tr><td style="text-align:center">可靠性</td><td style="text-align:center">非常差</td><td style="text-align:center">差</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">吞吐量</td><td style="text-align:center">低</td><td style="text-align:center">中</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;Netty是由<a href="https://baike.baidu.com/item/JBOSS" target="_blank" rel="noopener">JBOSS</a>提供的一个<a href="https://baike.baidu.com/item/java%E5%BC%80%E6%BA%90" target="_blank" rel="noopener">java开源</a>框架。Netty提供异步的、<a href="https://baike.baidu.com/item/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8" target="_blank" rel="noopener">事件驱动</a>的网络应用程序框架和工具，用以快速开发高性能、高可靠性的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">网络服务器</a>和客户端程序。</p><p>&emsp;&emsp;也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E7%AB%AF" target="_blank" rel="noopener">服务端</a>应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。</p><p>&emsp;&emsp;“快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。——百度百科</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p>API使用简单，开发门槛低</p></li><li><p>功能强大，预置了多种编解码功能，支持多种主流协议</p></li><li><p>性能高，通过与业界其他主流NIO框架相比，netty的综合性能最高</p></li><li><p>成熟，稳定，Netty已经修复了已经发现的所有的JDK NIO BUG，业务开发人员不用再为NIO的bug而烦恼</p></li><li><p>社区活跃，版本迭代周期短，发现bug可以及时被修复，同时有更多的新功能加入</p></li><li><p>经历了大规模的商界业务考验，只能得到了验证</p></li></ol><h2 id="粘包、拆包"><a href="#粘包、拆包" class="headerlink" title="粘包、拆包"></a>粘包、拆包</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>&emsp;&emsp;TCP是一个流协议，所谓的流，就是没有界限的一串数据。可以考虑河里的流水，他们并没有界限。tcp底层并不了解业务层数据的具体含义，他会根据tcp缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被tcp拆分成多个包进行发送，也可能把多个小包封装成一个大数据一起发送，这就是所谓的tcp粘包，拆包问题</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ol><li><p>应用程序write写入的字节大小大于套接口发送缓冲区的大小</p></li><li><p>进行MSS大小的tcp分段</p></li><li><p>以太网帧的payload大于MTU进行IP分片</p></li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li><p>消息定长，每个报文大小固定长度，不够的补0</p></li><li><p>包尾增加回车换行符进行分割。例如：FTP协议</p></li><li><p>将消息分为消息头和消息体。消息头中包含消息的总长度字段</p></li><li><p>更复杂的应用层协议</p></li></ol><h3 id="Netty框架的解决办法"><a href="#Netty框架的解决办法" class="headerlink" title="Netty框架的解决办法"></a>Netty框架的解决办法</h3><p>&emsp;&emsp;LineBasedFrameDecoder和StringDecoder两个类</p><h4 id="LineBasedFrameDecoder"><a href="#LineBasedFrameDecoder" class="headerlink" title="LineBasedFrameDecoder"></a>LineBasedFrameDecoder</h4><p>&emsp;&emsp;LineBasedFrameDecoder的工作原理是依次遍历ByteBuf中的可读字节，判断看是否有”\r”或者”\r\n”，如果有就以此为结束位置，从可读索引位置到结束区间的字节就组成了一行。他是以换行符为结束标志的解码器，支持携带结束符和不带结束符两种解码方式。同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读取的异常流</p><h4 id="StringDecoder"><a href="#StringDecoder" class="headerlink" title="StringDecoder"></a>StringDecoder</h4><p>&emsp;&emsp;StringDecoder的功能就非常简单，就是将接收到的对象换成字符串，然后继续调用后面的handler，LineBasedFrameDecoder+StringDecoder组合就是按换行符切换文本解码器，他被设计用来支持TCP粘包和拆包。Netty支持其他其他符号的解码器(DelimiterBasedFrameDecode)</p><p>&emsp;&emsp;说了这么多，代码来了，就是用Netty实现的心跳。对于懒癌晚期，已经风装好，可以直接拿过去用，注释也写的很清楚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import io.netty.bootstrap.Bootstrap;</span><br><span class="line">import io.netty.channel.Channel;</span><br><span class="line">import io.netty.channel.ChannelFuture;</span><br><span class="line">import io.netty.channel.ChannelInitializer;</span><br><span class="line">import io.netty.channel.ChannelOption;</span><br><span class="line">import io.netty.channel.ChannelPipeline;</span><br><span class="line">import io.netty.channel.EventLoopGroup;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line">import io.netty.handler.codec.LineBasedFrameDecoder;</span><br><span class="line">import io.netty.handler.codec.string.StringDecoder;</span><br><span class="line">import io.netty.handler.codec.string.StringEncoder;</span><br><span class="line">import io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 海晨忆</span><br><span class="line"> * @date 2018/2/6</span><br><span class="line"> * @desc</span><br><span class="line"> */</span><br><span class="line">public class SocketTcp &#123;</span><br><span class="line">  private static SocketTcp socketTcp = new SocketTcp();</span><br><span class="line">  private Channel channel = null;</span><br><span class="line">  private EventLoopGroup group;</span><br><span class="line">  private int port;</span><br><span class="line">  private String host;</span><br><span class="line"></span><br><span class="line">  public static SocketTcp getInstance() &#123;</span><br><span class="line">    return socketTcp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public SocketTcp setPort(int port) &#123;</span><br><span class="line">    this.port = port;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public SocketTcp setHost(String host) &#123;</span><br><span class="line">    this.host = host;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void connect() &#123;</span><br><span class="line">    if (channel != null) return;</span><br><span class="line">    if (group == null) &#123;</span><br><span class="line">      //NIO线程组</span><br><span class="line">      group = new NioEventLoopGroup();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;//配置Bootstrap</span><br><span class="line">      Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">      bootstrap.group(group)</span><br><span class="line">          .channel(NioSocketChannel.class)</span><br><span class="line">          .option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">          .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">              //以换行符为结束标记</span><br><span class="line">              ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">              pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">              pipeline.addLast(new LineBasedFrameDecoder(Integer.MAX_VALUE));</span><br><span class="line">              pipeline.addLast(new StringDecoder());</span><br><span class="line">              pipeline.addLast(new MyHeartSocket());</span><br><span class="line"></span><br><span class="line">              //以&quot;$_&quot;作为分隔符</span><br><span class="line">              /*ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">              pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">              String s = &quot;$_&quot;;</span><br><span class="line">              ByteBuf byteBuf = Unpooled.copiedBuffer(s.getBytes());</span><br><span class="line">              pipeline.addLast(new DelimiterBasedFrameDecoder(Integer.MAX_VALUE,byteBuf));</span><br><span class="line">              pipeline.addLast(new StringDecoder());</span><br><span class="line">              pipeline.addLast(new MyHeartSocket());*/</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      //发起异步连接操作</span><br><span class="line">      ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">      channel = channelFuture.channel();</span><br><span class="line">      //等待服务端监听端口关闭</span><br><span class="line">      channel.closeFuture().sync();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      disConnect();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 断开tcp连接.</span><br><span class="line">   */</span><br><span class="line">  private void disConnect() &#123;</span><br><span class="line">    if (null != group) &#123;</span><br><span class="line">      group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">    group = null;</span><br><span class="line">    channel = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void sendMessage(String msg) &#123;//连接成功后，通过Channel提供的接口进行IO操作</span><br><span class="line">    try &#123;</span><br><span class="line">      if (channel != null &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">        channel.writeAndFlush(msg).sync();</span><br><span class="line">        Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reConnect();</span><br><span class="line">        throw new Exception(&quot;channel is null | closed&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      reConnect();</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 重连.</span><br><span class="line">   */</span><br><span class="line">  private void reConnect() &#123;</span><br><span class="line">    new Thread(this::connect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package com.example.zwang.myapplication.socket;</span><br><span class="line"></span><br><span class="line">import android.os.SystemClock;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import io.netty.buffer.ByteBuf;</span><br><span class="line">import io.netty.buffer.Unpooled;</span><br><span class="line">import io.netty.channel.ChannelHandlerContext;</span><br><span class="line">import io.netty.channel.EventLoop;</span><br><span class="line">import io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MyHeartSocket extends SimpleChannelInboundHandler&lt;Object&gt; &#123;</span><br><span class="line">  private ChannelHandlerContext ctx;</span><br><span class="line">  private boolean isConnect = false;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;);</span><br><span class="line">    ByteBuf msg1 = (ByteBuf) msg;</span><br><span class="line">    byte[] bytes = new byte[msg1.readableBytes()];</span><br><span class="line">    msg1.readBytes(bytes);</span><br><span class="line">    String s = new String(bytes, &quot;UTF-8&quot;);</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    super.channelActive(ctx);</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;);</span><br><span class="line">    isConnect = true;</span><br><span class="line">    if (this.ctx == null) &#123;</span><br><span class="line">      synchronized (MyHeartSocket.class) &#123;</span><br><span class="line">        if (this.ctx == null) &#123;</span><br><span class="line">          this.ctx = ctx;</span><br><span class="line">          MyAppHeart();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void MyAppHeart() &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      while (ctx != null &amp;&amp; isConnect) &#123;</span><br><span class="line">        String data = &quot;123&quot;;</span><br><span class="line">        byte[] bytes = data.getBytes();</span><br><span class="line">        if (isConnect) &#123;</span><br><span class="line">          ctx.writeAndFlush(Unpooled.buffer(bytes.length).writeBytes(bytes));</span><br><span class="line">          SystemClock.sleep(3000);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    EventLoop loop = ctx.channel().eventLoop();</span><br><span class="line">    loop.schedule(() -&gt; SocketTcp.getInstance().connect(), 5, TimeUnit.SECONDS);</span><br><span class="line">    super.channelInactive(ctx);</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;);</span><br><span class="line">    isConnect = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">    super.userEventTriggered(ctx, evt);</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">    super.exceptionCaught(ctx, cause);</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;);</span><br><span class="line">    this.ctx.close();</span><br><span class="line">    this.ctx = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从用了netty框架，妈妈再也不用担心我的socket通讯了&lt;br&gt;
    
    </summary>
    
      <category term="Android -Socket" scheme="http://haichenyi.com/categories/Android-Socket/"/>
    
    
  </entry>
  
  <entry>
    <title>IO编程和NIO编程简介</title>
    <link href="http://haichenyi.com/2018/02/07/IO%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://haichenyi.com/2018/02/07/IO编程和NIO编程简介/</id>
    <published>2018-02-07T12:49:47.000Z</published>
    <updated>2018-02-22T13:08:36.720Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;传统的同步阻塞I/O通讯模型，导致的结果就是只要有一方处理数据缓慢，都会影响另外一方的处理性能。按照故障设计原则，一方的处理出现问题，不应该影响到另外一方才对。但是，在同步阻塞的模式下面，这样的情况是无法避免的，很难通过业务层去解决。既然同步无法避免，为了避免就产生了异步。Netty框架就一个完全异步非阻塞的I/O通讯方式<br><a id="more"></a></p><h2 id="同步阻塞式I-O编程"><a href="#同步阻塞式I-O编程" class="headerlink" title="同步阻塞式I/O编程"></a>同步阻塞式I/O编程</h2><p>&emsp;&emsp;简单的来说，传统同步阻塞的I/O通讯模式，服务器端处理的方式是，每当有一个新用户接入的时候，就new一个新的线程，一个线程只能处理一个客户端的连接，在高性能方面，并发高的情景下无法满足。伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 海晨忆</span><br><span class="line"> * @date 2018/2/9</span><br><span class="line"> * @desc</span><br><span class="line"> */</span><br><span class="line">public class SocketServer &#123;</span><br><span class="line">  private int port = 8080;</span><br><span class="line">  private Socket socket = null;</span><br><span class="line"></span><br><span class="line">  public SocketServer(int port) &#123;</span><br><span class="line">    this.port = port;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void connect() &#123;</span><br><span class="line">    ServerSocket server = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      server = new ServerSocket(port);</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        socket = server.accept();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">            new TimerServerHandler(socket).run();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      //释放资源</span><br><span class="line">      if (server != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          server.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        server = null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 海晨忆</span><br><span class="line"> * @date 2018/2/9</span><br><span class="line"> * @desc</span><br><span class="line"> */</span><br><span class="line">public class TimerServerHandler implements Runnable &#123;</span><br><span class="line">  private Socket socket;</span><br><span class="line"></span><br><span class="line">  public TimerServerHandler(Socket socket) &#123;</span><br><span class="line">    this.socket = socket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    BufferedReader in = null;</span><br><span class="line">    PrintWriter out = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      in = new BufferedReader(new InputStreamReader(this.socket.getInputStream()));</span><br><span class="line">      out = new PrintWriter(this.socket.getOutputStream(), true);</span><br><span class="line">      String currentTime = null;</span><br><span class="line">      String body = null;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        body = in.readLine();</span><br><span class="line">        if (body == null)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      //释放in，out，socket资源</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个就是最原始的服务端IO的代码，这里我就给出的是最简化的，当有新的客户端接入的时候，服务端是怎么处理线程的，可以看出，每当有新的客户端接入的时候，总是回新创建一个线程去服务这个新的客户端</p><h2 id="伪异步式编程"><a href="#伪异步式编程" class="headerlink" title="伪异步式编程"></a>伪异步式编程</h2><p>&emsp;&emsp;后来慢慢演化出一个版本“伪异步”模型，新增加一个线程池或者消息队列，满足一个线程或者多个线程满足N个客户端，通过线程池可以灵活的调用线程资源。通过设置线程池的最大值，防止海量并发接入造成的线程耗尽，它的底层实现依然是同步阻塞模型，伪代码如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import com.example.zwang.mysocket.server.TimerServerHandler;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 海晨忆</span><br><span class="line"> * @date 2018/2/9</span><br><span class="line"> * @desc</span><br><span class="line"> */</span><br><span class="line">public class SocketServer &#123;</span><br><span class="line">  private int port = 8080;</span><br><span class="line">  private Socket socket = null;</span><br><span class="line"></span><br><span class="line">  public SocketServer(int port) &#123;</span><br><span class="line">    this.port = port;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void connect() &#123;</span><br><span class="line">    ServerSocket server = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      server = new ServerSocket(port);</span><br><span class="line">      TimeServerHandlerExecutePool executePool = new TimeServerHandlerExecutePool(50, 1000);</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        socket = server.accept();</span><br><span class="line">        executePool.execute(new TimerServerHandler(socket));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">      //释放资源</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 海晨忆</span><br><span class="line"> * @date 2018/2/9</span><br><span class="line"> * @desc</span><br><span class="line"> */</span><br><span class="line">public class TimeServerHandlerExecutePool &#123;</span><br><span class="line">  private ExecutorService executor;</span><br><span class="line"></span><br><span class="line">  public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123;</span><br><span class="line">    executor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize,</span><br><span class="line">        120L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void execute(Runnable task) &#123;</span><br><span class="line">    executor.execute(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;“伪异步”的代码和传统同步的唯一区别就是在于，首先先创建了一个时间服务处理类的线程池，当有新的客户端接入的时候，先将socket请求封装成task，然后调用线程池的execute方法执行，从而避免了每一个新请求创建一个新线程。由于线程池和消息队列都是有限的，因此，无论客户端的并发量多大，它都不会导致线程个数过于大，而造成的内存溢出。相对于传统的同步阻塞，是一种改良。<br></p><p>&emsp;&emsp;但是他没有从更本上解决同步的问题，伪异步的问题在于，他还是有一方处理出现问题还是会影响到另一方。因为：</p><p>&emsp;&emsp;当对socket的输入流进行读取操作的时候，它会一直阻塞直到一下三种方式发生：  </p><ol><li><p>有数据可读  </p></li><li><p>可读数据已经读取完   </p></li><li><p>发生空指针或者I/O异常。  </p></li></ol><p>这意味者，当读取inputstream方处理速度缓慢(不管是什么原因造成的速度缓慢)，另一方会一直同步阻塞，直到这一方把数据处理完.</p><p>&emsp;&emsp;当调用outputstream的write方法写输出流的时候，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。学过TCP/IP相关知识的人都直到，当消息的接收方处理消息缓慢，不能及时的从TCP缓冲区读取数据，这将会导致发送方的TCP缓冲区的size一直减少，直到0.缓冲区为0，那么发消息的一方将无法将消息写入缓冲区，直到缓冲区的size大于0<br></p><p>&emsp;&emsp;通过以上。我们了解到读和写的操作都是同步阻塞的，阻塞的时间取决于对方的I/O线程的处理速度和网络I/O的传送速度。从本质上面看，我们无法保证对方的处理速度和网络传送速度。如果，我们的程序依靠与对方的处理速度，那么，他的可靠性将会非常差。</p><h2 id="NIO编程"><a href="#NIO编程" class="headerlink" title="NIO编程"></a>NIO编程</h2><p>&emsp;&emsp;官方叫法new I/O，也就是新的IO编程，更多的人喜欢称它为：Non-block IO即非阻塞IO。</p><p>&emsp;&emsp;与Socket和serverSocket类对应，NIO提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现，这两种都支持阻塞式编程和非阻塞式编程。开发人员可以根据自己的需求选择合适的编程模式。一般低负载，低并发的应用程序选择同步阻塞的方式以降低编程的复杂度。高负载，高并发的不用想了，非阻塞就是为了解决这个问题的</p><ol><li>缓冲区Buffer</li></ol><p>&emsp;&emsp;Buffer是一个对象，它包含一些写入或者读出的数据。再NIO中加入buffer对象，体现了新库和旧库的一个重要区别。在面向流的io中，可以直接把数据读取或者写入到stream对象中。在NIO库中，所有数据操作都是通过缓冲区处理的。</p><p>&emsp;&emsp;缓冲区实质上是一个数组，通常是一个字节数组（ByteBuffer），基本数据类型除了boolean没有，其他都有，如ShortBuffer,CharBuffer等等</p><ol><li>通道Channel</li></ol><p>&emsp;&emsp;Channel是一个通道，双向通道，网络数据都是通过Channel读取，写入的。是的，没错，Channel它既可以进行读操作，也可以进行写操作。而流只能是一个方向。只能读操作或者只能写操作，而channel是全双工，读写可以同时进行。channel可以分为两大类：网络读写的SelectableChannel和文件操作的FileChannel。我们前面提到的SocketChannel和ServerSocketChannel都是SelectableChannel的子类。</p><ol><li>多路复用器Selector</li></ol><p>&emsp;&emsp;selector多路复用器，他是java NIO编程的基础，熟练的掌握selector对于NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单的讲就是他会不断的轮询注册的channel，如果一个Channel发生了读写操作，这个Chnnel就会处于就绪状态，会被selector轮询出来，通过SelectorKey获取就绪Channel集合，进行后续的IO操作。一个selector对应多个Channel<br></p><p>&emsp;&emsp;由于原生NIO编码比较麻烦和复杂，我这里就给出了思路的伪代码。下一篇我们将用NIO中的Netty框架实现Socket通信，编码简单，一行代码解决烦人粘包、拆包问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 服务端nio过程的伪代码</span><br><span class="line">   *</span><br><span class="line">   * @param port 端口号</span><br><span class="line">   * @throws IOException IOException</span><br><span class="line">   */</span><br><span class="line">  private void init(int port) throws IOException &#123;</span><br><span class="line">    //第一步：打开ServerSocketChannel，用于监听客户端连接，它是所有客户端连接的父管道</span><br><span class="line">    ServerSocketChannel socketChannel = ServerSocketChannel.open();</span><br><span class="line">    //第二步：监听绑定端口，设置连接模式为非阻塞模式，</span><br><span class="line">    socketChannel.socket().bind(new InetSocketAddress(InetAddress.getByName(&quot;IP&quot;), port));</span><br><span class="line">    socketChannel.configureBlocking(false);</span><br><span class="line">    //第三步：创建Reactor线程，创建多路复用器，并启动线程。</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    new Thread().start();</span><br><span class="line">    //第四步：将ServerSocketChannel注册到Reactor线程的多路复用器上，监听accept事件</span><br><span class="line">    SelectionKey key = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/);</span><br><span class="line">    //第五步：多路复用器在线程run方法的无线循环体内轮询准备就绪的key</span><br><span class="line">    int num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">      SelectionKey next = it.next();</span><br><span class="line">      //deal with io event...</span><br><span class="line">    &#125;</span><br><span class="line">    //第六步：多路复用器检测到有新客户端接入，处理新的接入请求，完成TCP三次握手，建立物理链路</span><br><span class="line">    SocketChannel channel = socketChannel.accept();</span><br><span class="line">    //第七步：设置客户端为非阻塞模式</span><br><span class="line">    channel.configureBlocking(false);</span><br><span class="line">    channel.socket().setReuseAddress(true);</span><br><span class="line">    //第八步：将新接入的客户端注册到reactor线程的多路复用器上，监听读操作，读取客户端发送的消息</span><br><span class="line">    SelectionKey key1 = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/);</span><br><span class="line">    //第九步：异步读取客户端消息到缓冲区，</span><br><span class="line">    /*int readNumber = channel.read(&quot;receivebuff&quot;);*/</span><br><span class="line">    //第十步：对byteBuffer进行编解码，如果有半包信息指针reset，继续读取到后续的报文，将解码成功消息封装成task，投递到业务线程池，进行业务逻辑编排</span><br><span class="line">    Object massage = null;</span><br><span class="line">    while (buff.hasRemain()) &#123;</span><br><span class="line">      buff.mark();</span><br><span class="line">      Object massage1 = decode(btyeBuffer);</span><br><span class="line">      if (massage1 == null) &#123;</span><br><span class="line">        byteBuffer.reset();</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      massageList.add(massage1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!byteBuffer.hasRemain()) &#123;</span><br><span class="line">      byteBuffer.clean();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      byteBuffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    if (massageList != null &amp;&amp; !massageList.isEmpty()) &#123;</span><br><span class="line">      for (Object massage3 : massageList)&#123;</span><br><span class="line">        handlerTask(massage3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //第十一步：将POJO对象encode成ByteBuff，调用SocketChannel的异步write接口，将异步消息发送到客户端</span><br><span class="line">    socketChannel.write(buffer);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;传统的同步阻塞I/O通讯模型，导致的结果就是只要有一方处理数据缓慢，都会影响另外一方的处理性能。按照故障设计原则，一方的处理出现问题，不应该影响到另外一方才对。但是，在同步阻塞的模式下面，这样的情况是无法避免的，很难通过业务层去解决。既然同步无法避免，为了避免就产生了异步。Netty框架就一个完全异步非阻塞的I/O通讯方式&lt;br&gt;
    
    </summary>
    
      <category term="Android -Socket" scheme="http://haichenyi.com/categories/Android-Socket/"/>
    
    
  </entry>
  
</feed>
