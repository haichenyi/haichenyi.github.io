<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haichenyi.com/"/>
  <updated>2018-03-07T12:29:18.134Z</updated>
  <id>http://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EventBus源码解析(二)——注册</title>
    <link href="http://haichenyi.com/2018/03/07/EventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C/"/>
    <id>http://haichenyi.com/2018/03/07/EventBus源码解析-二-——注册/</id>
    <published>2018-03-07T12:24:37.000Z</published>
    <updated>2018-03-07T12:29:18.134Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前我们讲过<a href="http://haichenyi.com/2018/03/06/EventBus源码解析-一-——获取EventBus对象/">获取EventBus对象的源码</a>，这一篇，我们来讲讲注册的源码。推荐<a href="https://www.jianshu.com/p/bda4ed3017ba" target="_blank" rel="noopener">EventBus 3.0进阶：源码及其设计模式 完全解析</a></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they</span><br><span class="line">     * are no longer interested in receiving events.</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;.</span><br><span class="line">     * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link</span><br><span class="line">     * ThreadMode&#125; and priority.</span><br><span class="line">     */</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; <strong>翻译：</strong> 注册给订阅方去接收事件，订阅者一旦对接收事件不感兴趣了，就要unregister，订阅者必须要有用Subscribe注解的方法，注解也可以设置线程和优先级</p><p>&emsp;&emsp; <strong>白话文：</strong> 订阅者要是想接收消息，必须要先注册。当页面退出，或者不想接收消息的时候必须要反注册，不然他会一直处于接收消息的状态，页面退出会内存泄漏。订阅者的接收方法必须要用Subscribe注解，这个注解的后面可以设置接收这个消息的线程和优先级。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode = ThreadMode.MAIN,priority = 100,sticky = true)</span><br><span class="line">  public void handleMsg(DataBean dataBean)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就像上面这样写，我一个一个来讲。我们先来说说这个<strong><em>ThreadMode</em></strong>类，点进去，我们可以看到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 每个订阅的方法都有一个线程，决定那个线程的方法被叫做EventBus</span><br><span class="line">   * EventBus的线程可以跟Post事件的那个线程不相同</span><br><span class="line">   */</span><br><span class="line">public enum ThreadMode &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   *订阅者将在跟Post事件的那个线程的同一个线程中被调用，这是默认值，</span><br><span class="line">   * 因为，他没有线程切换，所以开销最少，所以也是推荐模式。需要注意的是</span><br><span class="line">   * post事件的线程可能是UI线程，也可能是其他线程，所以，这里的操作要做判断，</span><br><span class="line">   * 如果是UI操作，你必须要在UI线程中完成，如果是耗时操作，你必须要新开线程</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    POSTING,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 在Android上面，订阅者将会在UI线程中调用，如果post事件的线程是UI线程，</span><br><span class="line">   * 辣么，这个订阅方法将直接被调用，如果不是UI线程，辣么，它将要排队交付，</span><br><span class="line">   * 所以，这里可能阻塞线程，订阅者使用这个模式必须要快速返回，避免阻塞UI线程，</span><br><span class="line">   * 就是不要在这里做耗时操作。谢谢。</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    MAIN,</span><br><span class="line">    </span><br><span class="line">  /**</span><br><span class="line">   *这一个，跟上面的刚好对应，就是不管怎么样，都要排队交付，</span><br><span class="line">   * 不论post事件是不是处于UI线程发送的</span><br><span class="line">   */</span><br><span class="line">    </span><br><span class="line">    MAIN_ORDERED,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 在android上面，订阅方法将在子线程中调用。如果post事件处于子线程，</span><br><span class="line">   * 辣么，订阅方法将直接被调用。如果post事件处于UI线程，辣么，eventBus</span><br><span class="line">   * 就会新开线程，按照顺序处理事件，当然，也要注意，避免阻塞子线程</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    BACKGROUND,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 订阅方法将会在独立的线程中调用，这个线程总是独立语post事件</span><br><span class="line">   * 所处的线程和主线程。如果post事件是耗时操作：例如网络请求，</span><br><span class="line">   * 订阅方法调用的时候，不会等待。我们不用考虑线程数量的问题，</span><br><span class="line">   * EventBus已经限制了并发线程，并使用线程池高效的重用线程</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    ASYNC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他就是一个枚举类，几个值的意义，我说的很清楚了。</p><p>&emsp;&emsp;我们再来讲讲另外两个： <strong><em>sticky</em></strong>，默认值是false，如果设置成true，辣么，这个事件将会是粘性事件。发送事件的方式从<strong>post</strong>变成了<strong>postSticky</strong>，其他都没变。</p><p>&emsp;&emsp;再来讲讲 <strong><em>priority</em></strong> ，默认值是0，在同一个线程中值越大，优先级越高。优先级高的比优先级低的先收到消息。</p><p>好，终于准备工作做完了，我们来看看 <strong><em>register()</em></strong> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注册方法。首先，他通过反射的方式获得当前类名，然后通过当前类名，找到订阅方法，存到list里面。我们来看看 <strong><em>findSubscriberMethods()</em></strong>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">//首先从缓存中读取当前类的订阅方法，如果不等于null，就直接返回从缓存中读取到的list</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">        if (subscriberMethods != null) &#123;</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">//ignoreGeneratedIndex的值，从Builder可知，一般为false。</span><br><span class="line">        if (ignoreGeneratedIndex) &#123;</span><br><span class="line">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                    + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //将获取的subscriberMeyhods放入缓存中</span><br><span class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的注释写的很清楚，ignoreGeneratedIndex为false，辣么就会走<strong><em>findUsingInfo()</em></strong> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">//首先新建了一个FindState，FindState是一个静态内部类，保存订阅者的信息</span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line">        //初始化FindState</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line">        while (findState.clazz != null) &#123;</span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            //初始化的findState获得的订阅者信息，一般都是null</span><br><span class="line">            if (findState.subscriberInfo != null) &#123;</span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            //就会跳到这里</span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            //移动到父类继续查找</span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        return getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面，我们提到了<strong><em>FindState</em></strong>类，我们来看看这个类的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static class FindState &#123;</span><br><span class="line">//订阅方法的列表</span><br><span class="line">        final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;();</span><br><span class="line">//以class的名称为key，以方法为value</span><br><span class="line">        final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;();</span><br><span class="line">//以方法名称为key，订阅者类为value</span><br><span class="line">        final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;();</span><br><span class="line">        final StringBuilder methodKeyBuilder = new StringBuilder(128);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; subscriberClass;</span><br><span class="line">        Class&lt;?&gt; clazz;</span><br><span class="line">        boolean skipSuperClasses;</span><br><span class="line">        SubscriberInfo subscriberInfo;</span><br><span class="line">//初始化</span><br><span class="line">        void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">            this.subscriberClass = clazz = subscriberClass;</span><br><span class="line">            skipSuperClasses = false;</span><br><span class="line">            subscriberInfo = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不难看出，这里的几个map包括了，类名找方法，方法名找类，我们后面都用的到，然后就是初始化方法，前面我们注释里面写了，初始化之后一般信息都是null，这里我们也可以看到。所以，它会走 <strong><em>findUsingReflectionInSingleClass</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">        Method[] methods;</span><br><span class="line">        try &#123;</span><br><span class="line">            // This is faster than getMethods, especially when subscribers are fat classes like Activities</span><br><span class="line">            methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; catch (Throwable th) &#123;</span><br><span class="line">            // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses = true;</span><br><span class="line">        &#125;</span><br><span class="line">        /*------------------------------上面就是获取方法，重要的是在下面------------------------------------*/</span><br><span class="line">        //这里我强调的是我们前面的用法里面有说过注意点</span><br><span class="line">        //1.必须是public修饰</span><br><span class="line">        //2.必须是void类型</span><br><span class="line">        //3.必须是一个参数</span><br><span class="line">        //4.必须用Subscribe注解</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">        //获取方法的修饰符</span><br><span class="line">            int modifiers = method.getModifiers();</span><br><span class="line">            if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123;</span><br><span class="line">            //获取方法参数类型</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                //如果参数个数等于1</span><br><span class="line">                if (parameterTypes.length == 1) &#123;</span><br><span class="line">                //获取方法注解名称</span><br><span class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                    if (subscribeAnnotation != null) &#123;</span><br><span class="line">                    //参数类型 即为事件类型</span><br><span class="line">                        Class&lt;?&gt; eventType = parameterTypes[0];</span><br><span class="line">                        //调用checkAdd方法判断是否添加过</span><br><span class="line">                        if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        //从注解里面获取线程模式</span><br><span class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                            //新建一个SubscriberMethod对象，并添加到findState的subscriberMethods这个集合内</span><br><span class="line">                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                   //如果开启了严格验证，同时当前方法又有@Subscribe注解，对不符合要求的方法会抛出异常</span><br><span class="line">                &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                    String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                    throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</span><br><span class="line">                            &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                throw new EventBusException(methodName +</span><br><span class="line">                        &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法非常重要！！！在这个方法内部，利用反射的方式，对订阅者类进行扫描判断，是否满足条件从而找出订阅方法，并用上面的容器进行保存。辣么，上面提到的 <strong><em>checkAdd()</em></strong> 方法是怎么检查的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">            // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.</span><br><span class="line">            // Usually a subscriber doesn&apos;t have methods listening to the same event type.</span><br><span class="line">            Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">            if (existing == null) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (existing instanceof Method) &#123;</span><br><span class="line">                    if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</span><br><span class="line">                        // Paranoia check</span><br><span class="line">                        throw new IllegalStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Put any non-Method object to &quot;consume&quot; the existing Method</span><br><span class="line">                    anyMethodByEventType.put(eventType, this);</span><br><span class="line">                &#125;</span><br><span class="line">                return checkAddWithMethodSignature(method, eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个注释写的很清楚，两层检验，第一层是检测事件类型，第二次检验则是检验判断方法的完整，首先以eventType为键，方法为值，存到map中（这个map是在FindState类初始化的），put方法会有一个返回值，返回value，这个value是这个key对应的上一个值，所以说，如果是第一次存放，那么就会返回null。否则，之前存放过，辣么就会进入下一个判断 <strong><em>checkAddWithMethodSignature</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">            methodKeyBuilder.setLength(0);</span><br><span class="line">            methodKeyBuilder.append(method.getName());</span><br><span class="line">            methodKeyBuilder.append(&apos;&gt;&apos;).append(eventType.getName());</span><br><span class="line"></span><br><span class="line">            String methodKey = methodKeyBuilder.toString();</span><br><span class="line">            Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">            Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">            if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">                // Only add if not already found in a sub class</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Revert the put, old class is further down the class hierarchy</span><br><span class="line">                subscriberClassByMethodKey.put(methodKey, methodClassOld);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法就是用来判断方法签名是否相同的，方法签名是什么呢？就是修饰符+返回类型+方法名+参数list是否相同。如果方法签名相同，辣么，就把旧值赋值给methodClassOld，判断这个值不是为null，第一次调用，没有旧值，就肯定为null，所以，if前面的一个条件是满足的，后面一个条件<strong>methodClassOld.isAssignableFrom(methodClass)</strong> 的意思是判断旧值是否是methodClass或者同一个类，如果两个条件都不满足，辣么当前方法就不会添加为订阅方法。</p><p>&emsp;&emsp;那么，说了一大堆关于checkAdd和checkAddWithMethodSignature方法的源码，那么这两个方法到底有什么作用呢？从这两个方法的逻辑来看，第一层判断根据eventType来判断是否有多个方法订阅该事件，而第二层判断根据完整的方法签名(包括方法名字以及参数名字)来判断。下面是笔者的理解：</p><p>&emsp;&emsp;第一种情况：比如一个类有多个订阅方法，方法名不同，但它们的参数类型都是相同的(虽然一般不这样写，但不排除这样的可能)，那么遍历这些方法的时候，会多次调用到checkAdd方法，由于existing不为null，那么会进而调用checkAddWithMethodSignature方法，但是由于每个方法的名字都不同，因此methodClassOld会一直为null，因此都会返回true。也就是说，<strong>允许一个类有多个参数相同的订阅方法。</strong></p><p>&emsp;&emsp;第二种情况：类B继承自类A，而每个类都是有相同订阅方法，换句话说，类B的订阅方法继承并重写自类A，它们都有着一样的方法签名。方法的遍历会从子类开始，即B类，在checkAddWithMethodSignature方法中，methodClassOld为null，那么B类的订阅方法会被添加到列表中。接着，向上找到类A的订阅方法，由于methodClassOld不为null而且显然类B不是类A的父类，methodClassOld.isAssignableFrom(methodClass)也会返回false，那么会返回false。也就是说，<strong>子类继承并重写了父类的订阅方法，那么只会把子类的订阅方法添加到订阅者列表，父类的方法会忽略。</strong></p><p>&emsp;&emsp;让我们回到findUsingReflectionInSingleClass方法，当遍历完当前类的所有方法后，会回到findUsingInfo方法，接着会执行最后一行代码，即return getMethodsAndRelease(findState);那么我们继续 <strong><em>getMethodsAndRelease</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123;</span><br><span class="line">        //从findState获取subscriberMethods，放进新的ArrayList</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">        //把findState回收</span><br><span class="line">        findState.recycle();</span><br><span class="line">        synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">            for (int i = 0; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">                if (FIND_STATE_POOL[i] == null) &#123;</span><br><span class="line">                    FIND_STATE_POOL[i] = findState;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过该方法，把subscriberMethods不断逐层返回，直到返回EventBus#register()方法，最后开始遍历每一个订阅方法，并调用subscribe(subscriber, subscriberMethod)方法，那么，我们继续来看<strong><em>subscribe</em></strong>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// Must be called in synchronized block</span><br><span class="line">    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">        //将subscriber和subscriberMethod封装成 Subscription</span><br><span class="line">        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</span><br><span class="line">        //根据事件类型获取特定的 Subscription</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        //如果为null，说明该subscriber尚未注册该事件</span><br><span class="line">        if (subscriptions == null) &#123;</span><br><span class="line">            subscriptions = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //如果不为null，并且包含了这个subscription 那么说明该subscriber已经注册了该事件，抛出异常</span><br><span class="line">            if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //根据优先级来设置放进subscriptions的位置，优先级高的会先被通知</span><br><span class="line">        int size = subscriptions.size();</span><br><span class="line">        for (int i = 0; i &lt;= size; i++) &#123;</span><br><span class="line">            if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //根据subscriber(订阅者)来获取它的所有订阅事件</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">        if (subscribedEvents == null) &#123;</span><br><span class="line">            subscribedEvents = new ArrayList&lt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line">        </span><br><span class="line">//下面是对粘性事件的处理</span><br><span class="line">        if (subscriberMethod.sticky) &#123;</span><br><span class="line">        //从EventBusBuilder可知，eventInheritance默认为true</span><br><span class="line">            if (eventInheritance) &#123;</span><br><span class="line">                // Existing sticky events of all subclasses of eventType have to be considered.</span><br><span class="line">                // Note: Iterating over all events may be inefficient with lots of sticky events,</span><br><span class="line">                // thus data structure should be changed to allow a more efficient lookup</span><br><span class="line">                // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent = entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">             //根据eventType，从stickyEvents列表中获取特定的事件</span><br><span class="line">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                //分发事件</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到目前为止，注册流程基本分析完毕，丢一张流程图</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-2b90513e16f84c03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注册流程图.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前我们讲过&lt;a href=&quot;http://haichenyi.com/2018/03/06/EventBus源码解析-一-——获取EventBus对象/&quot;&gt;获取EventBus对象的源码&lt;/a&gt;，这一篇，我们来讲讲注册的源码。推荐&lt;a href=&quot;https://www.jianshu.com/p/bda4ed3017ba&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EventBus 3.0进阶：源码及其设计模式 完全解析&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="http://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 设计模式（Design Patterns）（三）</title>
    <link href="http://haichenyi.com/2018/03/07/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/03/07/Java-设计模式（Design-Patterns）（三）/</id>
    <published>2018-03-07T12:24:11.000Z</published>
    <updated>2018-03-07T12:26:37.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="十三、策略模式"><a href="#十三、策略模式" class="headerlink" title="十三、策略模式"></a>十三、策略模式</h2><p>顾名思义:不同的策略，对应我们项目中用到的地方就是，同一个功能，不同的实现方法。就比方说登录功能：我们有帐号密码登录，QQ第三方登录，微信第三方登录等等。其实我个人认为最典型的就是：同一个接口方法，不同的实现方式。</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface LoginInterface&#123;</span><br><span class="line">    void login();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PhoneLogin implements LoginInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void login()&#123;</span><br><span class="line">    //具体的逻辑</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;帐号密码登录&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class QqLogin implements LoginInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void login()&#123;</span><br><span class="line">    //具体的逻辑</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;QQ第三方登录&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像上面这样，同一个登录功能，不同的实现。</p><h2 id="十四、责任链模式"><a href="#十四、责任链模式" class="headerlink" title="十四、责任链模式"></a>十四、责任链模式</h2><p>责任链模式，我项目里面用的比较少，但是我知道一个android里面绝对常用的东西用的是责任连模式，那就是——<a href="http://haichenyi.com/2018/02/22/Android事件分发机制原理/">andoid事件分发</a></p><h2 id="十五、状态模式"><a href="#十五、状态模式" class="headerlink" title="十五、状态模式"></a>十五、状态模式</h2><p>状态模式，我项目里面用的比较少，但是我知道的是游戏里面用的很多。就是那种存档功能，遇到自己感觉过不去的地方，把当前进度存起来，过不去了之后，死了，游戏结束了，再读当前的存档。</p><p>PS：其他的设计模式等用到了再补充</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;十三、策略模式&quot;&gt;&lt;a href=&quot;#十三、策略模式&quot; class=&quot;headerlink&quot; title=&quot;十三、策略模式&quot;&gt;&lt;/a&gt;十三、策略模式&lt;/h2&gt;&lt;p&gt;顾名思义:不同的策略，对应我们项目中用到的地方就是，同一个功能，不同的实现方法。就比方说登录功能：我们有帐号密码登录，QQ第三方登录，微信第三方登录等等。其实我个人认为最典型的就是：同一个接口方法，不同的实现方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -设计模式" scheme="http://haichenyi.com/categories/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 设计模式（Design Patterns）（二）</title>
    <link href="http://haichenyi.com/2018/03/07/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/03/07/Java-设计模式（Design-Patterns）（二）/</id>
    <published>2018-03-07T12:23:53.000Z</published>
    <updated>2018-03-07T12:26:04.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六、适配器模式"><a href="#六、适配器模式" class="headerlink" title="六、适配器模式"></a>六、适配器模式</h2><p>分类有三种：类的适配器模式，对象的适配器模式，接口的适配器模式，我印象最深刻的是<strong><em>接口适配器模式</em></strong></p> <a id="more"></a><p><strong>接口适配器模式</strong></p><p>&emsp;&emsp;有的时候，我们写的一个接口，会有很多种方法。而，我们的实现类只需要实现某一种，或者某几种，所以，我们这里会借助一个抽象类，去实现接口的所有方法。我们的具体实现类跟这个抽象类去打交道，而不是跟原始的接口去打交道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123;</span><br><span class="line">  private BaseView baseView;</span><br><span class="line">  private boolean showLoading;</span><br><span class="line"></span><br><span class="line">  public MySubscriber(BaseView baseView) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MySubscriber(BaseView baseView, boolean showLoading) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">    this.showLoading = showLoading;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onStart() &#123;</span><br><span class="line">    super.onStart();</span><br><span class="line">    if (null != baseView &amp;&amp; showLoading) &#123;</span><br><span class="line">      baseView.showLoading();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onError(Throwable t) &#123;</span><br><span class="line">    if (null == baseView) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    baseView.hideLoading();</span><br><span class="line">    if (t instanceof ApiException) &#123;</span><br><span class="line">      ApiException apiException = (ApiException) t;</span><br><span class="line">      switch (apiException.getCode()) &#123;</span><br><span class="line">        case HttpCode.NO_PARAMETER:</span><br><span class="line">          baseView.showTipMsg(&quot;参数为空&quot;);</span><br><span class="line">          break;</span><br><span class="line">        case HttpCode.SERVER_ERR:</span><br><span class="line">          baseView.showTipMsg(&quot;服务器错误&quot;);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onComplete() &#123;</span><br><span class="line">    if (null != baseView) &#123;</span><br><span class="line">      baseView.hideLoading();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addSubscribe(helper.selectBrandList()</span><br><span class="line">        .compose(RxUtil.handleHttp())</span><br><span class="line">        .subscribeWith(new MySubscriber&lt;List&lt;String&gt;&gt;(baseView, true) &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onNext(List&lt;String&gt; dataList) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;,&quot;111&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个代码，就是我之前写的<a href="http://haichenyi.com/categories/Android-框架/">从零开始搭建一个主流项目框架</a>系列里面的网络请求，处理返回结果的回调方法，我的返回结果，不可能每个去实现onStart，onError，onNext，onCompleted方法。我的实现类只用去继承这个类，实现某一个，或者某几个方法。更直接的就是，我之前写的框架，BaseActivity，实现BaseView接口，然后，我其他的Activity去继承BaseActivity，选择实现BaseView的方法。</p><p>如果上面这样，你还无法认同，那我们看看下面这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//success动画结束监听</span><br><span class="line">    successAnim.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">        super.onAnimationEnd(animation);</span><br><span class="line">        if (null != myAnimotionInterface) &#123;</span><br><span class="line">          myAnimotionInterface.AnimationEnd();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>动画监听，我这里只想监听动画结束，在动画结束的时候，我做我的逻辑处理，但是，他的接口有开始，结束，暂停，重复等等监听，我不要这么，你们可以点 <strong>AnimatorListenerAdapter()</strong> 这个类，去看一下他是什么，他就是一个抽象类，实现了动画监听的那个接口，这个是官方封装好的一个类。</p><h2 id="七、装饰器模式"><a href="#七、装饰器模式" class="headerlink" title="七、装饰器模式"></a>七、装饰器模式</h2><p>这个模式就是我之前写<a href="http://haichenyi.com/categories/Android-框架/">从零开始搭建一个主流项目框架</a>系列里面网络请求，SP的操作，Socket的操作，关于他们的封装都是用的装饰者模式。说的官方一点：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。项目中的应用就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public interface HttpHelper &#123;</span><br><span class="line">  Flowable&lt;WeatherBean&gt; getWeather(String city);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 登录时获取验证码.</span><br><span class="line">   *</span><br><span class="line">   * @param phone 手机号</span><br><span class="line">   * @return &#123;&quot;code&quot;:0&#125;</span><br><span class="line">   */</span><br><span class="line">  Flowable&lt;HttpNoResult&gt; loginCode(String phone);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个就是装饰对象和被装饰对象实现的同一个接口，他们一开始就只有一个功能，那就是获取天气，后来他们又新加了一个功能，必须登录之后才能获取天气，那就多了一个登录功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class DataHelper implements HttpHelper, PreferencesHelper, SqlHelper &#123;</span><br><span class="line">  private SqlHelper sqlHelper;</span><br><span class="line">  private HttpHelper httpHelper;</span><br><span class="line">  private PreferencesHelper preferencesHelper;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 初始化数据帮助类.</span><br><span class="line">   *</span><br><span class="line">   * @param sqlHelper         &#123;@link SqlHelper&#125;</span><br><span class="line">   * @param httpHelper        &#123;@link HttpHelper&#125;</span><br><span class="line">   * @param preferencesHelper &#123;@link PreferencesHelper&#125;</span><br><span class="line">   */</span><br><span class="line">  public DataHelper(SqlHelper sqlHelper, HttpHelper httpHelper,</span><br><span class="line">                    PreferencesHelper preferencesHelper) &#123;</span><br><span class="line">    this.sqlHelper = sqlHelper;</span><br><span class="line">    this.httpHelper = httpHelper;</span><br><span class="line">    this.preferencesHelper = preferencesHelper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123;</span><br><span class="line">    return httpHelper.getWeather(city);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123;</span><br><span class="line">    return httpHelper.loginCode(phone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个就是装饰类，负责调用接口的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class RetrofitHttp implements HttpHelper &#123;</span><br><span class="line">  private WardrobeApi wardrobeApi;</span><br><span class="line">  private WeatherApi weatherApi;</span><br><span class="line"></span><br><span class="line">  @Inject</span><br><span class="line">  RetrofitHttp(WardrobeApi wardrobeApi, WeatherApi weatherApi) &#123;</span><br><span class="line">    this.wardrobeApi = wardrobeApi;</span><br><span class="line">    this.weatherApi = weatherApi;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123;</span><br><span class="line">    return weatherApi.getWeather(city, &quot;c41d9ca568d449e2802244d8eeb3d3c6&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123;</span><br><span class="line">    return wardrobeApi.loginCode(phone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个就是被装饰类，负责具体的实现，这里是retrofit网络请求。以上都是伪代码。具体就是为了说明这个装饰者模式的中心思想，以及我在项目中的运用，不保证一定完全正确，都是按照自己的理解写的。</p><p>PS：其他的设计模式等用到了再补充</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;六、适配器模式&quot;&gt;&lt;a href=&quot;#六、适配器模式&quot; class=&quot;headerlink&quot; title=&quot;六、适配器模式&quot;&gt;&lt;/a&gt;六、适配器模式&lt;/h2&gt;&lt;p&gt;分类有三种：类的适配器模式，对象的适配器模式，接口的适配器模式，我印象最深刻的是&lt;strong&gt;&lt;em&gt;接口适配器模式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -设计模式" scheme="http://haichenyi.com/categories/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 设计模式（Design Patterns）（一）</title>
    <link href="http://haichenyi.com/2018/03/06/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/03/06/Java-设计模式（Design-Patterns）（一）/</id>
    <published>2018-03-06T13:02:20.000Z</published>
    <updated>2018-03-06T13:06:53.893Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>设计模式的分类</em></strong></p><ol><li>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><a id="more"></a><p><strong>我只讲我用的多的，用的多的印象深刻，知道怎么讲，用的少的，不知道怎么讲。只讲我熟练的。</strong></p></li></ol><h2 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h2><p>单例模式，我想应该做过开发的人都用过。</p><h3 id="懒汉式（用的时候初始化，延迟加载）"><a href="#懒汉式（用的时候初始化，延迟加载）" class="headerlink" title="懒汉式（用的时候初始化，延迟加载）"></a>懒汉式（用的时候初始化，延迟加载）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MySocket&#123;</span><br><span class="line">    private static MySocket instance;</span><br><span class="line">    private MySocket()&#123;&#125;</span><br><span class="line">    public static synchronized MySocket getInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">            instance = new MySocket();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里在懒汉式的单例模式中加上了同步锁synchronized，所以，这是线程安全的，但是，也是因为锁，所以造成的效率低，可以根据不同实际情况判断是否需要加同步锁。</p><h3 id="饿汉式（加载类的时候直接初始化）"><a href="#饿汉式（加载类的时候直接初始化）" class="headerlink" title="饿汉式（加载类的时候直接初始化）"></a>饿汉式（加载类的时候直接初始化）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MySocket&#123;</span><br><span class="line">    private static MySocket instance = new MySocket();</span><br><span class="line">    private MySocket()&#123;&#125;</span><br><span class="line">    public static MySocket getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MySocket&#123;</span><br><span class="line">    private static MySocket instance;</span><br><span class="line">    private MySocket()&#123;&#125;</span><br><span class="line">    public static MySocket getInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">            synchronized(MySocket.class)&#123;</span><br><span class="line">                if(null == instance)&#123;</span><br><span class="line">                    instance = new MySocket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的双重校验锁，其实就是我这里的线程安全懒汉式的升级版本，双重校验锁很多开源框架都是用的这种单例，比方说：EventBus。关于单例模式的其他变种我就不说了。单例模式的最终目的，就是全局单例，一个项目不论哪里调用这个类都是引用的同一个对象。</p><h2 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class FragmentFactory &#123;</span><br><span class="line">  public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz) &#123;</span><br><span class="line">    return createFragment(clz, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz, Bundle bundle) &#123;</span><br><span class="line">    if (HomeFragment.class == clz) &#123;</span><br><span class="line">      return new HomeFragment();</span><br><span class="line">    &#125; else if (MyClothesFragment.class == clz) &#123;</span><br><span class="line">      return new MyClothesFragment();</span><br><span class="line">    &#125; else if (WardrobeStructureFragment.class == clz) &#123;</span><br><span class="line">      return new WardrobeStructureFragment();</span><br><span class="line">    &#125; else if (WifiFragment.class == clz) &#123;</span><br><span class="line">      return new WifiFragment();</span><br><span class="line">    &#125; else if (WardrobeConfigFragment.class == clz) &#123;</span><br><span class="line">      return new WardrobeConfigFragment();</span><br><span class="line">    &#125; else if (ShowFragment.class == clz) &#123;</span><br><span class="line">      return new ShowFragment();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new NullPointerException(&quot;not found fragment&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz) &#123;</span><br><span class="line">    return createDialogFragment(clz, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  private static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz, Bundle bundle) &#123;</span><br><span class="line">    if (clz == IconDialogFragment.class) &#123;</span><br><span class="line">      return (T) new IconDialogFragment();</span><br><span class="line">    &#125; else if (clz == PasswordDialogFragment.class) &#123;</span><br><span class="line">      return (T) PasswordDialogFragment.newInstance();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new NullPointerException(&quot;not found fragment&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个fragment工厂类，就是我项目里面用到的。常用的工厂模式就是静态工厂，利用static方法，我这里的工厂就是静态工厂。我们常说的工厂方法对应的这里是什么呢？其实，工厂方法也是一个普通的方法，对应的这里就是<strong><em>createFragment(Class&lt;? extends BaseFragment&gt; clz)</em></strong>。工厂模式什么时候用呢？在需要大量类似的数据的时候（个人观点），Android里面，工厂方法用的最多的就是创建Fragment。</p><h2 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface IFragmentFactory&#123;</span><br><span class="line">    BaseFragment createFragment();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HomeFactory implements IFragmentFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public BaseFragment createFragment()&#123;</span><br><span class="line">        return new HomeFragment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WifiFragment implements IFragmentFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public BaseFragment createFragment()&#123;</span><br><span class="line">        return new WifiFragment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我把上面的静态工厂类，改成了抽象工厂类，就是上面的代码。就是有一个工厂接口或者抽象的工厂类，然后创建不同的工厂类去实现这个接口，实现对应的类，返回你需要的东西</p><h2 id="四、建造者模式"><a href="#四、建造者模式" class="headerlink" title="四、建造者模式"></a>四、建造者模式</h2><p>我之前写Luban源码解析的时候就讲过建造者模式，可以去看一下，就在源码解析的一开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.mytakephoto;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/6</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class DataBean &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  private int age;</span><br><span class="line">  private String sex;</span><br><span class="line"></span><br><span class="line">  public DataBean(Builder builder) &#123;</span><br><span class="line">    this.name = builder.name;</span><br><span class="line">    this.age = builder.age;</span><br><span class="line">    this.sex = builder.sex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age = 20;</span><br><span class="line">    private String sex = &quot;男&quot;;</span><br><span class="line"></span><br><span class="line">    public Builder setName(String name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setAge(int age) &#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setSex(String sex) &#123;</span><br><span class="line">      this.sex = sex;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DataBean build() &#123;</span><br><span class="line">      return new DataBean(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码就是一个DataBean类，用建造者模式创建。要是还是不懂，你可以理解成，我们常常在写bean类的时候，往往要写set方法，你可以理解成，把set方法写在Builder里面，在Builder里面赋好值之后，在我们bean类的构造方法里面传递过来就可以了。</p><h2 id="五、原型模式"><a href="#五、原型模式" class="headerlink" title="五、原型模式"></a>五、原型模式</h2><p>这个模式，我没用到过，网上搜的是，类似于拷贝功能。可以自行搜索。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;设计模式的分类&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。&lt;/li&gt;
&lt;li&gt;结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -设计模式" scheme="http://haichenyi.com/categories/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://haichenyi.com/2018/03/06/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://haichenyi.com/2018/03/06/Java反射机制/</id>
    <published>2018-03-06T13:01:58.000Z</published>
    <updated>2018-03-06T13:07:08.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;在运行过程中，对任意一个类，都能知道这个类的所有属性和方法。对于任一个对象，都能调用他的任意一个方法和属性。这种动态获取信息以及动态调用对象的方法称为java语言的反射机制</p><a id="more"></a><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>我这里就列出我常用的两个方法私有类和变量</p><h3 id="方法Methods"><a href="#方法Methods" class="headerlink" title="方法Methods"></a>方法Methods</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">getDeclaredMethods()</td><td style="text-align:center">获取当前类的所有方法，包括public/private/protected/default修饰的方法</td></tr><tr><td style="text-align:center">getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td style="text-align:center">获取当前类的某一个方法,包括public/private/protected/default修饰的方法</td></tr><tr><td style="text-align:center">getMethods()</td><td style="text-align:center">获取当前类和所继承父类的public标识的所有方法，仅仅包括public</td></tr><tr><td style="text-align:center">getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td style="text-align:center">获取当前类和所继承父类的public标识的某一个方法，仅仅包括public</td></tr></tbody></table><p>&emsp;&emsp;上面就是两个类型的方法，一个是只获取当前类的方法，获取当前类的方法，包括所有类型的方法：public/private/protected/default。还有一个是获取当前类和所继承的父类的方法，仅仅包括public修饰的方法。</p><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在TakePhotoActivity.class类中有两个重载方法，一个无参，一个有一个String类型的参数</span><br><span class="line">private void myTest()&#123;</span><br><span class="line">    Log.v(&quot;WZ&quot;,&quot;myTest无参&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">private void myTest(String msg)&#123;</span><br><span class="line">    Log.v(&quot;WZ&quot;,&quot;myTest有参&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="调用无参的方法"><a href="#调用无参的方法" class="headerlink" title="调用无参的方法"></a>调用无参的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象</span><br><span class="line">try &#123;</span><br><span class="line">Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象</span><br><span class="line">//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象</span><br><span class="line">Method myTest = aClass1.getDeclaredMethod(&quot;myTest&quot;);</span><br><span class="line">myTest.setAccessible(true);//参数值为true，禁止访问控制检查</span><br><span class="line">myTest.invoke(takePhotoActivity);//执行私有方法</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      Log.v(&quot;WZ&quot;, e.getMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="调用有参的方法"><a href="#调用有参的方法" class="headerlink" title="调用有参的方法"></a>调用有参的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象</span><br><span class="line">Class[] arr = new Class[]&#123;String.class&#125;;</span><br><span class="line">try &#123;</span><br><span class="line">Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象</span><br><span class="line">//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象</span><br><span class="line">Method myTest = aClass1.getDeclaredMethod(&quot;myTest&quot;,arr);</span><br><span class="line">myTest.setAccessible(true);//参数值为true，禁止访问控制检查</span><br><span class="line">myTest.invoke(takePhotoActivity,&quot;s&quot;);//执行私有方法</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      Log.v(&quot;WZ&quot;, e.getMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有参的方法，在获取方法的时候，传一个Class[]数组，里面的值就是参数类型的类。或者还有另一种传的方法，前面获取方法的时候：</p><ol><li>获取方法的时候，无参的传一个空的Class[]，有参就传有值的Class[]数组</li><li>执行方法的时候，无参的传一个空的Object[]，有参就传有值的Object[]数组,至于传的值随便写，类型一样就行</li></ol><h3 id="变量Field"><a href="#变量Field" class="headerlink" title="变量Field"></a>变量Field</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">getDeclaredFields()</td><td style="text-align:center">获取当前类的所有类型的全局变量,包括public/private/protected/default修饰的变量</td></tr><tr><td style="text-align:center">getDeclaredField(String name)</td><td style="text-align:center">获取当前类的某一个类型的全局变量,包括public/private/protected/default修饰的变量</td></tr><tr><td style="text-align:center">getFields()</td><td style="text-align:center">获取当前类和继承父类的所有用public修饰的变量</td></tr><tr><td style="text-align:center">getField(String name)</td><td style="text-align:center">获取当前类和继承父类的某一个用public修饰的变量</td></tr></tbody></table><h4 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在TakePhotoActivity里面定义</span><br><span class="line">private int flag;</span><br></pre></td></tr></table></figure><h5 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TakePhotoActivity takePhotoActivity = new TakePhotoActivity();//new 一个类对象</span><br><span class="line">try &#123;</span><br><span class="line">Class&lt;? extends TakePhotoActivity&gt; aClass1 = takePhotoActivity.getClass();//通过getClass方法获取类对象</span><br><span class="line">//Class&lt;?&gt; aClass = Class.forName(&quot;com.haichenyi.mytakephoto.TakePhotoActivity&quot;);//通过路径获取Class对象</span><br><span class="line">Field flag = aClass.getDeclaredField(&quot;flag&quot;);</span><br><span class="line">flag.setAccessible(true);</span><br><span class="line">Object o = flag.get(takePhotoActivity);//这里就获取到了对象</span><br><span class="line">...//做你自己的逻辑处理</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      Log.v(&quot;WZ&quot;, e.getMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="设置变量的值"><a href="#设置变量的值" class="headerlink" title="设置变量的值"></a>设置变量的值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取变量的值跟上面一样</span><br><span class="line">flag.set(takePhotoActivity,10);//这样写会改变TakePhotoActivity中flag的值</span><br></pre></td></tr></table></figure><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/3/6</span><br><span class="line"> * Desc: 反射工具类</span><br><span class="line"> */</span><br><span class="line">public class ReflectionUtil &#123;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 获取私有成员变量的值</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public static Object getValue(Object instance, String fieldName)</span><br><span class="line">            throws IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">        Field field = instance.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true); // 参数值为true，禁止访问控制检查</span><br><span class="line"></span><br><span class="line">        return field.get(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 设置私有成员变量的值</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public static void setValue(Object instance, String fileName, Object value)</span><br><span class="line">            throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        Field field = instance.getClass().getDeclaredField(fileName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(instance, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 访问私有方法</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public static Object callMethod(Object instance, String methodName, Class[] classes, Object[] objects)</span><br><span class="line">            throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException,</span><br><span class="line">            InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        Method method = instance.getClass().getDeclaredMethod(methodName, classes);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        return method.invoke(instance, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在运行过程中，对任意一个类，都能知道这个类的所有属性和方法。对于任一个对象，都能调用他的任意一个方法和属性。这种动态获取信息以及动态调用对象的方法称为java语言的反射机制&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>EventBus源码解析(一)——获取EventBus对象</title>
    <link href="http://haichenyi.com/2018/03/06/EventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96EventBus%E5%AF%B9%E8%B1%A1/"/>
    <id>http://haichenyi.com/2018/03/06/EventBus源码解析-一-——获取EventBus对象/</id>
    <published>2018-03-06T13:01:41.000Z</published>
    <updated>2018-03-06T13:04:32.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>我们先来看一下他的类注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * EventBus is a central publish/subscribe event system for Android. Events are posted (&#123;@link #post(Object)&#125;) to the</span><br><span class="line"> * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events,</span><br><span class="line"> * subscribers must register themselves to the bus using &#123;@link #register(Object)&#125;. Once registered, subscribers</span><br><span class="line"> * receive events until &#123;@link #unregister(Object)&#125; is called. Event handling methods must be annotated by</span><br><span class="line"> * &#123;@link Subscribe&#125;, must be public, return nothing (void), and have exactly one parameter</span><br><span class="line"> * (the event).</span><br><span class="line"> *</span><br><span class="line"> * @author Markus Junginger, greenrobot</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><a id="more"></a><p>&emsp;&emsp;英语不是很好，大致讲一下这段话是什么意思：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a><strong>是重要的发布/订阅的Android事件系统。事件被发布给总线，这个总线将这个事件传递给跟他匹配类型的订阅者。接收事件必须在总线使用的时候注册他们。一旦注册，订阅者就会一直接收事件，直到他们被取消注册。这个接收方法必须增加注解Subscribe标识，必须是public，返回类型是void，并且只有一个参数。</strong> 简单的来说，<strong><em>就是用之前必须先注册，然后接收方法必须有Subscribe注解，必须是public，返回类型是void并且只有一个参数</em></strong></p><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><h4 id="第一步：依赖"><a href="#第一步：依赖" class="headerlink" title="第一步：依赖"></a>第一步：依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br></pre></td></tr></table></figure><h4 id="第二步：注册与反注册"><a href="#第二步：注册与反注册" class="headerlink" title="第二步：注册与反注册"></a>第二步：注册与反注册</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//注册，在onCrate里面</span><br><span class="line">EventBus.getDefault().register(this)</span><br><span class="line">//反注册，在onDestory里面</span><br><span class="line">EventBus.getDefault().unregister(this)</span><br></pre></td></tr></table></figure><h4 id="第三步：接收方法"><a href="#第三步：接收方法" class="headerlink" title="第三步：接收方法"></a>第三步：接收方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe</span><br><span class="line">public void handle(MyClothes myClothes)&#123;</span><br><span class="line">    //你的具体逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第四步：发送"><a href="#第四步：发送" class="headerlink" title="第四步：发送"></a>第四步：发送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(new MyClothes())</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过上面三步，你就可以正常使用EventBus了，前面两步要在一个类里面，因为接收之前，必须要注册，可以在任意的地方post</p><h3 id="源码解析—getDefault"><a href="#源码解析—getDefault" class="headerlink" title="源码解析—getDefault()"></a>源码解析—getDefault()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">        if (defaultInstance == null) &#123;</span><br><span class="line">            synchronized (EventBus.class) &#123;</span><br><span class="line">                if (defaultInstance == null) &#123;</span><br><span class="line">                    defaultInstance = new EventBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return defaultInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到这里使用的是双重校验锁的单例模式，保证不同的线程调用该方法得到的都是同一个EventBus实例。</p><h4 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus()"></a>EventBus()</h4><p>看到上面的单例模式之后，我们再来瞅瞅单例模式里面调用的构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public EventBus() &#123;</span><br><span class="line">        this(DEFAULT_BUILDER);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里他的空参数的构造方法里面调用的是一个参数的构造方法，我们来看看这个参数是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();</span><br></pre></td></tr></table></figure><h3 id="EventBusBuilder"><a href="#EventBusBuilder" class="headerlink" title="EventBusBuilder()"></a>EventBusBuilder()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventBusBuilder() &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个builder的构造方法里面什么都没有，也就是说没有初始化任何变量，那我们看一看他的变量，这里我就说一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;</span><br></pre></td></tr></table></figure><p><strong><em>Executors.newCachedThreadPool()</em></strong> 创建的是一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空线程池，若无回收，可新建线程。</p><p>接下来，我们再来看看只有EventBusBuilder参数的构造方法</p><h3 id="EventBus-EventBusBuilder-builder"><a href="#EventBus-EventBusBuilder-builder" class="headerlink" title="EventBus(EventBusBuilder builder)"></a>EventBus(EventBusBuilder builder)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">        subscriptionsByEventType = new HashMap&lt;&gt;();</span><br><span class="line">        typesBySubscriber = new HashMap&lt;&gt;();</span><br><span class="line">        stickyEvents = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;</span><br><span class="line">        backgroundPoster = new BackgroundPoster(this);</span><br><span class="line">        asyncPoster = new AsyncPoster(this);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讲到这里，很明显，他这里用的是建造者模式，跟我们之前讲的Luban的模式是一样的，这个建造者模式，我就不讲了。讲Luban的时候讲过的</p><p>&emsp;&emsp;这里我列出来的6个变量，其他变量并没有列出来，因为，其他变量都是builder里面的赋值，没有啥好讲的。我们来看看这6个成员变量的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line">private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line">private final Poster mainThreadPoster;</span><br><span class="line">private final BackgroundPoster backgroundPoster;</span><br><span class="line">private final AsyncPoster asyncPoster;</span><br></pre></td></tr></table></figure><p><strong>意义：</strong></p><ol><li>subscriptionsByEventType：可以看到这是一个是以event的class为key，以subscribe的list为value的map，有的人可能不知道CopyOnWriteArrayList，这是ArrayList的一个线程安全变种。（这里，有人会点到Subscription里面去看一下，可以看到就是一个类，封装了订阅者和订阅方法，重写了hashcode和equal方法）</li><li>typesBySubscriber：这是以订阅者类为key，以event的list为value的map，在注册和反注册的时候用的到</li><li>stickyEvents：粘性事件，以event的class为key，订阅者为value的map</li><li>后面这三个Poster都是用来处理粘性事件的</li></ol><p>&emsp;&emsp;我们说了这么多成员变量。我们知道这里的EventBusBuilder就是给EventBus初始化成员变量的，辣么，我们可不可以不用getDefault，获取eventBus对象呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventBus build1 = EventBus.getDefault();</span><br><span class="line"></span><br><span class="line">EventBus build2 = EventBus.builder().build();</span><br></pre></td></tr></table></figure><p>这两个build的区别是什么呢？我们可以点到build()方法里面去看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public EventBus build() &#123;</span><br><span class="line">        return new EventBus(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>他这里是直接new出来的，并没有单例，所以每次使用的都是new一个新的对象，而通过getDefault，获得是同一个对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;我们先来看一下他的类注释&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * EventBus is a central publish/subscribe event system for Android. Events are posted (&amp;#123;@link #post(Object)&amp;#125;) to the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * subscribers must register themselves to the bus using &amp;#123;@link #register(Object)&amp;#125;. Once registered, subscribers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * receive events until &amp;#123;@link #unregister(Object)&amp;#125; is called. Event handling methods must be annotated by&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;#123;@link Subscribe&amp;#125;, must be public, return nothing (void), and have exactly one parameter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * (the event).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @author Markus Junginger, greenrobot&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="http://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Android二维码扫描——BGAQRCode-Android</title>
    <link href="http://haichenyi.com/2018/03/05/Android%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E2%80%94%E2%80%94BGAQRCode-Android/"/>
    <id>http://haichenyi.com/2018/03/05/Android二维码扫描——BGAQRCode-Android/</id>
    <published>2018-03-05T12:14:02.000Z</published>
    <updated>2018-03-06T12:58:53.565Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;做过二维码扫描的童鞋都知道，要用Zxing，可是google官方推的Zxing，我们集成扫描的时候很慢，有时候就直接扫不出来，体验太差了。因为他适配了太多东西，我们只要一个扫描功能，然后就去网上搜索，怎么使zxing扫描变的很快，zxing的优化，然后跟着网上的博客，一步一步走，即使最终做完了，感觉体验还是不够好。我这里推荐一个二维码扫描的开源框架——<a href="https://github.com/bingoogolapple/BGAQRCode-Android" target="_blank" rel="noopener">BGAQRCode-Android</a></p><a id="more"></a><p>&emsp;&emsp;QRCode 扫描二维码、扫描条形码、相册获取图片后识别、生成带 Logo 二维码、支持微博微信、QQ 二维码扫描样式。他把Zbar和Zxing，都做了优化，扫描速度非常快，用户体验很好，用起来也非常方便</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;cn.bingoogolapple:bga-qrcode-zbar:1.2.1&apos;</span><br><span class="line">或者</span><br><span class="line">implementation &apos;cn.bingoogolapple:bga-qrcode-zxing:1.2.1&apos;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>以Zbar为例（Zxing类似）</p><h4 id="第一步：XML文件"><a href="#第一步：XML文件" class="headerlink" title="第一步：XML文件"></a>第一步：XML文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;cn.bingoogolapple.qrcode.zbar.ZBarView</span><br><span class="line">        android:id=&quot;@+id/zbarview&quot;</span><br><span class="line">        style=&quot;@style/MatchMatch&quot;</span><br><span class="line">        app:qrcv_animTime=&quot;1000&quot;</span><br><span class="line">        app:qrcv_borderColor=&quot;@android:color/white&quot;</span><br><span class="line">        app:qrcv_borderSize=&quot;1dp&quot;</span><br><span class="line">        app:qrcv_cornerColor=&quot;@color/colorPrimaryDark&quot;</span><br><span class="line">        app:qrcv_cornerLength=&quot;20dp&quot;</span><br><span class="line">        app:qrcv_cornerSize=&quot;3dp&quot;</span><br><span class="line">        app:qrcv_isShowDefaultScanLineDrawable=&quot;true&quot;</span><br><span class="line">        app:qrcv_maskColor=&quot;#33FFFFFF&quot;</span><br><span class="line">        app:qrcv_rectWidth=&quot;200dp&quot;</span><br><span class="line">        app:qrcv_scanLineColor=&quot;@color/colorPrimaryDark&quot;</span><br><span class="line">        app:qrcv_topOffset=&quot;90dp&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong><em>自定义属性说明</em></strong></p><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">说明</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">qrcv_topOffset</td><td style="text-align:center">扫描框距离 toolbar 底部的距离</td><td style="text-align:center">90dp</td></tr><tr><td style="text-align:center">qrcv_cornerSize</td><td style="text-align:center">扫描框边角线的宽度</td><td style="text-align:center">3dp</td></tr><tr><td style="text-align:center">qrcv_cornerLength</td><td style="text-align:center">扫描框边角线的长度</td><td style="text-align:center">20dp</td></tr><tr><td style="text-align:center">qrcv_cornerColor</td><td style="text-align:center">扫描框边角线的颜色</td><td style="text-align:center">@android:color/white</td></tr><tr><td style="text-align:center">qrcv_rectWidth</td><td style="text-align:center">扫描框的宽度</td><td style="text-align:center">200dp</td></tr><tr><td style="text-align:center">qrcv_barcodeRectHeight</td><td style="text-align:center">条码扫样式描框的高度</td><td style="text-align:center">140dp</td></tr><tr><td style="text-align:center">qrcv_maskColor</td><td style="text-align:center">除去扫描框，其余部分阴影颜色</td><td style="text-align:center">#33FFFFFF</td></tr><tr><td style="text-align:center">qrcv_scanLineSize</td><td style="text-align:center">扫描线的宽度</td><td style="text-align:center">1dp</td></tr><tr><td style="text-align:center">qrcv_scanLineColor</td><td style="text-align:center">扫描线的颜色「扫描线和默认的扫描线图片的颜色」</td><td style="text-align:center">@android:color/white</td></tr><tr><td style="text-align:center">qrcv_scanLineMargin</td><td style="text-align:center">扫描线距离上下或者左右边框的间距</td><td style="text-align:center">0dp</td></tr><tr><td style="text-align:center">qrcv_isShowDefaultScanLineDrawable</td><td style="text-align:center">是否显示默认的图片扫描线「设置该属性后 qrcv_scanLineSize 将失效，可以通过 qrcv_scanLineColor 设置扫描线的颜色，避免让你公司的UI单独给你出特定颜色的扫描线图片」</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_customScanLineDrawable</td><td style="text-align:center">扫描线的图片资源「默认的扫描线图片样式不能满足你的需求时使用，设置该属性后 qrcv_isShowDefaultScanLineDrawable、qrcv_scanLineSize、qrcv_scanLineColor 将失效」</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">qrcv_borderSize</td><td style="text-align:center">扫描边框的宽度</td><td style="text-align:center">1dp</td></tr><tr><td style="text-align:center">qrcv_borderColor</td><td style="text-align:center">扫描边框的颜色</td><td style="text-align:center">@android:color/white</td></tr><tr><td style="text-align:center">qrcv_animTime</td><td style="text-align:center">扫描线从顶部移动到底部的动画时间「单位为毫秒」</td><td style="text-align:center">1000</td></tr><tr><td style="text-align:center">qrcv_isCenterVertical</td><td style="text-align:center">扫描框是否垂直居中，该属性为true时会忽略 qrcv_topOffset 属性</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_toolbarHeight</td><td style="text-align:center">Toolbar 的高度，通过该属性来修正由 Toolbar 导致扫描框在垂直方向上的偏差</td><td style="text-align:center">0dp</td></tr><tr><td style="text-align:center">qrcv_isBarcode</td><td style="text-align:center">是否是扫条形码</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_tipText</td><td style="text-align:center">提示文案</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">qrcv_tipTextSize</td><td style="text-align:center">提示文案字体大小</td><td style="text-align:center">14sp</td></tr><tr><td style="text-align:center">qrcv_tipTextColor</td><td style="text-align:center">提示文案颜色</td><td style="text-align:center">@android:color/white</td></tr><tr><td style="text-align:center">qrcv_isTipTextBelowRect</td><td style="text-align:center">提示文案是否在扫描框的底部</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_tipTextMargin</td><td style="text-align:center">提示文案与扫描框之间的间距</td><td style="text-align:center">20dp</td></tr><tr><td style="text-align:center">qrcv_isShowTipTextAsSingleLine</td><td style="text-align:center">是否把提示文案作为单行显示</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_isShowTipBackground</td><td style="text-align:center">是否显示提示文案的背景</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_tipBackgroundColor</td><td style="text-align:center">提示文案的背景色</td><td style="text-align:center">#22000000</td></tr><tr><td style="text-align:center">qrcv_isScanLineReverse</td><td style="text-align:center">扫描线是否来回移动</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">qrcv_isShowDefaultGridScanLineDrawable</td><td style="text-align:center">是否显示默认的网格图片扫描线</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">qrcv_customGridScanLineDrawable</td><td style="text-align:center">扫描线的网格图片资源</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">qrcv_isOnlyDecodeScanBoxArea</td><td style="text-align:center">是否只识别扫描框区域的二维码</td><td style="text-align:center">false</td></tr></tbody></table><h4 id="第二步：获取控件，并实现QRCodeView-Delegate接口"><a href="#第二步：获取控件，并实现QRCodeView-Delegate接口" class="headerlink" title="第二步：获取控件，并实现QRCodeView.Delegate接口"></a>第二步：获取控件，并实现QRCodeView.Delegate接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QRCodeView mQRCodeView = (ZBarView) findViewById(R.id.zbarview);</span><br><span class="line">mQRCodeView.setDelegate(this);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">  public void onScanQRCodeSuccess(String result) &#123;</span><br><span class="line">    vibrate();</span><br><span class="line">    Toast.makeText(this,result,Toast.LENGTH_SHORT).show();</span><br><span class="line">    mQRCodeView.startSpot();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onScanQRCodeOpenCameraError() &#123;</span><br><span class="line">    Toast.makeText(this,&quot;错误&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="第四步：实现onStart，onStop，onDestroy方法"><a href="#第四步：实现onStart，onStop，onDestroy方法" class="headerlink" title="第四步：实现onStart，onStop，onDestroy方法"></a>第四步：实现onStart，onStop，onDestroy方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onStart() &#123;</span><br><span class="line">    super.onStart();</span><br><span class="line">    mQRCodeView.startCamera();//打开相机</span><br><span class="line">    mQRCodeView.showScanRect();//显示扫描框</span><br><span class="line">    mQRCodeView.startSpot();//开始识别二维码</span><br><span class="line">    //mQRCodeView.openFlashlight();//开灯</span><br><span class="line">    //mQRCodeView.closeFlashlight();//关灯</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onStop() &#123;</span><br><span class="line">    mQRCodeView.stopCamera();</span><br><span class="line">    super.onStop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDestroy() &#123;</span><br><span class="line">    mQRCodeView.onDestroy();</span><br><span class="line">    super.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void vibrate() &#123;</span><br><span class="line">    Vibrator vibrator = (Vibrator) getSystemService(VIBRATOR_SERVICE);</span><br><span class="line">    vibrator.vibrate(200);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="第五步：添加权限"><a href="#第五步：添加权限" class="headerlink" title="第五步：添加权限"></a>第五步：添加权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt;</span><br></pre></td></tr></table></figure><p>经过上面5步，扫描功能就已经出来了，Zbar扫描比Zxing快，Zbar是基于C实现的，Zxing是基于C++。有个问题就是Zbar无法生成二维码，如果你是集成的BGA的Zxing可以生成二维码。Zxing生成二维码的方式如下：</p><p><strong><em>耗时操作，新开线程</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//中文</span><br><span class="line">Bitmap bitmap = QRCodeEncoder.syncEncodeQRCode(&quot;海晨忆&quot;, BGAQRCodeUtil.dp2px(this, 150));</span><br><span class="line"></span><br><span class="line">//带logo</span><br><span class="line">Bitmap logoBitmap = BitmapFactory.decodeResource(TestGeneratectivity.this.getResources(), R.mipmap.logo);</span><br><span class="line">QRCodeEncoder.syncEncodeQRCode(&quot;海晨忆&quot;, BGAQRCodeUtil.dp2px(TestGeneratectivity.this, 150), Color.parseColor(&quot;#ff0000&quot;), logoBitmap);</span><br></pre></td></tr></table></figure><p><strong><em>解析图片二维码</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//mEnglishLogoIv：显示二维码的控件</span><br><span class="line">mEnglishLogoIv.setDrawingCacheEnabled(true);</span><br><span class="line">Bitmap bitmap = mEnglishLogoIv.getDrawingCache();</span><br><span class="line"></span><br><span class="line">//返回二维码图片里的内容 或 null</span><br><span class="line">String result = QRCodeDecoder.syncDecodeQRCode(bitmap);</span><br><span class="line">String result = QRCodeDecoder.syncDecodeQRCode(picturePath);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;做过二维码扫描的童鞋都知道，要用Zxing，可是google官方推的Zxing，我们集成扫描的时候很慢，有时候就直接扫不出来，体验太差了。因为他适配了太多东西，我们只要一个扫描功能，然后就去网上搜索，怎么使zxing扫描变的很快，zxing的优化，然后跟着网上的博客，一步一步走，即使最终做完了，感觉体验还是不够好。我这里推荐一个二维码扫描的开源框架——&lt;a href=&quot;https://github.com/bingoogolapple/BGAQRCode-Android&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BGAQRCode-Android&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android WIFI功能——WifiManager</title>
    <link href="http://haichenyi.com/2018/03/05/Android-WIFI%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94WifiManager/"/>
    <id>http://haichenyi.com/2018/03/05/Android-WIFI功能——WifiManager/</id>
    <published>2018-03-05T12:13:31.000Z</published>
    <updated>2018-03-06T12:59:02.079Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前做了关于Android wifi的相关功能，这里做一个记录</p><a id="more"></a><h3 id="第一步：获取WifiManager"><a href="#第一步：获取WifiManager" class="headerlink" title="第一步：获取WifiManager"></a>第一步：获取WifiManager</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WifiManager wifiMgr = (WifiManager)Context.getSystemService(Context.WIFI_SERVICE);</span><br></pre></td></tr></table></figure><h3 id="第二步：获取周围热点信息和已连接wifi信息"><a href="#第二步：获取周围热点信息和已连接wifi信息" class="headerlink" title="第二步：获取周围热点信息和已连接wifi信息"></a>第二步：获取周围热点信息和已连接wifi信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ScanResult&gt; scanResults = wifiMgr.getScanResults();//扫描到的周围热点信息</span><br><span class="line">WifiInfo info = wifiMgr.getConnectionInfo();//已连接wifi信息</span><br></pre></td></tr></table></figure><p>这里我说一下几个字段的意思：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String name;//ssid对应的wifi名字</span><br><span class="line">public String capabilities;//用来判断是否有密码</span><br><span class="line">public int level;//信号等级，这里是负数</span><br><span class="line">public String BSSID;//macid</span><br></pre></td></tr></table></figure><p>这里我需要强调的就是level，是负数，<strong><em>负数越大，信号越好</em></strong></p><h3 id="第三步：检测wifi信息，这里我给出几个工具类"><a href="#第三步：检测wifi信息，这里我给出几个工具类" class="headerlink" title="第三步：检测wifi信息，这里我给出几个工具类"></a>第三步：检测wifi信息，这里我给出几个工具类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 连接有密码的wifi.</span><br><span class="line">   *</span><br><span class="line">   * @param SSID     ssid</span><br><span class="line">   * @param Password Password</span><br><span class="line">   * @return apConfig</span><br><span class="line">   */</span><br><span class="line">  private WifiConfiguration setWifiParamsPassword(String SSID, String Password) &#123;</span><br><span class="line">    WifiConfiguration apConfig = new WifiConfiguration();</span><br><span class="line">    apConfig.SSID = &quot;\&quot;&quot; + SSID + &quot;\&quot;&quot;;</span><br><span class="line">    apConfig.preSharedKey = &quot;\&quot;&quot; + Password + &quot;\&quot;&quot;;</span><br><span class="line">    //不广播其SSID的网络</span><br><span class="line">    apConfig.hiddenSSID = true;</span><br><span class="line">    apConfig.status = WifiConfiguration.Status.ENABLED;</span><br><span class="line">    //公认的IEEE 802.11验证算法。</span><br><span class="line">    apConfig.allowedAuthAlgorithms.clear();</span><br><span class="line">    apConfig.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);</span><br><span class="line">    //公认的的公共组密码</span><br><span class="line">    apConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);</span><br><span class="line">    apConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);</span><br><span class="line">    //公认的密钥管理方案</span><br><span class="line">    apConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);</span><br><span class="line">    //密码为WPA。</span><br><span class="line">    apConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);</span><br><span class="line">    apConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);</span><br><span class="line">    //公认的安全协议。</span><br><span class="line">    apConfig.allowedProtocols.set(WifiConfiguration.Protocol.RSN);</span><br><span class="line">    return apConfig;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 连接没有密码wifi.</span><br><span class="line">   *</span><br><span class="line">   * @param ssid ssid</span><br><span class="line">   * @return configuration</span><br><span class="line">   */</span><br><span class="line">  private WifiConfiguration setWifiParamsNoPassword(String ssid) &#123;</span><br><span class="line">    WifiConfiguration configuration = new WifiConfiguration();</span><br><span class="line">    configuration.SSID = &quot;\&quot;&quot; + ssid + &quot;\&quot;&quot;;</span><br><span class="line">    configuration.status = WifiConfiguration.Status.ENABLED;</span><br><span class="line">    configuration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);</span><br><span class="line">    configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);</span><br><span class="line">    configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);</span><br><span class="line">    configuration.allowedPairwiseCiphers</span><br><span class="line">        .set(WifiConfiguration.PairwiseCipher.TKIP);</span><br><span class="line">    configuration.allowedPairwiseCiphers</span><br><span class="line">        .set(WifiConfiguration.PairwiseCipher.CCMP);</span><br><span class="line">    configuration.allowedProtocols.set(WifiConfiguration.Protocol.RSN);</span><br><span class="line">    return configuration;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static final int WIFI_NO_PASS = 0;</span><br><span class="line">  private static final int WIFI_WEP = 1;</span><br><span class="line">  private static final int WIFI_PSK = 2;</span><br><span class="line">  private static final int WIFI_EAP = 3;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 判断是否有密码.</span><br><span class="line">   *</span><br><span class="line">   * @param result ScanResult</span><br><span class="line">   * @return 0</span><br><span class="line">   */</span><br><span class="line">  public static int getSecurity(MyScanResult result) &#123;</span><br><span class="line">    if (null != result &amp;&amp; null != result.capabilities) &#123;</span><br><span class="line">      if (result.capabilities.contains(&quot;WEP&quot;)) &#123;</span><br><span class="line">        return WIFI_WEP;</span><br><span class="line">      &#125; else if (result.capabilities.contains(&quot;PSK&quot;)) &#123;</span><br><span class="line">        return WIFI_PSK;</span><br><span class="line">      &#125; else if (result.capabilities.contains(&quot;EAP&quot;)) &#123;</span><br><span class="line">        return WIFI_EAP;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return WIFI_NO_PASS;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面三个工具类，一个用来判断是否需要密码，另外两个用来连接wifi</p><h3 id="连接wifi"><a href="#连接wifi" class="headerlink" title="连接wifi"></a>连接wifi</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//需要密码</span><br><span class="line">wifiMgr.enableNetwork(wifiMgr.addNetwork(</span><br><span class="line">                    setWifiParamsPassword(mClickResult.name, password)), true);</span><br><span class="line">//不需要密码</span><br><span class="line">wifiMgr.enableNetwork(wifiMgr.addNetwork(setWifiParamsNoPassword(mClickResult.name)),</span><br><span class="line">              true);</span><br></pre></td></tr></table></figure><h3 id="wifi监听"><a href="#wifi监听" class="headerlink" title="wifi监听"></a>wifi监听</h3><p>PS：关于wifi状态的监听，就是监听你当前的网络状态即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.receiver.NetworkReceiver&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.net.wifi.WIFI_STATE_CHANGED&quot;/&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.net.wifi.STATE_CHANGE&quot;/&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.net.wifi.supplicant.STATE_CHANGE&quot;/&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.net.wifi.NETWORK_IDS_CHANGED&quot;/&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/receiver&gt;</span><br></pre></td></tr></table></figure><p>首先在你的清单文件注册这四种action的广播，这里给出我的网络监听广播</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/1/10</span><br><span class="line"> * Desc: 网络广播监听</span><br><span class="line"> */</span><br><span class="line">public class NetworkReceiver extends BroadcastReceiver &#123;</span><br><span class="line">  public static final int STATE1 = 1;//密码错误</span><br><span class="line">  public static final int STATE2 = 2;//连接成功</span><br><span class="line">  public static final int STATE3 = 3;//连接失败</span><br><span class="line">  public static final int STATE4 = 4;//正在获取ip地址</span><br><span class="line">  public static final int STATE5 = 5;//正在连接</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">    if (WifiManager.SUPPLICANT_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123;</span><br><span class="line">      //密码错误广播,是不是正在获得IP地址</span><br><span class="line">      int linkWifiResult = intent.getIntExtra(WifiManager.EXTRA_SUPPLICANT_ERROR, -1);</span><br><span class="line">      if (linkWifiResult == WifiManager.ERROR_AUTHENTICATING) &#123;</span><br><span class="line">        //密码错误</span><br><span class="line">        ToastUtils.showTipMsg(R.string.password_wrong);</span><br><span class="line">        sendNetworkStateChange(new NetWorkInfo().setState(STATE1));</span><br><span class="line">      &#125;</span><br><span class="line">      SupplicantState supplicantState = intent.getParcelableExtra(WifiManager.EXTRA_NEW_STATE);</span><br><span class="line">      NetworkInfo.DetailedState state = WifiInfo.getDetailedStateOf(supplicantState);</span><br><span class="line">      Log.v(Constants.HTTP_WZ, state.name());</span><br><span class="line">      if (state == NetworkInfo.DetailedState.CONNECTING) &#123;</span><br><span class="line">        //正在连接</span><br><span class="line">        ToastUtils.showTipMsg(R.string.linking);</span><br><span class="line">        sendNetworkStateChange(new NetWorkInfo().setState(STATE5));</span><br><span class="line">      &#125; else if (state == NetworkInfo.DetailedState.FAILED</span><br><span class="line">          || state == NetworkInfo.DetailedState.DISCONNECTING) &#123;</span><br><span class="line">        //连接失败</span><br><span class="line">        sendNetworkStateChange(new NetWorkInfo().setState(STATE3));</span><br><span class="line">        ToastUtils.showTipMsg(R.string.linked_failed);</span><br><span class="line">      &#125; else if (state == NetworkInfo.DetailedState.CONNECTED) &#123;</span><br><span class="line">        //连接成功</span><br><span class="line">        ToastUtils.showTipMsg(R.string.linked_success);</span><br><span class="line">      &#125; else if (state == NetworkInfo.DetailedState.OBTAINING_IPADDR) &#123;</span><br><span class="line">        //正在获取ip地址</span><br><span class="line">        sendNetworkStateChange(new NetWorkInfo().setState(STATE4));</span><br><span class="line">      &#125; else if (state == NetworkInfo.DetailedState.IDLE) &#123;</span><br><span class="line">        //闲置的</span><br><span class="line">        ConnectivityManager connectManager = (ConnectivityManager) BaseApplication.getInstance()</span><br><span class="line">            .getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        NetworkInfo activeNetworkInfo = null;</span><br><span class="line">        if (connectManager != null) &#123;</span><br><span class="line">          activeNetworkInfo = connectManager.getActiveNetworkInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        if (activeNetworkInfo == null) &#123;</span><br><span class="line">          sendNetworkStateChange(new NetWorkInfo().setState(STATE3));</span><br><span class="line">          ToastUtils.showTipMsg(R.string.linked_failed);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (WifiManager.WIFI_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123;</span><br><span class="line">      // 监听wifi的打开与关闭，与wifi的连接无关</span><br><span class="line">      int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, 0);</span><br><span class="line">      Log.v(Constants.HTTP_WZ, &quot;wifiState:&quot; + wifiState);</span><br><span class="line">      switch (wifiState) &#123;</span><br><span class="line">        case WifiManager.WIFI_STATE_DISABLING://正在停止0</span><br><span class="line">          ToastUtils.showTipMsg(R.string.close_wifi);</span><br><span class="line">          break;</span><br><span class="line">        case WifiManager.WIFI_STATE_DISABLED://已停止1</span><br><span class="line">          break;</span><br><span class="line">        case WifiManager.WIFI_STATE_UNKNOWN://未知4</span><br><span class="line">          break;</span><br><span class="line">        case WifiManager.WIFI_STATE_ENABLING://正在打开2</span><br><span class="line">          ToastUtils.showTipMsg(R.string.opening_wifi);</span><br><span class="line">          break;</span><br><span class="line">        case WifiManager.WIFI_STATE_ENABLED://已开启3</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (WifiManager.NETWORK_STATE_CHANGED_ACTION.equals(intent.getAction())) &#123;</span><br><span class="line">      // 监听wifi的连接状态即是否连上了一个有效无线路由</span><br><span class="line">      Parcelable parcelableExtra = intent</span><br><span class="line">          .getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);</span><br><span class="line">      if (null != parcelableExtra) &#123;</span><br><span class="line">        // 获取联网状态的NetWorkInfo对象</span><br><span class="line">        NetworkInfo networkInfo = (NetworkInfo) parcelableExtra;</span><br><span class="line">        //获取的State对象则代表着连接成功与否等状态</span><br><span class="line">        NetworkInfo.State state = networkInfo.getState();</span><br><span class="line">        //判断网络是否已经连接</span><br><span class="line">        boolean isConnected = state == NetworkInfo.State.CONNECTED;</span><br><span class="line">        Log.v(Constants.HTTP_WZ, &quot;isConnected:&quot; + isConnected);</span><br><span class="line">        if (isConnected) &#123;</span><br><span class="line">          ToastUtils.showTipMsg(R.string.linked_success);</span><br><span class="line">          sendNetworkStateChange(new NetWorkInfo().setState(STATE2));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 发送网络状态eventBus.</span><br><span class="line">   *</span><br><span class="line">   * @param info info</span><br><span class="line">   */</span><br><span class="line">  private void sendNetworkStateChange(NetWorkInfo info) &#123;</span><br><span class="line">    EventBus.getDefault().post(info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">  private String getConnectionType(int type) &#123;</span><br><span class="line">    String connType = &quot;&quot;;</span><br><span class="line">    if (type == ConnectivityManager.TYPE_MOBILE) &#123;</span><br><span class="line">      connType = &quot;移动网络&quot;;</span><br><span class="line">    &#125; else if (type == ConnectivityManager.TYPE_WIFI) &#123;</span><br><span class="line">      connType = &quot;WIFI网络&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return connType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static class NetWorkInfo &#123;</span><br><span class="line">    public int state;//1密码错误，2:连接成功，3:连接失败</span><br><span class="line"></span><br><span class="line">    private NetWorkInfo setState(int state) &#123;</span><br><span class="line">      this.state = state;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释应该写的很清楚，我就不做过多的解释了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前做了关于Android wifi的相关功能，这里做一个记录&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>简单的蓝牙通信</title>
    <link href="http://haichenyi.com/2018/03/05/%E7%AE%80%E5%8D%95%E7%9A%84%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/"/>
    <id>http://haichenyi.com/2018/03/05/简单的蓝牙通信/</id>
    <published>2018-03-05T12:12:58.000Z</published>
    <updated>2018-03-06T12:59:29.265Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前公司做智能家居类型，其中做了一个智能衣柜项目，与衣柜通信就是用的蓝牙通信。一些操作一些简单的开关指令，蓝牙通信与socket是类似的。</p><a id="more"></a><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>清单文件注册权限</li><li>启动蓝牙服务（记得在清单文件中静态注册服务）</li><li>注册蓝牙广播（在蓝牙服务中动态注册蓝牙广播）</li><li>搜索，绑定，完成</li><li>退出app，停止服务，并在蓝牙服务的onDestory方法中取消注册蓝牙广播</li></ol><p>不想写说明，只想贴代码</p><h4 id="第一步：注册权限"><a href="#第一步：注册权限" class="headerlink" title="第一步：注册权限"></a>第一步：注册权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--获取蓝牙信息状态权限--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="第二步、第三步、第五步：启动蓝牙服务，注册蓝牙广播，停止服务"><a href="#第二步、第三步、第五步：启动蓝牙服务，注册蓝牙广播，停止服务" class="headerlink" title="第二步、第三步、第五步：启动蓝牙服务，注册蓝牙广播，停止服务"></a>第二步、第三步、第五步：启动蓝牙服务，注册蓝牙广播，停止服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/1/4</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class BluetoothService extends Service &#123;</span><br><span class="line">  //得到蓝牙适配器</span><br><span class="line">  private BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();</span><br><span class="line">  private BluetoothReceiver mReceiver;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    EventBus.getDefault().register(this);</span><br><span class="line">    if (mBluetoothAdapter != null) &#123;</span><br><span class="line">      mReceiver = new BluetoothReceiver().setBluetoothAdapter(mBluetoothAdapter);</span><br><span class="line">      //注册设备被发现时的广播</span><br><span class="line">      IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);</span><br><span class="line">      registerReceiver(mReceiver, filter);</span><br><span class="line">      //注册一个搜索结束时的广播</span><br><span class="line">      IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);</span><br><span class="line">      registerReceiver(mReceiver, filter2);</span><br><span class="line">      startLinkBluetooth();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Nullable</span><br><span class="line">  @Override</span><br><span class="line">  public IBinder onBind(Intent intent) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 开始连接蓝牙设备.</span><br><span class="line">   */</span><br><span class="line">  private void startLinkBluetooth() &#123;</span><br><span class="line">    if (null != mBluetoothAdapter) &#123;</span><br><span class="line">      //判断蓝牙是否打开</span><br><span class="line">      if (!mBluetoothAdapter.isEnabled()) &#123;</span><br><span class="line">        //若没打开则打开蓝牙</span><br><span class="line">        mBluetoothAdapter.enable();</span><br><span class="line">      &#125;</span><br><span class="line">      mBluetoothAdapter.startDiscovery();</span><br><span class="line">      Log.v(Constants.HTTP_WZ, &quot;正在扫描&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Subscribe</span><br><span class="line">  @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">  public void handleMsg(BluetoothInfo bluetoothInfo) &#123;</span><br><span class="line">    if (bluetoothInfo.isLink) &#123;</span><br><span class="line">      startLinkBluetooth();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static class BluetoothInfo &#123;</span><br><span class="line">    private boolean isLink = false;</span><br><span class="line"></span><br><span class="line">    public BluetoothInfo setLink(boolean link) &#123;</span><br><span class="line">      this.isLink = link;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    EventBus.getDefault().unregister(this);</span><br><span class="line">    if (mReceiver != null) &#123;</span><br><span class="line">      mReceiver.unRegister();</span><br><span class="line">      unregisterReceiver(mReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是我的蓝牙服务类，这个类的逻辑怎么走的呢？</p><ol><li><p>EventBus的东西我就不说了</p></li><li><p>首先获取蓝牙适配器</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();</span><br></pre></td></tr></table></figure><ol><li>初始化蓝牙广播，注册蓝牙广播</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (mBluetoothAdapter != null) &#123;</span><br><span class="line">      mReceiver = new BluetoothReceiver().setBluetoothAdapter(mBluetoothAdapter);</span><br><span class="line">      //注册设备被发现时的广播</span><br><span class="line">      IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);</span><br><span class="line">      registerReceiver(mReceiver, filter);</span><br><span class="line">      //注册一个搜索结束时的广播</span><br><span class="line">      IntentFilter filter2 = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);</span><br><span class="line">      registerReceiver(mReceiver, filter2);</span><br><span class="line">      startLinkBluetooth();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>开始准备连接蓝牙设备</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 开始连接蓝牙设备.</span><br><span class="line">   */</span><br><span class="line">  private void startLinkBluetooth() &#123;</span><br><span class="line">    if (null != mBluetoothAdapter) &#123;</span><br><span class="line">      //判断蓝牙是否打开</span><br><span class="line">      if (!mBluetoothAdapter.isEnabled()) &#123;</span><br><span class="line">        //若没打开则打开蓝牙</span><br><span class="line">        mBluetoothAdapter.enable();</span><br><span class="line">      &#125;</span><br><span class="line">      mBluetoothAdapter.startDiscovery();</span><br><span class="line">      Log.v(Constants.HTTP_WZ, &quot;正在扫描&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>上面4步蓝牙扫描就完成了，这里我还要说的是，在服务的onDestory方法里面，记得停止服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    EventBus.getDefault().unregister(this);</span><br><span class="line">    if (mReceiver != null) &#123;</span><br><span class="line">      mReceiver.unRegister();</span><br><span class="line">      unregisterReceiver(mReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>再就是在清单文件里面静态注册蓝牙服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;.service.BluetoothService&quot;/&gt;</span><br></pre></td></tr></table></figure><ol><li>启动服务的方式，我用的是非绑定的方式，同样，记得停止服务。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent bluetoothService = new Intent(this, BluetoothService.class);</span><br><span class="line">startService(bluetoothService);//启动蓝牙服务</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopService(bluetoothService);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">  @Override</span><br><span class="line">  public IBinder onBind(Intent intent) &#123;</span><br><span class="line">  //非绑定方式，返回值为null</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="第四步：搜索，绑定，完成搜索"><a href="#第四步：搜索，绑定，完成搜索" class="headerlink" title="第四步：搜索，绑定，完成搜索"></a>第四步：搜索，绑定，完成搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/1/4</span><br><span class="line"> * Desc: 蓝牙广播监听</span><br><span class="line"> */</span><br><span class="line">public class BluetoothReceiver extends BroadcastReceiver &#123;</span><br><span class="line">  //衣柜的蓝牙名称</span><br><span class="line">  private static final String WARDROBE_NAME = &quot;WARDROBE&quot;;</span><br><span class="line">  // 固定的UUID</span><br><span class="line">  private static final String SPP_UUID = &quot;00001101-0000-1000-8000-00805F9B34FB&quot;;</span><br><span class="line">  private BluetoothSocket bluetoothSocket;</span><br><span class="line">  private BluetoothAdapter bluetoothAdapter;</span><br><span class="line">  private InputStream mInputStream;</span><br><span class="line">  private OutputStream outputStream;</span><br><span class="line">  private boolean isRunning = false;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">    String action = intent.getAction();</span><br><span class="line">    if (action != null) &#123;</span><br><span class="line">      if (action.equals(BluetoothDevice.ACTION_FOUND)) &#123;</span><br><span class="line">        BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</span><br><span class="line">        Log.v(Constants.HTTP_WZ, device.getName() + device.getAddress());</span><br><span class="line">        if (device.getBondState() == BluetoothDevice.BOND_BONDED</span><br><span class="line">            &amp;&amp; device.getName().equals(WARDROBE_NAME)) &#123;</span><br><span class="line">          UUID uuid = UUID.fromString(SPP_UUID);</span><br><span class="line">          try &#123;</span><br><span class="line">            bluetoothSocket = device.createRfcommSocketToServiceRecord(uuid);</span><br><span class="line">            Log.v(Constants.HTTP_WZ, &quot;准备连接&quot;);</span><br><span class="line">            connect();</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) &#123;</span><br><span class="line">        if (!EventBus.getDefault().isRegistered(this))</span><br><span class="line">          EventBus.getDefault().register(this);</span><br><span class="line">        Observable.timer(2, TimeUnit.SECONDS)</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(aLong -&gt; &#123;</span><br><span class="line">              if (null == bluetoothSocket || !bluetoothSocket.isConnected())</span><br><span class="line">                ToastUtils.showTipMsg(R.string.no_wardrobe);</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void connect() &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      if (bluetoothSocket != null) &#123;</span><br><span class="line">        bluetoothAdapter.cancelDiscovery();</span><br><span class="line">        try &#123;</span><br><span class="line">          bluetoothSocket.connect();</span><br><span class="line">          Observable.just(1)</span><br><span class="line">              .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">              .subscribe(integer -&gt; ToastUtils.showTipMsg(R.string.link_wardrobe));</span><br><span class="line">          Log.v(Constants.HTTP_WZ, &quot;连接成功&quot;);</span><br><span class="line">          mInputStream = bluetoothSocket.getInputStream();</span><br><span class="line">          Log.v(Constants.HTTP_WZ, &quot;mInputSream:&quot; + mInputStream.toString());</span><br><span class="line">          isRunning = true;</span><br><span class="line">          outputStream = bluetoothSocket.getOutputStream();</span><br><span class="line">          Log.v(Constants.HTTP_WZ, &quot;outputStream:&quot; + outputStream.toString());</span><br><span class="line">          BufferedReader br;</span><br><span class="line">          while (isRunning) &#123;</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(mInputStream, &quot;utf-8&quot;));</span><br><span class="line">            String s = br.readLine();</span><br><span class="line">            //acceptReply(s);</span><br><span class="line">            Log.v(Constants.HTTP_WZ, &quot;收到的数据:&quot; + s);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          try &#123;</span><br><span class="line">            if (mInputStream != null) &#123;</span><br><span class="line">              mInputStream.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;mInputSream.close()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (outputStream != null) &#123;</span><br><span class="line">              outputStream.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;outputStream.close()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bluetoothSocket != null) &#123;</span><br><span class="line">              bluetoothSocket.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;socket.close()&quot;);</span><br><span class="line">              bluetoothSocket = null;</span><br><span class="line">            &#125;</span><br><span class="line">            isRunning = false;</span><br><span class="line">          &#125; catch (Exception e2) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BluetoothReceiver setBluetoothAdapter(BluetoothAdapter adapter) &#123;</span><br><span class="line">    this.bluetoothAdapter = adapter;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 反注册eventBus.</span><br><span class="line">   */</span><br><span class="line">  public void unRegister() &#123;</span><br><span class="line">    EventBus.getDefault().unregister(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是我的蓝牙广播类，这个逻辑又是怎么走的呢？</p><ol><li>前面服务里面注册的两个action，一个<strong><em>BluetoothDevice.ACTION_FOUND</em></strong>，还有一个<strong><em>BluetoothAdapter.ACTION_DISCOVERY_FINISHED</em></strong>，做了一个if判断，是发现了设备还是已经完成了扫描设备</li><li>发现设备之后，获取蓝牙信息，<strong>他这里是获取到一个蓝牙信息就会走一遍这个方法，并不是说一次获取一个列表</strong>。</li><li>找到了蓝牙设备之后就是连接了，伪代码讲解：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 固定的UUID连接的时候需要uuid</span><br><span class="line">  private static final String SPP_UUID = &quot;00001101-0000-1000-8000-00805F9B34FB&quot;;</span><br><span class="line">  </span><br><span class="line">//获取socket</span><br><span class="line">BluetoothSocket bluetoothSocket =device.createRfcommSocketToServiceRecord(uuid);</span><br><span class="line"></span><br><span class="line">//连接之前取消扫描，注意非空判断。adapter是在服务里面申明的，通过setBluetoothAdapter方法传过来的</span><br><span class="line">bluetoothAdapter.cancelDiscovery();</span><br><span class="line"></span><br><span class="line">//连接，这里是阻塞的方式，注意要新开线程连接</span><br><span class="line">bluetoothSocket.connect();</span><br><span class="line"></span><br><span class="line">//获取输入流对象和输出流对象</span><br><span class="line">InputStream mInputStream = bluetoothSocket.getInputStream();</span><br><span class="line">OutputStream outputStream = bluetoothSocket.getOutputStream();</span><br><span class="line"></span><br><span class="line">//发送消息</span><br><span class="line">private void sendInstruct(String msg) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (null == bluetoothSocket || !bluetoothSocket.isConnected()) &#123;</span><br><span class="line">        SocketUtils.reLinkBluetooth();</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      Log.v(Constants.HTTP_WZ, &quot;发送的数据--&gt;&quot; + msg + BluetoothInstruct.FINISH);</span><br><span class="line">      outputStream.write(msg.getBytes());</span><br><span class="line">      outputStream.flush();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//接收消息，一次读一行，简单的蓝牙通信换行符作为结束标记</span><br><span class="line">BufferedReader br;</span><br><span class="line">while (isRunning) &#123;</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(mInputStream, &quot;utf-8&quot;));</span><br><span class="line">            String s = br.readLine();</span><br><span class="line">            acceptReply(s);</span><br><span class="line">            Log.v(Constants.HTTP_WZ, &quot;收到的数据:&quot; + s);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">//异常的时候释放资源</span><br><span class="line">try &#123;</span><br><span class="line">            if (mInputStream != null) &#123;</span><br><span class="line">              mInputStream.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;mInputSream.close()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (outputStream != null) &#123;</span><br><span class="line">              outputStream.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;outputStream.close()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bluetoothSocket != null) &#123;</span><br><span class="line">              bluetoothSocket.close();</span><br><span class="line">              Log.v(Constants.HTTP_WZ, &quot;socket.close()&quot;);</span><br><span class="line">              bluetoothSocket = null;</span><br><span class="line">            &#125;</span><br><span class="line">            isRunning = false;</span><br><span class="line">          &#125; catch (Exception e2) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前公司做智能家居类型，其中做了一个智能衣柜项目，与衣柜通信就是用的蓝牙通信。一些操作一些简单的开关指令，蓝牙通信与socket是类似的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android拍照功能——TakePhoto</title>
    <link href="http://haichenyi.com/2018/03/05/Android%E6%8B%8D%E7%85%A7%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94TakePhoto/"/>
    <id>http://haichenyi.com/2018/03/05/Android拍照功能——TakePhoto/</id>
    <published>2018-03-05T12:12:03.000Z</published>
    <updated>2018-03-06T12:58:23.128Z</updated>
    
    <content type="html"><![CDATA[<p>之前在写项目框架Andoroid 6.0，动态获取权限的时候就提到过<a href="https://github.com/crazycodeboy/TakePhoto" target="_blank" rel="noopener">TakePhoto开源框架</a></p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.jph.takephoto:takephoto_library:4.0.3&apos;</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>我这里就说拍照，选择相册的功能。其他功能请移步<a href="https://github.com/crazycodeboy/TakePhoto" target="_blank" rel="noopener">TakePhoto开源框架</a>看说明文档，写的很清楚。最后会给出一个工具类，拷贝过去就可以直接用。</p><ol><li>定义两个变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private TakePhoto takePhoto;</span><br><span class="line">private InvokeParam invokeParam;</span><br></pre></td></tr></table></figure><ol><li>添加如下代码获取TakePhoto实例</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public TakePhoto getTakePhoto()&#123;</span><br><span class="line">    if (takePhoto==null)&#123;</span><br><span class="line">      takePhoto= (TakePhoto) TakePhotoInvocationHandler.of(this).bind(new TakePhotoImpl(this,this));</span><br><span class="line">    &#125;</span><br><span class="line">    //设置压缩规则，最大500kb</span><br><span class="line">    takePhoto.onEnableCompress(new CompressConfig.Builder().setMaxSize(500 * 1024).create(), true);</span><br><span class="line">    return takePhoto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>实现两个接口：TakePhoto.TakeResultListener,InvokeListener</li><li>在 onCreate,onActivityResult,onSaveInstanceState方法中调用TakePhoto对用的方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    getTakePhoto().onCreate(savedInstanceState);</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    getTakePhoto().onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    super.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">    getTakePhoto().onSaveInstanceState(outState);</span><br><span class="line">    super.onSaveInstanceState(outState);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>重写TPermissionType invoke(InvokeParam invokeParam)方法，添加如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;</span><br><span class="line">    super.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    //以下代码为处理Android6.0、7.0动态权限所需</span><br><span class="line">    PermissionManager.TPermissionType type=PermissionManager.onRequestPermissionsResult(requestCode,permissions,grantResults);</span><br><span class="line">    PermissionManager.handlePermissionsResult(this,type,invokeParam,this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public PermissionManager.TPermissionType invoke(InvokeParam invokeParam) &#123;</span><br><span class="line">    PermissionManager.TPermissionType type=PermissionManager.checkPermission(TContextWrap.of(this),invokeParam.getMethod());</span><br><span class="line">    if(PermissionManager.TPermissionType.WAIT.equals(type))&#123;</span><br><span class="line">      this.invokeParam=invokeParam;</span><br><span class="line">    &#125;</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;到这里，根据他官方的介绍就已经全部写完了，然后怎么分调用相机，相册还是文件夹呢？</p><ol><li>调用不同的方法，常用的：相机，相册，多选</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    flag = getIntent().getIntExtra(&quot;flag&quot;, 0);</span><br><span class="line">    File file = new File(getExternalCacheDir(), System.currentTimeMillis() + &quot;.png&quot;);</span><br><span class="line">    Uri uri = Uri.fromFile(file);</span><br><span class="line">    int size = Math.min(getResources().getDisplayMetrics().widthPixels, getResources().getDisplayMetrics().heightPixels);</span><br><span class="line">    CropOptions cropOptions = new CropOptions.Builder().setOutputX(size).setOutputX(size).setWithOwnCrop(false).create();</span><br><span class="line">    if (flag == 1) &#123;</span><br><span class="line">      //相机获取照片并剪裁</span><br><span class="line">      takePhoto.onPickFromCaptureWithCrop(uri, cropOptions);</span><br><span class="line">      //相机获取不剪裁</span><br><span class="line">      //takePhoto.onPickFromCapture(uri);</span><br><span class="line">    &#125; else if (flag == 2) &#123;</span><br><span class="line">      //相册获取照片并剪裁</span><br><span class="line">      takePhoto.onPickFromGalleryWithCrop(uri, cropOptions);</span><br><span class="line">      //相册获取不剪裁</span><br><span class="line">//      takePhoto.onPickFromGallery();</span><br><span class="line">    &#125; else if (flag == 3) &#123;</span><br><span class="line">      //多选，并剪裁</span><br><span class="line">      takePhoto.onPickMultipleWithCrop(9, cropOptions);</span><br><span class="line">      //多选，不剪裁</span><br><span class="line">//      takePhoto.onPickMultiple(9);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面一个页面调用startActivityForResult，传一个标记过来，用来判断调用不同的方式。</p><p>&emsp;&emsp;我这里还想多说的是，一般我们这个拍照功能，都有三个选项，拍照，相册，取消，从底部弹出。这个我估计还是大部分人写的动画实现的。我想说的是<strong><em>BottomSheetDialog</em></strong>，这个是MD推出的一个控件，现在微信用的就是这个，用起来也非常方便，简单。</p><p>&emsp;&emsp;至于，工具类，直接下载项目，把对应的TakePhotoActivity文件拷贝过去就可以了。</p><p><a href="http://download.csdn.net/download/qq_27634797/10272409" target="_blank" rel="noopener">资源链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在写项目框架Andoroid 6.0，动态获取权限的时候就提到过&lt;a href=&quot;https://github.com/crazycodeboy/TakePhoto&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TakePhoto开源框架&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android图片压缩——Luban鲁班压缩</title>
    <link href="http://haichenyi.com/2018/03/02/Android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E2%80%94%E2%80%94Luban%E9%B2%81%E7%8F%AD%E5%8E%8B%E7%BC%A9/"/>
    <id>http://haichenyi.com/2018/03/02/Android图片压缩——Luban鲁班压缩/</id>
    <published>2018-03-02T12:14:04.000Z</published>
    <updated>2018-03-02T12:16:22.942Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Android让人头疼的OOM，造成OOM的原因之一就是图片，现在的手机像素越来越高，随便一张图片都是好几M，甚至几十M，这样的照片加载到app，可想而知，随便加载几张图片，手机内存就不够用了，自然而然就造成了OOM，所以，Android的图片压缩异常重要。这里，我推荐一款开源框架——<a href="https://github.com/Curzibn/Luban" target="_blank" rel="noopener">Luban</a></p><a id="more"></a><h2 id="效果与对比"><a href="#效果与对比" class="headerlink" title="效果与对比"></a>效果与对比</h2><p>&emsp;&emsp;这里就不放效果图了，我拷贝了鲁班github上面的介绍——Android图片压缩工具，仿微信朋友圈压缩策略，因为是逆向推算，效果还没法跟微信一模一样，但是已经很接近微信朋友圈压缩后的效果，具体看以下对比！</p><table><thead><tr><th style="text-align:center">内容</th><th style="text-align:center">原图</th><th style="text-align:center">Luban</th><th style="text-align:center">Wechat</th></tr></thead><tbody><tr><td style="text-align:center">截屏 720P</td><td style="text-align:center">720*1280,390k</td><td style="text-align:center">720*1280,87k</td><td style="text-align:center">720*1280,56k</td></tr><tr><td style="text-align:center">截屏 1080P</td><td style="text-align:center">1080*1920,2.21M</td><td style="text-align:center">1080*1920,104k</td><td style="text-align:center">1080*1920,112k</td></tr><tr><td style="text-align:center">拍照 13M(4:3)</td><td style="text-align:center">3096*4128,3.12M</td><td style="text-align:center">1548*2064,141k</td><td style="text-align:center">1548*2064,147k</td></tr><tr><td style="text-align:center">拍照 9.6M(16:9)</td><td style="text-align:center">4128*2322,4.64M</td><td style="text-align:center">1032*581,97k</td><td style="text-align:center">1032*581,74k</td></tr><tr><td style="text-align:center">滚动截屏</td><td style="text-align:center">1080*6433,1.56M</td><td style="text-align:center">1080*6433,351k</td><td style="text-align:center">1080*6433,482k</td></tr></tbody></table><p>从这里就能看出，效果还是非常不错的</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;top.zibin:Luban:1.1.3&apos;</span><br></pre></td></tr></table></figure><h2 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h2><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>&emsp;&emsp;Luban内部采用IO线程进行图片压缩，外部调用只需设置好结果监听即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Luban.with(this)</span><br><span class="line">        .load(photos)                                   // 传人要压缩的图片列表</span><br><span class="line">        .ignoreBy(100)                                  // 忽略不压缩图片的大小</span><br><span class="line">        .setTargetDir(getPath())                        // 设置压缩后文件存储位置</span><br><span class="line">        .setCompressListener(new OnCompressListener() &#123; //设置回调</span><br><span class="line">          @Override</span><br><span class="line">          public void onStart() &#123;</span><br><span class="line">            // TODO 压缩开始前调用，可以在方法内启动 loading UI</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onSuccess(File file) &#123;</span><br><span class="line">            // TODO 压缩成功后调用，返回压缩后的图片文件</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onError(Throwable e) &#123;</span><br><span class="line">            // TODO 当压缩过程出现问题时调用</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).launch();    //启动压缩</span><br></pre></td></tr></table></figure><h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>&emsp;&emsp;同步方法请尽量避免在主线程调用以免阻塞主线程，下面以rxJava调用为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flowable.just(photos)</span><br><span class="line">    .observeOn(Schedulers.io())</span><br><span class="line">    .map(new Function&lt;List&lt;String&gt;, List&lt;File&gt;&gt;() &#123;</span><br><span class="line">      @Override public List&lt;File&gt; apply(@NonNull List&lt;String&gt; list) throws Exception &#123;</span><br><span class="line">        // 同步方法直接返回压缩后的文件</span><br><span class="line">        return Luban.with(MainActivity.this).load(list).get();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上，均是它github上面说明都有的，我这里就是copy过来了而已。重点要说的是，他是怎么实现的，源码分析。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="第一步：Luban-with"><a href="#第一步：Luban-with" class="headerlink" title="第一步：Luban.with()"></a>第一步：<strong><em>Luban.with()</em></strong></h3><p>点击去看到源码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Builder with(Context context) &#123;</span><br><span class="line">    return new Builder(context);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里是一个静态的with方法，返回值是Builder，一般对设计模式比较熟悉的人，看到这里就应该懂了，他这里使用的是建造者模式。什么是建造者模式呢？建造者模式和工厂模式很相似，比工厂模式多了一个控制类，其实说白了，就是在创建对象的时候，减少初始化数据的代码，怎么理解呢？我们接着往下看。我们点到Builder里面看到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static class Builder &#123;</span><br><span class="line">    private Context context;//上下文对象</span><br><span class="line">    private String mTargetDir;//压缩后图片存放位置</span><br><span class="line">    private List&lt;String&gt; mPaths;//多个文件的list</span><br><span class="line">    private int mLeastCompressSize = 100;//忽略100kb以下的图片，不压缩</span><br><span class="line">    private OnCompressListener mCompressListener;//回调方法</span><br><span class="line"></span><br><span class="line">    Builder(Context context) &#123;</span><br><span class="line">      this.context = context;</span><br><span class="line">      this.mPaths = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Luban build() &#123;</span><br><span class="line">      return new Luban(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看到了是一个静态的内部类Builder，我们这里看到了有5个变量，上面我们说道了，为了减少初始化数据的代码，就拿这个举例子说明，我如果有4个地方调用这个鲁班压缩，其中这4个地方，mTargetDir，mLeastCompressSize这2个变量的值都是一样的，其他3个不一样，按照我们以往的写法都得一个一个的赋值，要写4遍，那如果使用建造者模式了，这里就只用写一遍赋值，这2个变量。其他3个不一样，就得写多遍。当然，这是我个人对于建造者模式的理解。</p><p>&emsp;&emsp;我上面多粘贴了一个<strong><em>build()</em></strong>方法，为什么会多粘贴一个呢？就是为了更好的说明建造者模式，我们可以看到他这个方法，返回的是Luban对象，调用的是需要传Builder的构造方法，我们点进去看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Luban(Builder builder) &#123;</span><br><span class="line">    this.mPaths = builder.mPaths;</span><br><span class="line">    this.mTargetDir = builder.mTargetDir;</span><br><span class="line">    this.mCompressListener = builder.mCompressListener;</span><br><span class="line">    this.mLeastCompressSize = builder.mLeastCompressSize;</span><br><span class="line">    mHandler = new Handler(Looper.getMainLooper(), this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;他这里就是赋值，他这个值就是Builder里面默认的，我们不论在哪里调用这个方法，都不用去一个一个赋值，因为，他已经处理好了。</p><h3 id="第二步：load"><a href="#第二步：load" class="headerlink" title="第二步：load()"></a>第二步：<strong><em>load()</em></strong></h3><p>点击去看到源码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Builder load(File file) &#123;</span><br><span class="line">      this.mPaths.add(file.getAbsolutePath());</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder load(String string) &#123;</span><br><span class="line">      this.mPaths.add(string);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder load(List&lt;String&gt; list) &#123;</span><br><span class="line">      this.mPaths.addAll(list);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里，我们会看到三个重载方法，一个传文件，他会获取到文件的绝对路径存进去，实际上还是存的字符串，中间那个存的是字符串，最后面那个传String类型的list，它调用的addAll方法，最后还是存的String在mPaths里面。我们点击mPaths，他就是一个String类型的list，在Builder的构造方法里面初始化的。他就是存放你的图片路径的集合</p><h3 id="第三步：ignoreBy-和-setTargetDir"><a href="#第三步：ignoreBy-和-setTargetDir" class="headerlink" title="第三步：ignoreBy() 和 setTargetDir()"></a>第三步：<strong><em>ignoreBy()</em></strong> 和 <strong><em>setTargetDir()</em></strong></h3><p>点击去看到源码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * do not compress when the origin image file size less than one value</span><br><span class="line"> *</span><br><span class="line"> * @param size</span><br><span class="line"> *     the value of file size, unit KB, default 100K</span><br><span class="line"> */</span><br><span class="line">public Builder ignoreBy(int size) &#123;</span><br><span class="line">  this.mLeastCompressSize = size;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Builder setTargetDir(String targetDir) &#123;</span><br><span class="line">  this.mTargetDir = targetDir;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这两个我为啥要放在一起讲呢？因为这两个没啥好说的，都是设置值，跟我们平时写的set方法的作用是一样的。没啥好说的</p><h3 id="第四步：setCompressListener-OnCompressListener-listener"><a href="#第四步：setCompressListener-OnCompressListener-listener" class="headerlink" title="第四步：setCompressListener(OnCompressListener listener)"></a>第四步：<strong><em>setCompressListener(OnCompressListener listener)</em></strong></h3><p>点击去看到源码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Builder setCompressListener(OnCompressListener listener) &#123;</span><br><span class="line">      this.mCompressListener = listener;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个就是我们平时写自定义view的时候，要写回调方法，是一样的道理，他这里就是压缩方法的回调</p><h3 id="第五步：launch"><a href="#第五步：launch" class="headerlink" title="第五步：launch()"></a>第五步：<strong><em>launch()</em></strong></h3><p>点击去看到源码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * begin compress image with asynchronous</span><br><span class="line"> */</span><br><span class="line">public void launch() &#123;</span><br><span class="line">  build().launch(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里，我们看到他先调用了build(),我们前面讲了，他这个方法就是赋值，然后调用了launch(context)方法，我们点进去看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * start asynchronous compress thread</span><br><span class="line">   */</span><br><span class="line">  @UiThread private void launch(final Context context) &#123;</span><br><span class="line">    if (mPaths == null || mPaths.size() == 0 &amp;&amp; mCompressListener != null) &#123;</span><br><span class="line">      mCompressListener.onError(new NullPointerException(&quot;image file cannot be null&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = mPaths.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">      final String path = iterator.next();</span><br><span class="line">      if (Checker.isImage(path)) &#123;</span><br><span class="line">        AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() &#123;</span><br><span class="line">          @Override public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_START));</span><br><span class="line"></span><br><span class="line">              File result = Checker.isNeedCompress(mLeastCompressSize, path) ?</span><br><span class="line">                  new Engine(path, getImageCacheFile(context, Checker.checkSuffix(path))).compress() :</span><br><span class="line">                  new File(path);</span><br><span class="line"></span><br><span class="line">              mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_SUCCESS, result));</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">              mHandler.sendMessage(mHandler.obtainMessage(MSG_COMPRESS_ERROR, e));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Log.e(TAG, &quot;can not read the path : &quot; + path);</span><br><span class="line">      &#125;</span><br><span class="line">      iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法就是最后，执行压缩的方法，前面都是初始化，我们可以看到，他这个方法是在主线程调用的，所以，我们不用考虑切换线程的问题，直接可以操作UI变化。我一步一步的讲：</p><ol><li>首先，他这个是用的迭代器，循环遍历，遍历一个就移除一个</li><li>然后就是通过handler发消息调用</li><li>具体压缩代码。最重要的就是第三点，我把第三点，提到下面讲</li></ol><p>接着上面的第三点，具体压缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File result = Checker.isNeedCompress(mLeastCompressSize, path) ?</span><br><span class="line">                  new Engine(path, getImageCacheFile(context, Checker.checkSuffix(path))).compress() :</span><br><span class="line">                  new File(path);</span><br></pre></td></tr></table></figure><p>首先，他整体是一个三目运算符，我们点isNeedCompress()方法看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static boolean isNeedCompress(int leastCompressSize, String path) &#123;</span><br><span class="line">    if (leastCompressSize &gt; 0) &#123;</span><br><span class="line">      File source = new File(path);</span><br><span class="line">      if (!source.exists()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (source.length() &lt;= (leastCompressSize &lt;&lt; 10)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法就是用来判断，你给定路径的图片大小和你规定的忽略文件大小比较，他这里先做了你给定的最小值判断，要大于0，不大于0就返回ture。然后做了文件是否存在的判断，如果文件不存在，就返回fals。最后，给定文件大小是不是小于等于最小值左移10位的值，小于就返回false。</p><p>然后，如果返回的是true，就去压缩，如果，返回的是false，就直接返回file文件。压缩的方法点进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Engine(String srcImg, File tagImg) throws IOException &#123;</span><br><span class="line">    if (Checker.isJPG(srcImg)) &#123;</span><br><span class="line">      this.srcExif = new ExifInterface(srcImg);</span><br><span class="line">    &#125;</span><br><span class="line">    this.tagImg = tagImg;</span><br><span class="line">    this.srcImg = srcImg;</span><br><span class="line"></span><br><span class="line">    BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = true;</span><br><span class="line">    options.inSampleSize = 1;</span><br><span class="line"></span><br><span class="line">    BitmapFactory.decodeFile(srcImg, options);</span><br><span class="line">    this.srcWidth = options.outWidth;</span><br><span class="line">    this.srcHeight = options.outHeight;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这就又要说道另一个类了Engine类，它的类注释就是：用于操作，开始压缩，管理活动，缓存资源的类。他这里传原文件，也就是你需要压缩的图片，还有一个就是目标文件，也就是你压缩之后，要保存的文件。</p><p>&emsp;&emsp;我们先看第二个参数是什么怎么传的，有的人看不懂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Returns a mFile with a cache audio name in the private cache directory.</span><br><span class="line">   *</span><br><span class="line">   * @param context</span><br><span class="line">   *     A context.</span><br><span class="line">   */</span><br><span class="line">  private File getImageCacheFile(Context context, String suffix) &#123;</span><br><span class="line">    if (TextUtils.isEmpty(mTargetDir)) &#123;</span><br><span class="line">      mTargetDir = getImageCacheDir(context).getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String cacheBuilder = mTargetDir + &quot;/&quot; +</span><br><span class="line">        System.currentTimeMillis() +</span><br><span class="line">        (int) (Math.random() * 1000) +</span><br><span class="line">        (TextUtils.isEmpty(suffix) ? &quot;.jpg&quot; : suffix);</span><br><span class="line"></span><br><span class="line">    return new File(cacheBuilder);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;他这里就是新建一个文件，设置路径，设置名称，然后返回文件</p><p>&emsp;&emsp;再掉回去看Engine的构造方法，我们这里获取到了源文件和目标文件，我们只用把压缩后的流存到目标文件就行了。我之前写过一篇关于图片压缩的博客。它这里的option就是设置压缩的参数，不懂的可以看一下我之前的博客，或者用google百度一下就知道了。具体压缩就是用的bitmap的工厂类，调用的decodeFile方法。没错就是这一句 <strong><em>BitmapFactory.decodeFile(srcImg, options);</em></strong></p><p>最后，辣么一切都准备就绪了，怎么样开始压缩呢？<strong><em>compress()</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">File compress() throws IOException &#123;</span><br><span class="line">    BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">    options.inSampleSize = computeSize();</span><br><span class="line"></span><br><span class="line">    Bitmap tagBitmap = BitmapFactory.decodeFile(srcImg, options);</span><br><span class="line">    ByteArrayOutputStream stream = new ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">    tagBitmap = rotatingImage(tagBitmap);</span><br><span class="line">    tagBitmap.compress(Bitmap.CompressFormat.JPEG, 60, stream);</span><br><span class="line">    tagBitmap.recycle();</span><br><span class="line"></span><br><span class="line">    FileOutputStream fos = new FileOutputStream(tagImg);</span><br><span class="line">    fos.write(stream.toByteArray());</span><br><span class="line">    fos.flush();</span><br><span class="line">    fos.close();</span><br><span class="line">    stream.close();</span><br><span class="line"></span><br><span class="line">    return tagImg;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里面就是常规的压缩，存储的逻辑了，最最重要的压缩算法呢？就是这里的<strong><em>computeSize()</em></strong>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private int computeSize() &#123;</span><br><span class="line">    srcWidth = srcWidth % 2 == 1 ? srcWidth + 1 : srcWidth;</span><br><span class="line">    srcHeight = srcHeight % 2 == 1 ? srcHeight + 1 : srcHeight;</span><br><span class="line"></span><br><span class="line">    int longSide = Math.max(srcWidth, srcHeight);</span><br><span class="line">    int shortSide = Math.min(srcWidth, srcHeight);</span><br><span class="line"></span><br><span class="line">    float scale = ((float) shortSide / longSide);</span><br><span class="line">    if (scale &lt;= 1 &amp;&amp; scale &gt; 0.5625) &#123;</span><br><span class="line">      if (longSide &lt; 1664) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">      &#125; else if (longSide &gt;= 1664 &amp;&amp; longSide &lt; 4990) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">      &#125; else if (longSide &gt; 4990 &amp;&amp; longSide &lt; 10240) &#123;</span><br><span class="line">        return 4;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return longSide / 1280 == 0 ? 1 : longSide / 1280;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (scale &lt;= 0.5625 &amp;&amp; scale &gt; 0.5) &#123;</span><br><span class="line">      return longSide / 1280 == 0 ? 1 : longSide / 1280;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return (int) Math.ceil(longSide / (1280.0 / scale));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Bitmap rotatingImage(Bitmap bitmap) &#123;</span><br><span class="line">    if (srcExif == null) return bitmap;</span><br><span class="line"></span><br><span class="line">    Matrix matrix = new Matrix();</span><br><span class="line">    int angle = 0;</span><br><span class="line">    int orientation = srcExif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);</span><br><span class="line">    switch (orientation) &#123;</span><br><span class="line">      case ExifInterface.ORIENTATION_ROTATE_90:</span><br><span class="line">        angle = 90;</span><br><span class="line">        break;</span><br><span class="line">      case ExifInterface.ORIENTATION_ROTATE_180:</span><br><span class="line">        angle = 180;</span><br><span class="line">        break;</span><br><span class="line">      case ExifInterface.ORIENTATION_ROTATE_270:</span><br><span class="line">        angle = 270;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix.postRotate(angle);</span><br><span class="line"></span><br><span class="line">    return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;你以为我会一步一步给你讲<a href="https://github.com/Curzibn/Luban/blob/master/DESCRIPTION.md" target="_blank" rel="noopener">Luban算法逻辑</a>吗？那是不可能的，我特么都不会，怎么给你讲。我直接把他github上算法逻辑的介绍拷贝过来了：</p><ol><li>判断图片比例值，是否处于以下区间内；</li></ol><ul><li>[1, 0.5625) 即图片处于 [1:1 ~ 9:16) 比例范围内</li><li>[0.5625, 0.5) 即图片处于 [9:16 ~ 1:2) 比例范围内</li><li>[0.5, 0) 即图片处于 [1:2 ~ 1:∞) 比例范围内</li></ul><ol><li>判断图片最长边是否过边界值；</li></ol><ul><li>[1, 0.5625) 边界值为：1664 <em> n（n=1）, 4990 </em> n（n=2）, 1280 * pow(2, n-1)（n≥3）</li><li>[0.5625, 0.5) 边界值为：1280 * pow(2, n-1)（n≥1）</li><li>[0.5, 0) 边界值为：1280 * pow(2, n-1)（n≥1）</li></ul><ol><li>计算压缩图片实际边长值，以第2步计算结果为准，超过某个边界值则：width / pow(2, n-1)，height/pow(2, n-1)</li><li>计算压缩图片的实际文件大小，以第2、3步结果为准，图片比例越大则文件越大。<br>size = (newW <em> newH) / (width </em> height) * m；</li></ol><ul><li>[1, 0.5625) 则 width &amp; height 对应 1664，4990，1280 * n（n≥3），m 对应 150，300，300；</li><li>[0.5625, 0.5) 则 width = 1440，height = 2560, m = 200；</li><li>[0.5, 0) 则 width = 1280，height = 1280 / scale，m = 500；注：scale为比例值</li></ul><ol><li>判断第4步的size是否过小</li></ol><ul><li>[1, 0.5625) 则最小 size 对应 60，60，100</li><li>[0.5625, 0.5) 则最小 size 都为 100</li><li>[0.5, 0) 则最小 size 都为 100</li></ul><ol><li>将前面求到的值压缩图片 width, height, size 传入压缩流程，压缩图片直到满足以上数值</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Android让人头疼的OOM，造成OOM的原因之一就是图片，现在的手机像素越来越高，随便一张图片都是好几M，甚至几十M，这样的照片加载到app，可想而知，随便加载几张图片，手机内存就不够用了，自然而然就造成了OOM，所以，Android的图片压缩异常重要。这里，我推荐一款开源框架——&lt;a href=&quot;https://github.com/Curzibn/Luban&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Luban&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="http://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（八）—— 私有目录被限制访问(Android 7.0)</title>
    <link href="http://haichenyi.com/2018/03/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E7%A7%81%E6%9C%89%E7%9B%AE%E5%BD%95%E8%A2%AB%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE-Android7.0/"/>
    <id>http://haichenyi.com/2018/03/01/从零开始搭建一个主流项目框架（八）—私有目录被限制访问-Android7.0/</id>
    <published>2018-03-01T15:22:01.000Z</published>
    <updated>2018-03-07T12:21:15.505Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;我这里只说我关心的问题，并不是说Android 7.0只增加了一个“私有目录被限制访问”，当然还有其他的变化。android 7.0的新特性中，对程序员开发造成最直接的变化就是<strong>FileUriExposedException</strong>异常，这个异常的产生就是由<strong>私有目录被限制访问</strong>造成的</p><a id="more"></a><p>&emsp;&emsp;Andoird 7.0中为了提高文件的安全性，面向Android N或者更高版本的应用私有目录将会被禁止访问，常见最直接的bug就是：<strong>你的应用给其他应用传递file:// URI类型的Uri时，可能导致接受者无法访问该路径</strong>会造成我们前面说的文件uri异常。</p><h3 id="调用系统相机"><a href="#调用系统相机" class="headerlink" title="调用系统相机"></a>调用系统相机</h3><p>最直接的就是我们常用的拍照功能,我们自己的应用启动手机相机，这里手机相机就是其他应用，按照我们以前的写法就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);</span><br><span class="line">if (!file.getParentFile().exists())file.getParentFile().mkdirs();</span><br><span class="line">Uri imageUri = Uri.fromFile(file);</span><br><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);//设置Action为拍照</span><br><span class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);//将拍取的照片保存到指定URI</span><br><span class="line">startActivityForResult(intent,986);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;先创建一个存放我们拍照图片的存放file，参数就是路径+文件名称，当我们还是按之前的写法，跑在android N及以上的机型的时候，会报如下异常：</p><p>FileUriExposedException.png</p><p>&emsp;&emsp;这就是由于Android 7.0执行了“StrictMode API 政策禁”对我们广大程序员造成的最常见，最直接的结果。辣么，怎么解决呢？</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h4><p>使用FileProvider解决上面的问题，步骤如下：</p><h5 id="第一步：在清单文件里面申请provider"><a href="#第一步：在清单文件里面申请provider" class="headerlink" title="第一步：在清单文件里面申请provider"></a>第一步：在清单文件里面申请provider</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name=&quot;android.support.v4.content.FileProvider&quot;</span><br><span class="line">    android:authorities=&quot;com.haichenyi.myproject.fileprovider&quot;</span><br><span class="line">    android:grantUriPermissions=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;false&quot;&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;</span><br><span class="line">        android:resource=&quot;@xml/file_paths&quot; /&gt;</span><br><span class="line">&lt;/provider&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;FileProvider是V4包下面的类，这里exproted属性必须给false，不然也会报异常，grantUriPermissions的值给true，表示授予临时URI访问权限，下面meta-data就是指定共享目录，authorities属性后面讲</p><h4 id="第二步：指定共享目录"><a href="#第二步：指定共享目录" class="headerlink" title="第二步：指定共享目录"></a>第二步：指定共享目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;path&gt;</span><br><span class="line">        &lt;external-path</span><br><span class="line">            name=&quot;camera_photos&quot;</span><br><span class="line">            path=&quot;&quot;/&gt;</span><br><span class="line">    &lt;/path&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有点android开发基础的人就知道，这个@xml目录是位于res根目录，跟layout目录平级的。所以，你得先创建xml文件夹，然后新建file_paths文件，添加上面的代码在文件中。这里的path路径，我们先瞅瞅下面的表：</p><table><thead><tr><th style="text-align:center">物理路径</th><th style="text-align:center">写法</th></tr></thead><tbody><tr><td style="text-align:center">Context.getFilesDir() + /path/</td><td style="text-align:center"><strong><files-path name="name" path="path"></files-path></strong></td></tr><tr><td style="text-align:center">Context.getCacheDir() + /path/</td><td style="text-align:center"><strong><cache-path name="name" path="path"></cache-path></strong></td></tr><tr><td style="text-align:center">Environment.getExternalStorageDirectory() + /path/</td><td style="text-align:center"><strong><external-path name="name" path="path"></external-path></strong></td></tr><tr><td style="text-align:center">Context.getExternalFilesDir(String) + /path/</td><td style="text-align:center"><strong><external-files-path name="name" path="path"></external-files-path></strong></td></tr><tr><td style="text-align:center">Context.getExternalCacheDir() + /path/</td><td style="text-align:center"><strong><external-cache-path name="name" path="path"></external-cache-path></strong></td></tr></tbody></table><p>&emsp;&emsp;辣么，我们代码中path=””，是有特殊意义的，它代码根目录，也就是说你可以向其它的应用共享根目录及其子目录下任何一个文件了，如果你将path设为path=”pictures”， 那么它代表着根目录下的pictures目录(eg:/storage/emulated/0/pictures)，如果你向其它应用分享pictures目录范围之外的文件是不行的</p><h4 id="第三步：使用FileProvider"><a href="#第三步：使用FileProvider" class="headerlink" title="第三步：使用FileProvider"></a>第三步：使用FileProvider</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val file = File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot; + System.currentTimeMillis() + &quot;.jpg&quot;)</span><br><span class="line">        if (!file.parentFile.exists()) file.parentFile.mkdirs()</span><br><span class="line">        //变化</span><br><span class="line">        val imageUri = FileProvider.getUriForFile(this, &quot;com.haichenyi.myproject.fileprovider&quot;, file)//通过FileProvider创建一个content类型的Uri</span><br><span class="line">        val intent = Intent()</span><br><span class="line">        //变化</span><br><span class="line">        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION) //添加这一句表示对目标应用临时授权该Uri所代表的文件</span><br><span class="line">        intent.action = MediaStore.ACTION_IMAGE_CAPTURE//设置Action为拍照</span><br><span class="line">        intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri)//将拍取的照片保存到指定URI</span><br><span class="line">        startActivityForResult(intent, 986)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们调用系统相机的代码发生了变化，变化的位置，我都注明了获取imageUri的方式发生了变化，其中，第二个参数就是我们在前面说放在后面讲的authorities属性的内容，再就是增加了一个flag，表示临时授权。加上如上代码，我们就可以正常调用系统相机了。</p><p>&emsp;&emsp;经过如上步骤之后，我们就能拍照了，拍完照片之后的存放路径在哪里呢？我们前面说了，这里我打印出了路径，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file!!.absolutePath:/storage/emulated/0/temp/1519896174785.jpg</span><br><span class="line"></span><br><span class="line">imageUri:content://com.haichenyi.myproject.fileprovider/camera_photos/temp/1519896174785.jpg</span><br></pre></td></tr></table></figure><h3 id="照片裁剪"><a href="#照片裁剪" class="headerlink" title="照片裁剪"></a>照片裁剪</h3><p>Android 7.0之前，我们裁剪照片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);</span><br><span class="line">if (!file.getParentFile().exists())file.getParentFile().mkdirs();</span><br><span class="line">Uri outputUri = Uri.fromFile(file);</span><br><span class="line">Uri imageUri=Uri.fromFile(new File(&quot;/storage/emulated/0/temp/1519896174785.jpg&quot;));</span><br><span class="line">Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);</span><br><span class="line">intent.setDataAndType(imageUri, &quot;image/*&quot;);</span><br><span class="line">intent.putExtra(&quot;crop&quot;, &quot;true&quot;);</span><br><span class="line">intent.putExtra(&quot;aspectX&quot;, 1);</span><br><span class="line">intent.putExtra(&quot;aspectY&quot;, 1);</span><br><span class="line">intent.putExtra(&quot;scale&quot;, true);</span><br><span class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri);</span><br><span class="line">intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());</span><br><span class="line">intent.putExtra(&quot;noFaceDetection&quot;, true); // no face detection</span><br><span class="line">startActivityForResult(intent,987);</span><br></pre></td></tr></table></figure><p>Android 7.0之后，我们裁剪照片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">File file=new File(Environment.getExternalStorageDirectory(), &quot;/temp/&quot;+System.currentTimeMillis() + &quot;.jpg&quot;);</span><br><span class="line">if (!file.getParentFile().exists())file.getParentFile().mkdirs();</span><br><span class="line">Uri outputUri = FileProvider.getUriForFile(context, &quot;com.haichenyi.myproject.fileprovider&quot;,file);</span><br><span class="line">Uri imageUri=FileProvider.getUriForFile(context, &quot;com.haichenyi.myproject.fileprovider&quot;, new File(&quot;/storage/emulated/0/temp/1519896174785.jpg&quot;);//通过FileProvider创建一个content类型的Uri</span><br><span class="line">Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);</span><br><span class="line">intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">intent.setDataAndType(imageUri, &quot;image/*&quot;);</span><br><span class="line">intent.putExtra(&quot;crop&quot;, &quot;true&quot;);</span><br><span class="line">intent.putExtra(&quot;aspectX&quot;, 1);</span><br><span class="line">intent.putExtra(&quot;aspectY&quot;, 1);</span><br><span class="line">intent.putExtra(&quot;scale&quot;, true);</span><br><span class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri);</span><br><span class="line">intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString());</span><br><span class="line">intent.putExtra(&quot;noFaceDetection&quot;, true); // no face detection</span><br><span class="line">startActivityForResult(intent,987);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;拍照裁剪这是一个很常用的功能，很早之前就写过一篇，封装的不是很好。最近，又做了一遍这个功能，发现了一个好用的框架——<a href="https://github.com/crazycodeboy/TakePhoto" target="_blank" rel="noopener">TakePhoto</a></p><p><a href="http://download.csdn.net/download/qq_27634797/10265743" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;我这里只说我关心的问题，并不是说Android 7.0只增加了一个“私有目录被限制访问”，当然还有其他的变化。android 7.0的新特性中，对程序员开发造成最直接的变化就是&lt;strong&gt;FileUriExposedException&lt;/strong&gt;异常，这个异常的产生就是由&lt;strong&gt;私有目录被限制访问&lt;/strong&gt;造成的&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（七）—— 权限申请(Android 6.0)</title>
    <link href="http://haichenyi.com/2018/03/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7-Android6.0/"/>
    <id>http://haichenyi.com/2018/03/01/从零开始搭建一个主流项目框架（七）—权限申请-Android6.0/</id>
    <published>2018-03-01T15:21:35.000Z</published>
    <updated>2018-03-01T15:30:26.841Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;总所周知，Android 6.0以上的版本，google对权限做了更严格的限制，不能app自动给权限，必须要让用户选择是否给权限。如果，用户不给权限，辣么，用这个功能的时候，app会造成崩溃，所以，最简单的办法就是，用户不给权限，不让用户用这个功能，也就是页面不做跳转。</p><a id="more"></a><p>&emsp;&emsp;当时，刚出来这个权限问题的时候，本人用原生的写，写了封装，搞了好长时间，总感觉各种不爽，各种不舒服，后来好了，大牛封装了一个开源框架——<a href="https://github.com/tbruyelle/RxPermissions" target="_blank" rel="noopener">RxPermission</a>，一行代码解决动态申请权限问题。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar&apos;</span><br></pre></td></tr></table></figure><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.utils</span><br><span class="line"></span><br><span class="line">import android.app.Activity</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.net.Uri</span><br><span class="line">import android.os.Build</span><br><span class="line">import android.os.Environment</span><br><span class="line">import android.provider.Settings</span><br><span class="line">import android.support.v7.app.AlertDialog</span><br><span class="line">import com.haichenyi.myproject.R</span><br><span class="line">import com.tbruyelle.rxpermissions2.RxPermissions</span><br><span class="line">import java.io.File</span><br><span class="line">import java.io.FileInputStream</span><br><span class="line">import java.io.IOException</span><br><span class="line">import java.util.*</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/28</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">object RxPerUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 请求权限的获取方法</span><br><span class="line">     * activity：Activity对象</span><br><span class="line">     * permissions：需要获取的权限，可以传多个</span><br><span class="line">     * aloe: (b: Boolean)：一个参数的回调方法，b为true，表示用户给了权限，false，表示没有给权限</span><br><span class="line">     */</span><br><span class="line">    fun requestPermission(activity: Activity, vararg permissions: String, aloe: (b: Boolean) -&gt; Unit) &#123;</span><br><span class="line">        RxPermissions(activity).request(*permissions)</span><br><span class="line">                .subscribe &#123; aBoolean -&gt; aloe(aBoolean) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 当用户拒绝给权限的时候调用，跳转权限设置页面，让用户手动给权限</span><br><span class="line">     * activity：Activity对象</span><br><span class="line">     * permissionName：权限名称</span><br><span class="line">     * msg：提示信息</span><br><span class="line">     */</span><br><span class="line">    fun setupPermission(activity: Activity, permissionName: String, msg: String,</span><br><span class="line">                        aloe: () -&gt; Unit) &#123;</span><br><span class="line">        AlertDialog.Builder(activity, R.style.Theme_AppCompat_Dialog).setTitle(&quot;权限申请&quot;)</span><br><span class="line">                .setMessage(String.format(Locale.getDefault(),</span><br><span class="line">                        &quot;请在“权限”中开启“%1s权限”，以正常使用%2s&quot;, permissionName, msg))</span><br><span class="line">                .setCancelable(false)</span><br><span class="line">                .setNegativeButton(android.R.string.cancel) &#123; dialog, which -&gt; aloe &#125;.setPositiveButton(&quot;去设置&quot;) &#123; dialog, which -&gt;</span><br><span class="line">            if (isMiUi()) &#123;</span><br><span class="line">                setMiUiPermissions(activity)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                activity.startActivityForResult(Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)</span><br><span class="line">                        .setData(Uri.fromParts(&quot;package&quot;, activity.packageName, null)), 1000)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.create().show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun setMiUiPermissions(activity: Activity) &#123;</span><br><span class="line">        if (isMiUi()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // MIUI 8</span><br><span class="line">                activity.startActivityForResult(Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;)</span><br><span class="line">                        .setClassName(&quot;com.miui.securitycenter&quot;,</span><br><span class="line">                                &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;)</span><br><span class="line">                        .putExtra(&quot;extra_pkgname&quot;, activity.packageName), 1000)</span><br><span class="line">            &#125; catch (e: Exception) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // MIUI 5/6/7</span><br><span class="line">                    activity.startActivityForResult(Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;)</span><br><span class="line">                            .setClassName(&quot;com.miui.securitycenter&quot;,</span><br><span class="line">                                    &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;)</span><br><span class="line">                            .putExtra(&quot;extra_pkgname&quot;, activity.packageName), 1000)</span><br><span class="line">                &#125; catch (e1: Exception) &#123;</span><br><span class="line">                    // 否则跳转到应用详情</span><br><span class="line">                    activity.startActivityForResult(Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)</span><br><span class="line">                            .setData(Uri.fromParts(&quot;package&quot;, activity.packageName,</span><br><span class="line">                                    null)), 1000)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun isMiUi(): Boolean &#123;</span><br><span class="line">        val device = Build.MANUFACTURER</span><br><span class="line">        if (device == &quot;Xiaomi&quot;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                val prop = Properties()</span><br><span class="line">                prop.load(FileInputStream(File(Environment.getRootDirectory(), &quot;build.prop&quot;)))</span><br><span class="line">                return (prop.getProperty(&quot;ro.miui.ui.version.code&quot;, null) != null</span><br><span class="line">                        || prop.getProperty(&quot;ro.miui.ui.version.name&quot;, null) != null</span><br><span class="line">                        || prop.getProperty(&quot;ro.miui.internal.storage&quot;, null) != null)</span><br><span class="line">            &#125; catch (e: IOException) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RxPerUtils.requestPermission(this, Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE) &#123;</span><br><span class="line">                if (it) &#123;</span><br><span class="line">                    //这里写你自己的逻辑，已经获得权限，做你自己的业务逻辑操作</span><br><span class="line">                    ToastUtils.showTipMsg(&quot;已经获得权限&quot;)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    RxPerUtils.setupPermission(this, &quot;相机和存储&quot;,</span><br><span class="line">                            &quot;相机功能&quot;) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;请求权限的整个过程就是：</p><ol><li>用RxPermission去请求权限，需要传activity对象,然后就是你需要获取的权限（可以传多个），再就是回调方法</li><li>在回调方法里面做判断，用户是否给了权限，如果给了，就走你正常的逻辑。如果没有给，就弹对话框提示用户，去设置页面给权限。</li></ol><p>&emsp;&emsp;就这么简单，方法都封装好了，如果，你嫌弃系统自带的对话框样式不好看，你也可以自己写一个样式。项目就不传了，如果你有之前的代码，就直接把我这几个方法拷贝过去用就可以了，没有之前的代码，就去瞅瞅之前的博客吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;总所周知，Android 6.0以上的版本，google对权限做了更严格的限制，不能app自动给权限，必须要让用户选择是否给权限。如果，用户不给权限，辣么，用这个功能的时候，app会造成崩溃，所以，最简单的办法就是，用户不给权限，不让用户用这个功能，也就是页面不做跳转。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（六）——Socket网络编程</title>
    <link href="http://haichenyi.com/2018/02/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://haichenyi.com/2018/02/26/从零开始搭建一个主流项目框架（六）—Socket网络编程/</id>
    <published>2018-02-26T14:02:22.000Z</published>
    <updated>2018-02-26T14:03:53.771Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Android中常用的网络编程方式：Http和Socket，Http通讯方式，我们在前面已经加到框架里面了，用的是现在主流的RxJava+Retrofit+OkHttp的方式，用起来也很方便。今天，我们来说说Socket网络编程。前面已经有一篇讲过IO和NIO的区别，还有一篇讲过Netty了，今天这篇的目的就是把Netty加到我们这个框架里面。</p><a id="more"></a><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;io.netty:netty-all:5.0.0.Alpha2&apos;</span><br></pre></td></tr></table></figure><p>添加依赖，老生常谈的问题了，我就不多说了。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import android.util.Log</span><br><span class="line">import com.haichenyi.myproject.model.bean.SocketTcpBean</span><br><span class="line">import io.netty.bootstrap.Bootstrap</span><br><span class="line">import io.netty.channel.Channel</span><br><span class="line">import io.netty.channel.ChannelInitializer</span><br><span class="line">import io.netty.channel.ChannelOption</span><br><span class="line">import io.netty.channel.EventLoopGroup</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup</span><br><span class="line">import io.netty.channel.socket.SocketChannel</span><br><span class="line">import io.netty.channel.socket.nio.NioSocketChannel</span><br><span class="line">import io.netty.handler.codec.LineBasedFrameDecoder</span><br><span class="line">import io.netty.handler.codec.string.StringDecoder</span><br><span class="line">import io.netty.handler.codec.string.StringEncoder</span><br><span class="line">import io.netty.util.CharsetUtil</span><br><span class="line">import org.greenrobot.eventbus.EventBus</span><br><span class="line">import org.greenrobot.eventbus.Subscribe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/26</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">class SocketTcp &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private val socket = SocketTcp()</span><br><span class="line">        fun getInstance(): SocketTcp = socket</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private var port: Int = 0</span><br><span class="line">    private var host: String = &quot;&quot;</span><br><span class="line">    private var channel: Channel? = null</span><br><span class="line">    private var group: EventLoopGroup? = null</span><br><span class="line">    fun setPort(port: Int): SocketTcp &#123;</span><br><span class="line">        this.port = port</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun setHost(host: String): SocketTcp &#123;</span><br><span class="line">        this.host = host</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun connect() &#123;</span><br><span class="line">        if (null != channel) return</span><br><span class="line">        if (null == group) &#123;</span><br><span class="line">            if (!EventBus.getDefault().isRegistered(this))</span><br><span class="line">                EventBus.getDefault().register(this)</span><br><span class="line">            group = NioEventLoopGroup()</span><br><span class="line">        &#125;</span><br><span class="line">        val bootstrap = Bootstrap()</span><br><span class="line">        try &#123;</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel::class.java)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">                    .handler(object : ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        override fun initChannel(ch: SocketChannel?) &#123;</span><br><span class="line">                            //以换行符为结束标记</span><br><span class="line">                            val pipeline = ch!!.pipeline()</span><br><span class="line">                            pipeline.addLast(&quot;encoder&quot;, StringEncoder(CharsetUtil.UTF_8))</span><br><span class="line">                            pipeline.addLast(LineBasedFrameDecoder(Integer.MAX_VALUE))</span><br><span class="line">                            pipeline.addLast(StringDecoder())</span><br><span class="line">                            pipeline.addLast(HeartTcp())</span><br><span class="line"></span><br><span class="line">                            //以&quot;#_&quot;作为分隔符</span><br><span class="line">                            /*val pipeline = ch!!.pipeline()</span><br><span class="line">                            pipeline.addLast(&quot;encoder&quot;, StringEncoder(CharsetUtil.UTF_8))</span><br><span class="line">                            val s = &quot;#_&quot;</span><br><span class="line">                            val byteBuf = Unpooled.copiedBuffer(s.toByteArray())</span><br><span class="line">                            pipeline.addLast(DelimiterBasedFrameDecoder(Integer.MAX_VALUE, byteBuf))</span><br><span class="line">                            pipeline.addLast(StringDecoder())*/</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            //发起异步连接操作</span><br><span class="line">            val channelFuture = bootstrap.connect(host, port).sync()</span><br><span class="line">            channel = channelFuture.channel()</span><br><span class="line">            //等待服务端监听端口关闭</span><br><span class="line">            channel!!.closeFuture().sync()</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            disConnect()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //连接成功后，通过Channel提供的接口进行IO操作</span><br><span class="line">    fun sendMessage(msg: String) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (channel != null &amp;&amp; channel!!.isOpen) &#123;</span><br><span class="line">                channel!!.writeAndFlush(msg).sync()</span><br><span class="line">                Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw Exception(&quot;channel is null | closed&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            reConnect()</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 断开tcp连接.</span><br><span class="line">     */</span><br><span class="line">    private fun disConnect() &#123;</span><br><span class="line">        if (null != group) &#123;</span><br><span class="line">            group!!.shutdownGracefully()</span><br><span class="line">        &#125;</span><br><span class="line">//        EventBus.getDefault().unregister(this)</span><br><span class="line">        group = null</span><br><span class="line">        channel = null</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;disConnect&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Subscribe</span><br><span class="line">    fun handle(socketTcpBean: SocketTcpBean) &#123;</span><br><span class="line">        sendMessage(socketTcpBean.msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重连.</span><br><span class="line">     */</span><br><span class="line">    private fun reConnect() &#123;</span><br><span class="line">        Thread(Runnable &#123; this.connect() &#125;).start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import android.os.SystemClock</span><br><span class="line">import android.util.Log</span><br><span class="line">import io.netty.buffer.Unpooled</span><br><span class="line">import io.netty.channel.ChannelHandlerContext</span><br><span class="line">import io.netty.channel.SimpleChannelInboundHandler</span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HeartTcp : SimpleChannelInboundHandler&lt;Any&gt;() &#123;</span><br><span class="line">    private var ctx: ChannelHandlerContext? = null</span><br><span class="line">    private var isConnect = false</span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun channelActive(ctx: ChannelHandlerContext) &#123;</span><br><span class="line">        super.channelActive(ctx)</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;)</span><br><span class="line">        isConnect = true</span><br><span class="line">        if (this.ctx == null) &#123;</span><br><span class="line">            synchronized(HeartTcp::class.java) &#123;</span><br><span class="line">                if (this.ctx == null) &#123;</span><br><span class="line">                    this.ctx = ctx</span><br><span class="line">                    myAppHeart()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun myAppHeart() &#123;</span><br><span class="line">        Thread &#123;</span><br><span class="line">            while (ctx != null &amp;&amp; isConnect) &#123;</span><br><span class="line">                val data = &quot;123&quot;</span><br><span class="line">                val bytes = data.toByteArray()</span><br><span class="line">                if (isConnect) &#123;</span><br><span class="line">                    ctx!!.writeAndFlush(Unpooled.buffer(bytes.size).writeBytes(bytes))</span><br><span class="line">                    SystemClock.sleep(3000)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun channelInactive(ctx: ChannelHandlerContext) &#123;</span><br><span class="line">        val loop = ctx.channel().eventLoop()</span><br><span class="line">        loop.schedule(&#123; SocketTcp.getInstance().connect() &#125;, 5, TimeUnit.SECONDS)</span><br><span class="line">        super.channelInactive(ctx)</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;)</span><br><span class="line">        isConnect = false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun userEventTriggered(ctx: ChannelHandlerContext, evt: Any) &#123;</span><br><span class="line">        super.userEventTriggered(ctx, evt)</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun exceptionCaught(ctx: ChannelHandlerContext, cause: Throwable) &#123;</span><br><span class="line">        super.exceptionCaught(ctx, cause)</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;)</span><br><span class="line">        this.ctx = null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(Exception::class)</span><br><span class="line">    override fun messageReceived(ctx: ChannelHandlerContext, msg: Any) &#123;</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;)</span><br><span class="line">        /*val msg1 = msg</span><br><span class="line">        val bytes = ByteArray(msg1.readableBytes())</span><br><span class="line">        msg1.readBytes(bytes)</span><br><span class="line">        val s = String(bytes*//*, &quot;UTF-8&quot;*//*)*/</span><br><span class="line">        val s = msg.toString()</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我这里就是把我前面那个讲Netty创建Socket连接的代码拷贝过来转成了kotlin代码，这里我就不做过多的解释了。</p><p>&emsp;&emsp;一般，我们都是后台新开一个服务去启动socket，所以，我们还要创建一个Service，去处理socket。我这里就是非绑定启动这个服务。在oncreate方法里面去连接服务器即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import android.app.Service</span><br><span class="line">import android.content.Intent</span><br><span class="line">import android.os.IBinder</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/26</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">class SocketService : Service() &#123;</span><br><span class="line">    override fun onBind(intent: Intent?): IBinder? &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">        Thread(Runnable &#123; SocketTcp.getInstance().setPort(8080).setHost(&quot;192.168.0.235&quot;).connect() &#125;).start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之所以要新建一个服务，就是可能你在连接socket的时候，可能要做一些其他信息的初始化，而这些信息初始化也是只有在连接socket服务器之前才需要的，写在这里方便一起管理，要是写在activity里面不便于管理。上面都是扯淡，最主要的是我们在最初学Android的时候，教你们的老师应该讲过，什么时候需要用到服务，就是不需要页面，用户并不关心它长什么样子，需要长连接的任务，都放在服务里面。正好，socket连接正好满足这些条件。</p><p>&emsp;&emsp;细心的同学可能注意了，我在Tcp类里面有一个EventBus，我这里是把发TCP消息给拿出来了，便于管理。我这边还新建了一个SocketUtils类，就是处理Socket请求的方法，我们发消息之类的方法，都是调用SocketUtils类里面的方法，不用去改Tcp类。这样做就只有一个目的，就是便于统一管理，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.model.bean.SocketTcpBean</span><br><span class="line">import org.greenrobot.eventbus.EventBus</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/26</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">object SocketUtils &#123;</span><br><span class="line">    fun sendTcpMsg(msg: String) &#123;</span><br><span class="line">        sendTcpMsg(SocketTcpBean(msg))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun sendTcpMsg(socketTcpBean: SocketTcpBean) &#123;</span><br><span class="line">        EventBus.getDefault().post(socketTcpBean)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至于这个SocketTcpBean类，就是一个普通的java bean类，里面就只有一个参数msg，你需要发的消息</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>我先给出来代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import android.util.Log</span><br><span class="line">import com.haichenyi.myproject.model.bean.SocketUdpBean</span><br><span class="line">import io.netty.bootstrap.Bootstrap</span><br><span class="line">import io.netty.buffer.Unpooled</span><br><span class="line">import io.netty.channel.Channel</span><br><span class="line">import io.netty.channel.ChannelOption</span><br><span class="line">import io.netty.channel.EventLoopGroup</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup</span><br><span class="line">import io.netty.channel.socket.DatagramPacket</span><br><span class="line">import io.netty.channel.socket.nio.NioDatagramChannel</span><br><span class="line">import org.greenrobot.eventbus.EventBus</span><br><span class="line">import org.greenrobot.eventbus.Subscribe</span><br><span class="line">import java.net.InetSocketAddress</span><br><span class="line">import java.nio.charset.Charset</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/26</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">class SocketUdp &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private val socket = SocketUdp()</span><br><span class="line">        fun getInstance(): SocketUdp = socket</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private var port: Int = 0</span><br><span class="line">    private var channel: Channel? = null</span><br><span class="line">    private var group: EventLoopGroup? = null</span><br><span class="line"></span><br><span class="line">    fun setPort(port: Int): SocketUdp &#123;</span><br><span class="line">        this.port = port</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun connect() &#123;</span><br><span class="line">        if (null != channel) return</span><br><span class="line">        if (null == group) &#123;</span><br><span class="line">            if (!EventBus.getDefault().isRegistered(this))</span><br><span class="line">                EventBus.getDefault().register(this)</span><br><span class="line">            group = NioEventLoopGroup()</span><br><span class="line">        &#125;</span><br><span class="line">        val bootstrap = Bootstrap()</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioDatagramChannel::class.java)</span><br><span class="line">                .option(ChannelOption.SO_BROADCAST, true)</span><br><span class="line">                .handler(UdpHandler())</span><br><span class="line">        try &#123;</span><br><span class="line">            channel = bootstrap.bind(port).sync().channel()</span><br><span class="line">            channel!!.closeFuture().sync()</span><br><span class="line">        &#125; catch (e: InterruptedException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            disConnect()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 断开tcp连接.</span><br><span class="line">     */</span><br><span class="line">    private fun disConnect() &#123;</span><br><span class="line">        if (null != group) &#123;</span><br><span class="line">            group!!.shutdownGracefully()</span><br><span class="line">        &#125;</span><br><span class="line">//        EventBus.getDefault().unregister(this)</span><br><span class="line">        group = null</span><br><span class="line">        channel = null</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;disConnect&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //连接成功后，通过Channel提供的接口进行IO操作</span><br><span class="line">    private fun sendMessage(host: String, port: Int, data: ByteArray) &#123;</span><br><span class="line">        val packet = DatagramPacket(Unpooled.copiedBuffer(data),</span><br><span class="line">                InetSocketAddress(host, port))</span><br><span class="line">        channel?.let &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                it.writeAndFlush(packet).sync()</span><br><span class="line">                Log.d(&quot;wz&quot;, &quot;send succeed &quot; + String(data, Charset.forName(&quot;UTF-8&quot;)))</span><br><span class="line">            &#125; catch (e: Exception) &#123;</span><br><span class="line">                reConnect()</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Subscribe</span><br><span class="line">    fun handle(socketUdpBean: SocketUdpBean) &#123;</span><br><span class="line">        sendMessage(socketUdpBean.host,socketUdpBean.port,socketUdpBean.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重连.</span><br><span class="line">     */</span><br><span class="line">    private fun reConnect() &#123;</span><br><span class="line">        Thread(Runnable &#123; this.connect() &#125;).start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.socket</span><br><span class="line"></span><br><span class="line">import android.util.Log</span><br><span class="line">import io.netty.channel.ChannelHandlerContext</span><br><span class="line">import io.netty.channel.SimpleChannelInboundHandler</span><br><span class="line">import io.netty.channel.socket.DatagramPacket</span><br><span class="line">import java.nio.charset.Charset</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/26</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">class UdpHandler : SimpleChannelInboundHandler&lt;DatagramPacket&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    override fun messageReceived(ctx: ChannelHandlerContext?, msg: DatagramPacket?) &#123;</span><br><span class="line">        val byteBuf = msg!!.content()</span><br><span class="line">        val bytes = ByteArray(byteBuf.readableBytes())</span><br><span class="line">        byteBuf.readBytes(bytes)</span><br><span class="line">        val s = String(bytes, Charset.forName(&quot;UTF-8&quot;))</span><br><span class="line">        Log.v(&quot;WZ&quot;, &quot;UDP收到的消息是--&gt;$s&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的代码跟TCP类似，我想说的就只有三点：</p><ol><li>首先你客户端开启UDP的时候，需要bind一个端口号，这个端口号是服务器给你发消息的时候，需要的端口号。</li><li>它的管道里面的handle类型DatagramPacket</li><li>再有就是给目标主机发消息，UDP需要传目标地址，端口号，还有消息。这里的目标地址就是服务器的地址，端口号就是服务器跟你通信的端口号，消息就是你需要发送给服务器的信息</li></ol><p>&emsp;&emsp;其实，这里的区别就是TCP与UDP的区别，TCP和UDP什么区别呢？</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">TCP</th><th style="text-align:center">UDP</th></tr></thead><tbody><tr><td style="text-align:center">是否连接</td><td style="text-align:center">面向连接</td><td style="text-align:center">面向非连接</td></tr><tr><td style="text-align:center">传输效率</td><td style="text-align:center">慢</td><td style="text-align:center">快</td></tr><tr><td style="text-align:center">数据是否有序</td><td style="text-align:center">有序</td><td style="text-align:center">无序</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">安全</td><td style="text-align:center">不安全</td></tr><tr><td style="text-align:center">模式</td><td style="text-align:center">流模式</td><td style="text-align:center">报文模式</td></tr><tr><td style="text-align:center">系统资源</td><td style="text-align:center">多</td><td style="text-align:center">少</td></tr></tbody></table><p>区别的总结：最典型的对比就是打电话（TCP）和发短信（UDP）的区别</p><ol><li>是否连接方面，TCP是1对1，UDP可以1对N</li><li>传输效率：TCP必须等到一个消息全部传完了才能传下一个，UDP可以一直发</li><li>数据是否有序：TCP是按顺序一条一条的发，当然是有序的。UDP则是无序的</li><li>安全性方面：TCP有3次握手机制，采用的全双工的可靠信道，保证了数据的安全，UDP则没有3次握手机制，采用的是不可靠信道</li><li>模式方面：TCP是面向字节流，实际上TCP把数据看成了一连串无结构的字节流，UDP则是面向报文的</li><li>系统资源方面：TCP首部开销20个字节，UDP首部开销8个字节</li></ol><p><a href="http://download.csdn.net/download/qq_27634797/10260329" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Android中常用的网络编程方式：Http和Socket，Http通讯方式，我们在前面已经加到框架里面了，用的是现在主流的RxJava+Retrofit+OkHttp的方式，用起来也很方便。今天，我们来说说Socket网络编程。前面已经有一篇讲过IO和NIO的区别，还有一篇讲过Netty了，今天这篇的目的就是把Netty加到我们这个框架里面。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（五）—GreenDao的增删改查</title>
    <link href="http://haichenyi.com/2018/02/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94GreenDao%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>http://haichenyi.com/2018/02/24/从零开始搭建一个主流项目框架（五）—GreenDao的增删改查/</id>
    <published>2018-02-24T13:17:55.000Z</published>
    <updated>2018-02-24T13:20:09.619Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇我们讲了GreenDao的数据库的依赖和创建，这一篇，我们来讲常用的增删改查四种方法。我们操作数据库都是Dao层，不同的表，有不懂的Dao层对象。我们上一篇的数据库接口的实现类里面，我们定义了UserDao，我们这一篇讲的就是操作我们昨天创建的user表。</p><a id="more"></a><p>&emsp;&emsp;在写下面几个方法之前，我还是先把MVP的用法先讲一遍吧，防止有人不知道，以增操作为例，另外三个就不再讲了：</p><ol><li><p>点击页面的增按钮，我们要调用P层的方法去做增操作。效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-8b4f3073de1af3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增1.png"></p></li><li><p>P层的方法从哪来呢？P层实现的接口来撒，所以，我们只用在接口定义对应的方法，在P层去实现，效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-0d7bc09082e64fa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增2.png"></p></li><li><p>辣么，具体实现代码怎么写呢？既不记得，我们的装饰者模式，我们P层里面有一个DataHelper对象，通过它去调用对应的方法就可以了，效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-85447db350c369a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增3.png"></p></li><li><p>接下来，datahelper的方法又是从哪里来呢？我们的DataHelper是不是实现了SqlHelper接口，所以，直接在SqlHelper定义方法，在datahelper实现即可，效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-58575c3a7edb7ebc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增4.png"></p></li><li><p>最后，前面只是调用了，具体实现在哪里呢？我之前有没有讲过装饰者模式，一个接口，两个实现方法，对，没错，就是在SqlImpl方法里面实现，效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-70f33a5a63a304fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增5.png"></p></li></ol><p>&emsp;&emsp;通过以上5步，就完成我们的增操作。有同鞋就会问，那参数怎么传？我特么怎么知道需要传什么传输，你这个方法是干什么的，调用这个方法需要什么数据，你就丢在参数里面传过去，即可。</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//插入单个对象</span><br><span class="line">userDao.insert(user);</span><br><span class="line"></span><br><span class="line">//插入一个list</span><br><span class="line">userDao.insertInTx(users);</span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//basePresenter.onAdd(User(&quot;小红&quot;, 1, 165, &quot;50KG&quot;, 18))</span><br><span class="line">val dataList = mutableListOf&lt;User&gt;()</span><br><span class="line">dataList.add(User(&quot;小刚&quot;, 2, 175, &quot;60KG&quot;, 28))</span><br><span class="line">dataList.add(User(&quot;小东&quot;, 2, 185, &quot;65KG&quot;, 25))</span><br><span class="line">basePresenter.onAddList(dataList)</span><br></pre></td></tr></table></figure><p>效果图我就不贴出来了，如果，你的效果出不来，就肯定是你的代码写的有问题，我写这个博客都是边写代码，边写博客，我这边肯定是没问题的。</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查询单个对象</span><br><span class="line">userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();</span><br><span class="line">//查询一个list</span><br><span class="line">userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list();</span><br></pre></td></tr></table></figure><h4 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val user = basePresenter.onSelect(&quot;小红&quot;)</span><br><span class="line">println(user.name)</span><br><span class="line">val users = basePresenter.onSelectList(&quot;小东&quot;)</span><br><span class="line"> users.forEach &#123;</span><br><span class="line">     println(it.name)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里，我需要做一点说明，那就是手动能力强的宝宝，看见有两个查询方法，一个查询一个对象，一个查询list，这两个方法没问题，查询肯定是查询的一个，list里面也是只有一个对象，就有宝宝想着多插入几条数据，这个时候，项目就可能崩掉，因为，你插入的名字是相同的，我们这里名字是作为主键，表里面主键是不能相同的，所以就崩掉了，所以，你就得改表结构，正好测试我们之前说的版本更新问题，我这里亲测可用，数据也不会丢失。步骤如下：</p><ol><li>修改数据库版本，把1改成2</li><li>User bean里面增加一个字段id Long类型，递增即可，clean，build项目</li><li>在你的Activity里面会报错，因为，你User的构造方法里面新增了一个参数，辣么这里你用的时候参数个数都不对，肯定报错，你把id字段对应的参数传null即可，他自己递增。这里也只有Long类型可以传null</li><li>重新运行项目，没有问题</li></ol><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*//通过主键删除一个对象，删除满足条件的第一个对象</span><br><span class="line">    User user1 = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();</span><br><span class="line">    //一定要记得做非空判断</span><br><span class="line">    if (user1 != null) &#123;</span><br><span class="line">      userDao.deleteByKey(user1.getId());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;);</span><br><span class="line">    &#125;*/</span><br><span class="line"></span><br><span class="line">    //通过主键删除一个满足条件的List</span><br><span class="line">    List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().list();</span><br><span class="line">    if (list.size() &gt; 0) &#123;</span><br><span class="line">      List&lt;Long&gt; keys = new ArrayList&lt;&gt;();</span><br><span class="line">      for (User user : list) &#123;</span><br><span class="line">        keys.add(user.getId());</span><br><span class="line">      &#125;</span><br><span class="line">      userDao.deleteByKeyInTx(keys);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ToastUtils.Companion.showTipMsg(&quot;为查询到相关数据&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="调用-2"><a href="#调用-2" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//basePresenter.onDelete(&quot;小红&quot;)</span><br><span class="line">basePresenter.onDelete(&quot;小东&quot;)</span><br></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = userDao.queryBuilder().where(UserDao.Properties.Name.eq(oldName)).build().list();</span><br><span class="line">    if (list.size() &gt; 0) &#123;</span><br><span class="line">      for (User user : list) &#123;</span><br><span class="line">        user.setName(newName);</span><br><span class="line">      &#125;</span><br><span class="line">//      userDao.update(user1);</span><br><span class="line">      userDao.updateInTx(list);</span><br><span class="line">      ToastUtils.Companion.showTipMsg(&quot;修改成功&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ToastUtils.Companion.showTipMsg(&quot;未查询到相关数据&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="调用-3"><a href="#调用-3" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basePresenter.onUpdate(&quot;小刚&quot;, &quot;小贝&quot;)</span><br></pre></td></tr></table></figure><p>完了，数据库的简单的增删改查</p><p><a href="http://download.csdn.net/download/qq_27634797/10257729" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇我们讲了GreenDao的数据库的依赖和创建，这一篇，我们来讲常用的增删改查四种方法。我们操作数据库都是Dao层，不同的表，有不懂的Dao层对象。我们上一篇的数据库接口的实现类里面，我们定义了UserDao，我们这一篇讲的就是操作我们昨天创建的user表。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（四）—Kotlin+GreenDao3.2</title>
    <link href="http://haichenyi.com/2018/02/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94Kotlin-GreenDao3-2/"/>
    <id>http://haichenyi.com/2018/02/24/从零开始搭建一个主流项目框架（四）—Kotlin-GreenDao3-2/</id>
    <published>2018-02-24T13:16:34.000Z</published>
    <updated>2018-02-24T13:19:17.773Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本篇介绍android常用的数据库之一<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">GreenDao</a>的简单用法，增删改查。基于前面搭的框架，当然，你也可以选择不用。看懂用法之后，用起来很方便。GreenDao数据库升级到3.0版本之后api用起来更加方便了，便于让开发人员专注于业务逻辑。我需要额外说明的是，我把之前的项目框架转成了<a href="http://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">kotlin</a>，不会<a href="http://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">kotlin</a>语法的同学，可以去研究一下。</p><a id="more"></a><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>最终，我们要添加如下代码，效果图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-a6b08f6861b1e514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化数据库.png"></p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>&emsp;&emsp;打开的你根目录下面的build.gradle文件，也就是项目下面的，并不是app目录下面的build.gradle。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// In your root build.gradle file:</span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        ...//其他你自己的</span><br><span class="line">        mavenCentral() // add repository</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.0.0&apos;</span><br><span class="line">        ...//其他你自己的</span><br><span class="line">        classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>&emsp;&emsp;打开你的项目下面的build.gradle文件，也就是你的app目录下面的，之前我们添加依赖的时候的那个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// In your app projects build.gradle file:</span><br><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.greenrobot:greendao:3.2.2&apos; // add library</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;完成上面两步，辣么，关于greendao的依赖我们就添加完成了</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>&emsp;&emsp;我们首先得有一个bean类，这个bean类对应的就是数据库表的表结构。我这里想说明的是（敲黑板了），<strong>看到了很多网上说的什么主键id必须用Long类型，这种说法是不准确的，准确的说，你的主键字段名称，如果是“id”，辣么，你这个字段“id”，必须用Long类型，如果你换一个名称，比方说“myId”，辣么，你就不必用Long类型</strong>，这个问题，说大不大，说小，又困扰了我有一会。我这里新建用户表，就需要一个User的java bean类。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.bean;</span><br><span class="line"></span><br><span class="line">import org.greenrobot.greendao.annotation.Entity;</span><br><span class="line">import org.greenrobot.greendao.annotation.Id;</span><br><span class="line">import org.greenrobot.greendao.annotation.NotNull;</span><br><span class="line">import org.greenrobot.greendao.annotation.Property;</span><br><span class="line">import org.greenrobot.greendao.annotation.Transient;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc: 用户表的bean类</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class User &#123;</span><br><span class="line">  @Id</span><br><span class="line">  private String name;</span><br><span class="line">  private int sex;</span><br><span class="line">  @Property(nameInDb = &quot;Height&quot;)</span><br><span class="line">  private int height;</span><br><span class="line">  private String weight;</span><br><span class="line">  @NotNull</span><br><span class="line">  private int age;</span><br><span class="line">  @Transient</span><br><span class="line">  private String character;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我把几个常用的注解都写出来了，说一下这几个注解是什么意思</p><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">@Entity</td><td style="text-align:center">用于标识这是一个需要Greendao帮我们生成代码的bean</td></tr><tr><td style="text-align:center">@Id</td><td style="text-align:center">标明主键，括号里可以指定是否自增</td></tr><tr><td style="text-align:center">@Property</td><td style="text-align:center">用于设置属性在数据库中的列名（默认不写就是保持一致）</td></tr><tr><td style="text-align:center">@NotNull</td><td style="text-align:center">非空</td></tr><tr><td style="text-align:center">@Transient</td><td style="text-align:center">标识这个字段是自定义的不会创建到数据库表里</td></tr></tbody></table><p>简单的讲一下：</p><ol><li><p>@Entity：标识的bean类，我们在运行的时候，greendao会自动帮我们生成对应的表</p></li><li><p>@Id：标识的字段就是这个表对应的主键</p></li><li><p>@Property：标识的字段在表中对应的那一栏的名称是后面括号里面的，这个表height字段对应表中的Height，一般我们直接设置成默认就可以了</p></li><li><p>@NotNull：标识的字段，这个字段在表中不能为空，不然就出错，所以，在添加数据的时候设置默认值</p></li><li><p>@Transient：标识的字段，在生成表的时候不会生成对应的字段。这个什么时候用呢？这个，我一般用作标记flag，比方说，从数据库拿数据，又不想重新写一个bean类，就用这个bean类，RecyclerView，填充完数据，item点击的时候，状态发生变化，我们要有一个flag，就通过修改这个字段的值，页面做出相应的变化。</p></li></ol><p>&emsp;&emsp;写到这里，我们的bean类也有了，要怎么生成数据库呢？在生成数据库之前，我们先把项目重新clean一遍，再build一遍，看到你刚写的需要生成表的bean类变成了如下样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.bean;</span><br><span class="line"></span><br><span class="line">import org.greenrobot.greendao.annotation.Entity;</span><br><span class="line">import org.greenrobot.greendao.annotation.Id;</span><br><span class="line">import org.greenrobot.greendao.annotation.NotNull;</span><br><span class="line">import org.greenrobot.greendao.annotation.Property;</span><br><span class="line">import org.greenrobot.greendao.annotation.Transient;</span><br><span class="line">import org.greenrobot.greendao.annotation.Generated;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc: 用户表的bean类</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class User &#123;</span><br><span class="line">  @Id</span><br><span class="line">  private String name;</span><br><span class="line">  private int sex;</span><br><span class="line">  @Property(nameInDb = &quot;Height&quot;)</span><br><span class="line">  private int height;</span><br><span class="line">  private String weight;</span><br><span class="line">  @NotNull</span><br><span class="line">  private int age;</span><br><span class="line">  @Transient</span><br><span class="line">  private String character;</span><br><span class="line">  @Generated(hash = 717717955)</span><br><span class="line">  public User(String name, int sex, int height, String weight, int age) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.sex = sex;</span><br><span class="line">      this.height = height;</span><br><span class="line">      this.weight = weight;</span><br><span class="line">      this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  @Generated(hash = 586692638)</span><br><span class="line">  public User() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getName() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setName(String name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  public int getSex() &#123;</span><br><span class="line">      return this.sex;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setSex(int sex) &#123;</span><br><span class="line">      this.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  public int getHeight() &#123;</span><br><span class="line">      return this.height;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setHeight(int height) &#123;</span><br><span class="line">      this.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getWeight() &#123;</span><br><span class="line">      return this.weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setWeight(String weight) &#123;</span><br><span class="line">      this.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public int getAge() &#123;</span><br><span class="line">      return this.age;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setAge(int age) &#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，greendao通过注解的方式帮我们自动生成了set/get方法，还有构造方法，这就对了，我们不用关，之后我们再执行如下代码生成数据库和表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(getApplicationContext(), &quot;haichenyi.db&quot;, null);</span><br><span class="line">DaoMaster daoMaster = new DaoMaster(devOpenHelper.getWritableDb());</span><br><span class="line">DaoSession daoSession = daoMaster.newSession();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。注意：默认的 DaoMaster.DevOpenHelper会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。升级的问题，我们在后面讲，这里我们先把数据库和表先创建了。</p><p>&emsp;&emsp;上面这个方式是java格式的，由于，我昨天写完框架之后，我把项目转成了kotlin代码，所以这里有点不一样，项目我后面会上传。这里我要说明的是（敲黑板）<strong>我用kotlin的时候，碰到了一个问题，当我使用greendao的时候，他提示我，无法引入用注解方式生成的类，dagger2也是一样的，我用java代码写就没有问题</strong>，我写这篇博客的时候，目前还没有找到解决的办法。</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-57cbd658b027825f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="greendao的问题.png"></p><p>&emsp;&emsp;我用了另外一种方式，采用跟之前网络请求一样的设计模式——装饰者模式。我这里就不多做说明了。我贴出我的代码。</p><p>SqlHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.sql;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public interface SqlHelper &#123;</span><br><span class="line">  void onAdd();</span><br><span class="line"></span><br><span class="line">  void onDelete();</span><br><span class="line"></span><br><span class="line">  void onUpdate();</span><br><span class="line"></span><br><span class="line">  void onSelect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里定义增删改查4个方法，用于测试这4个功能</p><p>SqlImpl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.sql;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.MyApplication;</span><br><span class="line">import com.haichenyi.myproject.model.bean.DaoMaster;</span><br><span class="line">import com.haichenyi.myproject.model.bean.DaoSession;</span><br><span class="line">import com.haichenyi.myproject.model.bean.UserDao;</span><br><span class="line">import com.haichenyi.myproject.utils.ToastUtils;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class SqlImpl implements SqlHelper &#123;</span><br><span class="line">  private final UserDao userDao;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 初始化Sql Dao.</span><br><span class="line">   *</span><br><span class="line">   * @param application &#123;@link MyApplication&#125;</span><br><span class="line">   */</span><br><span class="line">  public SqlImpl(MyApplication application) &#123;</span><br><span class="line">    SqlOpenHelper helper = new SqlOpenHelper(application, &quot;haichenyi.db&quot;);</span><br><span class="line">    DaoSession daoSession = new DaoMaster(helper.getWritableDb()).newSession();</span><br><span class="line">    userDao = daoSession.getUserDao();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onAdd() &#123;</span><br><span class="line">    ToastUtils.Companion.showTipMsg(&quot;增加数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onDelete() &#123;</span><br><span class="line">    ToastUtils.Companion.showTipMsg(&quot;删除数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUpdate() &#123;</span><br><span class="line">    ToastUtils.Companion.showTipMsg(&quot;更新数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onSelect() &#123;</span><br><span class="line">    ToastUtils.Companion.showTipMsg(&quot;查询数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;功能实现类，看到他的构造方法里面，第二个参数就是我们的数据库名称，后面通过getWritableDb()获取的是可写的数据库，可写就肯定可读。然后就是接口的实现类了，这里就是具体的增删改查功能的实现类，我这里在对应的方法里面就写了Toast，增删改查具体怎么写后面再说</p><p>SqlOpenHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.sql;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.model.bean.DaoMaster;</span><br><span class="line">import com.haichenyi.myproject.model.bean.UserDao;</span><br><span class="line"></span><br><span class="line">import org.greenrobot.greendao.database.Database;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class SqlOpenHelper extends DaoMaster.OpenHelper &#123;</span><br><span class="line">  public SqlOpenHelper(Context context, String name) &#123;</span><br><span class="line">    super(context, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  @Override</span><br><span class="line">  public void onUpgrade(Database db, int oldVersion, int newVersion) &#123;</span><br><span class="line">    super.onUpgrade(db, oldVersion, newVersion);</span><br><span class="line"></span><br><span class="line">    MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onCreateAllTables(Database db, boolean ifNotExists) &#123;</span><br><span class="line">        DaoMaster.createAllTables(db, ifNotExists);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onDropAllTables(Database db, boolean ifExists) &#123;</span><br><span class="line">        DaoMaster.dropAllTables(db, ifExists);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, UserDao.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个类用于管理数据库的表对应的字段发生变化的时候，数据库需要进行的版本更新，连上下面那个类，都是用于版本数据库版本更新的，防止数据丢失。怎么写呢？看到最后面的&emsp;<strong>UserDao.class</strong>&emsp;了吗？这个就是我们需要更新的表，你哪个表需要更新，直接写在后面就可以了，这个是可以一次传多个表的，并不是一次只能传一个</p><p>MigrationHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.sql;</span><br><span class="line"></span><br><span class="line">import android.database.Cursor;</span><br><span class="line">import android.database.SQLException;</span><br><span class="line">import android.database.sqlite.SQLiteDatabase;</span><br><span class="line">import android.support.annotation.NonNull;</span><br><span class="line">import android.text.TextUtils;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import org.greenrobot.greendao.AbstractDao;</span><br><span class="line">import org.greenrobot.greendao.database.Database;</span><br><span class="line">import org.greenrobot.greendao.database.StandardDatabase;</span><br><span class="line">import org.greenrobot.greendao.internal.DaoConfig;</span><br><span class="line"></span><br><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/2/24</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public final class MigrationHelper &#123;</span><br><span class="line">  public static boolean DEBUG = false;</span><br><span class="line">  private static String TAG = &quot;MigrationHelper&quot;;</span><br><span class="line">  private static final String SQLITE_MASTER = &quot;sqlite_master&quot;;</span><br><span class="line">  private static final String SQLITE_TEMP_MASTER = &quot;sqlite_temp_master&quot;;</span><br><span class="line"></span><br><span class="line">  private static WeakReference&lt;ReCreateAllTableListener&gt; weakListener;</span><br><span class="line"></span><br><span class="line">  public interface ReCreateAllTableListener &#123;</span><br><span class="line">    void onCreateAllTables(Database db, boolean ifNotExists);</span><br><span class="line"></span><br><span class="line">    void onDropAllTables(Database db, boolean ifExists);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void migrate(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    printLog(&quot;【The Old Database Version】&quot; + db.getVersion());</span><br><span class="line">    Database database = new StandardDatabase(db);</span><br><span class="line">    migrate(database, daoClasses);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void migrate(SQLiteDatabase db, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    weakListener = new WeakReference&lt;&gt;(listener);</span><br><span class="line">    migrate(db, daoClasses);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void migrate(Database database, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    weakListener = new WeakReference&lt;&gt;(listener);</span><br><span class="line">    migrate(database, daoClasses);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void migrate(Database database, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    printLog(&quot;【Generate temp table】start&quot;);</span><br><span class="line">    generateTempTables(database, daoClasses);</span><br><span class="line">    printLog(&quot;【Generate temp table】complete&quot;);</span><br><span class="line"></span><br><span class="line">    ReCreateAllTableListener listener = null;</span><br><span class="line">    if (weakListener != null) &#123;</span><br><span class="line">      listener = weakListener.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (listener != null) &#123;</span><br><span class="line">      listener.onDropAllTables(database, true);</span><br><span class="line">      printLog(&quot;【Drop all table by listener】&quot;);</span><br><span class="line">      listener.onCreateAllTables(database, false);</span><br><span class="line">      printLog(&quot;【Create all table by listener】&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dropAllTables(database, true, daoClasses);</span><br><span class="line">      createAllTables(database, false, daoClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    printLog(&quot;【Restore data】start&quot;);</span><br><span class="line">    restoreData(database, daoClasses);</span><br><span class="line">    printLog(&quot;【Restore data】complete&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static void generateTempTables(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    for (int i = 0; i &lt; daoClasses.length; i++) &#123;</span><br><span class="line">      String tempTableName = null;</span><br><span class="line"></span><br><span class="line">      DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]);</span><br><span class="line">      String tableName = daoConfig.tablename;</span><br><span class="line">      if (!isTableExists(db, false, tableName)) &#123;</span><br><span class="line">        printLog(&quot;【New Table】&quot; + tableName);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">        tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;);</span><br><span class="line">        StringBuilder dropTableStringBuilder = new StringBuilder();</span><br><span class="line">        dropTableStringBuilder.append(&quot;DROP TABLE IF EXISTS &quot;).append(tempTableName).append(&quot;;&quot;);</span><br><span class="line">        db.execSQL(dropTableStringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        StringBuilder insertTableStringBuilder = new StringBuilder();</span><br><span class="line">        insertTableStringBuilder.append(&quot;CREATE TEMPORARY TABLE &quot;).append(tempTableName);</span><br><span class="line">        insertTableStringBuilder.append(&quot; AS SELECT * FROM &quot;).append(tableName).append(&quot;;&quot;);</span><br><span class="line">        db.execSQL(insertTableStringBuilder.toString());</span><br><span class="line">        printLog(&quot;【Table】&quot; + tableName + &quot;\n ---Columns--&gt;&quot; + getColumnsStr(daoConfig));</span><br><span class="line">        printLog(&quot;【Generate temp table】&quot; + tempTableName);</span><br><span class="line">      &#125; catch (SQLException e) &#123;</span><br><span class="line">        Log.e(TAG, &quot;【Failed to generate temp table】&quot; + tempTableName, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static boolean isTableExists(Database db, boolean isTemp, String tableName) &#123;</span><br><span class="line">    if (db == null || TextUtils.isEmpty(tableName)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    String dbName = isTemp ? SQLITE_TEMP_MASTER : SQLITE_MASTER;</span><br><span class="line">    String sql = &quot;SELECT COUNT(*) FROM &quot; + dbName + &quot; WHERE type = ? AND name = ?&quot;;</span><br><span class="line">    Cursor cursor = null;</span><br><span class="line">    int count = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">      cursor = db.rawQuery(sql, new String[]&#123;&quot;table&quot;, tableName&#125;);</span><br><span class="line">      if (cursor == null || !cursor.moveToFirst()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      count = cursor.getInt(0);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (cursor != null)</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    return count &gt; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private static String getColumnsStr(DaoConfig daoConfig) &#123;</span><br><span class="line">    if (daoConfig == null) &#123;</span><br><span class="line">      return &quot;no columns&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder builder = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; daoConfig.allColumns.length; i++) &#123;</span><br><span class="line">      builder.append(daoConfig.allColumns[i]);</span><br><span class="line">      builder.append(&quot;,&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (builder.length() &gt; 0) &#123;</span><br><span class="line">      builder.deleteCharAt(builder.length() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return builder.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private static void dropAllTables(Database db, boolean ifExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    reflectMethod(db, &quot;dropTable&quot;, ifExists, daoClasses);</span><br><span class="line">    printLog(&quot;【Drop all table by reflect】&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static void createAllTables(Database db, boolean ifNotExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    reflectMethod(db, &quot;createTable&quot;, ifNotExists, daoClasses);</span><br><span class="line">    printLog(&quot;【Create all table by reflect】&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * dao class already define the sql exec method, so just invoke it</span><br><span class="line">   */</span><br><span class="line">  private static void reflectMethod(Database db, String methodName, boolean isExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    if (daoClasses.length &lt; 1) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      for (Class cls : daoClasses) &#123;</span><br><span class="line">        Method method = cls.getDeclaredMethod(methodName, Database.class, boolean.class);</span><br><span class="line">        method.invoke(null, db, isExists);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static void restoreData(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;</span><br><span class="line">    for (int i = 0; i &lt; daoClasses.length; i++) &#123;</span><br><span class="line">      DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]);</span><br><span class="line">      String tableName = daoConfig.tablename;</span><br><span class="line">      String tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;);</span><br><span class="line"></span><br><span class="line">      if (!isTableExists(db, true, tempTableName)) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        // get all columns from tempTable, take careful to use the columns list</span><br><span class="line">        List&lt;String&gt; columns = getColumns(db, tempTableName);</span><br><span class="line">        ArrayList&lt;String&gt; properties = new ArrayList&lt;&gt;(columns.size());</span><br><span class="line">        for (int j = 0; j &lt; daoConfig.properties.length; j++) &#123;</span><br><span class="line">          String columnName = daoConfig.properties[j].columnName;</span><br><span class="line">          if (columns.contains(columnName)) &#123;</span><br><span class="line">            properties.add(&quot;`&quot; + columnName + &quot;`&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (properties.size() &gt; 0) &#123;</span><br><span class="line">          final String columnSQL = TextUtils.join(&quot;,&quot;, properties);</span><br><span class="line"></span><br><span class="line">          StringBuilder insertTableStringBuilder = new StringBuilder();</span><br><span class="line">          insertTableStringBuilder.append(&quot;REPLACE INTO &quot;).append(tableName).append(&quot; (&quot;);</span><br><span class="line">          insertTableStringBuilder.append(columnSQL);</span><br><span class="line">          insertTableStringBuilder.append(&quot;) SELECT &quot;);</span><br><span class="line">          insertTableStringBuilder.append(columnSQL);</span><br><span class="line">          insertTableStringBuilder.append(&quot; FROM &quot;).append(tempTableName).append(&quot;;&quot;);</span><br><span class="line">          db.execSQL(insertTableStringBuilder.toString());</span><br><span class="line">          printLog(&quot;【Restore data】 to &quot; + tableName);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder dropTableStringBuilder = new StringBuilder();</span><br><span class="line">        dropTableStringBuilder.append(&quot;DROP TABLE &quot;).append(tempTableName);</span><br><span class="line">        db.execSQL(dropTableStringBuilder.toString());</span><br><span class="line">        printLog(&quot;【Drop temp table】&quot; + tempTableName);</span><br><span class="line">      &#125; catch (SQLException e) &#123;</span><br><span class="line">        Log.e(TAG, &quot;【Failed to restore data from temp table 】&quot; + tempTableName, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static List&lt;String&gt; getColumns(Database db, String tableName) &#123;</span><br><span class="line">    List&lt;String&gt; columns = null;</span><br><span class="line">    Cursor cursor = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      cursor = db.rawQuery(&quot;SELECT * FROM &quot; + tableName + &quot; limit 0&quot;, null);</span><br><span class="line">      if (null != cursor &amp;&amp; cursor.getColumnCount() &gt; 0) &#123;</span><br><span class="line">        columns = Arrays.asList(cursor.getColumnNames());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (cursor != null)</span><br><span class="line">        cursor.close();</span><br><span class="line">      if (null == columns)</span><br><span class="line">        columns = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    return columns;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static void printLog(String info) &#123;</span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">      Log.d(TAG, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个类是工具类，拿过去用就好了，还有就是，应用怎么判断是否需要版本更新呢？打开你的app下面的build.grade，在根结点下面添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greendao &#123;</span><br><span class="line">    schemaVersion 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当你发布新版本的时候，把这个版本号+1即可。</p><p>&emsp;&emsp;当然，我门这里依然是用的dagger生成的全局单例，所以，你还需要在你的AppModule下面添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Provides</span><br><span class="line">@Singleton</span><br><span class="line">SqlHelper provideSqlHelper() &#123;</span><br><span class="line">  return new SqlImpl(application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;记得把项目重新clean一遍，build一遍，重新跑项目的时候，找到你的数据库。data-data-你的应用包名-databases-haichenyi.db，这个就是我们的数据库。找个Sqlite可视化工具打开，你会看到如下结构。</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-76d1c00d544ec20b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表结构.png"></p><p>&emsp;&emsp;太多了，不写了，下一篇写增删改查。</p><p><a href="http://download.csdn.net/download/qq_27634797/10257727" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本篇介绍android常用的数据库之一&lt;a href=&quot;https://github.com/greenrobot/greenDAO&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GreenDao&lt;/a&gt;的简单用法，增删改查。基于前面搭的框架，当然，你也可以选择不用。看懂用法之后，用起来很方便。GreenDao数据库升级到3.0版本之后api用起来更加方便了，便于让开发人员专注于业务逻辑。我需要额外说明的是，我把之前的项目框架转成了&lt;a href=&quot;http://kotlinlang.org/docs/reference/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kotlin&lt;/a&gt;，不会&lt;a href=&quot;http://kotlinlang.org/docs/reference/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kotlin&lt;/a&gt;语法的同学，可以去研究一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（三）—RxJava2.0+Retrofit2.0+OkHttp</title>
    <link href="http://haichenyi.com/2018/02/23/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94RxJava2-0-Retrofit2-0-OkHttp/"/>
    <id>http://haichenyi.com/2018/02/23/从零开始搭建一个主流项目框架（三）—RxJava2-0-Retrofit2-0-OkHttp/</id>
    <published>2018-02-23T12:40:26.000Z</published>
    <updated>2018-02-23T12:41:56.915Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇，我们把mvp+dagger加进去了，这一篇，我们把网络请求加上</p><p>&emsp;&emsp;我这里的网络请求是用的装饰者模式去写的，什么是装饰者模式呢？在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。我的理解就是一个接口，两个实现类，一个实现类负责调用接口的方法，另一个类负责功能的具体实现。本文中所提到的代码都是伪代码，最后会给出完整的，最初版本的项目框架。不包含任何业务逻辑</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/7041675-e4ef229beca589e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构.png"></p><p>&emsp;&emsp;容我一个一个来说，首先，我们一般请求网络的时候，会有统一的返回数据格式，一个是需要判断返回code码的，就比方说登录功能，那登录成功，还是失败，我们只用判断code码即可，这种类型，我们统一是HttpNoResult。还有一个是返回数据的，就比方说查一个列表数据。这里我们统一的是HttpResult。我先给出这两个类的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:没有解析数据的返回</span><br><span class="line"> */</span><br><span class="line">public class HttpNoResult &#123;</span><br><span class="line">  private int code;</span><br><span class="line">  private String msg;</span><br><span class="line"></span><br><span class="line">  public int getCode() &#123;</span><br><span class="line">    return code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpNoResult setCode(int code) &#123;</span><br><span class="line">    this.code = code;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getMsg() &#123;</span><br><span class="line">    return msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpNoResult setMsg(String msg) &#123;</span><br><span class="line">    this.msg = msg;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    return &quot;HttpNoResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &apos;&#125;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">import com.google.gson.annotations.SerializedName;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:有解析数据的返回</span><br><span class="line"> */</span><br><span class="line">public class HttpResult&lt;T&gt; &#123;</span><br><span class="line">  private int code;</span><br><span class="line">  private String msg;</span><br><span class="line">  @SerializedName(value = &quot;result&quot;)</span><br><span class="line">  private T data;</span><br><span class="line"></span><br><span class="line">  public int getCode() &#123;</span><br><span class="line">    return code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpResult setCode(int code) &#123;</span><br><span class="line">    this.code = code;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getMsg() &#123;</span><br><span class="line">    return msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpResult setMsg(String msg) &#123;</span><br><span class="line">    this.msg = msg;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public T getData() &#123;</span><br><span class="line">    return data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpResult setData(T data) &#123;</span><br><span class="line">    this.data = data;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    return &quot;HttpResult&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &quot;, data=&quot; + data + &apos;&#125;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我就需要说一点，有数据返回的时候，每个数据类型都是不一样的，所以，这里我用的泛型传递，不同的数据类型，传不同的bean对象</p><p>&emsp;&emsp;言归正传，我们来说说网络请求的一个接口，两个实现类。</p><p>一个接口—HttpHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">import io.reactivex.Flowable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:网络接口，接口参数Token统一处理，方法中不传Token</span><br><span class="line"> */</span><br><span class="line">public interface HttpHelper &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 登录时获取验证码.</span><br><span class="line">   *</span><br><span class="line">   * @param phone 手机号</span><br><span class="line">   * @return &#123;&quot;code&quot;:0&#125;</span><br><span class="line">   */</span><br><span class="line">  Flowable&lt;HttpNoResult&gt; loginCode(String phone);</span><br><span class="line">  /*Flowable&lt;HttpResult&lt;Login&gt;&gt; login(String phone, String code);</span><br><span class="line">  Flowable&lt;HttpResult&lt;List&lt;DiyBean&gt;&gt;&gt; diyKeys(String allId);*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Flowable是RxJava2.0新增的，所以说RxJava完美兼容Retrofit，泛型就是我们需要解析的数据</p><ol><li><p>loginCode方法是说返回数据，我们只用判断是否是成功还是失败，</p></li><li><p>login方法是说返回数据是一个Login对象，至于对象是什么内容，那就是和你们后台确认了</p></li><li><p>diyKeys方法就是说，返回数据是一个list对象，每个list的item是DiyBean对象</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.model.http.HttpHelper;</span><br><span class="line">import com.haichenyi.myproject.model.http.HttpNoResult;</span><br><span class="line"></span><br><span class="line">import io.reactivex.Flowable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:网络请求的实现类</span><br><span class="line"> */</span><br><span class="line">public class DataHelper implements HttpHelper &#123;</span><br><span class="line">  private HttpHelper http;</span><br><span class="line"></span><br><span class="line">  public DataHelper(HttpHelper http) &#123;</span><br><span class="line">    this.http = http;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123;</span><br><span class="line">    return http.loginCode(phone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;DataHelper是HttpHelper的实现类，他的唯一作用就是调用接口的方法即可，具体的功能实现是后面一个类，这里需要说明的是这个类的构造方法要public表示，因为他要dagger生成，用private或者protected表示无法生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.model.http.api.HttpApi;</span><br><span class="line"></span><br><span class="line">import io.reactivex.Flowable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc: 网络接口Retrofit实现</span><br><span class="line"> */</span><br><span class="line">public class RetrofitHelper implements HttpHelper&#123;</span><br><span class="line">  private HttpApi httpApi;</span><br><span class="line"></span><br><span class="line">  @Inject</span><br><span class="line">  RetrofitHelper(HttpApi httpApi) &#123;</span><br><span class="line">    this.httpApi = httpApi;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123;</span><br><span class="line">    return httpApi.loginCode(phone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;RetrofitHelper类作为HttpHelper接口的实现类，他是具体功能的实现类，为什么说他是具体功能的实现类呢？因为，他是调用HttpApi接口的方法。HttpApi接口是干什么用的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http.api;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.model.http.HttpNoResult;</span><br><span class="line">import com.haichenyi.myproject.model.http.ProtocolHttp;</span><br><span class="line"></span><br><span class="line">import io.reactivex.Flowable;</span><br><span class="line">import retrofit2.http.Field;</span><br><span class="line">import retrofit2.http.FormUrlEncoded;</span><br><span class="line">import retrofit2.http.POST;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:网络请求接口api</span><br><span class="line"> */</span><br><span class="line">public interface HttpApi &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 登录时获取验证码.</span><br><span class="line">   *</span><br><span class="line">   * @param phone 手机号</span><br><span class="line">   * @return &#123;&quot;code&quot;:0&#125;</span><br><span class="line">   */</span><br><span class="line">  @FormUrlEncoded</span><br><span class="line">  @POST(ProtocolHttp.METHOD_LOGIN_CODE)</span><br><span class="line">  Flowable&lt;HttpNoResult&gt; loginCode(@Field(&quot;phone&quot;) String phone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是Retrofit的网络请求的方式，看不懂？这个就是Retrofit的东西了<br>方法注解，包含@GET、@POST、@PUT、@DELETE、@PATH、@HEAD、@OPTIONS、@HTTP。<br>标记注解，包含@FormUrlEncoded、@Multipart、@Streaming。<br>参数注解，包含@Query、@QueryMap、@Body、@Field，@FieldMap、@Part，@PartMap。<br>其他注解，包含@Path、@Header、@Headers、@Url。</p><p>这里我们还差一个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public interface ProtocolHttp &#123;</span><br><span class="line">  String HTTP_HOST = &quot;http://xxx.xx.xxx.xxx:8080/app/con/&quot;;</span><br><span class="line">  String HTTP_COMMON = &quot;common/&quot;;</span><br><span class="line">  String METHOD_LOGIN_CODE = HTTP_COMMON + &quot;code&quot;;//登录发送验证码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，这里需要注意的是不能以”\”结尾，然后就是，跟你们后台商量，格式不要错了，尽量就只有接口名字不同，接口名字前面部分都是一样的。</p><p>&emsp;&emsp;到此，这里基本上就说完了，那么有同鞋就会问了，接口定义方法的时候，我们知道该如何写返回数据类型呢？这个我就不知道了，你得问你们后台，根据后台返回的数据类型去写对应的bean类。推荐一个功能PostMan。</p><p>&emsp;&emsp;到目前为止，我们都还没有初始化网络请求的参数，这些网络请求的参数在哪里初始化呢？这些参数，我们就只用初始化一次，我们就想到了dagger的全局单例模式，没错，就是这个，我们上一篇写了很多没有用的东西，里面有一个HttpModule</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.module;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.di.qualifier.ApiUrl;</span><br><span class="line">import com.haichenyi.myproject.model.http.ProtocolHttp;</span><br><span class="line">import com.haichenyi.myproject.model.http.api.HttpApi;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import javax.inject.Singleton;</span><br><span class="line"></span><br><span class="line">import dagger.Module;</span><br><span class="line">import dagger.Provides;</span><br><span class="line">import okhttp3.OkHttpClient;</span><br><span class="line">import retrofit2.Retrofit;</span><br><span class="line">import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;</span><br><span class="line">import retrofit2.converter.gson.GsonConverterFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:网络请求的参数初始化</span><br><span class="line"> */</span><br><span class="line">@Module</span><br><span class="line">public class HttpModule &#123;</span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  OkHttpClient.Builder providesOkHttpHelper() &#123;</span><br><span class="line">//请求读写超时时间</span><br><span class="line">    return new OkHttpClient.Builder()</span><br><span class="line">        .connectTimeout(10, TimeUnit.SECONDS)</span><br><span class="line">        .readTimeout(10, TimeUnit.SECONDS)</span><br><span class="line">        .writeTimeout(10, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  OkHttpClient provideClient(OkHttpClient.Builder builder) &#123;</span><br><span class="line">    return builder</span><br><span class="line">//        .addInterceptor(new MyHttpInterceptor())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  Retrofit.Builder providesRetrofitBuilder() &#123;</span><br><span class="line">    return new Retrofit.Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  HttpApi provideApi(@ApiUrl Retrofit retrofit) &#123;</span><br><span class="line">    return retrofit.create(HttpApi.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  @ApiUrl</span><br><span class="line">  Retrofit providesApiRetrofit(Retrofit.Builder builder, OkHttpClient client) &#123;</span><br><span class="line">    return createRetrofit(builder, client, ProtocolHttp.HTTP_HOST);//这里就是你的网络请求的url</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Retrofit createRetrofit(Retrofit.Builder builder, OkHttpClient client, String host) &#123;</span><br><span class="line">    return builder.client(client)</span><br><span class="line">        .baseUrl(host)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())//添加gson自动解析，我们不用关</span><br><span class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，注释写的都有，考过去用就行了</p><p>在AppModule里面添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.module;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.MyApplication;</span><br><span class="line">import com.haichenyi.myproject.model.DataHelper;</span><br><span class="line">import com.haichenyi.myproject.model.http.HttpHelper;</span><br><span class="line">import com.haichenyi.myproject.model.http.RetrofitHelper;</span><br><span class="line"></span><br><span class="line">import javax.inject.Singleton;</span><br><span class="line"></span><br><span class="line">import dagger.Module;</span><br><span class="line">import dagger.Provides;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Module</span><br><span class="line">public class AppModule &#123;</span><br><span class="line">  private MyApplication application;</span><br><span class="line"></span><br><span class="line">  public AppModule(MyApplication application) &#123;</span><br><span class="line">    this.application = application;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  DataHelper provideDataHelper(HttpHelper httpHelper) &#123;</span><br><span class="line">    return new DataHelper(httpHelper);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Provides</span><br><span class="line">  @Singleton</span><br><span class="line">  HttpHelper provideHttpHelper(RetrofitHelper retrofitHelper) &#123;</span><br><span class="line">    return retrofitHelper;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里都是dagger了生成全局单例对象需要的东西</p><p>在AppComponent里面添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.component;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.di.module.AppModule;</span><br><span class="line">import com.haichenyi.myproject.di.module.HttpModule;</span><br><span class="line">import com.haichenyi.myproject.model.DataHelper;</span><br><span class="line"></span><br><span class="line">import javax.inject.Singleton;</span><br><span class="line"></span><br><span class="line">import dagger.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Singleton</span><br><span class="line">@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)</span><br><span class="line">public interface AppComponent &#123;</span><br><span class="line">  DataHelper getDataHelper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BaseMvpPresenter里面添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">import io.reactivex.disposables.CompositeDisposable;</span><br><span class="line">import io.reactivex.disposables.Disposable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123;</span><br><span class="line">  protected T baseView;</span><br><span class="line">  private CompositeDisposable disposables;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void attachView(T baseView) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected void addSubscribe(Disposable disposable) &#123;</span><br><span class="line">    if (null == disposables) &#123;</span><br><span class="line">      disposables = new CompositeDisposable();</span><br><span class="line">    &#125;</span><br><span class="line">    disposables.add(disposable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void detachView() &#123;</span><br><span class="line">    this.baseView = null;</span><br><span class="line">    unSubscribe();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void unSubscribe() &#123;</span><br><span class="line">    if (null != disposables) &#123;</span><br><span class="line">      disposables.clear();</span><br><span class="line">      disposables = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，就全部写完了，关于网络请求的内容。调用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.presenter;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BaseMvpPresenter;</span><br><span class="line">import com.haichenyi.myproject.base.MyApplication;</span><br><span class="line">import com.haichenyi.myproject.contract.MainContract;</span><br><span class="line">import com.haichenyi.myproject.model.DataHelper;</span><br><span class="line"></span><br><span class="line">import javax.inject.Inject;</span><br><span class="line"></span><br><span class="line">import io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line">import io.reactivex.schedulers.Schedulers;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt;</span><br><span class="line">    implements MainContract.Presenter &#123;</span><br><span class="line">  private DataHelper dataHelper;</span><br><span class="line">  @Inject</span><br><span class="line">  MainPresenter() &#123;</span><br><span class="line">    dataHelper = MyApplication.getAppComponent().getDataHelper();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void loadData() &#123;</span><br><span class="line">    addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe());</span><br><span class="line">//    baseView.showTipMsg(&quot;加载数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得在清单文件里面，加上网络权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure><p>网络请求，这样调用之后在哪处理呢？我给出我的几个处理的工具类。首先，按如下图设置1.8支持lambda表达式</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-cbecfbc473c7b512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置.png"></p><p>然后添加如下几个类</p><p>HttpCode </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc: 网络请求状态码</span><br><span class="line"> */</span><br><span class="line">public interface HttpCode &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 成功.</span><br><span class="line">   */</span><br><span class="line">  int SUCCESS = 0;</span><br><span class="line">  /**</span><br><span class="line">   * 参数为空.</span><br><span class="line">   */</span><br><span class="line">  int NO_PARAMETER = 1;</span><br><span class="line">  /**</span><br><span class="line">   * 服务器错误.</span><br><span class="line">   */</span><br><span class="line">  int SERVER_ERR = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApiException </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc: 接口异常判断处理</span><br><span class="line"> */</span><br><span class="line">public class ApiException extends Exception &#123;</span><br><span class="line">  private int code;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">  public ApiException(int code) &#123;</span><br><span class="line">    this.code = code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ApiException(int code, String message) &#123;</span><br><span class="line">    super(message);</span><br><span class="line">    this.code = code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int getCode() &#123;</span><br><span class="line">    return code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ApiException setCode(int code) &#123;</span><br><span class="line">    this.code = code;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyRxUtils </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line">import io.reactivex.BackpressureStrategy;</span><br><span class="line">import io.reactivex.Flowable;</span><br><span class="line">import io.reactivex.FlowableTransformer;</span><br><span class="line">import io.reactivex.Scheduler;</span><br><span class="line">import io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line">import io.reactivex.schedulers.Schedulers;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/27</span><br><span class="line"> * Desc:切换线程的工具类</span><br><span class="line"> */</span><br><span class="line">public class MyRxUtils &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 从其他线程转到主线程.</span><br><span class="line">   *</span><br><span class="line">   * @param scheduler Schedulers.io()等等</span><br><span class="line">   * @param &lt;T&gt;       t</span><br><span class="line">   * @return FlowableTransformer</span><br><span class="line">   */</span><br><span class="line">  public static &lt;T&gt; FlowableTransformer&lt;T, T&gt; toMain(Scheduler scheduler) &#123;</span><br><span class="line">    return upstream -&gt; upstream.subscribeOn(scheduler).observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; FlowableTransformer&lt;HttpResult&lt;T&gt;, T&gt; handResult() &#123;</span><br><span class="line">    return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .flatMap(tHttpResult -&gt; &#123;</span><br><span class="line">          if (tHttpResult.getCode() == HttpCode.SUCCESS) &#123;</span><br><span class="line">            return /*createData(tHttpResult.data)*/Flowable.just(tHttpResult.getData());</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            return Flowable.error(new ApiException(tHttpResult.getCode(), tHttpResult.getMsg()));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static &lt;T&gt; Flowable&lt;T&gt; createData(final T data) &#123;</span><br><span class="line">    return Flowable.create(e -&gt; &#123;</span><br><span class="line">      e.onNext(data);</span><br><span class="line">      e.onComplete();</span><br><span class="line">    &#125;, BackpressureStrategy.ERROR);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySubscriber</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.model.http;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BaseView;</span><br><span class="line">import io.reactivex.subscribers.ResourceSubscriber;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123;</span><br><span class="line">  private BaseView baseView;</span><br><span class="line">  private boolean showLoading;</span><br><span class="line"></span><br><span class="line">  public MySubscriber(BaseView baseView) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MySubscriber(BaseView baseView, boolean showLoading) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">    this.showLoading = showLoading;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onStart() &#123;</span><br><span class="line">    super.onStart();</span><br><span class="line">    if (null != baseView &amp;&amp; showLoading) &#123;</span><br><span class="line">      baseView.showLoading();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onError(Throwable t) &#123;</span><br><span class="line">    if (null == baseView) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    baseView.hideLoading();</span><br><span class="line">    if (t instanceof ApiException) &#123;</span><br><span class="line">      ApiException apiException = (ApiException) t;</span><br><span class="line">      switch (apiException.getCode()) &#123;</span><br><span class="line">        case HttpCode.NO_PARAMETER:</span><br><span class="line">          baseView.showTipMsg(&quot;参数为空&quot;);</span><br><span class="line">          break;</span><br><span class="line">        case HttpCode.SERVER_ERR:</span><br><span class="line">          baseView.showTipMsg(&quot;服务器错误&quot;);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onComplete() &#123;</span><br><span class="line">    if (null != baseView) &#123;</span><br><span class="line">      baseView.hideLoading();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个类不想多做解释，结合注释，仔细看几遍，就知道是干嘛用的了</p><p>加上这几个之后调用方式就变成了以下的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.presenter;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BaseMvpPresenter;</span><br><span class="line">import com.haichenyi.myproject.base.MyApplication;</span><br><span class="line">import com.haichenyi.myproject.contract.MainContract;</span><br><span class="line">import com.haichenyi.myproject.model.DataHelper;</span><br><span class="line">import com.haichenyi.myproject.model.http.HttpNoResult;</span><br><span class="line">import com.haichenyi.myproject.model.http.MyRxUtils;</span><br><span class="line">import com.haichenyi.myproject.model.http.MySubscriber;</span><br><span class="line"></span><br><span class="line">import javax.inject.Inject;</span><br><span class="line"></span><br><span class="line">import io.reactivex.schedulers.Schedulers;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt;</span><br><span class="line">    implements MainContract.Presenter &#123;</span><br><span class="line">  private DataHelper dataHelper;</span><br><span class="line"></span><br><span class="line">  @Inject</span><br><span class="line">  MainPresenter() &#123;</span><br><span class="line">    dataHelper = MyApplication.getAppComponent().getDataHelper();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void loadData() &#123;</span><br><span class="line">    addSubscribe(dataHelper.loginCode(&quot;134xxxxxxxx&quot;)</span><br><span class="line">        .compose(MyRxUtils.toMain(Schedulers.io()))</span><br><span class="line">        .subscribeWith(new MySubscriber&lt;HttpNoResult&gt;(baseView, true) &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onNext(HttpNoResult httpNoResult) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">//    baseView.showTipMsg(&quot;加载数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完了，完了，终于写完了。</p><p><a href="http://download.csdn.net/download/qq_27634797/10256152" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇，我们把mvp+dagger加进去了，这一篇，我们把网络请求加上&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我这里的网络请求是用的装饰者模式去写的，什么是装饰者模式呢？在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。我的理解就是一个接口，两个实现类，一个实现类负责调用接口的方法，另一个类负责功能的具体实现。本文中所提到的代码都是伪代码，最后会给出完整的，最初版本的项目框架。不包含任何业务逻辑&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（二）—MVP+dagger2</title>
    <link href="http://haichenyi.com/2018/02/23/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94MVP-dagger2/"/>
    <id>http://haichenyi.com/2018/02/23/从零开始搭建一个主流项目框架（二）—MVP-dagger2/</id>
    <published>2018-02-23T12:36:38.000Z</published>
    <updated>2018-02-23T12:38:17.053Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;接着上一篇简单的框架，没有看过的同鞋可以去喵一眼。上一篇我们搭好了简单的框架，初始化一次的内容丢在Application里面，所有的activity继承一个类BaseActivity，还有Fragment继承的一个类BaseFragment</p><a id="more"></a><p>&emsp;&emsp;现在我们来加上MVP，不懂MVP的同鞋可以看一下，我前面写过的三种主流框架的对比。我们先导入dagger2的两个包，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.google.dagger:dagger:2.14.1&apos;</span><br><span class="line">annotationProcessor &quot;com.google.dagger:dagger-compiler:2.14.1&quot;</span><br></pre></td></tr></table></figure><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>&emsp;&emsp;新建BasePresenter接口，BaseMvpPresenter类去实现BasePresenter接口，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.shfzwkeji.smartwardrobe.base;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc: 不带mvp的presenter的基类</span><br><span class="line"> */</span><br><span class="line">public interface BasePresenter&lt;T extends BaseView&gt; &#123;</span><br><span class="line">  void attachView(T baseView);</span><br><span class="line"></span><br><span class="line">  void detachView();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:带mvp的presenter的基类</span><br><span class="line"> */</span><br><span class="line">public class BaseMvpPresenter&lt;T extends BaseView&gt; implements BasePresenter&lt;T&gt; &#123;</span><br><span class="line">  protected T baseView;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void attachView(T baseView) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void detachView() &#123;</span><br><span class="line">    this.baseView = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里就只有两个方法，一个是绑定view，还有一个是在ondestory方法里面解除绑定的方法，用来保证P层的生命周期和V层同步，避免了，当V层销毁的时候，P层仍然存在造成的内存泄漏。</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>&emsp;&emsp;新建BaseMvpActivity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">import javax.inject.Inject;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:带MVP的Activity</span><br><span class="line"> */</span><br><span class="line">public abstract class BaseMvpActivity&lt;T extends BasePresenter&gt;  extends BaseActivity&#123;</span><br><span class="line">  @Inject</span><br><span class="line">  protected T basePresenter;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  protected void initView() &#123;</span><br><span class="line">    super.initView();</span><br><span class="line">    initInject();</span><br><span class="line">    if (null != basePresenter) &#123;</span><br><span class="line">      basePresenter.attachView(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void initInject();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDestroy() &#123;</span><br><span class="line">    if (null != basePresenter) &#123;</span><br><span class="line">      basePresenter.detachView();</span><br><span class="line">      basePresenter = null;</span><br><span class="line">    &#125;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运用dagger2注解的方式，生成P层，这里我们在用P层之前得先生成P层，所以initject方法一定要在basePresenter用之前调用，因为他就是生成P层的代码。</p><p>&emsp;&emsp;怎么生成呢？dagger我们一般都命名成di层，所以，我们先创建di层的package，项目结构图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-97ad0d5ba60d4af3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构图.png"></p><p>&emsp;&emsp;这里给出的是mvp+dagger加入之后的项目结构。我们重点看选中的di层，里面有4个package分别是component，module，qualifier，scope四个包，至于他们的作用分别是什么，请自行百度，google，dagger的用法。我这里先贴出这几个类，接口的代码：</p><p>ActivityComponent </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.component;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.MainActivity;</span><br><span class="line">import com.haichenyi.myproject.di.module.ActivityModule;</span><br><span class="line">import com.haichenyi.myproject.di.scope.ActivityScope;</span><br><span class="line"></span><br><span class="line">import dagger.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@ActivityScope</span><br><span class="line">@Component(dependencies = AppComponent.class, modules = ActivityModule.class)</span><br><span class="line">public interface ActivityComponent &#123;</span><br><span class="line">  void inject(MainActivity mainActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppComponent </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.component;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.di.module.AppModule;</span><br><span class="line">import com.haichenyi.myproject.di.module.HttpModule;</span><br><span class="line"></span><br><span class="line">import javax.inject.Singleton;</span><br><span class="line"></span><br><span class="line">import dagger.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Singleton</span><br><span class="line">@Component(modules = &#123;AppModule.class, HttpModule.class&#125;)</span><br><span class="line">public interface AppComponent &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityModule </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.module;</span><br><span class="line"></span><br><span class="line">import dagger.Module;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Module</span><br><span class="line">public class ActivityModule &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppModule </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.module;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.MyApplication;</span><br><span class="line"></span><br><span class="line">import dagger.Module;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Module</span><br><span class="line">public class AppModule &#123;</span><br><span class="line">  private MyApplication application;</span><br><span class="line"></span><br><span class="line">  public AppModule(MyApplication application) &#123;</span><br><span class="line">    this.application = application;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpModule </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.module;</span><br><span class="line"></span><br><span class="line">import dagger.Module;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Module</span><br><span class="line">public class HttpModule &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityScope </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.di.scope;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line">import javax.inject.Scope;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">@Scope</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface ActivityScope &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这几个类，接口里面基本上都没有内容，因为这几个类都是后面才会用的到的，这里我直接贴出来，说起来方便一些。还需要加两个方法，在MyApplication里面加如下方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 获取AppComponent.</span><br><span class="line">   *</span><br><span class="line">   * @return AppComponent</span><br><span class="line">   */</span><br><span class="line">  public static synchronized AppComponent getAppComponent() &#123;</span><br><span class="line">    if (null == appComponent) &#123;</span><br><span class="line">      appComponent = DaggerAppComponent.builder()</span><br><span class="line">          .appModule(new AppModule(getInstance()))</span><br><span class="line">          .httpModule(new HttpModule())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line">    return appComponent;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在BaseActivity里面加如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected ActivityComponent getActivityComponent() &#123;</span><br><span class="line">    return DaggerActivityComponent.builder()</span><br><span class="line">        .appComponent(MyApplication.getAppComponent())</span><br><span class="line">        .activityModule(new ActivityModule())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;加完这两个方法之后，肯定会有错误提示，重新编译一遍项目就可以了，如果重新编译一遍，还是不行，请重新对比一下，哪里不一样。</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>&emsp;&emsp;就是关于mvp的了，从上面图应该看到了，有一个presenter包，和contract包，我们之前有一篇博客讲过，MVP就是多了很多个接口，这些接口写在哪呢？就在contract层</p><p>MainContract 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.contract;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BasePresenter;</span><br><span class="line">import com.haichenyi.myproject.base.BaseView;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public interface MainContract &#123;</span><br><span class="line">  interface IView extends BaseView&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  interface Presenter extends BasePresenter&lt;IView&gt;&#123;</span><br><span class="line">    void loadData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我需要说明的就是Presenter接口继承的是IVew，不是BaseView，页面变化的方法都是在IView接口里面定义，逻辑处理，网络请求方法都是在Presenter接口里面定义</p><p>MainPresenter 代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.presenter;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BaseMvpPresenter;</span><br><span class="line">import com.haichenyi.myproject.contract.MainContract;</span><br><span class="line"></span><br><span class="line">import javax.inject.Inject;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MainPresenter extends BaseMvpPresenter&lt;MainContract.IView&gt;</span><br><span class="line">    implements MainContract.Presenter &#123;</span><br><span class="line">  @Inject</span><br><span class="line">  MainPresenter() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void loadData() &#123;</span><br><span class="line">    baseView.showTipMsg(&quot;加载数据&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我需要说明的是注意继承BaseMvpPresenter传的是MainContract.IView，不是BaseView，实现MainContract.Presenter接口，还有一点就是注意构造方法，上面有注解，这里的loadData里面应该是我们的网络请求逻辑，这里我放到后面一篇在说，这里我先就直接Toast，表示走了这个方法</p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>&emsp;&emsp;就是MainActivity，这里我贴出代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.base.BaseMvpActivity;</span><br><span class="line">import com.haichenyi.myproject.contract.MainContract;</span><br><span class="line">import com.haichenyi.myproject.presenter.MainPresenter;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends BaseMvpActivity&lt;MainPresenter&gt; implements MainContract.IView &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected int getLayoutId(Bundle savedInstanceState) &#123;</span><br><span class="line">    return R.layout.activity_main;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void initData() &#123;</span><br><span class="line">    super.initData();</span><br><span class="line">    initToolbar(true, false, true).setMyTitle(&quot;主页&quot;).setMoreTitle(&quot;更多&quot;);</span><br><span class="line">    basePresenter.loadData();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void initInject() &#123;</span><br><span class="line">    getActivityComponent().inject(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我需要说明的是继承BaseMvpActivity，泛型直接传MainPresenter，然后，实现MainContract.IView接口，直接用basePresenter调用方法，需要实现initInject方法，只要是是继承BaseMvpActivity的activity，都需要在ActivityComponent()里面注册一边。比方说，LoginActivity也是继承的BaseMvpActivity，辣么，在di层的component包下面的ActivityComponent接口里面定义一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void inject(LoginActivity loginActivity);</span><br></pre></td></tr></table></figure><p>在LoginActivity的initInject方法里面写同样的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getActivityComponent().inject(this);</span><br></pre></td></tr></table></figure><p>就像这样写就可以了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;写到这里，mvp+dagger2基本上完成了，MVP的目的就是解藕，把业务逻辑，网络请求丢在P层，页面不发生变化，就只用改P层逻辑，从而达到了解藕的目的。dagger2简化了代码，并且，它有着全局单例模式，和局部单例模式，优化了我们的内存，减少了内存浪费。不用每次都去new一个P层对象出来。下一篇，我们就把网络请求加上</p><p><a href="http://download.csdn.net/download/qq_27634797/10256146" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;接着上一篇简单的框架，没有看过的同鞋可以去喵一眼。上一篇我们搭好了简单的框架，初始化一次的内容丢在Application里面，所有的activity继承一个类BaseActivity，还有Fragment继承的一个类BaseFragment&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个主流项目框架（一）—简单的框架</title>
    <link href="http://haichenyi.com/2018/02/23/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%B5%81%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E7%AE%80%E5%8D%95%E7%9A%84%E6%A1%86%E6%9E%B6/"/>
    <id>http://haichenyi.com/2018/02/23/从零开始搭建一个主流项目框架（一）—简单的框架/</id>
    <published>2018-02-23T12:30:11.000Z</published>
    <updated>2018-02-23T12:33:47.969Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>&emsp;&emsp;首先先说出，最终的目的是现在主流的MVP+RxJava+Retrofit+OkHttp框架。让大家心里有底</p><p>&emsp;&emsp;开发工具Android Studio3.0，还在用eclipse的同鞋，强烈推荐你跨出这一步，你会发现一个新的世界。android studio都出来这么久了，你还在远古时代做开发，说句不好听的，你完全与时代脱轨，你不适合做开发（纯属个人观点）</p><a id="more"></a><p>&emsp;&emsp;本篇就只有三部分，第一部分就是新建一个Application，第二部分就是BaseActivity，第三部分就是BaseFragment</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>&emsp;&emsp;首先你得有application类，去初始化应用只用初始化一次的内容，继承Application，然后在清单文件里面注册。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject;</span><br><span class="line"></span><br><span class="line">import android.app.Application;</span><br><span class="line"></span><br><span class="line">import com.squareup.leakcanary.LeakCanary;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line">  private static MyApplication instance;</span><br><span class="line"></span><br><span class="line">  public MyApplication getInstance() &#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void setInstance(MyApplication instance) &#123;</span><br><span class="line">    MyApplication.instance = instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    setInstance(this);</span><br><span class="line">    initLeakCanary();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 初始化内存检测工具</span><br><span class="line">   */</span><br><span class="line">  private void initLeakCanary() &#123;</span><br><span class="line">    if (LeakCanary.isInAnalyzerProcess(this)) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    LeakCanary.install(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上代码，我这里就初始化了一个全局application单例对象，还初始化square公司出品的一个内存检测工具，用于检测你项目中内存泄漏情况。便于你优化项目。</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-44c0f8e0ac459dbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="清单文件.png"></p><p>&emsp;&emsp;如上图所示，这个就是清单文件，在application结点下面，添加name标签，内容就是你创建的application的名字。这里你还需要添加两个内存检测的依赖。</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-6fb1ca45a82b3b14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构.png"></p><p>&emsp;&emsp;如上图所示，首先把你的项目结构视图切换到Project，打开你的app目录下的build.gradle文件，在dependencies结点下面（只要是添加开源库都是在该结点下面，后面就不说了），添加如下两行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">releaseImplementation &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;</span><br><span class="line">debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后的1.5.4是版本号，你可以在github上面搜索<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">leakcanary</a>，找最新的版本</p><h3 id="BaseActivity"><a href="#BaseActivity" class="headerlink" title="BaseActivity"></a>BaseActivity</h3><p>&emsp;&emsp;创建基类BaseActivity，也就是所有Activity的父类。还有一个基类的接口BaseView，BaseActivity继承刚才添加的依赖的SupportActivity类，实现BaseView接口，并且实现点击事件的接口（选择实现，你要是不乐意在基类里面写，你可以在你自己的子类里面重新实现一遍也是可以的）。代码如下：每个方法注释写的很清楚，就不用一一解释了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">import android.app.AlertDialog;</span><br><span class="line">import android.graphics.Color;</span><br><span class="line">import android.graphics.drawable.ColorDrawable;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.support.annotation.Nullable;</span><br><span class="line">import android.view.Window;</span><br><span class="line">import android.widget.ProgressBar;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.utils.ToastUtils;</span><br><span class="line"></span><br><span class="line">import me.yokeyword.fragmentation.SupportActivity;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public abstract class BaseActivity extends SupportActivity implements BaseView &#123;</span><br><span class="line">  private AlertDialog loadingDialog;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Toast 提示用户</span><br><span class="line">   * @param msg 提示内容String</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void showTipMsg(String msg) &#123;</span><br><span class="line">    ToastUtils.showTipMsg(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Toast 提示用户</span><br><span class="line">   * @param msg 提示内容res目录下面的String的int值</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void showTipMsg(int msg) &#123;</span><br><span class="line">    ToastUtils.showTipMsg(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 网络请求的时候显示正在加载的对话框</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void showLoading() &#123;</span><br><span class="line">    if (null == loadingDialog) &#123;</span><br><span class="line">      loadingDialog = new AlertDialog.Builder(this).setView(new ProgressBar(this)).create();</span><br><span class="line">      loadingDialog.setCanceledOnTouchOutside(false);</span><br><span class="line">      Window window = loadingDialog.getWindow();</span><br><span class="line">      if (null != window) &#123;</span><br><span class="line">        window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!loadingDialog.isShowing()) &#123;</span><br><span class="line">      loadingDialog.show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 网络请求完成时隐藏加载对话框</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void hideLoading() &#123;</span><br><span class="line">    if (null != loadingDialog) &#123;</span><br><span class="line">      if (loadingDialog.isShowing()) &#123;</span><br><span class="line">        loadingDialog.dismiss();</span><br><span class="line">      &#125;</span><br><span class="line">      loadingDialog = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void invalidToken() &#123;</span><br><span class="line">    //用于检测你当前用户的token是否有效，无效就返回登录界面，具体的业务逻辑你自己实现</span><br><span class="line">    //如果需要做到实时检测，推荐用socket长连接，每隔10秒发送一个验证当前登录用户token是否过期的请求</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Finish当前页面，最好实现onBackPressedSupport()，这个方法会有一个退栈操作，</span><br><span class="line">   * 开源框架实现的，我们不用管</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void myFinish() &#123;</span><br><span class="line">    onBackPressedSupport();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onBackPressedSupport() &#123;</span><br><span class="line">    super.onBackPressedSupport();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面是目前BaseActivity代码，注释写的很清楚，你会发现BaseView你并没有，下面我给出BaseView的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">import android.support.annotation.StringRes;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public interface BaseView &#123;</span><br><span class="line">  void showTipMsg(String msg);</span><br><span class="line"></span><br><span class="line">  void showTipMsg(@StringRes int msg);</span><br><span class="line"></span><br><span class="line">  void showLoading();</span><br><span class="line"></span><br><span class="line">  void hideLoading();</span><br><span class="line"></span><br><span class="line">  void invalidToken();</span><br><span class="line"></span><br><span class="line">  void myFinish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;BaseView就是一个接口，是所有V层的基类，代码很简单，Toast方法，显示隐藏加载的对话框方法，检验token是否过期的方法，finish当前页面的方法。什么？Toast方法你没有，下面我贴出来我的Toast的工具类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc: 实时更新的Toast工具类</span><br><span class="line"> */</span><br><span class="line">public final class ToastUtils &#123;</span><br><span class="line">  private static Toast toast;</span><br><span class="line"></span><br><span class="line">  private ToastUtils() &#123;</span><br><span class="line">    throw new RuntimeException(&quot;工具类不允许创建对象&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;all&quot;)</span><br><span class="line">  private static void init() &#123;</span><br><span class="line">    if (toast == null) &#123;</span><br><span class="line">      toast = Toast.makeText(MyApplication.getInstance(), &quot;&quot;, Toast.LENGTH_SHORT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void showTipMsg(String msg) &#123;</span><br><span class="line">    if (null == toast) &#123;</span><br><span class="line">      init();</span><br><span class="line">    &#125;</span><br><span class="line">    toast.setText(msg);</span><br><span class="line">    toast.show();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void showTipMsg(@StringRes int msg) &#123;</span><br><span class="line">    if (null == toast) &#123;</span><br><span class="line">      init();</span><br><span class="line">    &#125;</span><br><span class="line">    toast.setText(msg);</span><br><span class="line">    toast.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面我贴出了三个类，这里我要说明的是，我又创建了两个package，一个是base，一个是utils，我把BaseActivity,BaseView,MyApplication放在base包下面，Toast的工具类放在utils包下面</p><p>&emsp;&emsp;再就是添加一些常用的东西了，这里我没有用黄油刀，用过一段时间之后，感觉他的每个控件都是全局的，有点占内存，就放弃了。我下面贴出BaseActivity新增的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 保存当前activity对象，在OnCreate里面添加，记得在OnDestroy里面移除</span><br><span class="line">   * 有什么用呢？</span><br><span class="line">   * 比方说有一个需求，让你在任意位置弹出对话框，弹对话框又需要一个context对象，这个时候，</span><br><span class="line">   * 你就只用传当前list的最上层的activity对象就可以了</span><br><span class="line">   * 当然还有其他需求</span><br><span class="line">   */</span><br><span class="line">  public static List&lt;BaseActivity&gt; activities = new ArrayList&lt;&gt;();</span><br><span class="line">  private Toolbar toolbar;</span><br><span class="line">  private TextView tvToolbarTitle;</span><br><span class="line">  private TextView tvToolbarRight;</span><br><span class="line">  private TextView tvBack;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    activities.add(this);</span><br><span class="line">    //强制竖屏(不强制加)</span><br><span class="line">    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br><span class="line">    int layoutId = getLayoutId(savedInstanceState);</span><br><span class="line">    View inflate = getLayoutInflater().inflate(R.layout.activity_base, toolbar, false);</span><br><span class="line">    LinearLayout rootLinearLayout = inflate.findViewById(R.id.ll_layout_base_activity);</span><br><span class="line">    //没有布局的时候传0</span><br><span class="line">    if (0 == layoutId) &#123;</span><br><span class="line">      setContentView(rootLinearLayout);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      View rootView = getLayoutInflater().inflate(layoutId, rootLinearLayout, true);</span><br><span class="line">      setContentView(rootView);</span><br><span class="line">    &#125;</span><br><span class="line">    stateBar();</span><br><span class="line">    initView();</span><br><span class="line">    initData();</span><br><span class="line">    setOnClick(R.id.tv_back_base_activity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置点击事件.</span><br><span class="line">   *</span><br><span class="line">   * @param ids 被点击View的ID</span><br><span class="line">   * @return &#123;@link BaseActivity&#125;</span><br><span class="line">   */</span><br><span class="line">  public BaseActivity setOnClick(@IdRes int... ids) &#123;</span><br><span class="line">    View view;</span><br><span class="line">    for (int id : ids) &#123;</span><br><span class="line">      view = findViewById(id);</span><br><span class="line">      if (null != view) &#123;</span><br><span class="line">        view.setOnClickListener(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置点击事件.</span><br><span class="line">   *</span><br><span class="line">   * @param views 被点击View</span><br><span class="line">   * @return &#123;@link BaseActivity&#125;</span><br><span class="line">   */</span><br><span class="line">  public BaseActivity setOnClick(View... views) &#123;</span><br><span class="line">    for (View view : views) &#123;</span><br><span class="line">      view.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 获取当前布局对象</span><br><span class="line">   *</span><br><span class="line">   * @param savedInstanceState 这个是当前activity保存的数据，最常见的就是横竖屏切换的时候，</span><br><span class="line">   *                           数据丢失问题</span><br><span class="line">   * @return 当前布局的int值</span><br><span class="line">   */</span><br><span class="line">  protected abstract int getLayoutId(Bundle savedInstanceState);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDestroy() &#123;</span><br><span class="line">    activities.remove(this);</span><br><span class="line">    super.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected void initData() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected void initView() &#123;</span><br><span class="line">    toolbar = findViewById(R.id.toolbar_base_activity);</span><br><span class="line">    tvToolbarTitle = findViewById(R.id.tv_title_base_activity);</span><br><span class="line">    tvToolbarRight = findViewById(R.id.tv_right_base_activity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置状态栏背景颜色，不能改变状态栏内容的颜色</span><br><span class="line">   */</span><br><span class="line">  private void stateBar() &#123;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">    &#125;</span><br><span class="line">    SystemBarTintManager tintManager = new SystemBarTintManager(this);</span><br><span class="line">    tintManager.setStatusBarTintEnabled(true);</span><br><span class="line">    tintManager.setNavigationBarTintEnabled(true);</span><br><span class="line">    tintManager.setTintColor(Color.parseColor(&quot;#000000&quot;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">    switch (v.getId()) &#123;</span><br><span class="line">      case R.id.tv_back_base_activity:</span><br><span class="line">        onBackPressedSupport();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我需要说明的是，新增了一个开源框架，就是设置状态栏背景颜色的<a href="https://github.com/jgilfelt/SystemBarTint" target="_blank" rel="noopener">systembartint</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.readystatesoftware.systembartint:systembartint:1.0.3&apos;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再就是设置activity标题内容，左边，右边的内容，左边右边可能是文字，也可能是图片。所以，我在用的时候，都是用的TextView，ImageView，不能设置文字。方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public BaseActivity setTitles(CharSequence title) &#123;</span><br><span class="line">    tvToolbarTitle.setText(title);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 初始化toolbar的内容</span><br><span class="line">   * @param isShowToolbar 是否显示toolbar</span><br><span class="line">   * @param isShowBack 是否显示左边的TextView</span><br><span class="line">   * @param isShowMore 是否显示右边的TextView</span><br><span class="line">   * @return 当前activity对象，可以连点</span><br><span class="line">   */</span><br><span class="line">  protected BaseActivity initToolbar(boolean isShowToolbar, boolean isShowBack,</span><br><span class="line">                                     boolean isShowMore) &#123;</span><br><span class="line">    setSupportActionBar(toolbar);</span><br><span class="line">    ActionBar actionBar = getSupportActionBar();</span><br><span class="line">    if (null != actionBar) &#123;</span><br><span class="line">      if (isShowToolbar) &#123;</span><br><span class="line">        actionBar.show();</span><br><span class="line">        tvBack = findViewById(R.id.tv_back_base_activity);</span><br><span class="line">        TextView textView = findViewById(R.id.tv_right_base_activity);</span><br><span class="line">        if (null != tvBack &amp;&amp; null != textView) &#123;</span><br><span class="line">          tvBack.setVisibility(isShowBack ? View.VISIBLE : View.INVISIBLE);</span><br><span class="line">          textView.setVisibility(isShowMore ? View.VISIBLE : View.INVISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        actionBar.hide();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BaseActivity setToolbarBack(int colorId) &#123;</span><br><span class="line">    toolbar.setBackgroundColor(getResources().getColor(colorId));</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">  public BaseActivity setMyTitle(String title) &#123;</span><br><span class="line">    tvToolbarTitle.setText(title);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BaseActivity setMyTitle(@StringRes int stringId) &#123;</span><br><span class="line">    tvToolbarTitle.setText(stringId);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setMoreTitle(String moreTitle) &#123;</span><br><span class="line">    tvToolbarRight.setText(moreTitle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public BaseActivity setMoreTitle(@StringRes int stringId) &#123;</span><br><span class="line">    tvToolbarRight.setText(stringId);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置左边内容.</span><br><span class="line">   *</span><br><span class="line">   * @param leftTitle 内容</span><br><span class="line">   * @return &#123;@link BaseActivity&#125;</span><br><span class="line">   */</span><br><span class="line">  public BaseActivity setLeftTitle(String leftTitle) &#123;</span><br><span class="line">    if (tvBack != null) &#123;</span><br><span class="line">      tvBack.setBackground(null);</span><br><span class="line">      tvBack.setText(leftTitle);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置左边内容.</span><br><span class="line">   *</span><br><span class="line">   * @param leftTitle 内容</span><br><span class="line">   */</span><br><span class="line">  public void setLeftTitle(@StringRes int leftTitle) &#123;</span><br><span class="line">    if (tvBack != null) &#123;</span><br><span class="line">      tvBack.setBackground(null);</span><br><span class="line">      tvBack.setText(leftTitle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">  protected BaseActivity setMoreBackground(int resId) &#123;</span><br><span class="line">    tvToolbarRight.setBackgroundResource(resId);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到上面的方法返回值都是BaseActivity，这样做的目的就只有一个，可以连点，写一个方法之后，可以接着点写下一个方法，不用写一个方法就要加分号，就换一行写下一个方法。</p><p>&emsp;&emsp;还要加一句，在你的app主题里面添加两个item，也就是你的res目录下面的style：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;</span><br><span class="line">&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我这里贴出我目前的style的图片</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-3d1615eeaef01d7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="style.png"></p><p>&emsp;&emsp;下面有一个LineHorizontal样式，就是你toolbar下面的那个横线</p><h3 id="BaseFragment"><a href="#BaseFragment" class="headerlink" title="BaseFragment"></a>BaseFragment</h3><p>&emsp;&emsp;BaseFragment跟BaseActivity的逻辑是差不多的，我这里就贴出代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.myproject.base;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.support.annotation.IdRes;</span><br><span class="line">import android.support.annotation.NonNull;</span><br><span class="line">import android.support.annotation.Nullable;</span><br><span class="line">import android.view.LayoutInflater;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.myproject.utils.ToastUtils;</span><br><span class="line"></span><br><span class="line">import me.yokeyword.fragmentation.SupportFragment;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/2/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public abstract class BaseFragment extends SupportFragment implements BaseView,</span><br><span class="line">    View.OnClickListener &#123;</span><br><span class="line">  protected boolean isInit;</span><br><span class="line">  private View rootView;</span><br><span class="line"></span><br><span class="line">  @Nullable</span><br><span class="line">  @Override</span><br><span class="line">  public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,</span><br><span class="line">                           @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    int layoutRes = layoutRes();</span><br><span class="line">    if (0 != layoutRes) &#123;</span><br><span class="line">      return inflater.inflate(layoutRes, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return super.onCreateView(inflater, container, savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onViewCreated(view, savedInstanceState);</span><br><span class="line">    rootView = view;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onLazyInitView(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onLazyInitView(savedInstanceState);</span><br><span class="line">    isInit = true;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected &lt;T extends View&gt; T findViewById(@IdRes int id) &#123;</span><br><span class="line">    return rootView.findViewById(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置点击事件.</span><br><span class="line">   *</span><br><span class="line">   * @param ids 被点击View的ID</span><br><span class="line">   * @return &#123;@link BaseFragment&#125;</span><br><span class="line">   */</span><br><span class="line">  public BaseFragment setOnClick(@IdRes int... ids) &#123;</span><br><span class="line">    for (int id : ids) &#123;</span><br><span class="line">      rootView.findViewById(id).setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 设置点击事件.</span><br><span class="line">   *</span><br><span class="line">   * @param views 被点击View的ID</span><br><span class="line">   * @return &#123;@link BaseFragment&#125;</span><br><span class="line">   */</span><br><span class="line">  public BaseFragment setOnClick(View... views) &#123;</span><br><span class="line">    for (View view : views) &#123;</span><br><span class="line">      view.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void init();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onDestroy() &#123;</span><br><span class="line">    rootView = null;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract int layoutRes();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void showTipMsg(String msg) &#123;</span><br><span class="line">    ToastUtils.showTipMsg(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void showTipMsg(int msg) &#123;</span><br><span class="line">    ToastUtils.showTipMsg(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void showLoading() &#123;</span><br><span class="line">    BaseActivity activity = (BaseActivity) getActivity();</span><br><span class="line">    /*if (activity instanceof BaseMvpActivity) &#123;</span><br><span class="line">      activity.showLoading();</span><br><span class="line">    &#125;*/</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void hideLoading() &#123;</span><br><span class="line">    BaseActivity activity = (BaseActivity) getActivity();</span><br><span class="line">    /*if (activity instanceof BaseMvpActivity) &#123;</span><br><span class="line">      activity.hideLoading();</span><br><span class="line">    &#125;*/</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void invalidToken() &#123;</span><br><span class="line">    BaseActivity activity = (BaseActivity) getActivity();</span><br><span class="line">    /*if (activity instanceof BaseMvpActivity) &#123;</span><br><span class="line">      activity.invalidToken();</span><br><span class="line">    &#125;*/</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void myFinish() &#123;</span><br><span class="line">    onBackPressedSupport();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;两者在布局抽象方法里面有一点区别，Activity的传了Boundle参数，Fragment没有传，因为Fragment可以通过getArguments()方法获取到这个对象，而Activity不能获取到。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;到此，一个简单的项目框架就出来了，目前还是框架的第一步，是一个雏形，还不包括MVP，dagger等等，下一篇就加上MVP，我这个人有个好习惯，就是喜欢写注释，我注释写的很清楚，是干什么用的，我也衷心的希望，你能写好注释。</p><p><a href="http://download.csdn.net/download/qq_27634797/10256144" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;首先先说出，最终的目的是现在主流的MVP+RxJava+Retrofit+OkHttp框架。让大家心里有底&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;开发工具Android Studio3.0，还在用eclipse的同鞋，强烈推荐你跨出这一步，你会发现一个新的世界。android studio都出来这么久了，你还在远古时代做开发，说句不好听的，你完全与时代脱轨，你不适合做开发（纯属个人观点）&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>MVC、MVP、MVVM比较</title>
    <link href="http://haichenyi.com/2018/02/22/MVC%E3%80%81MVP%E3%80%81MVVM%E6%AF%94%E8%BE%83/"/>
    <id>http://haichenyi.com/2018/02/22/MVC、MVP、MVVM比较/</id>
    <published>2018-02-22T13:43:00.000Z</published>
    <updated>2018-02-22T13:48:18.240Z</updated>
    
    <content type="html"><![CDATA[<p>Android框架的最终目的，也是体现一个项目好坏的唯一标准——<strong>高类聚，低耦合</strong></p><a id="more"></a><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>&emsp;&emsp;我们刚接触android写代码的时候基本上都是MVC架构。什么是MVC架构呢？</p><p>&emsp;&emsp;MVC：Model View Controller的简称。流程图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-e7fc3f5706296a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mvc流程图.png"></p><p>&emsp;&emsp;当用户发出事件的时候，首先通过V层，通知C层，然后C层通知Model层数据发生了变化，更新数据，M层直接显示数据到V层。</p><p>&emsp;&emsp;通俗的讲，xml可以理解层View层，你封装的网络请求的帮助类理解成model层，activity，fragment理解成Controller层。这么理解是可以的，但是，你不能说xml就是view层，这样说是不对的</p><p>&emsp;&emsp;举个例子，比方说一个登录的网络请求，首先，你需要点击按钮去触发网络请求的方法，你点击的这个button就是写在xml布局里面的，这就是V层。然后触发的网络请求帮助类去发送对应的登录请求方法，这就是model层。两者是怎么联系在一起的呢？就是我们在activity，fragment层里面写的onclick方法。activity，fragment就是Controller层。</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>&emsp;&emsp;所有的UI变化，网络请求等等业务逻辑之类的都写在Activity里面，Activity既要处理业务逻辑，又要处理UI变化，代码就显得非常臃肿。</p><p>&emsp;&emsp;这个时候，MVP就顺势而生，什么是MVP架构呢？</p><p>&emsp;&emsp;MVP：Model View Presenter的简称</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-a146abe4db80cdf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MVP流程图.png"></p><p>&emsp;&emsp;MVP作为MVC的演化版本，解决了MVC不少的缺点，对于Android来说，MVP的M层，相对于MVC来说是一样的，而不一样的就是activity不再是controller，而是纯粹的V层，所有关于用户事件的转发，全都由P层去处理</p><p>&emsp;&emsp;MVP和MVC最明显的差别就是，M层和V层完全解藕，两者的通信是通过P层，P层作为桥梁，用于操作View层发送的事件到P层，P层去操作M层，并且，讲数据返回给V层。整个过层M层和V层两者完全没有联系。辣么，就有好奇的宝宝就问了，这样做解决不了更本问题，你这样做P层和V层不一样耦合在一起了吗？我们并不能完全不耦合，只是尽可能减少耦合度。我们写程序最终目的就是高类聚，低耦合，不是说完全不耦合。并且，我们这里P层和V层是通过接口通信的，如果网络请求逻辑发生变化，直接修改P层里面的代码，就可以了。V层完全不用改。如果业务逻辑发生变化，我们直接重新定义接口也非常方便</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>&emsp;&emsp;由微软提出来的—MVVM。什么是MVVM架构呢？</p><p>&emsp;&emsp;MVVM：Model View ViewModel</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-b41a65879e0e8d11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MVVM流程图.png"></p><p>&emsp;&emsp;一眼看上去更MVP差不多，只是把P层换成了ViewModel层。还有一点就是View层和ViewModel层是相互绑定的关系，当你更新ViewMdel层数据的时候，View层的UI就要相应的发生变化。</p><p>&emsp;&emsp;不管怎么说，三种模式的出现，或者说所有的开发模式，或者说是架构的出现，他们都有一个最终的目的，那就体现是一个项目架构好坏的：<strong>高类聚，低耦合</strong></p><p>&emsp;&emsp;学习成本，MVC最简单，弊端也是最多的，学起来也是最快的。MVP和MVVM两者都是MVC的演化版本，两者没法评论优缺点，各有千秋。MVP是目前最火的架构（-.-）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;吹了这么多，MVP有没有什么缺点呢？答案是肯定的：有。本人认为，MVP是目前已知框架最好的</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><p>P层比较臃肿，所有的逻辑代码，网络请求都丢在P层</p></li><li><p>接口很多，一个功能，相对于MVC来讲，需要多写很多代码</p></li><li><p>V层P层耦合度过于高，一旦视图需要变更，P层就要相应的发生变化</p></li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>解藕，这个不用说了</p></li><li><p>结构清晰明了，不会过了一个月就变成别人的代码</p></li><li><p>提高了维护性，功能出了问题，直接定位到接口，修改接口就行了</p></li><li><p>容易进行单元测试，虽然会用单元测试的人比较少</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android框架的最终目的，也是体现一个项目好坏的唯一标准——&lt;strong&gt;高类聚，低耦合&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
</feed>
