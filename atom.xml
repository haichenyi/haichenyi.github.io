<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haichenyi.com/"/>
  <updated>2018-02-22T13:48:18.240Z</updated>
  <id>http://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MVC、MVP、MVVM比较</title>
    <link href="http://haichenyi.com/2018/02/22/MVC%E3%80%81MVP%E3%80%81MVVM%E6%AF%94%E8%BE%83/"/>
    <id>http://haichenyi.com/2018/02/22/MVC、MVP、MVVM比较/</id>
    <published>2018-02-22T13:43:00.000Z</published>
    <updated>2018-02-22T13:48:18.240Z</updated>
    
    <content type="html"><![CDATA[<p>Android框架的最终目的，也是体现一个项目好坏的唯一标准——<strong>高类聚，低耦合</strong></p><a id="more"></a><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>&emsp;&emsp;我们刚接触android写代码的时候基本上都是MVC架构。什么是MVC架构呢？</p><p>&emsp;&emsp;MVC：Model View Controller的简称。流程图如下：<br><img src="http://upload-images.jianshu.io/upload_images/7041675-e7fc3f5706296a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mvc流程图.png"></p><p>&emsp;&emsp;当用户发出事件的时候，首先通过V层，通知C层，然后C层通知Model层数据发生了变化，更新数据，M层直接显示数据到V层。</p><p>&emsp;&emsp;通俗的讲，xml可以理解层View层，你封装的网络请求的帮助类理解成model层，activity，fragment理解成Controller层。这么理解是可以的，但是，你不能说xml就是view层，这样说是不对的</p><p>&emsp;&emsp;举个例子，比方说一个登录的网络请求，首先，你需要点击按钮去触发网络请求的方法，你点击的这个button就是写在xml布局里面的，这就是V层。然后触发的网络请求帮助类去发送对应的登录请求方法，这就是model层。两者是怎么联系在一起的呢？就是我们在activity，fragment层里面写的onclick方法。activity，fragment就是Controller层。</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>&emsp;&emsp;所有的UI变化，网络请求等等业务逻辑之类的都写在Activity里面，Activity既要处理业务逻辑，又要处理UI变化，代码就显得非常臃肿。</p><p>&emsp;&emsp;这个时候，MVP就顺势而生，什么是MVP架构呢？</p><p>&emsp;&emsp;MVP：Model View Presenter的简称</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-a146abe4db80cdf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MVP流程图.png"></p><p>&emsp;&emsp;MVP作为MVC的演化版本，解决了MVC不少的缺点，对于Android来说，MVP的M层，相对于MVC来说是一样的，而不一样的就是activity不再是controller，而是纯粹的V层，所有关于用户事件的转发，全都由P层去处理</p><p>&emsp;&emsp;MVP和MVC最明显的差别就是，M层和V层完全解藕，两者的通信是通过P层，P层作为桥梁，用于操作View层发送的事件到P层，P层去操作M层，并且，讲数据返回给V层。整个过层M层和V层两者完全没有联系。辣么，就有好奇的宝宝就问了，这样做解决不了更本问题，你这样做P层和V层不一样耦合在一起了吗？我们并不能完全不耦合，只是尽可能减少耦合度。我们写程序最终目的就是高类聚，低耦合，不是说完全不耦合。并且，我们这里P层和V层是通过接口通信的，如果网络请求逻辑发生变化，直接修改P层里面的代码，就可以了。V层完全不用改。如果业务逻辑发生变化，我们直接重新定义接口也非常方便</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>&emsp;&emsp;由微软提出来的—MVVM。什么是MVVM架构呢？</p><p>&emsp;&emsp;MVVM：Model View ViewModel</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-b41a65879e0e8d11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MVVM流程图.png"></p><p>&emsp;&emsp;一眼看上去更MVP差不多，只是把P层换成了ViewModel层。还有一点就是View层和ViewModel层是相互绑定的关系，当你更新ViewMdel层数据的时候，View层的UI就要相应的发生变化。</p><p>&emsp;&emsp;不管怎么说，三种模式的出现，或者说所有的开发模式，或者说是架构的出现，他们都有一个最终的目的，那就体现是一个项目架构好坏的：<strong>高类聚，低耦合</strong></p><p>&emsp;&emsp;学习成本，MVC最简单，弊端也是最多的，学起来也是最快的。MVP和MVVM两者都是MVC的演化版本，两者没法评论优缺点，各有千秋。MVP是目前最火的架构（-.-）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;吹了这么多，MVP有没有什么缺点呢？答案是肯定的：有。本人认为，MVP是目前已知框架最好的</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><p>P层比较臃肿，所有的逻辑代码，网络请求都丢在P层</p></li><li><p>接口很多，一个功能，相对于MVC来讲，需要多写很多代码</p></li><li><p>V层P层耦合度过于高，一旦视图需要变更，P层就要相应的发生变化</p></li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>解藕，这个不用说了</p></li><li><p>结构清晰明了，不会过了一个月就变成别人的代码</p></li><li><p>提高了维护性，功能出了问题，直接定位到接口，修改接口就行了</p></li><li><p>容易进行单元测试，虽然会用单元测试的人比较少</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android框架的最终目的，也是体现一个项目好坏的唯一标准——&lt;strong&gt;高类聚，低耦合&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Android事件分发机制原理</title>
    <link href="http://haichenyi.com/2018/02/22/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://haichenyi.com/2018/02/22/Android事件分发机制原理/</id>
    <published>2018-02-22T13:30:11.000Z</published>
    <updated>2018-02-22T13:51:55.865Z</updated>
    
    <content type="html"><![CDATA[<p>推荐：<a href="http://www.gcssloop.com/#blog" target="_blank" rel="noopener">非著名程序员</a>的<a href="http://www.gcssloop.com/customview/CustomViewIndex" target="_blank" rel="noopener">安卓自定义View教程目录</a>，我的自定义view就是看他的这个系列学会的</p><p>&emsp;&emsp;首先，我们需要确认的是android的事件传递机制是<strong>责任链模式</strong>，如果自己能处理就拦截下来自己处理，如果自己处理不了或者不确定就传递给下一个对象</p><a id="more"></a><h2 id="事件的拦截、分发、消费"><a href="#事件的拦截、分发、消费" class="headerlink" title="事件的拦截、分发、消费"></a>事件的拦截、分发、消费</h2><p>&emsp;&emsp;我们要知道三个方法，控制事件反而拦截，分发与消费。如下表：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">相关方法</th><th style="text-align:center">Activity</th><th style="text-align:center">ViewGroup</th><th style="text-align:center">View</th></tr></thead><tbody><tr><td style="text-align:center">事件分发</td><td style="text-align:center">dispatchTouchEvent</td><td style="text-align:center">有</td><td style="text-align:center">有</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">事件拦截</td><td style="text-align:center">onInterceptTouchEvent</td><td style="text-align:center">无</td><td style="text-align:center">有</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">事件处理</td><td style="text-align:center">onTouchEvent</td><td style="text-align:center">有</td><td style="text-align:center">有</td><td style="text-align:center">有</td></tr></tbody></table><p>以上三个方法，均有boolean类型的返回值，通过设置true，false来控制事件传递的流程</p><p>Activity和View均没有事件拦截方法，是因为</p><ol><li><p>Activity作为事件响应起点，如果，Activity把事件拦截了，辣么将为导致整个屏幕都无法点击</p></li><li><p>View作为事件响应的最末端，要么消费事件，要么不处理回传，没必要拦截事件</p></li></ol><h2 id="事件分发流程"><a href="#事件分发流程" class="headerlink" title="事件分发流程"></a>事件分发流程</h2><p>&emsp;&emsp;先给出一张图<img src="http://upload-images.jianshu.io/upload_images/7041675-9b8401bc04e365de.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分发流程"></p><p>&emsp;&emsp;这里，我们看到多了两个东西，一个是PhoneWindow，一个是DecorView，我们平时写的布局，最外层的父布局就是这里的RootView，有过几个app开发经验的程序员都应该知道，app的状态栏颜色的修改，还有那个主题的内容修改，修改后显示在哪呢？没错，就是DecorView里面。</p><p>&emsp;&emsp;再有就是phoneWindow，其实，知不知道没什么用，phonewindow是Window的唯一实现类，Window是干嘛的呢？Window是一个抽象类，所有的视图，事件传递都归它管理，所以，phonewindow管理视图，上面说的DecorView就是phonewindow的一个内部实现类，除了自己的功能外，还负责消息传递。</p><p>&emsp;&emsp;说了这么多，该来讲讲事件传递的流程了。android的view是树形结构的，基于这样的结构，我们的事件可以有序的分发。事件收集之后，起点是Activity，然后有序的向下传递，大致如下：</p><p><code>Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View</code></p><p>如果这个事件没有对象处理，辣么，它会依次往回传递，如果还是没有人处理，辣么就会被Activity抛弃掉</p><p><code>Activity &lt;－ PhoneWindow &lt;－ DecorView &lt;－ ViewGroup &lt;－ ... &lt;－ View</code></p><p>这就是文章开头我们提到的，责任链模式</p><p>下面我给出ViewGroup的事件分发机制的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    boolean result = false;             // 默认状态为没有消费过</span><br><span class="line"></span><br><span class="line">    if (!onInterceptTouchEvent(ev)) &#123;   // 如果没有拦截交给子View</span><br><span class="line">        result = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!result) &#123;                      // 如果事件没有被消费,询问自身onTouchEvent</span><br><span class="line">        result = onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;情景：老板: 我看公司最近业务不咋地，准备发展一下电商业务，下周之前做个淘宝出来试试怎么样。<br>&emsp;&emsp;事件顺序，老板(MainActivity)要做淘宝，这个事件通过各个部门(ViewGroup)一层一层的往下传，传到最底层的时候，码农小王(View1)发现做不了，于是消息又一层一层的回传到老板那里。<br>&emsp;&emsp;可以看到整个事件传递路线非常有序。从Activity开始，最后回传给Activity结束(由于我们无法操作Phone Window和DecorView，所以没有它们的信息)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MainActivity [老板]: dispatchTouchEvent     经理,我准备发展一下电商业务,下周之前做一个淘宝出来.</span><br><span class="line">RootView     [经理]: dispatchTouchEvent     呼叫技术部,老板要做淘宝,下周上线.</span><br><span class="line">RootView     [经理]: onInterceptTouchEvent  (老板可能疯了,但又不是我做.)</span><br><span class="line">ViewGroupA   [组长]: dispatchTouchEvent     老板要做淘宝,下周上线?</span><br><span class="line">ViewGroupA   [组长]: onInterceptTouchEvent  (看着不太靠谱,先问问小王怎么看)</span><br><span class="line">View1        [码农]: dispatchTouchEvent     做淘宝???</span><br><span class="line">View1        [码农]: onTouchEvent           这个真心做不了啊.</span><br><span class="line">ViewGroupA   [组长]: onTouchEvent           小王说做不了.</span><br><span class="line">RootView     [经理]: onTouchEvent           报告老板, 技术部说做不了.</span><br><span class="line">MainActivity [老板]: onTouchEvent           这么简单都做不了,你们都是干啥的(愤怒).</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事件分发机制设计到到情形非常多，这里就不一一列举了，记住以下几条原则就行了。</p><ol><li><p>如果事件被消费，就意味着事件信息传递终止。</p></li><li><p>如果事件一直没有被消费，最后会传给Activity，如果Activity也不需要就被抛弃。</p></li><li><p>判断事件是否被消费是根据返回值，而不是根据你是否使用了事件。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐：&lt;a href=&quot;http://www.gcssloop.com/#blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;非著名程序员&lt;/a&gt;的&lt;a href=&quot;http://www.gcssloop.com/customview/CustomViewIndex&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安卓自定义View教程目录&lt;/a&gt;，我的自定义view就是看他的这个系列学会的&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先，我们需要确认的是android的事件传递机制是&lt;strong&gt;责任链模式&lt;/strong&gt;，如果自己能处理就拦截下来自己处理，如果自己处理不了或者不确定就传递给下一个对象&lt;/p&gt;
    
    </summary>
    
      <category term="Android -自定义view" scheme="http://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>Android自定义View</title>
    <link href="http://haichenyi.com/2018/02/08/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <id>http://haichenyi.com/2018/02/08/Android自定义View/</id>
    <published>2018-02-08T13:55:20.000Z</published>
    <updated>2018-02-08T13:56:33.180Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android -自定义view" scheme="http://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>MVP+Dagger+RxJava+Retrofit+OkHttp的简单框架</title>
    <link href="http://haichenyi.com/2018/02/08/MVP-Dagger-RxJava-Retrofit-OkHttp%E7%9A%84%E7%AE%80%E5%8D%95%E6%A1%86%E6%9E%B6/"/>
    <id>http://haichenyi.com/2018/02/08/MVP-Dagger-RxJava-Retrofit-OkHttp的简单框架/</id>
    <published>2018-02-08T13:53:09.000Z</published>
    <updated>2018-02-08T13:59:05.461Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android -框架" scheme="http://haichenyi.com/categories/Android-%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Netty的简单使用，实现socket通讯</title>
    <link href="http://haichenyi.com/2018/02/08/Netty%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E8%AE%AF/"/>
    <id>http://haichenyi.com/2018/02/08/Netty的简单使用，实现socket通讯/</id>
    <published>2018-02-08T13:46:05.000Z</published>
    <updated>2018-02-22T12:59:18.347Z</updated>
    
    <content type="html"><![CDATA[<p>自从用了netty框架，妈妈再也不用担心我的socket通讯了<br><a id="more"></a><br>&emsp;&emsp;题外话，很多人都把JDK1.4提供的NIO称之为异步非阻塞I/O；其实，并不然，从严格意义上面讲，它只能称为非阻塞I/O。在JDK1.7提供的NIO 2.0，新增了异步的套接字通道Channel，它才是真正的异步非阻塞I/O。下表是不同I/O模型的对比：</p><p>表1-1 几种I/O模型和同能对比</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">同步阻塞I/O(BIO)</th><th style="text-align:center">伪异步I/O</th><th style="text-align:center">非阻塞I/O(NIO)</th><th style="text-align:center">异步I/O(AIO)</th></tr></thead><tbody><tr><td style="text-align:center">客户端个数：I/O线程</td><td style="text-align:center">1:1</td><td style="text-align:center">M:N(M可以大于N)</td><td style="text-align:center">M:1(1个I/O线程处理多个客户端连接)</td><td style="text-align:center">M:0(不需要启动额外的I/O线程，被动回调)</td></tr><tr><td style="text-align:center">I/O类型(阻塞)</td><td style="text-align:center">阻塞I/O</td><td style="text-align:center">阻塞I/O</td><td style="text-align:center">非阻塞I/O</td><td style="text-align:center">非阻塞I/O</td></tr><tr><td style="text-align:center">I/O类型(同步)</td><td style="text-align:center">同步I/O</td><td style="text-align:center">同步I/O</td><td style="text-align:center">同步I/O(I/O多路复用)</td><td style="text-align:center">异步I/O</td></tr><tr><td style="text-align:center">API使用难度</td><td style="text-align:center">简单</td><td style="text-align:center">简单</td><td style="text-align:center">非常复杂</td><td style="text-align:center">复杂</td></tr><tr><td style="text-align:center">调试难度</td><td style="text-align:center">简单</td><td style="text-align:center">简单</td><td style="text-align:center">复杂</td><td style="text-align:center">复杂</td></tr><tr><td style="text-align:center">可靠性</td><td style="text-align:center">非常差</td><td style="text-align:center">差</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">吞吐量</td><td style="text-align:center">低</td><td style="text-align:center">中</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;Netty是由<a href="https://baike.baidu.com/item/JBOSS" target="_blank" rel="noopener">JBOSS</a>提供的一个<a href="https://baike.baidu.com/item/java%E5%BC%80%E6%BA%90" target="_blank" rel="noopener">java开源</a>框架。Netty提供异步的、<a href="https://baike.baidu.com/item/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8" target="_blank" rel="noopener">事件驱动</a>的网络应用程序框架和工具，用以快速开发高性能、高可靠性的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">网络服务器</a>和客户端程序。</p><p>&emsp;&emsp;也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E7%AB%AF" target="_blank" rel="noopener">服务端</a>应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。</p><p>&emsp;&emsp;“快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。——百度百科</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p>API使用简单，开发门槛低</p></li><li><p>功能强大，预置了多种编解码功能，支持多种主流协议</p></li><li><p>性能高，通过与业界其他主流NIO框架相比，netty的综合性能最高</p></li><li><p>成熟，稳定，Netty已经修复了已经发现的所有的JDK NIO BUG，业务开发人员不用再为NIO的bug而烦恼</p></li><li><p>社区活跃，版本迭代周期短，发现bug可以及时被修复，同时有更多的新功能加入</p></li><li><p>经历了大规模的商界业务考验，只能得到了验证</p></li></ol><h2 id="粘包、拆包"><a href="#粘包、拆包" class="headerlink" title="粘包、拆包"></a>粘包、拆包</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>&emsp;&emsp;TCP是一个流协议，所谓的流，就是没有界限的一串数据。可以考虑河里的流水，他们并没有界限。tcp底层并不了解业务层数据的具体含义，他会根据tcp缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被tcp拆分成多个包进行发送，也可能把多个小包封装成一个大数据一起发送，这就是所谓的tcp粘包，拆包问题</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ol><li><p>应用程序write写入的字节大小大于套接口发送缓冲区的大小</p></li><li><p>进行MSS大小的tcp分段</p></li><li><p>以太网帧的payload大于MTU进行IP分片</p></li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li><p>消息定长，每个报文大小固定长度，不够的补0</p></li><li><p>包尾增加回车换行符进行分割。例如：FTP协议</p></li><li><p>将消息分为消息头和消息体。消息头中包含消息的总长度字段</p></li><li><p>更复杂的应用层协议</p></li></ol><h3 id="Netty框架的解决办法"><a href="#Netty框架的解决办法" class="headerlink" title="Netty框架的解决办法"></a>Netty框架的解决办法</h3><p>&emsp;&emsp;LineBasedFrameDecoder和StringDecoder两个类</p><h4 id="LineBasedFrameDecoder"><a href="#LineBasedFrameDecoder" class="headerlink" title="LineBasedFrameDecoder"></a>LineBasedFrameDecoder</h4><p>&emsp;&emsp;LineBasedFrameDecoder的工作原理是依次遍历ByteBuf中的可读字节，判断看是否有”\r”或者”\r\n”，如果有就以此为结束位置，从可读索引位置到结束区间的字节就组成了一行。他是以换行符为结束标志的解码器，支持携带结束符和不带结束符两种解码方式。同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读取的异常流</p><h4 id="StringDecoder"><a href="#StringDecoder" class="headerlink" title="StringDecoder"></a>StringDecoder</h4><p>&emsp;&emsp;StringDecoder的功能就非常简单，就是将接收到的对象换成字符串，然后继续调用后面的handler，LineBasedFrameDecoder+StringDecoder组合就是按换行符切换文本解码器，他被设计用来支持TCP粘包和拆包。Netty支持其他其他符号的解码器(DelimiterBasedFrameDecode)</p><p>&emsp;&emsp;说了这么多，代码来了，就是用Netty实现的心跳。对于懒癌晚期，已经风装好，可以直接拿过去用，注释也写的很清楚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import io.netty.bootstrap.Bootstrap;</span><br><span class="line">import io.netty.channel.Channel;</span><br><span class="line">import io.netty.channel.ChannelFuture;</span><br><span class="line">import io.netty.channel.ChannelInitializer;</span><br><span class="line">import io.netty.channel.ChannelOption;</span><br><span class="line">import io.netty.channel.ChannelPipeline;</span><br><span class="line">import io.netty.channel.EventLoopGroup;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line">import io.netty.handler.codec.LineBasedFrameDecoder;</span><br><span class="line">import io.netty.handler.codec.string.StringDecoder;</span><br><span class="line">import io.netty.handler.codec.string.StringEncoder;</span><br><span class="line">import io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 海晨忆</span><br><span class="line"> * @date 2018/2/6</span><br><span class="line"> * @desc</span><br><span class="line"> */</span><br><span class="line">public class SocketTcp &#123;</span><br><span class="line">  private static SocketTcp socketTcp = new SocketTcp();</span><br><span class="line">  private Channel channel = null;</span><br><span class="line">  private EventLoopGroup group;</span><br><span class="line">  private int port;</span><br><span class="line">  private String host;</span><br><span class="line"></span><br><span class="line">  public static SocketTcp getInstance() &#123;</span><br><span class="line">    return socketTcp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public SocketTcp setPort(int port) &#123;</span><br><span class="line">    this.port = port;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public SocketTcp setHost(String host) &#123;</span><br><span class="line">    this.host = host;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void connect() &#123;</span><br><span class="line">    if (channel != null) return;</span><br><span class="line">    if (group == null) &#123;</span><br><span class="line">      //NIO线程组</span><br><span class="line">      group = new NioEventLoopGroup();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;//配置Bootstrap</span><br><span class="line">      Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">      bootstrap.group(group)</span><br><span class="line">          .channel(NioSocketChannel.class)</span><br><span class="line">          .option(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">          .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">              //以换行符为结束标记</span><br><span class="line">              ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">              pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">              pipeline.addLast(new LineBasedFrameDecoder(Integer.MAX_VALUE));</span><br><span class="line">              pipeline.addLast(new StringDecoder());</span><br><span class="line">              pipeline.addLast(new MyHeartSocket());</span><br><span class="line"></span><br><span class="line">              //以&quot;$_&quot;作为分隔符</span><br><span class="line">              /*ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">              pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">              String s = &quot;$_&quot;;</span><br><span class="line">              ByteBuf byteBuf = Unpooled.copiedBuffer(s.getBytes());</span><br><span class="line">              pipeline.addLast(new DelimiterBasedFrameDecoder(Integer.MAX_VALUE,byteBuf));</span><br><span class="line">              pipeline.addLast(new StringDecoder());</span><br><span class="line">              pipeline.addLast(new MyHeartSocket());*/</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      //发起异步连接操作</span><br><span class="line">      ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line">      channel = channelFuture.channel();</span><br><span class="line">      //等待服务端监听端口关闭</span><br><span class="line">      channel.closeFuture().sync();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      disConnect();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 断开tcp连接.</span><br><span class="line">   */</span><br><span class="line">  private void disConnect() &#123;</span><br><span class="line">    if (null != group) &#123;</span><br><span class="line">      group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">    group = null;</span><br><span class="line">    channel = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void sendMessage(String msg) &#123;//连接成功后，通过Channel提供的接口进行IO操作</span><br><span class="line">    try &#123;</span><br><span class="line">      if (channel != null &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">        channel.writeAndFlush(msg).sync();</span><br><span class="line">        Log.d(&quot;wz&quot;, &quot;send succeed &quot; + msg);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reConnect();</span><br><span class="line">        throw new Exception(&quot;channel is null | closed&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      reConnect();</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 重连.</span><br><span class="line">   */</span><br><span class="line">  private void reConnect() &#123;</span><br><span class="line">    new Thread(this::connect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package com.example.zwang.myapplication.socket;</span><br><span class="line"></span><br><span class="line">import android.os.SystemClock;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import io.netty.buffer.ByteBuf;</span><br><span class="line">import io.netty.buffer.Unpooled;</span><br><span class="line">import io.netty.channel.ChannelHandlerContext;</span><br><span class="line">import io.netty.channel.EventLoop;</span><br><span class="line">import io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MyHeartSocket extends SimpleChannelInboundHandler&lt;Object&gt; &#123;</span><br><span class="line">  private ChannelHandlerContext ctx;</span><br><span class="line">  private boolean isConnect = false;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;连接正常messageReceived&quot;);</span><br><span class="line">    ByteBuf msg1 = (ByteBuf) msg;</span><br><span class="line">    byte[] bytes = new byte[msg1.readableBytes()];</span><br><span class="line">    msg1.readBytes(bytes);</span><br><span class="line">    String s = new String(bytes, &quot;UTF-8&quot;);</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;接收到的消息:&quot; + s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    super.channelActive(ctx);</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;连接正常channelActive&quot;);</span><br><span class="line">    isConnect = true;</span><br><span class="line">    if (this.ctx == null) &#123;</span><br><span class="line">      synchronized (MyHeartSocket.class) &#123;</span><br><span class="line">        if (this.ctx == null) &#123;</span><br><span class="line">          this.ctx = ctx;</span><br><span class="line">          MyAppHeart();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void MyAppHeart() &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      while (ctx != null &amp;&amp; isConnect) &#123;</span><br><span class="line">        String data = &quot;123&quot;;</span><br><span class="line">        byte[] bytes = data.getBytes();</span><br><span class="line">        if (isConnect) &#123;</span><br><span class="line">          ctx.writeAndFlush(Unpooled.buffer(bytes.length).writeBytes(bytes));</span><br><span class="line">          SystemClock.sleep(3000);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    EventLoop loop = ctx.channel().eventLoop();</span><br><span class="line">    loop.schedule(() -&gt; SocketTcp.getInstance().connect(), 5, TimeUnit.SECONDS);</span><br><span class="line">    super.channelInactive(ctx);</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;重新连接socket服务器&quot;);</span><br><span class="line">    isConnect = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">    super.userEventTriggered(ctx, evt);</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;发送数据包&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">    super.exceptionCaught(ctx, cause);</span><br><span class="line">    Log.v(&quot;WZ&quot;, &quot;连接出现异常&quot;);</span><br><span class="line">    this.ctx.close();</span><br><span class="line">    this.ctx = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从用了netty框架，妈妈再也不用担心我的socket通讯了&lt;br&gt;
    
    </summary>
    
      <category term="Android -Socket" scheme="http://haichenyi.com/categories/Android-Socket/"/>
    
    
  </entry>
  
  <entry>
    <title>IO编程和NIO编程简介</title>
    <link href="http://haichenyi.com/2018/02/07/IO%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://haichenyi.com/2018/02/07/IO编程和NIO编程简介/</id>
    <published>2018-02-07T12:49:47.000Z</published>
    <updated>2018-02-22T13:08:36.720Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;传统的同步阻塞I/O通讯模型，导致的结果就是只要有一方处理数据缓慢，都会影响另外一方的处理性能。按照故障设计原则，一方的处理出现问题，不应该影响到另外一方才对。但是，在同步阻塞的模式下面，这样的情况是无法避免的，很难通过业务层去解决。既然同步无法避免，为了避免就产生了异步。Netty框架就一个完全异步非阻塞的I/O通讯方式<br><a id="more"></a></p><h2 id="同步阻塞式I-O编程"><a href="#同步阻塞式I-O编程" class="headerlink" title="同步阻塞式I/O编程"></a>同步阻塞式I/O编程</h2><p>&emsp;&emsp;简单的来说，传统同步阻塞的I/O通讯模式，服务器端处理的方式是，每当有一个新用户接入的时候，就new一个新的线程，一个线程只能处理一个客户端的连接，在高性能方面，并发高的情景下无法满足。伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 海晨忆</span><br><span class="line"> * @date 2018/2/9</span><br><span class="line"> * @desc</span><br><span class="line"> */</span><br><span class="line">public class SocketServer &#123;</span><br><span class="line">  private int port = 8080;</span><br><span class="line">  private Socket socket = null;</span><br><span class="line"></span><br><span class="line">  public SocketServer(int port) &#123;</span><br><span class="line">    this.port = port;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void connect() &#123;</span><br><span class="line">    ServerSocket server = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      server = new ServerSocket(port);</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        socket = server.accept();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">            new TimerServerHandler(socket).run();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      //释放资源</span><br><span class="line">      if (server != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          server.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        server = null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 海晨忆</span><br><span class="line"> * @date 2018/2/9</span><br><span class="line"> * @desc</span><br><span class="line"> */</span><br><span class="line">public class TimerServerHandler implements Runnable &#123;</span><br><span class="line">  private Socket socket;</span><br><span class="line"></span><br><span class="line">  public TimerServerHandler(Socket socket) &#123;</span><br><span class="line">    this.socket = socket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    BufferedReader in = null;</span><br><span class="line">    PrintWriter out = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      in = new BufferedReader(new InputStreamReader(this.socket.getInputStream()));</span><br><span class="line">      out = new PrintWriter(this.socket.getOutputStream(), true);</span><br><span class="line">      String currentTime = null;</span><br><span class="line">      String body = null;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        body = in.readLine();</span><br><span class="line">        if (body == null)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      //释放in，out，socket资源</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个就是最原始的服务端IO的代码，这里我就给出的是最简化的，当有新的客户端接入的时候，服务端是怎么处理线程的，可以看出，每当有新的客户端接入的时候，总是回新创建一个线程去服务这个新的客户端</p><h2 id="伪异步式编程"><a href="#伪异步式编程" class="headerlink" title="伪异步式编程"></a>伪异步式编程</h2><p>&emsp;&emsp;后来慢慢演化出一个版本“伪异步”模型，新增加一个线程池或者消息队列，满足一个线程或者多个线程满足N个客户端，通过线程池可以灵活的调用线程资源。通过设置线程池的最大值，防止海量并发接入造成的线程耗尽，它的底层实现依然是同步阻塞模型，伪代码如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import com.example.zwang.mysocket.server.TimerServerHandler;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 海晨忆</span><br><span class="line"> * @date 2018/2/9</span><br><span class="line"> * @desc</span><br><span class="line"> */</span><br><span class="line">public class SocketServer &#123;</span><br><span class="line">  private int port = 8080;</span><br><span class="line">  private Socket socket = null;</span><br><span class="line"></span><br><span class="line">  public SocketServer(int port) &#123;</span><br><span class="line">    this.port = port;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void connect() &#123;</span><br><span class="line">    ServerSocket server = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      server = new ServerSocket(port);</span><br><span class="line">      TimeServerHandlerExecutePool executePool = new TimeServerHandlerExecutePool(50, 1000);</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        socket = server.accept();</span><br><span class="line">        executePool.execute(new TimerServerHandler(socket));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">      //释放资源</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author 海晨忆</span><br><span class="line"> * @date 2018/2/9</span><br><span class="line"> * @desc</span><br><span class="line"> */</span><br><span class="line">public class TimeServerHandlerExecutePool &#123;</span><br><span class="line">  private ExecutorService executor;</span><br><span class="line"></span><br><span class="line">  public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123;</span><br><span class="line">    executor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize,</span><br><span class="line">        120L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void execute(Runnable task) &#123;</span><br><span class="line">    executor.execute(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;“伪异步”的代码和传统同步的唯一区别就是在于，首先先创建了一个时间服务处理类的线程池，当有新的客户端接入的时候，先将socket请求封装成task，然后调用线程池的execute方法执行，从而避免了每一个新请求创建一个新线程。由于线程池和消息队列都是有限的，因此，无论客户端的并发量多大，它都不会导致线程个数过于大，而造成的内存溢出。相对于传统的同步阻塞，是一种改良。<br></p><p>&emsp;&emsp;但是他没有从更本上解决同步的问题，伪异步的问题在于，他还是有一方处理出现问题还是会影响到另一方。因为：</p><p>&emsp;&emsp;当对socket的输入流进行读取操作的时候，它会一直阻塞直到一下三种方式发生：  </p><ol><li><p>有数据可读  </p></li><li><p>可读数据已经读取完   </p></li><li><p>发生空指针或者I/O异常。  </p></li></ol><p>这意味者，当读取inputstream方处理速度缓慢(不管是什么原因造成的速度缓慢)，另一方会一直同步阻塞，直到这一方把数据处理完.</p><p>&emsp;&emsp;当调用outputstream的write方法写输出流的时候，它将会被阻塞，直到所有要发送的字节全部写入完毕，或者发生异常。学过TCP/IP相关知识的人都直到，当消息的接收方处理消息缓慢，不能及时的从TCP缓冲区读取数据，这将会导致发送方的TCP缓冲区的size一直减少，直到0.缓冲区为0，那么发消息的一方将无法将消息写入缓冲区，直到缓冲区的size大于0<br></p><p>&emsp;&emsp;通过以上。我们了解到读和写的操作都是同步阻塞的，阻塞的时间取决于对方的I/O线程的处理速度和网络I/O的传送速度。从本质上面看，我们无法保证对方的处理速度和网络传送速度。如果，我们的程序依靠与对方的处理速度，那么，他的可靠性将会非常差。</p><h2 id="NIO编程"><a href="#NIO编程" class="headerlink" title="NIO编程"></a>NIO编程</h2><p>&emsp;&emsp;官方叫法new I/O，也就是新的IO编程，更多的人喜欢称它为：Non-block IO即非阻塞IO。</p><p>&emsp;&emsp;与Socket和serverSocket类对应，NIO提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现，这两种都支持阻塞式编程和非阻塞式编程。开发人员可以根据自己的需求选择合适的编程模式。一般低负载，低并发的应用程序选择同步阻塞的方式以降低编程的复杂度。高负载，高并发的不用想了，非阻塞就是为了解决这个问题的</p><ol><li>缓冲区Buffer</li></ol><p>&emsp;&emsp;Buffer是一个对象，它包含一些写入或者读出的数据。再NIO中加入buffer对象，体现了新库和旧库的一个重要区别。在面向流的io中，可以直接把数据读取或者写入到stream对象中。在NIO库中，所有数据操作都是通过缓冲区处理的。</p><p>&emsp;&emsp;缓冲区实质上是一个数组，通常是一个字节数组（ByteBuffer），基本数据类型除了boolean没有，其他都有，如ShortBuffer,CharBuffer等等</p><ol><li>通道Channel</li></ol><p>&emsp;&emsp;Channel是一个通道，双向通道，网络数据都是通过Channel读取，写入的。是的，没错，Channel它既可以进行读操作，也可以进行写操作。而流只能是一个方向。只能读操作或者只能写操作，而channel是全双工，读写可以同时进行。channel可以分为两大类：网络读写的SelectableChannel和文件操作的FileChannel。我们前面提到的SocketChannel和ServerSocketChannel都是SelectableChannel的子类。</p><ol><li>多路复用器Selector</li></ol><p>&emsp;&emsp;selector多路复用器，他是java NIO编程的基础，熟练的掌握selector对于NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单的讲就是他会不断的轮询注册的channel，如果一个Channel发生了读写操作，这个Chnnel就会处于就绪状态，会被selector轮询出来，通过SelectorKey获取就绪Channel集合，进行后续的IO操作。一个selector对应多个Channel<br></p><p>&emsp;&emsp;由于原生NIO编码比较麻烦和复杂，我这里就给出了思路的伪代码。下一篇我们将用NIO中的Netty框架实现Socket通信，编码简单，一行代码解决烦人粘包、拆包问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 服务端nio过程的伪代码</span><br><span class="line">   *</span><br><span class="line">   * @param port 端口号</span><br><span class="line">   * @throws IOException IOException</span><br><span class="line">   */</span><br><span class="line">  private void init(int port) throws IOException &#123;</span><br><span class="line">    //第一步：打开ServerSocketChannel，用于监听客户端连接，它是所有客户端连接的父管道</span><br><span class="line">    ServerSocketChannel socketChannel = ServerSocketChannel.open();</span><br><span class="line">    //第二步：监听绑定端口，设置连接模式为非阻塞模式，</span><br><span class="line">    socketChannel.socket().bind(new InetSocketAddress(InetAddress.getByName(&quot;IP&quot;), port));</span><br><span class="line">    socketChannel.configureBlocking(false);</span><br><span class="line">    //第三步：创建Reactor线程，创建多路复用器，并启动线程。</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    new Thread().start();</span><br><span class="line">    //第四步：将ServerSocketChannel注册到Reactor线程的多路复用器上，监听accept事件</span><br><span class="line">    SelectionKey key = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/);</span><br><span class="line">    //第五步：多路复用器在线程run方法的无线循环体内轮询准备就绪的key</span><br><span class="line">    int num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">      SelectionKey next = it.next();</span><br><span class="line">      //deal with io event...</span><br><span class="line">    &#125;</span><br><span class="line">    //第六步：多路复用器检测到有新客户端接入，处理新的接入请求，完成TCP三次握手，建立物理链路</span><br><span class="line">    SocketChannel channel = socketChannel.accept();</span><br><span class="line">    //第七步：设置客户端为非阻塞模式</span><br><span class="line">    channel.configureBlocking(false);</span><br><span class="line">    channel.socket().setReuseAddress(true);</span><br><span class="line">    //第八步：将新接入的客户端注册到reactor线程的多路复用器上，监听读操作，读取客户端发送的消息</span><br><span class="line">    SelectionKey key1 = socketChannel.register(selector, SelectionKey.OP_ACCEPT/*,ioHandler*/);</span><br><span class="line">    //第九步：异步读取客户端消息到缓冲区，</span><br><span class="line">    /*int readNumber = channel.read(&quot;receivebuff&quot;);*/</span><br><span class="line">    //第十步：对byteBuffer进行编解码，如果有半包信息指针reset，继续读取到后续的报文，将解码成功消息封装成task，投递到业务线程池，进行业务逻辑编排</span><br><span class="line">    Object massage = null;</span><br><span class="line">    while (buff.hasRemain()) &#123;</span><br><span class="line">      buff.mark();</span><br><span class="line">      Object massage1 = decode(btyeBuffer);</span><br><span class="line">      if (massage1 == null) &#123;</span><br><span class="line">        byteBuffer.reset();</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      massageList.add(massage1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!byteBuffer.hasRemain()) &#123;</span><br><span class="line">      byteBuffer.clean();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      byteBuffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    if (massageList != null &amp;&amp; !massageList.isEmpty()) &#123;</span><br><span class="line">      for (Object massage3 : massageList)&#123;</span><br><span class="line">        handlerTask(massage3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //第十一步：将POJO对象encode成ByteBuff，调用SocketChannel的异步write接口，将异步消息发送到客户端</span><br><span class="line">    socketChannel.write(buffer);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;传统的同步阻塞I/O通讯模型，导致的结果就是只要有一方处理数据缓慢，都会影响另外一方的处理性能。按照故障设计原则，一方的处理出现问题，不应该影响到另外一方才对。但是，在同步阻塞的模式下面，这样的情况是无法避免的，很难通过业务层去解决。既然同步无法避免，为了避免就产生了异步。Netty框架就一个完全异步非阻塞的I/O通讯方式&lt;br&gt;
    
    </summary>
    
      <category term="Android -Socket" scheme="http://haichenyi.com/categories/Android-Socket/"/>
    
    
  </entry>
  
</feed>
