<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haichenyi.com/"/>
  <updated>2022-01-27T10:24:52.200Z</updated>
  <id>https://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android存储之SharedPreferences源码解析</title>
    <link href="https://haichenyi.com/2022/01/27/Android%E5%AD%98%E5%82%A8%E4%B9%8BSharedPreferences%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://haichenyi.com/2022/01/27/Android存储之SharedPreferences源码解析/</id>
    <published>2022-01-27T06:24:56.000Z</published>
    <updated>2022-01-27T10:24:52.200Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人博客：<a href="http://haichenyi.com">haichenyi.com</a>。感谢关注</strong></p><p><span id="c1"></span></p><h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><ul><li><a href="#c1">1–目录</a></li><li><a href="#c2">2–简介</a></li><li><a href="#c3">3–getSharedPreferences会不会阻塞线程，为什么？</a></li><li><a href="#c4">4–get操作，为什么有时候会卡顿？</a></li><li><a href="#c5">5–commit和apply的区别</a></li><li><a href="#c6">6–sp写入异常会怎么处理？</a></li><li><a href="#c7">7–优化sp操作</a></li></ul><a id="more"></a><p><span id="c2"></span></p><h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h2><p>&emsp;&emsp;从工作开始，Android存储数据最常见的应该就是SharePreference，但是，你真的用懂了吗？源码你看过吗？Google对sp的定位你知道吗？是不是所有数据都应该用sp来存储呢？</p><p>&emsp;&emsp;为什么现在面试关于sp非常常见呢？不就是一个get，put键值对的东西吗？commit或者apply就提交存储了，这么简单的一个东西，有啥好问的？</p><p>&emsp;&emsp;腾讯的mmkv，Google的dataSorce又是什么东西呢？</p><p>&emsp;&emsp;先说说sp，Google对sp的定位是轻量级存储，轻量级是什么意思呢？数据量小，数据量大肯定不建议用，但是，往往很多程序员，不管三七二十一，全都是用sp做本地持久化，导致，或多或少的性能问题，当然，不可否认sp的设计也有它的弊端。</p><p>&emsp;&emsp;<strong><em>sp 加锁多 xml解析 全量更新 速度慢 性能差 提交数据可能会ANR</em></strong></p><p><span id="c3"></span></p><h2 id="3-getSharedPreferences会不会阻塞线程，为什么？"><a href="#3-getSharedPreferences会不会阻塞线程，为什么？" class="headerlink" title="3.getSharedPreferences会不会阻塞线程，为什么？"></a>3.getSharedPreferences会不会阻塞线程，为什么？</h2><p>下面从用法一步一步来讲解sp的问题</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(&quot;haichenyi&quot;, MODE_PRIVATE);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;上面这个是获取sp，第一个问题就来了，我们都知道获取sp这里是从磁盘读取数据，就是从文件中读取数据，我们一般从文件中读取数据都是要新开线程的，这里没有新开线程，会不会阻塞主线程，为什么？带着这个问题，我们往下走。</p><p><img src="/uploads/article/2022-01-27/sp1.png" alt="sp源码图1.png"></p><p>&emsp;&emsp;这里调用的是base的getSharedPreferences方法，我们看这个base的类型，会发现是Context类型的，Context我们都知道，是装饰者模式，它的实现类<strong>ContextImpl</strong>，我们到这个类里面区找上面的这个方法，如下图</p><p><img src="/uploads/article/2022-01-27/sp2.png" alt="sp源码图2.png"></p><p>&emsp;&emsp;这个里面逻辑并不复杂，就是一个name在 api19以下的空判断，然后就是file的空判断，用的ArrayMap存储，最后就是调用的重载方法，如下图</p><p><img src="/uploads/article/2022-01-27/sp3.png" alt="sp源码图3.png"></p><p>&emsp;&emsp;重点就是框起来的这里了，SharedPreferences的实现类SharedPreferencesImpl，这里也是装饰者模式(到处都是)。</p><p><img src="/uploads/article/2022-01-27/spImpl.png" alt="SharedPreferencesImpl类.png"></p><p>&emsp;&emsp;看到这里就知道了，它的startLoadFromDisk方法，看名字就知道是从磁盘读取数据，这里有个<strong>synchronized锁</strong>,锁对象是mLock，这个mLock比较重要。里面有一个mLoaded的Boolean类型的值，它也比较重要。下面具体读数据的逻辑，loadFromDisk是新开线程读取的。</p><p>&emsp;&emsp;所以，我们回到前面的问题会不会阻塞线程？虽然，它是同步返回的sp对象，但是，具体读数据的逻辑是新开线程的，所以，不会阻塞线程。</p><p><span id="c4"></span></p><h2 id="4-get操作，为什么有时候会卡顿？"><a href="#4-get操作，为什么有时候会卡顿？" class="headerlink" title="4.get操作，为什么有时候会卡顿？"></a>4.get操作，为什么有时候会卡顿？</h2><p>&emsp;&emsp;会卡顿吗？怎么没有碰到过呢？答案是肯定的，肯定会有卡顿的情况，这是为什么呢？我们来看看它的实现：</p><p><img src="/uploads/article/2022-01-27/spImpl-get.png" alt="SharedPreferencesImpl类的get方法.png"></p><p>&emsp;&emsp;我们来看看这个getXXX这一系列的方法，里面都有同步锁，然后，都有一个<strong>awaitLoadedLocked</strong>方法，重点就是这个方法，看名字就知道：等待加载锁。什么意思呢？我们看一下具体实现</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void awaitLoadedLocked() &#123;</span><br><span class="line">    ...</span><br><span class="line">    //while循环，当mLoaded为false的时候进入while</span><br><span class="line">    while (!mLoaded) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //wait方法</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; catch (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里有一个while循环，判断的就是上面我们提到过的mLoaded，然后，里面就是我们上面也提到过的mLock对象，mLock.wait()方法。</p><p>&emsp;&emsp;当代码执行到这里的时候，如果mLoaded是false，就会进入while循环，然后，会调用mLoack的wait方法，进入等待状态。</p><p>&emsp;&emsp;那，这个mLoaded的值又是在哪里修改的呢？mLock对象是时候唤醒呢？</p><p>&emsp;&emsp;我们回到上面说的，新开线程执行loadFromDisk方法</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void loadFromDisk() &#123;</span><br><span class="line">    ...</span><br><span class="line">    //开始从文件读取数据</span><br><span class="line">    Map&lt;String, Object&gt; map = null;</span><br><span class="line">    StructStat stat = null;</span><br><span class="line">    Throwable thrown = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">        if (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                str = new BufferedInputStream(</span><br><span class="line">                            new FileInputStream(mFile), 16 * 1024);</span><br><span class="line">                //把数据赋值给map</span><br><span class="line">                map = (Map&lt;String, Object&gt;) XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ErrnoException e) &#123;</span><br><span class="line">        // An errno exception means the stat failed. Treat as empty/non-existing by</span><br><span class="line">        // ignoring.</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        thrown = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        //修改mLoaded的值</span><br><span class="line">        mLoaded = true;</span><br><span class="line">        mThrowable = thrown;</span><br><span class="line"></span><br><span class="line">        // It&apos;s important that we always signal waiters, even if we&apos;ll make</span><br><span class="line">        // them fail with an exception. The try-finally is pretty wide, but</span><br><span class="line">        // better safe than sorry.</span><br><span class="line">        try &#123;</span><br><span class="line">            if (thrown == null) &#123;</span><br><span class="line">                if (map != null) &#123;</span><br><span class="line">                    //把刚才读取的数据赋值给全局变量mMap</span><br><span class="line">                    mMap = map;</span><br><span class="line">                    mStatTimestamp = stat.st_mtim;</span><br><span class="line">                    mStatSize = stat.st_size;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mMap = new HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // In case of a thrown exception, we retain the old map. That allows</span><br><span class="line">            // any open editors to commit and store updates.</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            mThrowable = t;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //唤醒mLock</span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;源码里面注释都写的比较清楚。mLoaded值的修改是在从磁盘中把数据读取完之后，然后，在finally里面调用notifyAll唤醒mLock。</p><p>&emsp;&emsp;数据读完之后，修改boolean值，然后，在finally里面唤醒，finally是try-catch最后执行的。</p><p>&emsp;&emsp;为什么会卡顿呢？我们平时用sp，是不是像下面这样用的：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这里是直接返回对象，</span><br><span class="line">//但是，它实际上数据量大的时候，是需要时间去从磁盘读数据的</span><br><span class="line">SharedPreferences sp = getSharedPreferences(&quot;haichenyi&quot;, MODE_PRIVATE);</span><br><span class="line">//当代码执行到这里的时候，我们虽然，拿到了sp对象，</span><br><span class="line">//但是，数据可能没有读取完，上面说的boolean的值，还是false，</span><br><span class="line">//就进入while循环，调用awit方法，进入等待状态</span><br><span class="line">//然后，过一会从磁盘读取完数据，修改boolean值为true，在finally调用notifyAll唤醒mLock</span><br><span class="line">//然后，唤醒了while循环，boolean的值这个时候是true，跳出while循环</span><br><span class="line">//所以，这个卡顿的时间，就是从磁盘读取数据的时间</span><br><span class="line">String s = sp.getString(&quot;xxx&quot;,&quot;aaa&quot;);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;上面代码的注释写的很清楚了吧？不用在做过多的解释了吧？</p><p><strong>PS:它这个卡顿仅限于第一次，为什么呢</strong>？因为它从磁盘读出数据之后，把数据存到内存中了（也就是loadFromDisk方法中的mMap对象），我在那里加了注释，可以去看一下。读取数据都是从这个mMap对象返回的，也就是从内存中返回，这也是为什么从另一方面说，sp返回数据比较快的原因。它都是从内存中返回的，并不是每次都是从磁盘读数据，然后返回的。</p><p><span id="c5"></span></p><h2 id="5-commit和apply的区别"><a href="#5-commit和apply的区别" class="headerlink" title="5.commit和apply的区别"></a>5.commit和apply的区别</h2><p>&emsp;&emsp;先说结论：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">返回值</th><th style="text-align:center">同步</th><th style="text-align:center">ANR</th></tr></thead><tbody><tr><td style="text-align:center">commit</td><td style="text-align:center">有</td><td style="text-align:center">同步提交</td><td style="text-align:center">可能会</td></tr><tr><td style="text-align:center">apply</td><td style="text-align:center">无</td><td style="text-align:center">异步提交</td><td style="text-align:center">可能会</td></tr></tbody></table><p>&emsp;&emsp;我们一个一个来慢慢说这个结论：</p><h3 id="是否有返回值"><a href="#是否有返回值" class="headerlink" title="是否有返回值"></a>是否有返回值</h3><p>&emsp;&emsp;这个很简单吧？用过如果没注意，可能不知道，因为，我们平时也不用处理这些东西，我们来看一下源码就知道了。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//看到这个方法有返回值就知道了，boolean类型的返回值</span><br><span class="line">public boolean commit() &#123;</span><br><span class="line">        ...</span><br><span class="line">        //为什么说每次都是全量更新，就在这里，这个commitToMemory方法里面，</span><br><span class="line">        //它每次都会把内存的map数据全部都更新好</span><br><span class="line">        MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">        //然后通过这个enqueueDisk方法全部都重新写到硬盘上</span><br><span class="line">        //第二个参数是null，它的注释也比较清楚</span><br><span class="line">        SharedPreferencesImpl.this.enqueueDiskWrite(</span><br><span class="line">            mcr, null /* sync write on this thread okay */);</span><br><span class="line">        try &#123;</span><br><span class="line">            //然后，写入等待</span><br><span class="line">            mcr.writtenToDiskLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        notifyListeners(mcr);</span><br><span class="line">        //返回写入结果</span><br><span class="line">        return mcr.writeToDiskResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//这个方法没有返回值</span><br><span class="line">public void apply() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;我们先说返回值的问题，上面这两个方法就是commit和apply的大致结构。所以，commit是有个boolean类型的返回值，apply是没有返回值的</p><h3 id="是否有同步"><a href="#是否有同步" class="headerlink" title="是否有同步"></a>是否有同步</h3><p>&emsp;&emsp;这个问题，上面commit的源码注释那里已经解释清楚了，它会有一个wait方法等待数据更新完，所以commit是同步的。</p><p>&emsp;&emsp;我们再来看看apply方法，上面主要是说返回值的问题，所以，没有把apply的源码贴出来，下面我们来看看apply的源码</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public void apply() &#123;</span><br><span class="line">    final long startTime = System.currentTimeMillis();</span><br><span class="line">    final MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    //重点就是这里，它这里是新建了一个runnable来执行await方法，</span><br><span class="line">    //上面commit方法是直接在当前线程执行的</span><br><span class="line">    final Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mcr.writtenToDiskLatch.await();</span><br><span class="line">            &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //然后调用了QueuedWork.addFinisher,把这个runnable传了进去</span><br><span class="line">    //这个QueuedWork是什么呢？下面我贴出来了这个方法，addFinisher</span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line">    //上面其实就是把runnable加到了一个队列当中</span><br><span class="line">    </span><br><span class="line">    //又新开了一个runnable执行了上面runnable的run方法，</span><br><span class="line">    //这是什么意思还要我做过多的解释吗？runnable.run()</span><br><span class="line">    Runnable postWriteRunnable = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            awaitCommit.run();</span><br><span class="line">            QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //回过头看看，commit的这个方法，第二个参数是null，上面我特意做了解释的。</span><br><span class="line">    //看这里，第二个参数，传的runnable</span><br><span class="line">    //就是在runnable的线程里面执行</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    // Okay to notify the listeners before it&apos;s hit disk</span><br><span class="line">    // because the listeners should always get the same</span><br><span class="line">    // SharedPreferences instance back, which has the</span><br><span class="line">    // changes reflected in memory.</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static void addFinisher(Runnable finisher) &#123;</span><br><span class="line">    synchronized (sLock) &#123;</span><br><span class="line">        //等于，就是把我们的runnable给add到了sFinishers，这个sFinishers又是什么呢？</span><br><span class="line">        sFinishers.add(finisher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//没错，它其实就是一个队列，再回到上面</span><br><span class="line">private static final LinkedList&lt;Runnable&gt; sFinishers = new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;我这里的源码解释的是比较清楚的了吧？所以，apply是异步的。</p><h3 id="是否会ANR"><a href="#是否会ANR" class="headerlink" title="是否会ANR"></a>是否会ANR</h3><p>&emsp;&emsp;说到ANR，我们先来聊一下ANR，什么是ANR？多长时间会造成ANR提示？</p><p>&emsp;&emsp;ANR：Android系统是消息驱动的，每个消息都需要在一定的时间范围内处理完，如果在规定的时间内未处理完，系统就会提示ANR异常</p><p>&emsp;&emsp;那么，这个时间是怎么限定的呢？</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">Service</th><th style="text-align:center">Broadcast</th><th style="text-align:center">Activity</th><th style="text-align:center">ContentProvider</th></tr></thead><tbody><tr><td style="text-align:center">前台(单位：s)</td><td style="text-align:center">20</td><td style="text-align:center">10</td><td style="text-align:center">5</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">后台(单位：s)</td><td style="text-align:center">20*10</td><td style="text-align:center">60</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><p>&emsp;&emsp;前两个都好理解，这个ANR就很难理解了，commit是同步提交，可能会ANR我可以理解，sp每次都是全量更新，commit又是在主线程提交，cpu峰值的时候，数据量大，可能就会卡住主线程，造成ANR。</p><p>&emsp;&emsp;辣么，问题就来了，commit同步卡能会卡住主线程，造成ANR，apply是异步的呀？为什么apply也会造成ANR呢？是结论错了吗？</p><p>&emsp;&emsp;<a href="https://blog.csdn.net/aloe20" target="_blank" rel="noopener">龙儿筝</a>给我说了一个结论：<strong>Google认为SP是数据持久化，数据的安全性要大于页面的行为，当页面离开时，会等待持久化完成。</strong></p><p>&emsp;&emsp;这个结论怎么理解呢？有一个场景，当你调用apply去更新数据，然后，紧接着下一行代码就执行了finish方法，或者跳转了下一个界面，此时会怎么样呢？</p><p>&emsp;&emsp;我们先来简单聊一聊activity启动相关的问题</p><p>&emsp;&emsp;简单的从AMS开始说两句吧，当zygote进程启动了系统主要的服务之后，里面就有一个AMS(ActivityManagerService)，AMS通过Binder创建了ActivityThread，然后通过handler开始发消息，创建Activity，我们activity的生命周期的回调，都说是系统调用了，系统是怎么调用的呢？都是通过handler发送一个一个的消息，然后去执行对应的回调方法。</p><p>&emsp;&emsp;然后，再是，我们常说的<strong>onCreate—onStart(可见，不能与用户交互)—onResume(可见，与用户交互)—activity running—onPause—onStop—onDestroy</strong></p><p>&emsp;&emsp;除了activity running，其余的每一种生命周期都对应着一个handler的message。handler的机制，在我的博文<a href="https://blog.csdn.net/qq_27634797/article/details/121451270" target="_blank" rel="noopener">深入理解handler机制</a>里面讲的很清楚了</p><p>&emsp;&emsp;辣么，从Activity A跳转Activity B，两个activity的生命周期是怎么变化的呢？</p><p>&emsp;&emsp;当A中启动B，生命周期的流程是这样的：</p><ol><li>A的onPause</li><li>B的onCreate-onStart-onResume</li><li>A的onStop</li></ol><p>&emsp;&emsp;扯了这么远，回到上面说的apply的问题，为什么它会ANR线程呢？</p><p>&emsp;&emsp;问题就出在这个A的onStop方法里面，我们来看看这个onStop放的源码：</p><p><img src="/uploads/article/2022-01-27/activity-onStop.png" alt="activity的onStop方法.png"></p><p>&emsp;&emsp;如上图，我们通过handler发送消息，最终定位到执行的是这一块的代码，看到我框起来的代码了吗？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Make sure any pending writes are now committed.</span><br><span class="line">//看这个注释写的，确认没有正在写入的操作，就是这个waitToFinish方法，</span><br><span class="line">//这个if判断，可以看实现，只要taget小于11判断就是true，我们现在都是大于11了，所以，这里是false</span><br><span class="line">//然后，前面取了一个非，所以，我们现在这里能进去</span><br><span class="line">//如果要是小于11呢？看activity的onPause方法里面，你会有新发现</span><br><span class="line">if (!r.isPreHoneycomb()) &#123;</span><br><span class="line">    QueuedWork.waitToFinish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;上面的注释很清楚了，这个waitToFinish方法里面的逻辑是什么样的呢？大致贴一下主要的逻辑：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void waitToFinish() &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        //while循环</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Runnable finisher;</span><br><span class="line">            synchronized (sLock) &#123;</span><br><span class="line">              //从sFinishers队列中取出runnable</span><br><span class="line">                finisher = sFinishers.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            if (finisher == null) &#123;</span><br><span class="line">                //空(队列中没有数据了)就中止while循环</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //执行runnable</span><br><span class="line">            finisher.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        sCanDelay = true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;我们想想之前apply方法里面，是不是新建的runnable，然后，把这个runnable是不是添加到sFinishers队列中去了？</p><p>&emsp;&emsp;所以，整个逻辑就是</p><ol><li>你在Activity A中apply之后(假设数据量大)，立马跳转Activity B</li><li>当Activity B正常启动完，走完它自己的onResume方法，执行了Activity A的onStop方法</li><li>执行的时候发现，QueueWork里面还有提交正在执行，就会等待它执行完，就会阻塞当前线程</li></ol><p><span id="c6"></span></p><h2 id="6-sp写入异常会怎么处理？"><a href="#6-sp写入异常会怎么处理？" class="headerlink" title="6.sp写入异常会怎么处理？"></a>6.sp写入异常会怎么处理？</h2><p>&emsp;&emsp;在代码执行getSharedPreferences的时候，你会发现，磁盘上会多一个同名文件，扩展名不一样，扩展名是  点<strong>bak</strong>,这个文件是备份文件。写入成功就会删除这个文件，写入失败，下次就会用这个备份文件。</p><p>&emsp;&emsp;我们再来找一下源码你会发现：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static File makeBackupFile(File prefsFile) &#123;</span><br><span class="line">    return new File(prefsFile.getPath() + &quot;.bak&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这个方法在哪调用的呢？在SharedPreferencesImpl的构造方法里面</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferencesImpl(File file, int mode) &#123;</span><br><span class="line">    mFile = file;</span><br><span class="line">    //就是这个变量</span><br><span class="line">    mBackupFile = makeBackupFile(file);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;我们再来看看这个写入方法，你会发现，在写入完成之后，会把这个文件删除</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private void writeToFile(MemoryCommitResult mcr, boolean isFromSyncCommit) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // Attempt to write the file, delete the backup and return true as atomically as</span><br><span class="line">    // possible.  If any exception occurs, delete the new file; next time we will restore</span><br><span class="line">    // from the backup.</span><br><span class="line">    try &#123;</span><br><span class="line">        FileOutputStream str = createFileOutputStream(mFile);</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            outputStreamCreateTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        if (str == null) &#123;</span><br><span class="line">            mcr.setDiskWriteResult(false, false);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</span><br><span class="line">        writeTime = System.currentTimeMillis();</span><br><span class="line">        FileUtils.sync(str);</span><br><span class="line">        fsyncTime = System.currentTimeMillis();</span><br><span class="line">        str.close();</span><br><span class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            setPermTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            final StructStat stat = Os.stat(mFile.getPath());</span><br><span class="line">            synchronized (mLock) &#123;</span><br><span class="line">                mStatTimestamp = stat.st_mtim;</span><br><span class="line">                mStatSize = stat.st_size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ErrnoException e) &#123;</span><br><span class="line">            // Do nothing</span><br><span class="line">        &#125;</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            fstatTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        // Writing was successful, delete the backup file if there is one.</span><br><span class="line">        //就是这里，写入操作在前面，如果前面没有异常，那就正常写完了，自然就会走到这里</span><br><span class="line">        //如果前面异常，自然就不会走到这里</span><br><span class="line">        mBackupFile.delete();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><span id="c7"></span></p><h2 id="7-优化sp操作"><a href="#7-优化sp操作" class="headerlink" title="7.优化sp操作"></a>7.优化sp操作</h2><ol><li>sp获取的时候，会新开线程去读取数据，我们可以提前读取sp，不要每次到用的时候，再去读取。</li><li>sp每次提交都是全量更新，不要每次修改了就直接提交，可以多修改几次之后，一起提交</li><li>sp是轻量级存储，数据量大，不要存sp</li><li>sp的内容不要太多，sp内容过多，读取的时候会非常慢，可以适当的拆分sp的内容，分多个sp存储，但是也不要太多</li></ol><p>&emsp;&emsp;但是，这些优化操作，都是基于sp原有的性能做的优化操作，不能从根本上解决问题。</p><p>&emsp;&emsp;sp的源码就说完了，为什么Google更新了十多版本之后的sp，最终还是放弃维护了？而是新出推出了Jetpack的组件之一DataStore这是人性的扭曲还是道德的沦丧，我们且听下回分解。</p><p>&emsp;&emsp;下一篇来聊聊MMKV，它是怎么从根本上解决问题的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;个人博客：&lt;a href=&quot;http://haichenyi.com&quot;&gt;haichenyi.com&lt;/a&gt;。感谢关注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-目录&quot;&gt;&lt;a href=&quot;#1-目录&quot; class=&quot;headerlink&quot; title=&quot;1. 目录&quot;&gt;&lt;/a&gt;1. 目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#c1&quot;&gt;1–目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c2&quot;&gt;2–简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c3&quot;&gt;3–getSharedPreferences会不会阻塞线程，为什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c4&quot;&gt;4–get操作，为什么有时候会卡顿？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c5&quot;&gt;5–commit和apply的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c6&quot;&gt;6–sp写入异常会怎么处理？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c7&quot;&gt;7–优化sp操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="https://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Android--MVVM之DataBinding(一)</title>
    <link href="https://haichenyi.com/2021/12/17/Android-MVVM%E4%B9%8BDataBinding-%E4%B8%80/"/>
    <id>https://haichenyi.com/2021/12/17/Android-MVVM之DataBinding-一/</id>
    <published>2021-12-17T15:26:10.000Z</published>
    <updated>2021-12-17T15:32:12.636Z</updated>
    
    <content type="html"><![CDATA[<p><span id="c1"></span></p><h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><ul><li><a href="#c1">1–目录</a></li><li><a href="#c2">2–DataBinding的疑惑</a></li><li><a href="#c3">3–设置页面布局</a></li><li><a href="#c4">4–获取view引用</a></li><li><a href="#c5">5–更新(界面)流程</a></li></ul><a id="more"></a><p><span id="c2"></span></p><h2 id="2-DataBinding的疑惑"><a href="#2-DataBinding的疑惑" class="headerlink" title="2.DataBinding的疑惑"></a>2.DataBinding的疑惑</h2><p>&emsp;&emsp;假设你已经会用databinding，不会就去看一下怎么用，很简单，</p><ol><li>下面是新建一个xml，名字叫<strong>layout_test1</strong>根布局是layout，你重新编译一下项目之后系统就会生成<strong>LayoutTest1Binding</strong>，以你的xml的名字加binding驼峰命名</li><li><strong>AgeData</strong>类两个属性，一个名字，一个年龄。</li></ol><p><img src="/uploads/article/2021-12-17/databinding方法图.png" alt="databinding方法图.png"></p><p>&emsp;&emsp;如上图所示，我们只要按照DataBinding规定的写法，我们通过获取到的引用就能拿到布局里面的控件，设置完数据，就能更新页面。</p><p>&emsp;&emsp;我们平常页面更新的三个流程：</p><ol><li>在onCreate生命周期方法里面通过setContentView设置页面布局</li><li>通过findViewById获取到控件的引用</li><li>通过控件的引用调用对应的方法TextView的就是setText方法去更新</li></ol><p>&emsp;&emsp;到DataBinding这里怎么就什么都不需要做了，就直接可以用了呢？</p><p>&emsp;&emsp;欢迎大家步入DataBinding的神奇世界，我来为大家一一解惑。</p><p><span id="c3"></span></p><h2 id="3-设置页面布局"><a href="#3-设置页面布局" class="headerlink" title="3.设置页面布局"></a>3.设置页面布局</h2><p>&emsp;&emsp;这个其实最简单，我们先来看一下它的用法，调用的一个工具类的setContentView方法，传递了一个泛型，如下代码：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val binding =</span><br><span class="line">            DataBindingUtil.setContentView&lt;LayoutTest1Binding&gt;(this, R.layout.layout_test1)</span><br><span class="line">binding.ageData = AgeData(&quot;张三&quot;,&quot;18岁&quot;)</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;那么，为什么按照它这个调用方式就能设置布局呢？我们来看一下它的setContentView方法：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//我们调用的这个方法，它又调用的一个setContentView重载方法</span><br><span class="line">public static &lt;T extends ViewDataBinding&gt; T setContentView(@NonNull Activity activity,</span><br><span class="line">            int layoutId) &#123;</span><br><span class="line">    return setContentView(activity, layoutId, sDefaultComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//内部调用这个方法</span><br><span class="line">public static &lt;T extends ViewDataBinding&gt; T setContentView(@NonNull Activity activity,</span><br><span class="line">            int layoutId, @Nullable DataBindingComponent bindingComponent) &#123;</span><br><span class="line">    //看到了嘛？等于说它实际上还是调用的activity的setContentView方法，只不过这里，它做了额外处理，拿到了传递的view</span><br><span class="line">    activity.setContentView(layoutId);</span><br><span class="line">    //decorView不是我们的重点，可以简单说一下，我们所写的布局只是我们自己的内容的根布局。decorView是整个界面的根布局</span><br><span class="line">    View decorView = activity.getWindow().getDecorView();</span><br><span class="line">    ViewGroup contentView = (ViewGroup) decorView.findViewById(android.R.id.content);</span><br><span class="line">    //看整个名字，绑定views</span><br><span class="line">    return bindToAddedViews(bindingComponent, contentView, 0, layoutId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;上面，我们看到了实际上，他还是调用的activity的setContentView方法去设置的布局。</p><p><span id="c4"></span></p><h2 id="4-获取view引用"><a href="#4-获取view引用" class="headerlink" title="4.获取view引用"></a>4.获取view引用</h2><p>&emsp;&emsp;我们平时设置布局，findViewById找到控件，然后通过调用控件的方法去设置内容，从而达到更新页面的功能。那么，databinding是怎么获取到控件的呢？我们接着上面的方法往下看：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//这里的parent就是我们的内容布局，也就是我们写的布局的上一层</span><br><span class="line">private static &lt;T extends ViewDataBinding&gt; T bindToAddedViews(DataBindingComponent component,</span><br><span class="line">            ViewGroup parent, int startChildren, int layoutId) &#123;</span><br><span class="line">    //获取全部子view的个数</span><br><span class="line">    final int endChildren = parent.getChildCount();</span><br><span class="line">    final int childrenAdded = endChildren - startChildren;</span><br><span class="line">    //判断当前获取的子view是不是一个</span><br><span class="line">    if (childrenAdded == 1) &#123;</span><br><span class="line">        //如果是一个，就直接获取</span><br><span class="line">        final View childView = parent.getChildAt(endChildren - 1);</span><br><span class="line">        //开始绑定</span><br><span class="line">        return bind(component, childView, layoutId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果不是一个，就看有多少个，创建一个数据</span><br><span class="line">        //for循环把子view的引用全部放进数据里面</span><br><span class="line">        final View[] children = new View[childrenAdded];</span><br><span class="line">        for (int i = 0; i &lt; childrenAdded; i++) &#123;</span><br><span class="line">            children[i] = parent.getChildAt(i + startChildren);</span><br><span class="line">        &#125;</span><br><span class="line">        //开始绑定</span><br><span class="line">        return bind(component, children, layoutId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;我们再来看看这里绑定的方法，这里调用的方法其实都是差不多的，都是重载方法，一个是传view，一个是传的view类型的数据。<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T extends ViewDataBinding&gt; T bind(DataBindingComponent bindingComponent, View[] roots,</span><br><span class="line">            int layoutId) &#123;</span><br><span class="line">    return (T) sMapper.getDataBinder(bindingComponent, roots, layoutId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static &lt;T extends ViewDataBinding&gt; T bind(DataBindingComponent bindingComponent, View root,</span><br><span class="line">            int layoutId) &#123;</span><br><span class="line">    return (T) sMapper.getDataBinder(bindingComponent, root, layoutId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public abstract class DataBinderMapper &#123;</span><br><span class="line">    public abstract ViewDataBinding getDataBinder(DataBindingComponent bindingComponent, View view,</span><br><span class="line">            int layoutId);</span><br><span class="line">    public abstract ViewDataBinding getDataBinder(DataBindingComponent bindingComponent,</span><br><span class="line">            View[] view, int layoutId);</span><br><span class="line">    public abstract int getLayoutId(String tag);</span><br><span class="line">    public abstract String convertBrIdToString(int id);</span><br><span class="line">    @NonNull</span><br><span class="line">    public List&lt;DataBinderMapper&gt; collectDependencies() &#123;</span><br><span class="line">        // default implementation for backwards compatibility.</span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;我们点进去发现跳转到了一个抽象类的方法。然后，怎么办呢？方法调用，不是静态的，肯定得看对象呀。静态的是<strong>类.方法名</strong>，不是静态的，<strong>变量.方法名</strong>。我们回过头来看这个调用的对象的类型。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class DataBindingUtil &#123;</span><br><span class="line">    //他的实际类是DataBinderMapperImpl，我们点到这个类里面去看一下</span><br><span class="line">    private static DataBinderMapper sMapper = new DataBinderMapperImpl();</span><br><span class="line">    //省略掉不需要的</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DataBinderMapperImpl extends MergedDataBinderMapper &#123;</span><br><span class="line">  DataBinderMapperImpl() &#123;</span><br><span class="line">    //熟悉嘛？这里有我们的包名，还有一个实现类，我们点到这个实现类里面去看,放到后面再说</span><br><span class="line">    addMapper(new com.haichenyi.hcy.DataBinderMapperImpl());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个方法addMapper里面 干什么了呢？</span><br><span class="line">public void addMapper(DataBinderMapper mapper) &#123;</span><br><span class="line">    Class&lt;? extends DataBinderMapper&gt; mapperClass = mapper.getClass();</span><br><span class="line">    //判断有没有添加过</span><br><span class="line">    if (mExistingMappers.add(mapperClass)) &#123;</span><br><span class="line">        //然后把这个mapper放进mMappers遍历里面</span><br><span class="line">        mMappers.add(mapper);</span><br><span class="line">        final List&lt;DataBinderMapper&gt; dependencies = mapper.collectDependencies();</span><br><span class="line">        for(DataBinderMapper dependency : dependencies) &#123;</span><br><span class="line">            addMapper(dependency);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;回到最开始的位置<strong>sMapper.getDataBinder</strong>方法，其中sMapper是<strong>DataBinderMapperImpl</strong>类型的，但是，它的类里面并没有getDataBinder方法，所以，这里调用的就是<strong>DataBinderMapperImpl父类的getDataBinder</strong>方法。也就是<strong>MergedDataBinderMapper</strong>。我们来看一下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MergedDataBinderMapper extends DataBinderMapper &#123;</span><br><span class="line">    ...</span><br><span class="line">    @Override</span><br><span class="line">    public ViewDataBinding getDataBinder(DataBindingComponent bindingComponent, View view,</span><br><span class="line">            int layoutId) &#123;</span><br><span class="line">        //这里遍历mMappers获取里面的每一项，然后调用getDataBinder方法。这个list从哪里赋值的呢？这个遍历不眼熟吗？</span><br><span class="line">        for(DataBinderMapper mapper : mMappers) &#123;</span><br><span class="line">            ViewDataBinding result = mapper.getDataBinder(bindingComponent, view, layoutId);</span><br><span class="line">            if (result != null) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (loadFeatures()) &#123;</span><br><span class="line">            return getDataBinder(bindingComponent, view, layoutId);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;没错，就是这里上面构造方法里面添加的<strong>addMapper(new com.haichenyi.hcy.DataBinderMapperImpl())</strong>，我们再来看看这个<strong>DataBinderMapperImpl</strong>，看看它的getDataBinder，因为前面<strong>sMapper.getDataBinder</strong>调用的就是它</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//简单的贴我们需要的</span><br><span class="line">public class DataBinderMapperImpl extends DataBinderMapper &#123;</span><br><span class="line">  private static final int LAYOUT_LAYOUTTEST1 = 1;</span><br><span class="line"></span><br><span class="line">  private static final SparseIntArray INTERNAL_LAYOUT_ID_LOOKUP = new SparseIntArray(1);</span><br><span class="line">  //首先是有一个静态的SparseIntArray，不知道是啥，反正，我基本上没用过这个东西，通过他这个存数据的方式来看，类似于map，应该是优化过后的，用在这里性能比较高，不然为啥不用map？</span><br><span class="line">  static &#123;</span><br><span class="line">    //以我们的布局id为key，以他自己定义的对应的int数据为值，来存</span><br><span class="line">    INTERNAL_LAYOUT_ID_LOOKUP.put(com.haichenyi.hcy.R.layout.layout_test1, LAYOUT_LAYOUTTEST1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //这里我直接贴出来了一个类型的，就是传view的，那个传view类型数组的，实际上就是循环调用的这个方法。</span><br><span class="line">  //可以看DataBinderMapperImpl的父类MergedDataBinderMapper里面有逻辑</span><br><span class="line">  @Override</span><br><span class="line">  public ViewDataBinding getDataBinder(DataBindingComponent component, View view, int layoutId) &#123;</span><br><span class="line">    //这里，就能够获取到值了，就是全局变量1</span><br><span class="line">    int localizedLayoutId = INTERNAL_LAYOUT_ID_LOOKUP.get(layoutId);</span><br><span class="line">    //1&gt;0，判断就进去了</span><br><span class="line">    if(localizedLayoutId &gt; 0) &#123;</span><br><span class="line">      //到这里，view.getTag，我们逻辑走到这里，我们没有设置tag啊？这里岂不是判断一直都是空？就抛异常了？</span><br><span class="line">      //我们可以打断点看一下，就会发现这里是能拿到值的，以我这个为例，这里获取到的tag是：layout/layout_test1_0，为什么呢？</span><br><span class="line">      final Object tag = view.getTag();</span><br><span class="line">      if(tag == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;view must have a tag&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      switch(localizedLayoutId) &#123;</span><br><span class="line">        case  LAYOUT_LAYOUTTEST1: &#123;</span><br><span class="line">          if (&quot;layout/layout_test1_0&quot;.equals(tag)) &#123;</span><br><span class="line">            return new LayoutTest1BindingImpl(component, view);</span><br><span class="line">          &#125;</span><br><span class="line">          throw new IllegalArgumentException(&quot;The tag for layout_test1 is invalid. Received: &quot; + tag);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  //省略</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;到这里，我们来聊一下，为什么他这里获取到的tag有值呢？项目重新编译的时候，databinding会根据xml的根布局是否是layout布局来重新生成xml。如下图：</p><p><img src="/uploads/article/2021-12-17/databinding生成xml的图.png" alt="databinding生成xml的图.png"></p><p>&emsp;&emsp;如上图所示，databinding传进来的layout其实就是这个layout，并不是我们自己写的布局。所以，这个位置getTag能获取到值。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line"></span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;ageData&quot;</span><br><span class="line">            type=&quot;com.haichenyi.hcy.data.AgeData&quot; /&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/tvName&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_marginTop=&quot;30dp&quot;</span><br><span class="line">            android:text=&quot;@&#123;ageData.name&#125;&quot;</span><br><span class="line">            android:textColor=&quot;@color/black&quot;</span><br><span class="line">            app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/tvAge&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_marginTop=&quot;30dp&quot;</span><br><span class="line">            android:text=&quot;@&#123;ageData.age&#125;&quot;</span><br><span class="line">            android:textColor=&quot;@color/black&quot;</span><br><span class="line">            app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toBottomOf=&quot;@id/tvName&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;LinearLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:gravity=&quot;center_horizontal&quot;</span><br><span class="line">            android:orientation=&quot;vertical&quot;</span><br><span class="line">            app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toBottomOf=&quot;@id/tvAge&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;ImageView</span><br><span class="line">                android:id=&quot;@+id/img&quot;</span><br><span class="line">                android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                android:src=&quot;@mipmap/ic_launcher_round&quot; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;ImageView</span><br><span class="line">                android:layout_marginTop=&quot;10dp&quot;</span><br><span class="line">                android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                android:src=&quot;@mipmap/ic_launcher_round&quot; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                android:text=&quot;@&#123;ageData.name&#125;&quot;/&gt;</span><br><span class="line">        &lt;/LinearLayout&gt;</span><br><span class="line">    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></div><p>对比一下我们自己的布局：就会发现规律</p><ol><li>在我们写的根布局会加上tag，名字叫：layout/(你的layout)_0</li><li>在你有用bean类属性(@{ageData.name}之类)的位置，他会给你的view加上tag，名字叫：binding_i,这个i，从1开始，依次+1</li></ol><p>&emsp;&emsp;结合总结的这两条规律，对比一下上面的两个。</p><p>&emsp;&emsp;我们再返回到上面，switch语句里面，就返回了<strong>LayoutTest1BindingImpl</strong>类，这个是不是很眼熟？没错，我们调用databinding的时候传递了一个泛型<strong>LayoutTest1Binding</strong>，他俩什么关系呢？Impl结尾，一看就知道是实现类。我们点到LayoutTest1BindingImpl看一下。</p><p>&emsp;&emsp;我们从前面获取到布局的实现类LayoutTest1BindingImpl，上面的流程就走完了，我们还是没有看到怎么获取view的方法，一个类的创建先走的它自己的构造方法，那我们就来看一下这个实现类构造方法里面是什么，或许就有答案了。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class LayoutTest1BindingImpl extends LayoutTest1Binding  &#123;</span><br><span class="line">    //表示布局里面有没有include标签，我们布局里面没有</span><br><span class="line">    @Nullable</span><br><span class="line">    private static final androidx.databinding.ViewDataBinding.IncludedLayouts sIncludes;</span><br><span class="line">    //这个变量是干什么的呢？</span><br><span class="line">    @Nullable</span><br><span class="line">    private static final android.util.SparseIntArray sViewsWithIds;</span><br><span class="line">    static &#123;</span><br><span class="line">        sIncludes = null;</span><br><span class="line">        sViewsWithIds = new android.util.SparseIntArray();</span><br><span class="line">        //为什么要把这个id叫img的控件这样放呢？为啥其他的不放在这里？</span><br><span class="line">        //这里就可以把答案给出来，我们这个img并没有在xml里面用bean类的属性，所以就单独这样放的。</span><br><span class="line">        //只要是在xml里面用了bean的属性，不管你有没有id，都是通过tag去获取的</span><br><span class="line">        //有个印象就行，下面还会说这个view的获取流程</span><br><span class="line">        sViewsWithIds.put(R.id.img, 4);</span><br><span class="line">    &#125;</span><br><span class="line">    // views</span><br><span class="line">    @NonNull</span><br><span class="line">    private final androidx.constraintlayout.widget.ConstraintLayout mboundView0;</span><br><span class="line">    @NonNull</span><br><span class="line">    private final android.widget.TextView mboundView3;</span><br><span class="line">    // variables</span><br><span class="line">    // values</span><br><span class="line">    // listeners</span><br><span class="line">    // Inverse Binding Event Handlers</span><br><span class="line"></span><br><span class="line">    public LayoutTest1BindingImpl(@Nullable androidx.databinding.DataBindingComponent bindingComponent, @NonNull View root) &#123;</span><br><span class="line">        //正常的调用自己的三个参数的构造方法，主要，看一下第三个参数，获取的是Object[]，下面贴出来了这个方法</span><br><span class="line">        this(bindingComponent, root, mapBindings(bindingComponent, root, 5, sIncludes, sViewsWithIds));</span><br><span class="line">    &#125;</span><br><span class="line">    private LayoutTest1BindingImpl(androidx.databinding.DataBindingComponent bindingComponent, View root, Object[] bindings) &#123;</span><br><span class="line">        //调用父类的构造方法</span><br><span class="line">        super(bindingComponent, root, 0</span><br><span class="line">            , (android.widget.ImageView) bindings[4]</span><br><span class="line">            , (android.widget.TextView) bindings[2]</span><br><span class="line">            , (android.widget.TextView) bindings[1]</span><br><span class="line">            );</span><br><span class="line">        this.mboundView0 = (androidx.constraintlayout.widget.ConstraintLayout) bindings[0];</span><br><span class="line">        this.mboundView0.setTag(null);</span><br><span class="line">        this.mboundView3 = (android.widget.TextView) bindings[3];</span><br><span class="line">        this.mboundView3.setTag(null);</span><br><span class="line">        this.tvAge.setTag(null);</span><br><span class="line">        this.tvName.setTag(null);</span><br><span class="line">        setRootTag(root);</span><br><span class="line">        // listeners</span><br><span class="line">        invalidateAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void invalidateAll() &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">                mDirtyFlags = 0x2L;</span><br><span class="line">        &#125;</span><br><span class="line">        requestRebind();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public void setAgeData(@Nullable com.haichenyi.hcy.data.AgeData AgeData) &#123;</span><br><span class="line">        this.mAgeData = AgeData;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            mDirtyFlags |= 0x1L;</span><br><span class="line">        &#125;</span><br><span class="line">        notifyPropertyChanged(BR.ageData);</span><br><span class="line">        super.requestRebind();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;重点就在这里了，mapBindings这个方法里面就是获取view的流程，我们，可以来看一下。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">protected static Object[] mapBindings(DataBindingComponent bindingComponent, View root,</span><br><span class="line">            int numBindings, IncludedLayouts includes, SparseIntArray viewsWithIds) &#123;</span><br><span class="line">    //这个numbindings的大小是你布局里面控件的个数</span><br><span class="line">    Object[] bindings = new Object[numBindings];</span><br><span class="line">    mapBindings(bindingComponent, root, bindings, includes, viewsWithIds, true);</span><br><span class="line">    return bindings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//来咯来咯，它来咯，本篇的重点</span><br><span class="line">private static void mapBindings(DataBindingComponent bindingComponent, View view,</span><br><span class="line">            Object[] bindings, IncludedLayouts includes, SparseIntArray viewsWithIds,</span><br><span class="line">            boolean isRoot) &#123;</span><br><span class="line">    final int indexInIncludes;</span><br><span class="line">    //这个getBinding方法可以点进去看一下，通过这个view的tag(R.id.dataBinding)，来获取ViewDataBinding对象。</span><br><span class="line">    //这个设置tag是在绑定完这个view后面才设置的，可以回过头去看LayoutTest1BindingImpl的构造方法里面，有个setRootTag方法，就是设置tag的位置</span><br><span class="line">    //所以，这里，我们还没有设置，这里获取到的就是空，这里判断就进不去，接着往下面走</span><br><span class="line">    final ViewDataBinding existingBinding = getBinding(view);</span><br><span class="line">    if (existingBinding != null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //就到了这里，这里这个tag就是前面说过的DataBinding自己生成的xml，添加的tag</span><br><span class="line">    //就是我们前面说的那两点规律，跟布局是layout/xxx_0,控件是bind_i,i是累加的</span><br><span class="line">    Object objTag = view.getTag();</span><br><span class="line">    final String tag = (objTag instanceof String) ? (String) objTag : null;</span><br><span class="line">    boolean isBound = false;</span><br><span class="line">    //判断是不是根布局，并且tag不为空，并且tag是以layout开头。</span><br><span class="line">    //结合我们的布局来看，layout/layout_test1_0满足这个条件</span><br><span class="line">    if (isRoot &amp;&amp; tag != null &amp;&amp; tag.startsWith(&quot;layout&quot;)) &#123;</span><br><span class="line">        //最后一个下划线的下标，我们的这里是19</span><br><span class="line">        final int underscoreIndex = tag.lastIndexOf(&apos;_&apos;);</span><br><span class="line">        //19大于0，后面这个判断是判断下划线的后一位，是否是数字，我们这里是0，也满足</span><br><span class="line">        if (underscoreIndex &gt; 0 &amp;&amp; isNumeric(tag, underscoreIndex + 1)) &#123;</span><br><span class="line">            //取出最后一位，我们这里是0</span><br><span class="line">            final int index = parseTagInt(tag, underscoreIndex + 1);</span><br><span class="line">            //这个数组里面0号位置之前没有放过，肯定是空的</span><br><span class="line">            if (bindings[index] == null) &#123;</span><br><span class="line">                //所以，就把0号位置放这个根布局</span><br><span class="line">                bindings[index] = view;</span><br><span class="line">            &#125;</span><br><span class="line">            //includes,当前布局有没有include标签，我们布局没有，一直都是空，这里indexInIncludes就等于-1</span><br><span class="line">            indexInIncludes = includes == null ? -1 : index;</span><br><span class="line">            isBound = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            indexInIncludes = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //这个else 是判断当前tag是不是binding打头</span><br><span class="line">    &#125; else if (tag != null &amp;&amp; tag.startsWith(BINDING_TAG_PREFIX)) &#123;</span><br><span class="line">        int tagIndex = parseTagInt(tag, BINDING_NUMBER_START);</span><br><span class="line">        //并且取出tag的最后一位，也就是那个数字位，</span><br><span class="line">        //判断这个位置有没有元素，没有元素，就把当前元素放到这个位置</span><br><span class="line">        //也就是我们的bindings[1]=TextView等</span><br><span class="line">        if (bindings[tagIndex] == null) &#123;</span><br><span class="line">            bindings[tagIndex] = view;</span><br><span class="line">        &#125;</span><br><span class="line">        isBound = true;</span><br><span class="line">        indexInIncludes = includes == null ? -1 : tagIndex;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Not a bound view</span><br><span class="line">        indexInIncludes = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //isBound这个值，是在前面有tag的时候，判断进去了，才会赋值成true</span><br><span class="line">    //可以理解成，没有自动生成tag的元素(也就是xml里面没有用@&#123;&#125;赋值)，前面判断进不去，这里判断会进去。</span><br><span class="line">    if (!isBound) &#123;</span><br><span class="line">        //要判断当前这个view有没有id，没有id就不用管，有id也要赋值</span><br><span class="line">        final int id = view.getId();</span><br><span class="line">        if (id &gt; 0) &#123;</span><br><span class="line">            int index;</span><br><span class="line">            //viewsWithIds.get(id, -1)，在viewsWithIds这个数组里面通过id获取它的索引</span><br><span class="line">            //我们再回过头去看一下LayoutTest1BindingImpl的static代码块，它那里提前就存好了对应的下标</span><br><span class="line">            //它这个下标是怎么来的呢？为什么我们这里img对应的是4呢？</span><br><span class="line">            //我个人理解是，它先循环完有tag元素的索引，我们这里到3了，然后，我们布局里面，有id没有设置用@&#123;&#125;赋值的，就依次累加，所以，我们这里img对应的索引是4</span><br><span class="line">            if (viewsWithIds != null &amp;&amp; (index = viewsWithIds.get(id, -1)) &gt;= 0 &amp;&amp;</span><br><span class="line">                    bindings[index] == null) &#123;</span><br><span class="line">                bindings[index] = view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断当前这个元素是不是ViewGroup，如果是ViewGroup，它里面可能还有子元素</span><br><span class="line">    if (view instanceof  ViewGroup) &#123;</span><br><span class="line">        final ViewGroup viewGroup = (ViewGroup) view;</span><br><span class="line">        final int count = viewGroup.getChildCount();</span><br><span class="line">        int minInclude = 0;</span><br><span class="line">        //循环它的子元素，去获取</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child = viewGroup.getChildAt(i);</span><br><span class="line">            boolean isInclude = false;</span><br><span class="line">            //这里是表示我们的布局里面有没有嵌套include标签，如果DataBinding的布局可能存在嵌套的情况，先循环里层的，再循环外层的</span><br><span class="line">            if (indexInIncludes &gt;= 0 &amp;&amp; child.getTag() instanceof String) &#123;</span><br><span class="line">                //不是本篇的重点就不说这里面了</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            //上面循环玩之后，就走到这里，绑定下一个子view</span><br><span class="line">            if (!isInclude) &#123;</span><br><span class="line">                mapBindings(bindingComponent, child, bindings, includes, viewsWithIds, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;经过上面这个方法的调用，就把布局里面定义了id的，生成了tag的view放进了binding里面，Object类型的数组返回回去。如下图所示：</p><p><img src="/uploads/article/2021-12-17/databinding绑定后的数组.png" alt="databinding绑定后的数组.png"></p><p>&emsp;&emsp;从上面循环也看出来了，优先通过tag找view，然后通过findViewById找view，两个都没有，就被丢弃了。所以，这里只有5个。我们布局一共7个view；LinearLayout和其中一个ImageView没有id，没有tag。循环的时候就没有找到。</p><p>&emsp;&emsp;再强调一遍DataBinding生成tag，是因为你再xml里面通过它规定的方式设置了值，即使，你没有给view设置id，这里也会绑定上，因为，它优先通过tag绑定view的。</p><p>&emsp;&emsp;流程走到这里，DataBinding已经把需要的view都找到了，并且放到了Object数组里面，接下来就是绑定引用了。我们再回过头去看重载的构造方法的代码：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public LayoutTest1BindingImpl(@Nullable androidx.databinding.DataBindingComponent bindingComponent, @NonNull View root) &#123;</span><br><span class="line">    this(bindingComponent, root, mapBindings(bindingComponent, root, 5, sIncludes, sViewsWithIds));</span><br><span class="line">&#125;</span><br><span class="line">//上面的mapBindings绑定好了view，传递到第三个参数，Object[] bindings。</span><br><span class="line">private LayoutTest1BindingImpl(androidx.databinding.DataBindingComponent bindingComponent, View root, Object[] bindings) &#123;</span><br><span class="line">    //super调用父类的方法，我们发现代码点不过去，我们就看类上面的继承</span><br><span class="line">    //CTRL+鼠标左键会直接指向xml，我们全局搜一下LayoutTest1Binding类，下面有图</span><br><span class="line">    super(bindingComponent, root, 0</span><br><span class="line">        //看这里获取view，强转，都是通过bindings前面绑定的</span><br><span class="line">        , (android.widget.ImageView) bindings[4]</span><br><span class="line">        , (android.widget.TextView) bindings[2]</span><br><span class="line">        , (android.widget.TextView) bindings[1]</span><br><span class="line">        );</span><br><span class="line">    this.mboundView0 = (androidx.constraintlayout.widget.ConstraintLayout) bindings[0];</span><br><span class="line">    this.mboundView0.setTag(null);</span><br><span class="line">    this.mboundView3 = (android.widget.TextView) bindings[3];</span><br><span class="line">    this.mboundView3.setTag(null);</span><br><span class="line">    this.tvAge.setTag(null);</span><br><span class="line">    this.tvName.setTag(null);</span><br><span class="line">    setRootTag(root);</span><br><span class="line">    // listeners</span><br><span class="line">    invalidateAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是这个类，点进去看</p><p><img src="/uploads/article/2021-12-17/LayoutTest1Binding.png" alt="LayoutTest1Binding.png"></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public abstract class LayoutTest1Binding extends ViewDataBinding &#123;</span><br><span class="line">  @NonNull</span><br><span class="line">  public final ImageView img;</span><br><span class="line"></span><br><span class="line">  @NonNull</span><br><span class="line">  public final TextView tvAge;</span><br><span class="line"></span><br><span class="line">  @NonNull</span><br><span class="line">  public final TextView tvName;</span><br><span class="line"></span><br><span class="line">  @Bindable</span><br><span class="line">  protected AgeData mAgeData;</span><br><span class="line"></span><br><span class="line">  protected LayoutTest1Binding(Object _bindingComponent, View _root, int _localFieldCount,</span><br><span class="line">      ImageView img, TextView tvAge, TextView tvName) &#123;</span><br><span class="line">    super(_bindingComponent, _root, _localFieldCount);</span><br><span class="line">    this.img = img;</span><br><span class="line">    this.tvAge = tvAge;</span><br><span class="line">    this.tvName = tvName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public abstract void setAgeData(@Nullable AgeData ageData);</span><br><span class="line"></span><br><span class="line">  @Nullable</span><br><span class="line">  public AgeData getAgeData() &#123;</span><br><span class="line">    return mAgeData;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里只贴出来了几个我们想要知道的东西，我们从前面通过tag，id把view找到之后，传递到构造方法里面，然后，这里创建的全局的变量，分别赋值给这些变量。这样，就拿到了这些引用了。</p><p>&emsp;&emsp;一直到这里，获取view的引用，绑定流程就走完了。再回过头去看最开始的问题binding.tvName,binding.tvAge等等，就是拿的这里的引用，也可以看到我们最开始拿到的binding这个变量的类型就是<strong>ViewDataBinding</strong>，我们这里的<strong>LayoutTest1Binding</strong>继承的就是<strong>ViewDataBinding</strong>，就全部串起来了。</p><p><span id="c5"></span></p><h2 id="5-更新-界面-流程"><a href="#5-更新-界面-流程" class="headerlink" title="5.更新(界面)流程"></a>5.更新(界面)流程</h2><p>&emsp;&emsp;可以先说结论，用的就是观察者模式。绑定view的后面它他先注册监听，我们设置数据的时候，触发回调，更新界面。</p><p>文章有点长了，更新流程放到下一章吧。这个view的绑定东西还是比较长的。最后总结一下绑定view的流程图</p><p><img src="/uploads/article/2021-12-17/view绑定流程知识点.png" alt="view绑定流程知识点.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span id=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-目录&quot;&gt;&lt;a href=&quot;#1-目录&quot; class=&quot;headerlink&quot; title=&quot;1. 目录&quot;&gt;&lt;/a&gt;1. 目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#c1&quot;&gt;1–目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c2&quot;&gt;2–DataBinding的疑惑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c3&quot;&gt;3–设置页面布局&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c4&quot;&gt;4–获取view引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c5&quot;&gt;5–更新(界面)流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="https://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Android--MVVM之ViewModel</title>
    <link href="https://haichenyi.com/2021/11/28/Android-MVVM%E4%B9%8BViewModel/"/>
    <id>https://haichenyi.com/2021/11/28/Android-MVVM之ViewModel/</id>
    <published>2021-11-28T14:00:39.000Z</published>
    <updated>2021-11-28T14:08:46.709Z</updated>
    
    <content type="html"><![CDATA[<p><span id="c1"></span></p><h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><ul><li><a href="#c1">1–目录</a></li><li><a href="#c2">2–前言(MVVM演变路程)</a></li><li><a href="#c3">3–目的</a></li><li><a href="#c4">4–ViewModel为什么不会内存泄漏？</a></li><li><a href="#c5">5–Activity屏幕旋，为什么ViewModel没有被重新创建还是使用的是之前的？</a></li><li><a href="#c6">6–Activity与Fragment之间数据如何共享的</a></li><li><a href="#c7">7–GlobeScope，viewModelScope，lifecycleScope的相关问题</a></li></ul><p><span id="c2"></span></p><h3 id="前言-MVVM演变路程"><a href="#前言-MVVM演变路程" class="headerlink" title="前言(MVVM演变路程)"></a>前言(MVVM演变路程)</h3><p>&emsp;&emsp;以前有说过MVC,MVP,MVVM之间的区别，这里就不再说了。</p><p>&emsp;&emsp;MVC架构，最主要的就是循环引用造成的逻辑复杂，维护困难。</p><p>&emsp;&emsp;为了解决MVC存在的问题，推出了MVP架构，MVP将View和Model完全隔离开了，直接P层从M层获取数据，从而更新V层，都是单向操作，逻辑就很明确。但是，这样重担就全部在P层了，所有的逻辑都在P层，造成接口过多，维护起来也困难。</p><p>&emsp;&emsp;为了解决MVP存在的问题，演变出了MVVM。</p><a id="more"></a><p><span id="c3"></span></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ol><li>为了解决MVP的痛点，推出用ViewModel替代Presenter，vm的生命周期与activity(fragment)同步，不用手动维护P层的生命周期。</li><li>使用LiveData与View通信，避免使用接口。结合DataBinding的双向绑定，不用手动更新UI了</li></ol><p><span id="c4"></span></p><h3 id="ViewModel为什么不会内存泄漏？"><a href="#ViewModel为什么不会内存泄漏？" class="headerlink" title="ViewModel为什么不会内存泄漏？"></a>ViewModel为什么不会内存泄漏？</h3><p>&emsp;&emsp;内存泄漏都是生命周期不同步造成的。上文中说到了，vm的生命周期与v相同，自然就不会内存泄漏了。</p><p>&emsp;&emsp;辣么，vm是怎么做到与v层生命周期同步的呢？其实，说到底就应该猜得到，为什么生命周期同步，肯定是v层销毁的时候，vm也被销毁。那么，我们就看一下activity销毁的时候，做了些什么？</p><p>我们先来说一下这个vm的简单用法：<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数：ViewModelStoreOwner</span><br><span class="line">//第二个参数：ViewModelProvider.Factory</span><br><span class="line">new ViewModelProvider(this,new ViewModelProvider.NewInstanceFactory()).get(HttpViewModel.class);</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;用ViewModel，我们知道必须要用<strong>ComponentActivity</strong>，普通的activity不行。为什么呢？我们来看一下：</p><p><img src="/uploads/article/2021-11-28/ComponentActivity图.png" alt="ComponentActivity图.png"></p><p>&emsp;&emsp;看到这个activity的实现了<strong>LifecycleOwner, ViewModelStoreOwner</strong>,这两个接口一个是监听生命周期的变化，一个是保存ViewModel的。再看看我们获取vm的时候传的参数。这就对应上了</p><p>&emsp;&emsp;所以，并不是非要用ComponentActivity，只要是实现了上面那两个接口的activity就行了。</p><p><strong>言归正传</strong>，为什么生命个周期同步？我们找一下这个activity的onDestoyr方法，搜了一下，它没有复写onDstory方法，这个activity的代码也并不多，两百行不到，所以，我找了一下，我看到了如下代码：</p><p><img src="/uploads/article/2021-11-28/ComponentActivity的onDstory.png" alt="ComponentActivity的onDstory.png"></p><p>&emsp;&emsp;它这里通过Lifecycle监听了onDestory事件，当activity销毁的时候，并且，后面那个判断满足的情况下，这里就会走。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这一行代码是干什么的呢？</span><br><span class="line">ComponentActivity.this.getViewModelStore().clear();</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;辣么，这一行代码到底是干什么的呢？我们先来看看这个<strong>ViewModelStore</strong>,这个类：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class ViewModelStore &#123;</span><br><span class="line">    //HashMap,以String为key，ViewModel为值存放ViewModel</span><br><span class="line">    private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap();</span><br><span class="line"></span><br><span class="line">    public ViewModelStore() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //存ViewModel</span><br><span class="line">    final void put(String key, ViewModel viewModel) &#123;</span><br><span class="line">        ViewModel oldViewModel = (ViewModel)this.mMap.put(key, viewModel);</span><br><span class="line">        if (oldViewModel != null) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //获取ViewModel</span><br><span class="line">    final ViewModel get(String key) &#123;</span><br><span class="line">        return (ViewModel)this.mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; keys() &#123;</span><br><span class="line">        return new HashSet(this.mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //看代码，就是一个迭代器，循环调用每个ViewModel的clear方法，最后，清空迭代器</span><br><span class="line">    //看到这里，就应该联想到了吧？</span><br><span class="line">    public final void clear() &#123;</span><br><span class="line">        Iterator var1 = this.mMap.values().iterator();</span><br><span class="line"></span><br><span class="line">        while(var1.hasNext()) &#123;</span><br><span class="line">            ViewModel vm = (ViewModel)var1.next();</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;我们再回过头来看一下，上面那一行代码是干什么？<strong>getViewModelStore()</strong> 方法</p><p><img src="/uploads/article/2021-11-28/getViewModelStore(" alt="getViewModelStore()方法图.png">方法图.png)</p><p>&emsp;&emsp;过程咱们先不说，咱先说这个方法值，就是为了获取ViewModelStore，所以上面那一行代码的意思就是：<strong>获取ViewModelStore之后，调用它的clear方法，循环销毁ViewModel</strong></p><p>这就是为什么ViewModel与Activity的生命周期同步：<strong>因为，在activity销毁的同时，系统会帮我们清空ViewModel</strong></p><p><span id="c5"></span></p><h3 id="Activity屏幕旋，为什么ViewModel没有被重新创建还是使用的是之前的？"><a href="#Activity屏幕旋，为什么ViewModel没有被重新创建还是使用的是之前的？" class="headerlink" title="Activity屏幕旋，为什么ViewModel没有被重新创建还是使用的是之前的？"></a>Activity屏幕旋，为什么ViewModel没有被重新创建还是使用的是之前的？</h3><p>&emsp;&emsp;讲道理activity屏幕旋转的时候，生命周期都更新了，也走了onDestory了，为什么View Model没有重新创建呢？</p><p>&emsp;&emsp;既然，没有重新创建，那就肯定是没有销毁了，为什么呢？我们再来看看这个销毁代码：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">this.getLifecycle().addObserver(new LifecycleEventObserver() &#123;</span><br><span class="line">    public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Event event) &#123;</span><br><span class="line">        //看这里销毁的条件，并不是只有一个，而是有两个，</span><br><span class="line">        //销毁事件满足了，后面那个条件又是什么呢？</span><br><span class="line">        if (event == Event.ON_DESTROY &amp;&amp; !ComponentActivity.this.isChangingConfigurations()) &#123;</span><br><span class="line">            ComponentActivity.this.getViewModelStore().clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>我们再来看看这个isChangingConfigurations()是返回的什么、</p><p><img src="/uploads/article/2021-11-28/isChangingConfigurations.png" alt="isChangingConfigurations.png"></p><p>这里就是返回了一个boolean值，这里，我们可以试着翻译一下上面的注释：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//检查是否这个activity是否处于正在销毁的为过程中，为了重新创建带有一个新的配置</span><br><span class="line">//有没有一点想法？</span><br><span class="line">//意思就是说，这个activity是不是因为一个新的配置需要重新创建而被销毁了。</span><br><span class="line">//（我不管你们认不认，反正，我觉得可以这样理解）</span><br><span class="line">Check to see whether this activity is in the process of being destroyed in order to be recreated with a new configuration. </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//看这个return的注释</span><br><span class="line">//如果，这个activity是需要根据新的配置重新创建而被销毁的话，就返回true，否则，就返回false。</span><br><span class="line">Returns:</span><br><span class="line">If the activity is being torn down in order to be recreated with a new configuration, returns true; else returns false.</span><br><span class="line"></span><br><span class="line">public boolean isChangingConfigurations() &#123;</span><br><span class="line">    return mChangingConfigurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;看到这里，结合我们的实际情况，屏幕旋转，可不就是新的配置吗？所以，这里返回的是true。我们再看那个条件，取反了。结合前面的 <strong>&amp;&amp;</strong>，那么，屏幕旋转的时候，这里就是false，所以，这里进不去。所以ViewModel就不会清空。</p><p>&emsp;&emsp;上面说了，ViewModel没有清空，那为什么传的activity的对象都不是同一个，获取到的ViewMode却是同一个呢？我们来看一下获取的位置：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//新建ViewModelProvider，调用了它两个参数的构造方法，获取ViewModelProvider，然后通过它的get方法获取ViewModel</span><br><span class="line">new ViewModelProvider(this,new ViewModelProvider.NewInstanceFactory()).get(HttpViewModel.class);</span><br><span class="line"></span><br><span class="line">//我们一层一层的追溯</span><br><span class="line">public class ViewModelProvider &#123;</span><br><span class="line">    //默认的key值，这里后面存ViewModel有用到</span><br><span class="line">    private static final String DEFAULT_KEY = &quot;androidx.lifecycle.ViewModelProvider.DefaultKey&quot;;</span><br><span class="line">    private final ViewModelProvider.Factory mFactory;</span><br><span class="line">    private final ViewModelStore mViewModelStore;</span><br><span class="line"></span><br><span class="line">    public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull ViewModelProvider.Factory factory) &#123;</span><br><span class="line">        //我们再来看看ViewModelStoreOwner的getViewModelStore是怎么实现的</span><br><span class="line">        this(owner.getViewModelStore(), factory);</span><br><span class="line">    &#125;</span><br><span class="line">    //上面的构造方法，调用的就是这个构造方法</span><br><span class="line">    public ViewModelProvider(@NonNull ViewModelStore store, @NonNull ViewModelProvider.Factory factory) &#123;</span><br><span class="line">        this.mFactory = factory;</span><br><span class="line">        this.mViewModelStore = store;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//看到这里就大概能够猜到，这里这么多判断空，肯定是复用了呀。</span><br><span class="line">@NonNull</span><br><span class="line">public ViewModelStore getViewModelStore() &#123;</span><br><span class="line">    //判断application有没有，没有就直接抛异常了</span><br><span class="line">    if (this.getApplication() == null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Your activity is not yet attached to the Application instance. You can&apos;t request ViewModel before onCreate call.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //mViewModelStore为空就重新赋值</span><br><span class="line">        if (this.mViewModelStore == null) &#123;</span><br><span class="line">            //这里是先获取了上一次配置的NonConfigurationInstances对象，它不为空，就把它的viewModelStore变量，赋值到这里</span><br><span class="line">            ComponentActivity.NonConfigurationInstances nc = (ComponentActivity.NonConfigurationInstances)this.getLastNonConfigurationInstance();</span><br><span class="line">            if (nc != null) &#123;</span><br><span class="line">                this.mViewModelStore = nc.viewModelStore;</span><br><span class="line">            &#125;</span><br><span class="line">            //到这里还是空，说明没有获取到，就重新new一个</span><br><span class="line">            if (this.mViewModelStore == null) &#123;</span><br><span class="line">                this.mViewModelStore = new ViewModelStore();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this.mViewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;重复一下免得忘记了，ViewModelStore里面有一个HashMap是用来存和取ViewModel的，我们前面把这个类都贴出来了，忘记了可以再去回顾一下。</p><p>&emsp;&emsp;继续，这里通过getLastNonConfigurationInstance()获取mViewModelStore，方法如下：</p><p><img src="/uploads/article/2021-11-28/getLastNonConfigurationInstance.png" alt="getLastNonConfigurationInstance.png"></p><p>&emsp;&emsp;这里为什么要截图呢？就是为了看注释，因为，这里啥逻辑也没有</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">//返回先前的对象，通过onRetainNonConfigurationInstance()方法</span><br><span class="line">Returns:</span><br><span class="line">the object previously returned by onRetainNonConfigurationInstance()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//我们再来看这个方法，直接返回了null，我们再看这个注释</span><br><span class="line">public Object onRetainNonConfigurationInstance() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//先直译：</span><br><span class="line">//被系统调用，作为activity销毁的一部分，由于配置发生了改变</span><br><span class="line">//当它知道一个新对象会被立马创建为了这个新配置</span><br><span class="line">//就是说：当activity需要被立马被重新创建，因为配置发生变化被销毁的时候，这个方法会被系统调用</span><br><span class="line">Called by the system, as part of destroying an activity due to a configuration change, when it is known that a new instance will immediately be created for the new configuration. </span><br><span class="line"></span><br><span class="line">//你能返回任意对象，你想要的在这里包括activity对象本身，</span><br><span class="line">//稍后被恢复通过调用getLastNonConfigurationInstance()方法在新的activity对象里面</span><br><span class="line">//就是说：activity前面不是说重新创建了吗？</span><br><span class="line">//当在新的activity里面调用getLastNonConfigurationInstance方法的时候，能返回你想要的任意对象包括activity本身</span><br><span class="line">You can return any object you like here, including the activity instance itself, which can later be retrieved by calling getLastNonConfigurationInstance() in the new activity instance.</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;到这里也没了，没法向下追溯了，都是系统调用的。我们追溯到</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object getLastNonConfigurationInstance() &#123;</span><br><span class="line">    //mLastNonConfigurationInstances这个变量赋值的位置是attach方法，这个方法也是系统调用的。</span><br><span class="line">    return mLastNonConfigurationInstances != null</span><br><span class="line">                ? mLastNonConfigurationInstances.activity : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;到这里，我也不知道该说啥了，都是系统赋值，我们这里就认为：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull ViewModelProvider.Factory factory) &#123;</span><br><span class="line">        //在ViewModelProvider重新创建的时候，owner.getViewModelStore()获取到的ViewModelStore还是原先的</span><br><span class="line">        //因为，这里的获取最终都是系统调用赋值的，也不知道最开始的值是不是相同的。就认为是相同的</span><br><span class="line">        this(owner.getViewModelStore(), factory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>ViewModelStore是相同的，那么，我们再来看一下获取ViewModel</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">@MainThread</span><br><span class="line">public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">    //这里获取了类的getCanonicalName值</span><br><span class="line">    String canonicalName = modelClass.getCanonicalName();</span><br><span class="line">    //判断是否为空</span><br><span class="line">    if (canonicalName == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //看这里字符串眼熟吗？上面说过了那个DEFAULT_KEY变量，然后加上这个类的路径名</span><br><span class="line">        return this.get(&quot;androidx.lifecycle.ViewModelProvider.DefaultKey:&quot; + canonicalName, modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">@MainThread</span><br><span class="line">public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123;</span><br><span class="line">    //通过这个key先获取ViewModel</span><br><span class="line">    ViewModel viewModel = this.mViewModelStore.get(key);</span><br><span class="line">    //判断是不是这个类的对象，怎么实现的，我不知道，是native方法</span><br><span class="line">    if (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        return viewModel;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (viewModel != null) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //这个mFactory是我们创建的时候传的单例对象，这都不是重点</span><br><span class="line">        if (this.mFactory instanceof ViewModelProvider.KeyedFactory) &#123;</span><br><span class="line">            viewModel = ((ViewModelProvider.KeyedFactory)((ViewModelProvider.KeyedFactory)this.mFactory)).create(key, modelClass);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            viewModel = this.mFactory.create(modelClass);</span><br><span class="line">        &#125;</span><br><span class="line">        //重点就是这里，它会先把这个对象存到ViewModelStore里面，然后，再返回这个对象。第一行，就是先通过这个对象先获取。</span><br><span class="line">        this.mViewModelStore.put(key, viewModel);</span><br><span class="line">        return viewModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>所以，这里就是先存，然后再取，所以，获取到的是同一个对象。</p><p>重要的事情说三遍：</p><p>这里存的key：<strong>系统写死的一个字符串+你的ViewModel类路径</strong></p><p>这里存的key：<strong>系统写死的一个字符串+你的ViewModel类路径</strong></p><p>这里存的key：<strong>系统写死的一个字符串+你的ViewModel类路径</strong></p><p>很多人可能就以为，这里是+你的Activity的类路径，你仔细考虑一下也会发现不对，因为，你一个activity可能有多个ViewModel，那如果是activity的类路径，这里怎么返回？所以，这里是+你的ViewModel的类路径。</p><p>所以，即使，你重新创建activity，你这个viewModel获取到的都是同一个。</p><p>整体就是：即时activity旋转，你获取到的是同一个mViewModelStore对象(系统调用的)，然后，根据key(系统的字符串+vm的类路径)获取到ViewModel对象。</p><p><span id="c6"></span></p><h3 id="Activity与Fragment之间数据如何共享"><a href="#Activity与Fragment之间数据如何共享" class="headerlink" title="Activity与Fragment之间数据如何共享"></a>Activity与Fragment之间数据如何共享</h3><p>&emsp;&emsp;上面说到了这个ViewModel的获取流程，这个问题就应该比较容易回答了，想办法让Fragment获取到同一个ViewModel就可以了。我们一般activity的一级页面都是1个activity+多个fragment的模式，那么，fragment怎么获取ViewModel呢？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//把我们之前第一个参数的位置，传递getActivity()即可。</span><br><span class="line">new ViewModelProvider(getActivity(),new ViewModelProvider.NewInstanceFactory()).get(HttpViewModel.class);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里有个位置需要注意，fragment的replace方法，移除view的时候，fragment并没有被销毁，ViewModel就没有被销毁，页面销毁了，ViewModel更新页面的时候，就可能会存在空指针的问题。所以，更新界面推荐用LiveData，LiveData在页面可见的时候更新，能避免这个问题</p><p><span id="c7"></span></p><h3 id="GlobeScope，viewModelScope，lifecycleScope的相关问题"><a href="#GlobeScope，viewModelScope，lifecycleScope的相关问题" class="headerlink" title="GlobeScope，viewModelScope，lifecycleScope的相关问题"></a>GlobeScope，viewModelScope，lifecycleScope的相关问题</h3><ul><li>GlobeScope：生命周期与app同步，随着kotlin的更新，已经不推荐使用这个了，除非你能保证，你这里做的操作不会存在内存泄漏的问题。</li><li>viewModelScope：在ViewModel里面使用协程，推荐使用viewModelScope，它会在ViewModel调用clear方法的时候取消。</li><li>lifecycleScope：在activity或者fragment里面使用协程的时候，用lifecycleScope，它在Lifecycle执行onDestory的时候取消</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span id=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-目录&quot;&gt;&lt;a href=&quot;#1-目录&quot; class=&quot;headerlink&quot; title=&quot;1. 目录&quot;&gt;&lt;/a&gt;1. 目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#c1&quot;&gt;1–目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c2&quot;&gt;2–前言(MVVM演变路程)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c3&quot;&gt;3–目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c4&quot;&gt;4–ViewModel为什么不会内存泄漏？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c5&quot;&gt;5–Activity屏幕旋，为什么ViewModel没有被重新创建还是使用的是之前的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c6&quot;&gt;6–Activity与Fragment之间数据如何共享的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c7&quot;&gt;7–GlobeScope，viewModelScope，lifecycleScope的相关问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span id=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言-MVVM演变路程&quot;&gt;&lt;a href=&quot;#前言-MVVM演变路程&quot; class=&quot;headerlink&quot; title=&quot;前言(MVVM演变路程)&quot;&gt;&lt;/a&gt;前言(MVVM演变路程)&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;以前有说过MVC,MVP,MVVM之间的区别，这里就不再说了。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;MVC架构，最主要的就是循环引用造成的逻辑复杂，维护困难。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;为了解决MVC存在的问题，推出了MVP架构，MVP将View和Model完全隔离开了，直接P层从M层获取数据，从而更新V层，都是单向操作，逻辑就很明确。但是，这样重担就全部在P层了，所有的逻辑都在P层，造成接口过多，维护起来也困难。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;为了解决MVP存在的问题，演变出了MVVM。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="https://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Android--深入理解handler机制</title>
    <link href="https://haichenyi.com/2021/11/21/Android-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3handler%E6%9C%BA%E5%88%B6/"/>
    <id>https://haichenyi.com/2021/11/21/Android-深入理解handler机制/</id>
    <published>2021-11-21T03:33:57.000Z</published>
    <updated>2021-11-21T03:37:54.851Z</updated>
    
    <content type="html"><![CDATA[<p><span id="c1"></span></p><h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><ul><li><a href="#c1">1–目录</a></li><li><a href="#c2">2–前言</a></li><li><a href="#c3">3–简单总结</a></li><li><a href="#c4">4–Looper的区别：MainLooper和普通Looper</a></li><li><a href="#c5">5–handler发送的消息过程</a></li><li><a href="#c6">6–MessageQueue怎么把这条消息放进队列的</a></li><li><a href="#c7">7–Looper读取消息：loop()</a></li><li><a href="#c8">8–MessageQueue读取消息：next()</a></li><li><a href="#c9">9–如何提高消息的优先级？同步消息，屏障消息，异步消息</a></li><li><a href="#c10">10–handler知识点总结</a></li></ul><p><span id="c2"></span></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;Android程序是一个以消息驱动的程序，页面的跟新，Activity生命周期的变化，点击事件等等都与消息息息相关。</p><a id="more"></a><p><span id="c3"></span></p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>&emsp;&emsp;<strong>简单的理解Handler发送消息的流程</strong>：Handler发送消息(message)到MessageQueue，然后，Looper通过loop()方法循环从MessageQueue里面读取消息。然后，发送给对应的target(Handler)。</p><p><img src="/uploads/article/2021-11-21/简单的理解send消息图.png" alt="简单的理解send消息图.png"></p><p>我们带着问题来理解这个流程，最后，我们在重新总结一下。辣么问题就来了：</p><ol><li>handler都是一样的，为什么Looper会分Looper.getMainLooper()和普通的Looper？</li><li>handler发送的消息过程是什么样子的？</li><li>Looper怎么读取消息的？</li><li>handler发送消息能发送延时消息，Looper读取到消息之后，怎么确定是立刻发送回去，还是隔多久发送回去？</li><li>怎么提升消息的优先级？</li><li>我们项目里面可能会用到的Looper.prepare()，Looper.loop()，这是做什么操作？</li></ol><p>&emsp;&emsp;我们结合源码一起来看一下这些问题：</p><p><span id="c4"></span></p><h3 id="Looper的区别：MainLooper和普通Looper"><a href="#Looper的区别：MainLooper和普通Looper" class="headerlink" title="Looper的区别：MainLooper和普通Looper"></a>Looper的区别：MainLooper和普通Looper</h3><p>第一个问题，handler都是一样的，为什么Looper会分Looper.getMainLooper()和普通的Looper？我们都知道</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler handler = new Handler(Looper.getMainLooper())</span><br></pre></td></tr></table></figure></div><p>通过这个Looper.getMainLooper()方式得到得Handler，可以改变UI，其他的不行，这是为什么呢？我们都知道，UI线程才能改变UI。</p><p><strong>ps：app的启动入口是在ActivityThread的main方法。</strong></p><p>捡一些 (<del>我看的懂的</del>),呸，是主要的，跟我们聊的这个相关的位置贴出来，源码如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        //loop调用了一个准备MainLooper方法（按照方法的名字意思翻译的）</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        //Looper调用loop()方法进入了循环模式</span><br><span class="line">        Looper.loop();</span><br><span class="line">        //如果走到这里，那就没有进入循环模式，就抛出异常了，异常字面意思很好理解，主线程的loop意外的退出了</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>注释应该写的比较清楚了吧？这里我想说的是，main启动的时候，这个线程就是UI线程，这个是系统给规定的，只有在这个线程里面才能改变UI。</p><p>我们再来看看这个Looper.prepareMainLooper()里面做了什么操作</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    //调用prepare方法，传了一个false的Boolean值</span><br><span class="line">    prepare(false);</span><br><span class="line">    //锁</span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        //sMainLooper不等于null，就抛异常</span><br><span class="line">        if (sMainLooper != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //等于null，就把myLooper()方法的返回值赋值给sMainLooper</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//prepare，一个Boolean类型的参数，看名字意思应该是：是否允许退出</span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    //sThreadLocal.get()值不等于null，就抛异常</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //sThreadLocal.get()值等于null，就new一个Looper，放到sThreadLocal中</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Looper的构造方法，我们此时主线程new的时候传的是false</span><br><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    //新建了一个消息队列，MsgQueue，并且把这个boolean传进去了，赋值给mQueue变量</span><br><span class="line">    mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">    //把当前线程赋值给了mThread变量</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line">//消息队列的构造方法，Boolean类型的参数，到这里就应该知道了，表示这个线程是否允许退出，true：允许退出。false：不允许退出</span><br><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    //nativeInit():native方法，不知道是啥，应该是一些需要的初始化</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br><span class="line">//sThreadLocal.get()的值返回回去</span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注释都有了，最开始调用的prepare(false)方法，看完上面的注释，我大致串一下。</p><p>ps:说一下这个sThreadLocal变量，我也不知道怎么说，反正就是它的类型是：<strong>ThreadLocal<looper></looper></strong>,它就是一个普通的类，然后泛型是Looper，所以，这个类就是用来放Looper的。大致这么理解</p><p>我们再说回这个方法，主要就是，</p><ol><li>先判断这个变量是不是空的，如果不是空的，就抛异常了，因为Looper是不允许我们自己手动创建的。</li><li>如果是空，就创建一个Looper，放进sThreadLocal变量里面；</li><li>然后，创建Looper的时候，顺道就创建了MessageQueue。主线程创建的MessageQueue是不允许主动退出的，如果消息队列退出了，退出app了。</li><li>并且，Looper的mQueue，mThread也都赋值好了，一个是消息队列，一个是当前线程(这两个变量用的也比较多)。</li></ol><p>prepare()方法，到这里就说完了，我们再看剩下的代码，往上面翻一下，再看一下。</p><p>ps：sMainLooper变量，类型就是Looper</p><p>剩下的代码就是一个锁方法，</p><ol><li>判断sMainLooper是不是不等于null，如果，不等于null就抛出了异常</li><li>如果等于null，就把上面创建的looper，赋值给sMainLooper</li></ol><p>&emsp;我们Looper.getMainLooper()获取的Looper就是这个sMainLooper，也就是我们当前线程(UI线程)的Looper，我们只有绑定了这个looper的handler才能改变UI，因为，这个handler是在给UI线程传递消息。</p><p>&emsp;&emsp;为什么不等于null就抛出异常了呢?因为sMainLooper只在系统的时候创建，不能在其他的时候创建，如果，在其他的时候创建，说明系统启动的时候没有创建Looper，那么，主线程就没法通信，这是有问题的。</p><p><strong>第一个问题我说明白了吧？Looper.getMainLooper()获取到的是主线程的Looper，跟它绑定的handler能改变UI，没有跟它绑定的hanler都不能改变UI</strong></p><p><span id="c5"></span></p><h3 id="handler发送的消息过程"><a href="#handler发送的消息过程" class="headerlink" title="handler发送的消息过程"></a>handler发送的消息过程</h3><p>第二个问题，handler发送的消息过程是什么样子的？</p><p>说到这里，我们<strong>先聊一下Message类</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class Message implements Parcelable &#123;</span><br><span class="line">    public int what;</span><br><span class="line">    public int arg1;</span><br><span class="line">    public int arg2;</span><br><span class="line">    public Object obj;</span><br><span class="line">    ...</span><br><span class="line">    public long when;</span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /*package*/ Handler target;</span><br><span class="line">    ...</span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /*package*/ Message next;</span><br><span class="line">    /** @hide */</span><br><span class="line">    public static final Object sPoolSync = new Object();</span><br><span class="line">    private static Message sPool;</span><br><span class="line">    private static int sPoolSize = 0;</span><br><span class="line">    private static final int MAX_POOL_SIZE = 50;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;写代码这么长时间，我们发了那么多消息，是不是都没有仔细看看Message的成员变量？看看上面这几个变量。</p><ol><li>what，arg1，arg2，obj可能我们用的比较多。</li><li>这个long 类型的when，很重要，是消息放在队列哪个位置的重要依据。是放在队头？还是队尾？（<strong>重点</strong>）</li><li>Handler类型的target变量，我们之前没注意过吧？字面意思：目标。目标handler（<strong>重点</strong>）</li><li>下面还有两个Message类型的变量，一个next，一个sPool；next字面意思：下一条消息。pool：水池。类型又是Message；那么，sPool：池子的消息</li><li>Object类型的sPoolSync：异步池子。根据经验来看，碰到过很多这种Object类型的东西，大部分都是加锁用的。synchronized(sPoolSync)，一般都是这样用</li><li>int类型的两个变量，sPoolSize值是0，再就是MAX_POOL_SIZE，值是50。字面的意思就是池子的大小是0，池子的最大值是50.</li></ol><p>&emsp;&emsp;什么池子啊，什么最大值啊。我相信很多人跟我的反应都是一样的，线程池，复用。所以这里就是消息池，消息能复用，消息池最大的消息个数是50个，异步。</p><p>&emsp;&emsp;延申到这里，引出我想问的第一个问题，消息的创建，消息创建的两种方式：一种是new出来，一种是obtain的方式，它有一系列的重载方法。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//第一种：new的方式</span><br><span class="line">Message msg1 = new Message();</span><br><span class="line">msg1.what = 1;</span><br><span class="line">msg1.arg1 = 20;</span><br><span class="line">handler.sendMessage(msg1);</span><br><span class="line"></span><br><span class="line">//第二种：obtain的方式</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.what =1;</span><br><span class="line">msg1.arg1 = 20;</span><br><span class="line">handler.sendMessage(msg);</span><br></pre></td></tr></table></figure></div><p>第一种没啥好说的，我们看第二种：Message.obtain()</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">        //加锁</span><br><span class="line">        synchronized (sPoolSync) &#123;</span><br><span class="line">            //判断sPool是否为空</span><br><span class="line">            if (sPool != null) &#123;</span><br><span class="line">                //sPool不为空，就复用sPool msg对象</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                //然后，把m的next赋值给sPool</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                //然后，把已经去出去的msg的额next置空</span><br><span class="line">                m.next = null;</span><br><span class="line">                m.flags = 0; // clear in-use flag</span><br><span class="line">                //这时候，消息池已经去出去了一条消息，消息池大小就减一</span><br><span class="line">                sPoolSize--;</span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //sPool为空，就new一个msg对象</span><br><span class="line">        return new Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>简单的理解就是，不需要重新创建消息，从消息池里面取出一条消息，赋值给我们需要创建的msg对象。</p><p>这里为什么要加锁？什么情况下需要加锁？当然是防止并发呀，handler可以随时随地的发消息，所以，为了防止并发，加锁。</p><p>问题来了，这个sPool是什么时候赋值的呢？我们创建消息的时候没有赋值。创建的时候没有赋值，我们在Message类里面，检索sPool对象，我们找到如下方法：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">    void recycleUnchecked() &#123;</span><br><span class="line">        //重置一些列的成员变量</span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = 0;</span><br><span class="line">        arg1 = 0;</span><br><span class="line">        arg2 = 0;</span><br><span class="line">        obj = null;</span><br><span class="line">        replyTo = null;</span><br><span class="line">        sendingUid = UID_NONE;</span><br><span class="line">        workSourceUid = UID_NONE;</span><br><span class="line">        when = 0;</span><br><span class="line">        target = null;</span><br><span class="line">        callback = null;</span><br><span class="line">        data = null;</span><br><span class="line">        //就是这里，加锁</span><br><span class="line">        synchronized (sPoolSync) &#123;</span><br><span class="line">            //当前消息池子是否小于限制的最大值</span><br><span class="line">            if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                //把sPool赋值给next</span><br><span class="line">                next = sPool;</span><br><span class="line">                //sPool赋值现在的消息</span><br><span class="line">                sPool = this;</span><br><span class="line">                //消息池子大小加1</span><br><span class="line">                sPoolSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>看这个方法名就应该能猜到，消息回收的时候调用的。所以，在消息回收的时候，就把这条消息重置，把这条回收的消息赋值给sPool，这里就是赋值的位置。在消息回收的时候赋值。</p><p>所以，只要你并发量不大，你每次都是obtain创建消息，基本上都是复用的，不会重新创建消息。</p><p><strong>消息说完了，跑题了，跑题了，言归正传</strong></p><p><strong>handler发送消息的流程</strong></p><p>欢迎来到走进科学之Android消息发送流程，我们来一步一步的剖析这条消息是怎么一步一步放进消息队列的。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.what =1;</span><br><span class="line">msg1.arg1 = 20;</span><br><span class="line">handler.sendMessage(msg);</span><br></pre></td></tr></table></figure></div><p>我们来看这个sendMessage的源码。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessage(@NonNull Message msg) &#123;</span><br><span class="line">        //是不是眼熟，没错，它实际上调用的就是我们延时消息的方法，只不过，这个延时的时间是0</span><br><span class="line">        return sendMessageDelayed(msg, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//我们再来看看这个sendMessageDelayed方法</span><br><span class="line">public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123;</span><br><span class="line">        //这里有个判断时间，小于0，就赋值给0，所以，发送延时消息的时候时间传递负数，会立马接收到消息，知道是为什么了吧？</span><br><span class="line">        if (delayMillis &lt; 0) &#123;</span><br><span class="line">            delayMillis = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里又调用的sendMessageAtTime方法</span><br><span class="line">        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里我想说的是SystemClock.uptimeMillis()：表示系统开机时间</span><br><span class="line">//我们再来看看这个sendMessageAtTime方法</span><br><span class="line"></span><br><span class="line">public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123;</span><br><span class="line">        //这里有一个消息队列的判断，这个消息队列是在Handler创建的时候赋值的。</span><br><span class="line">        //可以点进去看一下。Hander构造方法传递一个Looper，Looper构造方里面创建了msgQueue，就是这个。</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        //如果是空，就抛异常，因为消息队列都没有，循环啥？</span><br><span class="line">        if (queue == null) &#123;</span><br><span class="line">            RuntimeException e = new RuntimeException(</span><br><span class="line">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里又调用了enqueueMessage</span><br><span class="line">        return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,</span><br><span class="line">            long uptimeMillis) &#123;</span><br><span class="line">        //这里，我们前面说消息的时候，说很重要，就是在handler发送消息的这里赋值，这个值也是后面Looper发送给哪个handler的依据。</span><br><span class="line">        msg.target = this;</span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line">        //这个是判断你的这个消息是不是异步，提升消息优先级的位置。同步消息，同步屏障，异步消息。</span><br><span class="line">        if (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里就开始进入到消息队列了</span><br><span class="line">        return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;msg.target是后面Looper拿到这条消息之后，发送的目的地，不然，Looper怎么知道要发送给谁(handler)？</p><p>&emsp;&emsp;提升消息优先级的位置。同步消息，同步屏障，异步消息。也是比较重要，后面再细唠。</p><p><span id="c6"></span></p><h3 id="MessageQueue怎么把这条消息放进队列的"><a href="#MessageQueue怎么把这条消息放进队列的" class="headerlink" title="MessageQueue怎么把这条消息放进队列的"></a>MessageQueue怎么把这条消息放进队列的</h3><p>到这里handler的发送就完了，MessageQueue怎么把这条消息放进去的呢？方法如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        //判断有没有目标handler，如果没有，直接就抛异常，都没有这个目的地，我最后取出这条消息，我发给谁？所以，直接就抛异常</span><br><span class="line">        if (msg.target == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //加锁，不加锁，如果很多消息同时需要加紧队列就会出问题</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            //判断这条消息是否正在使用，如果正在使用，那也抛异常。为什么消息会正在使用呢？</span><br><span class="line">            //我们前面说了obtain方式消息是复用的，发送消息会并发，所以，是吧？</span><br><span class="line">            if (msg.isInUse()) &#123;</span><br><span class="line">                throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果，当前msgQueue正在退出，把消息回收了。</span><br><span class="line">            //比方说，你新建线程请求网络，网络请求完，线程一般就会死掉了，线程都没有了，MsgQueue当然要退出了。</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = new IllegalStateException(</span><br><span class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //走到这里，消息就准备放进消息队列了，就是放在那里的问题</span><br><span class="line">            //给消息加个标记，表示消息正在使用。跟前面那个判断正好对应</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            //这个时间，还记不记得？系统开机时间+你延时的时间</span><br><span class="line">            msg.when = when;</span><br><span class="line">            //把消息队列的当前消息赋值给p</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            //是否需要唤醒线程，唤醒跟休眠都是native方法。</span><br><span class="line">            boolean needWake;</span><br><span class="line">            //当前消息是空，说明当前消息队列没有消息，就直接把我们传递的这条消息加进队列</span><br><span class="line">            //我加进来的这条消息的执行时间是0，时间是不会有负数的，如果传进来是负数，都被改成0了，所以，我加的这条消息应该是最先执行的，所以，要加进队列</span><br><span class="line">            //加进来的这条消息的执行时间小于当前线程的执行时间，我加进来的这条消息执行的时间，比你当前消息队列循环的时间小，说明，我要在它的前面执行，要加进队列</span><br><span class="line">            //上面这个时间小的问题，你可以理解成，消息队列循环的时间是延时10秒处理的，我新进的这条消息是要延时5秒，所以，要放在它的前面</span><br><span class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">               //走到这里，说明新加消息需要放在队首 //我新加的消息放进来了之后，要把当前消息的后面，也就是我新加消息的next</span><br><span class="line">                //因为，我新加的消息要在它的前面执行</span><br><span class="line">                msg.next = p;</span><br><span class="line">                //然后，把我新加消息赋值给当前消息变量</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">         //走到这个else里面，就说明当前消息不需要放到队首，就循环判断看它要被放在哪 </span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                //进入死循环</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    //如果当前msg的下一个消息是空，表示没有消息了，for循环就要中止了，需要把新加消息放进来了</span><br><span class="line">                    //如果当前消息的下一条消息的执行时间在新加的执行时间的后面，说明，新加消息要在这条消息的前面执行。所以，for循环就要中止了，需要把新加消息放进来了</span><br><span class="line">                    if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //把当前消息放在新加消息的后面</span><br><span class="line">                msg.next = p; </span><br><span class="line">                //把新加消息，放在当前执行消息的后面。此时，消息就插件队列了</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">            //是否需要唤醒消息队列开始循环获取消息，是native层面做的事情。</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>总结下来就是：<strong>三个条件</strong></p><ol><li>根据当前队列是否空闲(p == null)</li><li>当前消息执行的时间when(when == 0)</li><li>当前队列执行的消息是否需要在新增消息的后面执行(when &lt; p.when)</li></ol><p>&emsp;&emsp;来判断当前消息是否需要插到队首，只要满足上面的任意一个条件，就需要放进队首；否则，for循环判断当前消息需要放到消息队列的哪个位置。需要插队的话就记得把队列中后面的消息放到当前消息的后面。</p><p>再重复一遍，这个时间是<strong>SystemClock.uptimeMillis() + delayMillis</strong>，系统开机时间+你传递的延时时间。</p><p>到这里，消息就被插件消息队列了。代码基本上每行都有注释，一遍没有看懂的话就多看几遍。</p><p><span id="c7"></span></p><h3 id="Looper读取消息：loop"><a href="#Looper读取消息：loop" class="headerlink" title="Looper读取消息：loop()"></a>Looper读取消息：loop()</h3><p>消息已经放进队列了，第二个问题就结束了，接下来就是第三个问题：<strong>Looper怎么读取消息的？</strong></p><p>Looper是通过loop()方法循环读取消息的。代码如下：</p><p>代码比较多，我把无关的(<del>看不懂的</del>)都去掉了<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">        //获取当前线程的looper</span><br><span class="line">        final Looper me = myLooper();</span><br><span class="line">        //如果，等于null，就抛异常，看异常的消息就应该看的出来，说没有在当前线程调用Looper.prepare()方法</span><br><span class="line">        //Looper.prepare()这个方法就是创建Looper的</span><br><span class="line">        if (me == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //获取当前线程的消息队列</span><br><span class="line">        final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        //进入死循环读取消息</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //读取队列中的下一条消息，可能会阻塞线程</span><br><span class="line">            Message msg = queue.next(); </span><br><span class="line">            //如果，没有消息了，就退出循环，进入休眠状态</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">                // No message indicates that the message queue is quitting.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            //获取观察者模式的对象</span><br><span class="line">            final Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            Object token = null;</span><br><span class="line">            if (observer != null) &#123;</span><br><span class="line">                //这里应该是这个观察者对象发送了一个消息正在分发的消息</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            try &#123;</span><br><span class="line">            //msg.target：是不是很眼熟？就是需要接收这条消息的handler //通过这个handler调用dispatchMessage方法，发送消息 msg.target.dispatchMessage(msg);</span><br><span class="line">                if (observer != null) &#123;</span><br><span class="line">                   //然后，观察者发送一个消息分发完成的消息 observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            &#125; catch (Exception exception) &#123;</span><br><span class="line">                if (observer != null) &#123;</span><br><span class="line">                   //如果出现了异常，这个观察者就发送一个消息分发异常的消息 observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                throw exception;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            //眼熟不？就是前面说的，消息回收，重复利用，就是在消息分发完成之后触发</span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></p><p>我们先看一下这个handler的dispatchMessage方法：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(@NonNull Message msg) &#123;</span><br><span class="line">        //这个Message的callback是什么时候赋值的呢？就是创建Message的时候，可以回过头去看一下</span><br><span class="line">        if (msg.callback != null) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mCallback != null) &#123;</span><br><span class="line">                if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //这个方法，眼熟吗？看下面，我们新建handler的时候，不就重写了这个方法吗？</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Handler handler = new Handler(Looper.getMainLooper())&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(@NonNull Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></div><p>到此，消息的发送，入队，取消息，处理，就形成了闭环了。整个流程：</p><ol><li>新建handler，发送消息sendMessage</li><li>此时消息的创建obtain复用模式，后面可能会造成正在使用的异常，所以，需要加锁同步一下</li><li>然后，消息进队，target(目的地的handler)和when(执行的时间系统开机时间+延时时间)</li><li>判断的三个条件，是放进队首(队列中是空的，时间是0，时间在队列消息时间的前面)，还是队中(需要循环判断队列中是否还有消息和时间)</li><li>通过loop方法取出来消息，通过这个消息的target发送消息</li></ol><p>我们接下来说第四个问题：<strong>handler发送消息能发送延时消息，Looper读取到消息之后，怎么确定是立刻发送回去，还是隔多久发送回去？</strong></p><p>我们上面分析完，好像并没有看到这个延时消息的问题啊，Looper的loop方法是，只要queue.next()返回给它消息了，它就直接发送回去了，没有什么延时。</p><p><span id="c8"></span></p><h3 id="MessageQueue读取消息：next"><a href="#MessageQueue读取消息：next" class="headerlink" title="MessageQueue读取消息：next()"></a>MessageQueue读取消息：next()</h3><p>重点就在这里queue.next()，读取消息。这里也是提升消息优先级的位置(同步屏障，异步消息)。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">    Message next() &#123;</span><br><span class="line">        </span><br><span class="line">        final long ptr = mPtr;</span><br><span class="line">        //通过注释翻译过来就是：loop已经退出了，或者应用正在尝试重启一个looper，就直接return null</span><br><span class="line">        if (ptr == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">        //下一次循环的时间，单位是：秒</span><br><span class="line">        int nextPollTimeoutMillis = 0;</span><br><span class="line">        //开始进入死循环去读取消息</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">                //不知道啥意思。</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line">            //这是一个native方法，看名字，大概的意思应该就是循环一次，经过nextPollTimeoutMillis长的时间</span><br><span class="line">            //就是底层C/C++经过这么长时间之后，触发一次循环</span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">            </span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                // Try to retrieve the next message.  Return if found.</span><br><span class="line">                final long now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = null;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                //屏障消息的实质就是创建一条target为null的消息</span><br><span class="line">                //看这里的if条件，正常的消息target不等于null，这里的判断是不会进入的。</span><br><span class="line">                if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                    // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                    //再看这里的do...while循环，退出的条件是找到一条不为空的异步消息。</span><br><span class="line">                    //msg.isAsynchronous():异步消息返回true，取反之后就是false，更前面&amp;&amp;，就是false，就退出do..while循环了</span><br><span class="line">                    do &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                //消息不为空</span><br><span class="line">                if (msg != null) &#123;</span><br><span class="line">                    //当前时间小于消息需要执行的时间，说明是延时消息。</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                        //修改这个下次循环的时间，前面说的native调用的时间，就是根据这个变量判断的。</span><br><span class="line">                        //时间就是消息执行的时间-系统开机时间=延时时间</span><br><span class="line">                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //否则就是一条实时消息，就是正常的赋值流程，返回这条消息给looper，然后发送出去</span><br><span class="line">                        // Got a message.</span><br><span class="line">                        mBlocked = false;</span><br><span class="line">                        if (prevMsg != null) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = null;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        return msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //消息是空，就表示没有更多消息了</span><br><span class="line">                    nextPollTimeoutMillis = -1;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>流程就是：</p><ol><li>先判断looper有没有，系统有没有重启，如果重启了，looper没有，那就直接返回一个null对象，Looper接收到了一个null对象，会直接return</li><li>然后，判断是不是屏障消息(屏障消息消息的target等于null)，如果是屏障消息，就进行do..while循环，直到取出一条异步消息为止</li><li>正常的判断消息，是同步消息还是延时消息，同步消息立刻返回，延时消息，提醒底层多长时间之后再调用我</li></ol><p>&emsp;&emsp;看到了吗？MessageQueue取消息的流程，通过msg的执行时间与当前系统的开机时间进行比较，延时消息就是判断了延时多长时间之后，告诉底层多长时间之后，你还要调用一次这个取消息的方法。这就是延时消息的实现。</p><p><span id="c9"></span></p><h3 id="如何提高消息的优先级？同步消息，屏障消息，异步消息"><a href="#如何提高消息的优先级？同步消息，屏障消息，异步消息" class="headerlink" title="如何提高消息的优先级？同步消息，屏障消息，异步消息"></a>如何提高消息的优先级？同步消息，屏障消息，异步消息</h3><p>既然说到这里，我们就直接聊一下这个消息的优先级</p><p>ps：这里的异步消息，同步消息，并不是说多线程去处理消息。异步消息是有一个属性是true</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//同步消息</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">//异步消息，调用了一个setAsynchronous并且设置为true</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.setAsynchronous(true);</span><br></pre></td></tr></table></figure></div><p>我们平时发消息是下面这个样子的：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Message msg1 = Message.obtain(handler,new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Log.v(&quot;hcy&quot;,&quot;这是一条延时3秒的消息&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">handler.sendMessageDelayed(msg1,3*1000);</span><br><span class="line"></span><br><span class="line">Message msg = Message.obtain(handler, new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Log.v(&quot;hcy&quot;,&quot;这是一条延时5秒的异步消息&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">handler.sendMessageDelayed(msg,5*1000);</span><br><span class="line">Log.v(&quot;hcy&quot;,&quot;两条消息都发送完了&quot;);</span><br></pre></td></tr></table></figure></div><p>上面就是new了两条消息，一条同步消息，一条异步消息，如果没有屏障消息的情况下，同步消息和异步消息是一样的，没啥区别。程序运行完，过三秒钟同步消息回调，再过两秒打印异步消息回调，上面消息的打印结果如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021-11-21 08:53:10.363 29452-29452/com.haichenyi.myapplication V/hcy: 两条消息都发送完了</span><br><span class="line">2021-11-21 08:53:13.366 29452-29452/com.haichenyi.myapplication V/hcy: 这是一条延时3秒的消息</span><br><span class="line">2021-11-21 08:53:15.365 29452-29452/com.haichenyi.myapplication V/hcy: 这是一条延时5秒的异步消息</span><br></pre></td></tr></table></figure></div><p>那么，什么是屏障消息呢？怎么实现呢？我们先说怎么实现的。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Message msg1 = Message.obtain(handler,new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;这是一条延时3秒的消息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">handler.sendMessageDelayed(msg1,3*1000);</span><br><span class="line"></span><br><span class="line">Message msg = Message.obtain(handler, new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;这是一条延时5秒的异步消息&quot;);</span><br><span class="line">        //异步消息处理完移除消息屏障</span><br><span class="line">        try &#123;</span><br><span class="line">            Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">            Method removeSyncBarrier = msgQueue.getDeclaredMethod(&quot;removeSyncBarrier&quot;, int.class);</span><br><span class="line">            removeSyncBarrier.invoke(Looper.myQueue(),token);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">    msg.setAsynchronous(true);</span><br><span class="line">&#125;</span><br><span class="line">handler.sendMessageDelayed(msg,5*1000);</span><br><span class="line">try &#123;</span><br><span class="line">    //启动消息屏障</span><br><span class="line">    Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">    Method postSyncBarrier = msgQueue.getDeclaredMethod(&quot;postSyncBarrier&quot;);</span><br><span class="line">    token = (int) postSyncBarrier.invoke(Looper.myQueue());</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">Log.v(&quot;hcy&quot;,&quot;两条消息都发送完了&quot;);</span><br></pre></td></tr></table></figure></div><p>打印结果如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021-11-21 09:05:36.915 29743-29743/com.haichenyi.myapplication V/hcy: 两条消息都发送完了</span><br><span class="line">2021-11-21 09:05:41.922 29743-29743/com.haichenyi.myapplication V/hcy: 这是一条延时5秒的异步消息</span><br><span class="line">2021-11-21 09:05:41.949 29743-29743/com.haichenyi.myapplication V/hcy: 这是一条延时3秒的消息</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;代码执行完之后，先是过了5秒回调了异步消息，然后立刻回调了同步消息，为什么呢？因为，同步消息是延时3秒执行呀，异步消息是延时5秒执行，因为加了消息屏障，会把异步消息的优先级提到同步消息的前面，所以，执行完异步消息，同步消息的执行时间早就过了，肯定要立刻执行呀。</p><p>说了这么多，那么，这个提升优先级是怎么实现的呢？透过现象去看本质。两段代码的区别，就是通过反射，执行了两个方法<strong>postSyncBarrier</strong>,<strong>removeSyncBarrier</strong>。其中还有一个带参数的方法。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//执行消息屏障</span><br><span class="line">try &#123;</span><br><span class="line">    Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">    Method postSyncBarrier = msgQueue.getDeclaredMethod(&quot;postSyncBarrier&quot;);</span><br><span class="line">    token = (int) postSyncBarrier.invoke(Looper.myQueue());</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除消息屏障</span><br><span class="line">try &#123;</span><br><span class="line">    Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">    Method removeSyncBarrier = msgQueue.getDeclaredMethod(&quot;removeSyncBarrier&quot;, int.class);</span><br><span class="line">    removeSyncBarrier.invoke(Looper.myQueue(),token);</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们先来看看这个消息屏障的方法：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">@TestApi</span><br><span class="line">//我们反射调用的是这个方法，它最终执行的是一个同样名字的带参的重载方法</span><br><span class="line">public int postSyncBarrier() &#123;</span><br><span class="line">    return postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最终执行到这里</span><br><span class="line">private int postSyncBarrier(long when) &#123;</span><br><span class="line">//以来还是老规矩，加锁，防止多线程调用</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        //token比较重要，是移除屏障的标记</span><br><span class="line">        final int token = mNextBarrierToken++;</span><br><span class="line">        //常规的msg的创建，msg执行的时间是系统的开机时间</span><br><span class="line">        final Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        //把这个token值赋值给了msg的arg1变量</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line">        //说白了，下面就是链表操作了，不停的移动指针</span><br><span class="line">        //prev：上一条消息变量</span><br><span class="line">        Message prev = null;</span><br><span class="line">        //p：消息。</span><br><span class="line">        //mMessages：这个变量眼熟不？我们前面消息从队列中取的时候就是那个next()方法，</span><br><span class="line">        //在进入for循环里面，判断是否是屏障消息之前，是不是也同样是给一个成员变量赋值，赋值的值也是mMessages。</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        //执行时间不等于0，前面取的时候那三个条件，有一个时间等于0，就插进消息队首，这里我觉得也可以这样理解</span><br><span class="line">        if (when != 0) &#123;</span><br><span class="line">            //这里是一个while循环，字面理解就是当前消息不等于null，当前消息的执行时间，小于屏障消息的执行时间，就继续循环。直到这两个条件不满足为止</span><br><span class="line">            //结合上下文的意思就是，我执行这个屏障消息的时候，如果发现队列里面还有消息的执行时间在我这个屏障消息的前面，就继续让它先执行。</span><br><span class="line">            while (p != null &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                //把当前消息赋值给变量prev</span><br><span class="line">                prev = p;</span><br><span class="line">                //把当前消息的下一条消息，赋值给p变量(当前消息变量)</span><br><span class="line">                p = p.next;</span><br><span class="line">                //继续while循环</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //经过上面的while循环之后，就找准了屏障消息该插入的为止了</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">        //如果prev不等于null，表示，消息队列里面还有需要在屏障消息前面执行的消息</span><br><span class="line">        //队列就变成了：prev-屏障消息-当前消息</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果prev等于null，就表示消息队列里面没有需要在屏障消息执行前面执行的消息了</span><br><span class="line">            //队列也就变成了：屏障消息-当前消息</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回这个token值。移除屏障消息的时候需要用到</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面这个执行消息屏障说的很清楚了吧？多看注释，多理解。</p><p>我们再来看看这个移除消息屏障</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">@TestApi</span><br><span class="line">public void removeSyncBarrier(int token) &#123;</span><br><span class="line">    //加锁</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        //两个变量赋值</span><br><span class="line">        Message prev = null;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        //这个while循环，第一个条件：当前消息不等于null(当前消息队列还有消息)</span><br><span class="line">        //第二个条件：当前消息得目的地不为空(我们屏障消息这里是等于空的，这里应该是为了判断其他地方调用这个方法)</span><br><span class="line">        //然后就是第三个条件，我们传进来的token值，就是上面执行屏障消息时候的返回值，当时赋值给了arg1。这里比较，如果相同，那么，这条消息就是屏障消息</span><br><span class="line">        //第二个条件和第三个条件是或的关系，满足一条就行。</span><br><span class="line">        //屏障消息就要移除，链表的常规移除操作</span><br><span class="line">        while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            //其实就是：原来是：上一条消息——屏障消息——下一条消息</span><br><span class="line">            //变成了：上一条消息——下一条消息</span><br><span class="line">        &#125;</span><br><span class="line">        //到这里就移除完了</span><br><span class="line">        //上面while循环完，发现当前消息是空，说明消息队列中没有消息了，直接抛异常</span><br><span class="line">        if (p == null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The specified message queue synchronization &quot;</span><br><span class="line">                        + &quot; barrier token has not been posted or has already been removed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        final boolean needWake;</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == null || mMessages.target != null;</span><br><span class="line">        &#125;</span><br><span class="line">        //消息回收</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        // If the loop is quitting then it is already awake.</span><br><span class="line">        // We can assume mPtr != 0 when mQuitting is false.</span><br><span class="line">        //native层的是否需要唤醒服务</span><br><span class="line">        if (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>总结一下这个提升消息优先级的方式就是：把你想发送的消息定义view异步消息发送，光这样还不行，还要发送一条屏障消息，具体流程：</p><ol><li>往消息队列里面插入一条target为null的消息</li><li>MessageQueue.next()方法读取的时候，会先判断这条消息是不是屏障消息，如果是，他就会执行do..while循环，直到找到一条异步消息为止。</li><li>MessageQueue拿到消息之后，正常的取消息流程</li><li>在你执行完这条异步消息之后，记得要移除屏障消息，不然所有的异步消息都在同步消息前面执行。</li></ol><p>其实有个更简单的方法，handler发消息的api都给出来了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//发送消息到队列前面</span><br><span class="line">handler.sendMessageAtFrontOfQueue(msg1);</span><br></pre></td></tr></table></figure></div><p>经过上面的整个流程之后，最后一个问题就比较简单了，自己看一下源码吧，我给出结论:</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepare():给当前线程创建Looper，MessageQueue的过程，这个MessageQueue是可退出的</span><br><span class="line"></span><br><span class="line">Looper.loop():从头到尾都在说loop()，循环读取消息。</span><br></pre></td></tr></table></figure></div><p><span id="c10"></span></p><h3 id="handler知识点总结"><a href="#handler知识点总结" class="headerlink" title="handler知识点总结"></a>handler知识点总结</h3><p>总结一下handler的东西：整理了一个流程图：</p><p><img src="/uploads/article/2021-11-21/handler知识点.png" alt="handler知识点.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span id=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-目录&quot;&gt;&lt;a href=&quot;#1-目录&quot; class=&quot;headerlink&quot; title=&quot;1. 目录&quot;&gt;&lt;/a&gt;1. 目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#c1&quot;&gt;1–目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c2&quot;&gt;2–前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c3&quot;&gt;3–简单总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c4&quot;&gt;4–Looper的区别：MainLooper和普通Looper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c5&quot;&gt;5–handler发送的消息过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c6&quot;&gt;6–MessageQueue怎么把这条消息放进队列的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c7&quot;&gt;7–Looper读取消息：loop()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c8&quot;&gt;8–MessageQueue读取消息：next()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c9&quot;&gt;9–如何提高消息的优先级？同步消息，屏障消息，异步消息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c10&quot;&gt;10–handler知识点总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span id=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Android程序是一个以消息驱动的程序，页面的跟新，Activity生命周期的变化，点击事件等等都与消息息息相关。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="https://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Android——触摸事件传递机制</title>
    <link href="https://haichenyi.com/2021/11/20/Android%E2%80%94%E2%80%94%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/"/>
    <id>https://haichenyi.com/2021/11/20/Android——触摸事件传递机制/</id>
    <published>2021-11-19T17:22:11.000Z</published>
    <updated>2021-11-19T17:38:54.295Z</updated>
    
    <content type="html"><![CDATA[<p><span id="c1"></span></p><h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1.目录"></a>1.目录</h2><ul><li><a href="#c1">1–目录</a></li><li><a href="#c2">2–预知识点</a></li><li><a href="#c3">3–Android点击事件</a></li><li><a href="#c4">3.1–结论</a></li><li><a href="#c5">3.2–某一层不想要分发这次事件，怎么办呢？(dispatch)</a></li><li><a href="#c6">3.3–view group想要拦截这次事件，怎么办？(onIntercept)</a></li><li><a href="#c7">3.4–某一层想自己处理，不回传了，怎么办？(onTouchEvent)</a></li></ul><p><span id="c2"></span></p><h2 id="2-预知识点"><a href="#2-预知识点" class="headerlink" title="2.预知识点"></a>2.预知识点</h2><ol><li>Android的一次点击事件由三部分组成：</li></ol><ul><li>ACTION_DOWN(按下)：只能有一个</li><li>ACTION_UP(抬起)：只能有一个</li><li>ACTION_MOVE(移动)：一个或者多个</li></ul><p>&emsp;&emsp;<strong>为什么移动事件能有多个呢</strong>？因为你手指按在屏幕上滑动会触发多个MOVE事件，而这次点击事件的结束，是在你手指离开屏幕的那一刻，才结束。</p><ol><li><p><strong>Android的事件传递是责任链的模式</strong>，一层一层的向下传递，传递到最下层之后，没人认领，就一层一层的往回传（这就是很多人说的从外到内，再从内到外）</p><a id="more"></a></li></ol><p><span id="c3"></span></p><h2 id="3-Android点击事件"><a href="#3-Android点击事件" class="headerlink" title="3.Android点击事件"></a>3.Android点击事件</h2><p><span id="c4"></span></p><h3 id="3-1-结论"><a href="#3-1-结论" class="headerlink" title="3.1 结论"></a>3.1 结论</h3><p>&emsp;&emsp; 简单的分析成从 <strong>Activity——ViewGroup——View</strong>，结论：如下图</p><p><img src="/uploads/article/2021-11-20/不做任何处理的结论图.png" alt="不做任何处理的结论图.png"></p><p><strong>有几点要注意：</strong></p><ul><li><strong>dispatch分发方法，不做任何处理，表示向下分发</strong></li><li><strong>onIntercept拦截方法，不做任何处理，表示不拦截</strong></li><li><strong>onTouchEvent，不做任何处理，表示不处理事件</strong></li><li><strong>view group比activity和view多一个拦截方法</strong>。activity不需要拦截方法是因为，他要么向下分发，要么自己处理不需要拦截。view也类似，要么分发，要么回传。</li></ul><p>这个图就是我们不修改默认的返回值的情况下，全部都是super的方式一层一层传递的结论。最上层的activity，中间层的viewgroup，最下层的view。跟着箭头的方向看：</p><ol><li>activity的分发事件不做处理，分发给中间层view group去做分发</li><li>view group的分发事件也不做处理，传递给自己的拦截方法</li><li>view group的拦截事件不做处理，传递给最下层的view去做分发</li><li>view的分发事件不做处理，它也没有下一层了，所以，它就会传递给自己的onTouchEvent方法，去处理事件</li><li>view的onTouchEvent方法，不做任何处理，那么，它就会回传给中间层view group的onTouchEvent方法</li><li>view group的onTouchEvent方法不做处理，就会回传给最上层activity的onTouchEvent方法</li><li>如果，最上层的activity的onTouchEvent方法也不做处理，那么，系统就会抛弃这次点击事件，也就是 这次点击事件没有任何反应。</li></ol><p>以上就是一次点击事件不做处理的正常流程</p><p>上面的结论是怎么的出来的呢？就是新建一个view group，新建一个view，重写这几个方法，打印日志，其他啥也没动。</p><p><img src="/uploads/article/2021-11-20/activity图.png" alt="activity图.png"></p><p><img src="/uploads/article/2021-11-20/viewgroup图.png" alt="viewgroup图.png"></p><p><img src="/uploads/article/2021-11-20/view图.png" alt="view图.png"></p><p><img src="/uploads/article/2021-11-20/activity布局图.png" alt="activity布局图.png"></p><p>想要验证上面的结论，自己也可以去写了试一下，没有什么难点，就是打印日志，把view写到activity布局里面，然后点击view就行了</p><p><strong>埋个点</strong>：这里日志打印都在super前面。</p><p>那么，问题来了，如果：</p><ol><li>某一层不想要分发这次事件，怎么办呢？(dispatch)</li><li>view group想要拦截这次事件，怎么办？(onIntercept)</li><li>某一层想自己处理，不回传了，怎么办？(onTouchEvent)</li></ol><p><span id="c5"></span></p><h3 id="3-2-某一层不想要分发这次事件，怎么办呢？-dispatch"><a href="#3-2-某一层不想要分发这次事件，怎么办呢？-dispatch" class="headerlink" title="3.2 某一层不想要分发这次事件，怎么办呢？(dispatch)"></a>3.2 某一层不想要分发这次事件，怎么办呢？(dispatch)</h3><p>&emsp;&emsp;<strong>activity层如果想要不分发这次点击事件，自己的onTouchEvent直接处理</strong>。你只有不调用super方法，直接写死返回值，不管是true，还是false，都会直接调用自己的onTouchEvent方法。就像下面这样：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//activity的dispatchTouchEvent方法</span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;activity:dispatchTouchEvent:&quot;+ev.getAction());</span><br><span class="line">        //只要你调用了super方法，不管是返回true还是false，都会正常的向下传递</span><br><span class="line">//        super.dispatchTouchEvent(ev);</span><br><span class="line">        return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>运行的结论我就不贴出来了。最后再总结一张总图</p><p>&emsp;&emsp;view group不分发，此时，activity已经分发下来了，view group不想往下分发了，就需要回传回activity的onTouchEvent方法。写法如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//view group的dispatchTouchEvent方法</span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;viewGroup:dispatchTouchEvent:&quot;+ev.getAction());</span><br><span class="line">        //不调用super方法，返回true，流程就会在这里中断，分发方法就直接消费了这次事件</span><br><span class="line">//        return super.dispatchTouchEvent(ev);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;view 不想分发，就需要回传给view group的onTouchEvent方法，然后是否需要回传给activity的onTouchEvent方法，就需要view group的onTouchEvent方法的返回值去判断了，后面再说。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//view 的dispatchTouchEvent方法</span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;view:dispatchTouchEvent:&quot;+event.getAction());</span><br><span class="line">//        return super.dispatchTouchEvent(event);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>那么，结论就如下表格：<br>|return|true|false|super.dispatchTouchEvent(event)|<br>|:–:|:–:|:–:|:–:|<br>|activity|中断|中断|分发|<br>|view group|中断|不分发|分发|<br>|view|中断|不分发|分发|</p><p>ps：中断：表示整个流程就中断了，没有任何回调了</p><p>不分发：表示正常回调，符合预期</p><p>符合预期，需要去思考一下。我们这里是不分发，就把事件还给上一层，那么，</p><ol><li>view group，就是触发activity的onTouchEvent方法。</li><li>view，就是触发view group的onTouchEvent方法。</li></ol><p><span id="c6"></span></p><h3 id="3-3-view-group想要拦截这次事件，怎么办？-onIntercept"><a href="#3-3-view-group想要拦截这次事件，怎么办？-onIntercept" class="headerlink" title="3.3 view group想要拦截这次事件，怎么办？(onIntercept)"></a>3.3 view group想要拦截这次事件，怎么办？(onIntercept)</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//view group的拦截事件</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;viewGroup:onInterceptTouchEvent:&quot;+ev.getAction());</span><br><span class="line">//        return super.onInterceptTouchEvent(ev);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>拦截事件：表示拦截了自己处理</p><p>那么，结论就如下表格：<br>|return|true|false|super.onInterceptTouchEvent(event)|<br>|:–:|:–:|:–:|:–:|<br>|view group|拦截|不拦截|不拦截|</p><p>这里的拦截，会触发自己的onTouchEvent方法。</p><p>上面的不分发，是触发上一层的onTouchEvent方法。</p><p>这里的概念都不能死记硬背，需要结合上下文去理解。</p><p><span id="c7"></span></p><h3 id="3-4-某一层想自己处理，不回传了，怎么办？-onTouchEvent"><a href="#3-4-某一层想自己处理，不回传了，怎么办？-onTouchEvent" class="headerlink" title="3.4 某一层想自己处理，不回传了，怎么办？(onTouchEvent)"></a>3.4 某一层想自己处理，不回传了，怎么办？(onTouchEvent)</h3><p>onTouchEvent是从内向外回传，那么，我们先来看最内层view的onTouchEvent，代码如下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//view的onTouchEvent代码</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;view:onTouchEvent:&quot;+event.getAction());</span><br><span class="line">//        return super.onTouchEvent(event);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>true，表示自己处理，不会往上回传。false,super表示不自己处理，需要回传</p><p>view group的onTouchEvent，代码如下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//view group的onTouchEvent代码</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;viewGroup:onTouchEvent:&quot;+event.getAction());</span><br><span class="line">//        return super.onTouchEvent(event);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>view group的结论与view的相同。都是：true，表示自己处理，不会往上回传。false,super表示不自己处理，需要回传。<br>&emsp;&emsp;activity没有上一层，不需要回传。所以，activity的onTouchEvent，不需要去考虑</p><p>那么，结论就如下表格：<br>|return|true|false|super.onTouchEvent(event)|<br>|:–:|:–:|:–:|:–:|<br>|view|自己处理|不处理|不处理|<br>|view group|自己处理|不处理|不处理|</p><p>到这里，事件的传递基本上就说完了。完整的流程图如下：</p><p><img src="/uploads/article/2021-11-20/完整的流程图.png" alt="完整的流程图.png"></p><p>更简单的理解：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">true</th><th style="text-align:center">false</th><th style="text-align:center">super</th></tr></thead><tbody><tr><td style="text-align:center">dispatch</td><td style="text-align:center">中断</td><td style="text-align:center">不分发</td><td style="text-align:center">正常流程</td></tr><tr><td style="text-align:center">Intercept</td><td style="text-align:center">拦截</td><td style="text-align:center">不不拦截</td><td style="text-align:center">正常流程</td></tr><tr><td style="text-align:center">onTouchEvent</td><td style="text-align:center">处理</td><td style="text-align:center">不处理</td><td style="text-align:center">正常流程</td></tr></tbody></table><p>dispatch：是否分发</p><p>Intercept：是否拦截</p><p>onTouchEvent：是否自己处理</p><p>true：真的</p><p>false：假的</p><p>分发需要额外单独记忆。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span id=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-目录&quot;&gt;&lt;a href=&quot;#1-目录&quot; class=&quot;headerlink&quot; title=&quot;1.目录&quot;&gt;&lt;/a&gt;1.目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#c1&quot;&gt;1–目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c2&quot;&gt;2–预知识点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c3&quot;&gt;3–Android点击事件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c4&quot;&gt;3.1–结论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c5&quot;&gt;3.2–某一层不想要分发这次事件，怎么办呢？(dispatch)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c6&quot;&gt;3.3–view group想要拦截这次事件，怎么办？(onIntercept)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c7&quot;&gt;3.4–某一层想自己处理，不回传了，怎么办？(onTouchEvent)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span id=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-预知识点&quot;&gt;&lt;a href=&quot;#2-预知识点&quot; class=&quot;headerlink&quot; title=&quot;2.预知识点&quot;&gt;&lt;/a&gt;2.预知识点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Android的一次点击事件由三部分组成：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ACTION_DOWN(按下)：只能有一个&lt;/li&gt;
&lt;li&gt;ACTION_UP(抬起)：只能有一个&lt;/li&gt;
&lt;li&gt;ACTION_MOVE(移动)：一个或者多个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;为什么移动事件能有多个呢&lt;/strong&gt;？因为你手指按在屏幕上滑动会触发多个MOVE事件，而这次点击事件的结束，是在你手指离开屏幕的那一刻，才结束。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Android的事件传递是责任链的模式&lt;/strong&gt;，一层一层的向下传递，传递到最下层之后，没人认领，就一层一层的往回传（这就是很多人说的从外到内，再从内到外）&lt;/p&gt;
    
    </summary>
    
      <category term="Android -自定义view" scheme="https://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA-TCP，UDP</title>
    <link href="https://haichenyi.com/2021/08/09/JAVA-TCP%EF%BC%8CUDP/"/>
    <id>https://haichenyi.com/2021/08/09/JAVA-TCP，UDP/</id>
    <published>2021-08-09T14:02:40.000Z</published>
    <updated>2021-08-09T14:31:44.254Z</updated>
    
    <content type="html"><![CDATA[<p><span id="c1"></span></p><h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><ul><li><a href="#c1">1–目录</a></li><li><a href="#c2">2–概念</a></li><li><a href="#c3">3–优缺点</a></li><li><a href="#c4">4–三次握手</a></li><li><a href="#c5">5–四次握手</a></li><li><a href="#c6">6–通信流程</a></li></ul><p><span id="c2"></span></p> <a id="more"></a><h3 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h3><p>&emsp;&emsp;首先，需要确定的就是他们是socket通信的两种协议。</p><p>&emsp;&emsp;<strong>TCP</strong>:一种面向连接，全双工可靠信道的传输层协议</p><p>&emsp;&emsp;<strong>UDP</strong>:一种无连接的，不可靠的传输层协议</p><p><span id="c3"></span></p><h3 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">安全</th><th style="text-align:center">有序</th><th style="text-align:center">速度</th><th style="text-align:center">对象个数</th><th style="text-align:center">开销</th><th style="text-align:center">方式</th></tr></thead><tbody><tr><td style="text-align:center">TCP</td><td style="text-align:center">安全</td><td style="text-align:center">有序</td><td style="text-align:center">慢</td><td style="text-align:center">1:1</td><td style="text-align:center">大</td><td style="text-align:center">面向字节流</td></tr><tr><td style="text-align:center">UDP</td><td style="text-align:center">不安全</td><td style="text-align:center">无序</td><td style="text-align:center">快</td><td style="text-align:center">1:1，1:N，N:N，N:1</td><td style="text-align:center">小</td><td style="text-align:center">面向报文</td></tr></tbody></table><blockquote><p>是否安全：TCP是采用的全双工可靠信道，很安全。UDP采用得是不可靠得传输协议</p><p>是否有序：TCP：有序，一个传完下一个才能继续。UDP：无序，只管发送，不管有没有接收到</p><p>传输速度：TCP：慢。必须上一个传完，下一个才能传。UDP：快，它可以一直发，不管你有没有接收到</p><p>面向对象：TCP：面向连接1:1。UDP：无连接，1:N。一个很老得比喻，也很形象。你把TCP理解成个人视频，把UDP理解成群视频。</p><p>开销：TCP：开销大，首部20个字节。UDP开销小：首部8个字节</p></blockquote><p><span id="c4"></span></p><h3 id="4-三次握手"><a href="#4-三次握手" class="headerlink" title="4. 三次握手"></a>4. 三次握手</h3><p>&emsp;&emsp;我们都知道TCP是全双工可靠信道。什么是信道？感觉打字不如贴图，如图：</p><p><img src="/uploads/article/2021-08-09/信道图.png" alt="信道图.png"></p><p>&emsp;&emsp;然后，我们来看看这个TCP的通信图</p><p><img src="/uploads/article/2021-08-09/TCP通信图.png" alt="TCP通信图.png"></p><p>已知：两个对象A和B，两个信道：信道1和信道2。</p><p><strong>第一次握手</strong>：A从信道1中给B发消息：我要跟你连接了。（说明：A可以从信道1发消息）</p><p><strong>第二次握手</strong>：B从信道2中给A回消息：好的，我同意了。（说明：B可以从信道2发消息，B可以从信道1收消息）</p><p><strong>第三次握手</strong>：A从信道1中给B回消息：那我们开始连接吧（A可以从信道2收消息）。B收到之后就建立了连接。</p><p><strong>为什么必须要三次握手，2次不行吗？</strong></p><p>&emsp;&emsp;全双工信道只能单方向发消息。如果是2次握手：表示A可以从信道1发消息。B可以从信道1收消息，信道2发消息。但是，B并不知道A能不能从信道2收到消息。所以，2次没法建立建立。</p><p><span id="c5"></span></p><h3 id="5-四次挥手"><a href="#5-四次挥手" class="headerlink" title="5. 四次挥手"></a>5. 四次挥手</h3><p><strong>第一次挥手</strong>：A从信道1给B发消息：我的事情都处理完了，我要跟你断开连接了。</p><p><strong>第二次挥手</strong>：B从信道1收到消息后，从信道2给A回一个消息：我知道了。然后，B继续处理未处理完的事情。</p><p><strong>第三次挥手</strong>：B的事情处理完之后，B从信道2给A发消息：我的事情都处理完了，我要跟你断开连接了。</p><p><strong>第四次挥手</strong>：A从信道2收到B发来的断开连接的消息之后。A从信道1给B回复：好的，我知道了，我们都断开吧。然后，A断开1，2信道。B从信道1收到了A的确认消息之后。B也断开1，2信道。</p><p><span id="c6"></span></p><h3 id="5-通信流程"><a href="#5-通信流程" class="headerlink" title="5. 通信流程"></a>5. 通信流程</h3><ol><li>先获取Socket套接字对象，绑定端口号，新开线程连接服务器。</li><li>然后通过套接字获取它的输入流和输入流。</li><li>新开两个线程，监听outputstream，和inputstream。输入流负责读从服务器返回的数据，输出流负责本地向服务器发送数据。</li><li>这个时候就需要注意拆包，粘包的问题，返回数据需要统一格式，读数据的时候可以根据这个格式来区分是否是一条完整的数据。</li><li>再就是需要监听网络状态的变化，若切换网络导致连接中断，这个时候就需要捕获异常，释放资源，再重新连接。</li></ol><p>&emsp;&emsp;一般如果没有限制必须要用原生的写，我一般都是用Netty，之前也写过一篇Netty用法的文章：<a href="http://haichenyi.com/2018/02/08/Netty%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E8%AE%AF/">Netty的简单使用，实现socket通讯</a></p><p>&emsp;&emsp;<strong>解决粘包，拆包:约定好每一条消息的规则</strong>。怎么约定呢？</p><p>举个栗子：</p><ol><li>定长。每条消息都是固定长度，不够补0。每次只读取一个固定长度的信息，这样自然就把每条消息分开了。</li><li>设置特定的结束符。双方约定好，每条消息的结尾跟一个特殊的符号，表示这条消息结束。这样也能把每条消息分开</li><li>每条消息的头部，定义好这条消息的长度。每次解析的时候，先解析这个长度，再开始解析数据。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span id=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-目录&quot;&gt;&lt;a href=&quot;#1-目录&quot; class=&quot;headerlink&quot; title=&quot;1. 目录&quot;&gt;&lt;/a&gt;1. 目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#c1&quot;&gt;1–目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c2&quot;&gt;2–概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c3&quot;&gt;3–优缺点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c4&quot;&gt;4–三次握手&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c5&quot;&gt;5–四次握手&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c6&quot;&gt;6–通信流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span id=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA -基础" scheme="https://haichenyi.com/categories/JAVA-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA—公平锁，非公平锁，悲观锁，乐观锁，死锁</title>
    <link href="https://haichenyi.com/2021/07/27/JAVA%E2%80%94%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81/"/>
    <id>https://haichenyi.com/2021/07/27/JAVA—公平锁，非公平锁，悲观锁，乐观锁，死锁/</id>
    <published>2021-07-27T13:44:50.000Z</published>
    <updated>2021-08-03T15:11:24.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这几个锁都可以从前面一篇<a href="http://haichenyi.com/2021/07/19/JAVA%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%99%A8AQS/#more">线程同步器AQS</a>里面找到影子,我先把前面一篇的加锁流程图拿过来用一用。</p> <a id="more"></a><p><img src="/uploads/article/2021-07-19/加锁流程图.png" alt="加锁流程图.png"></p><p>&emsp;&emsp;上面这个流程图是上一篇最开始讲的时候的一张流程图，后面写的时候，后面的流程图都没有画。这一片我们来画一下后面的流程图。</p><h3 id="公平锁，非公平锁"><a href="#公平锁，非公平锁" class="headerlink" title="公平锁，非公平锁"></a>公平锁，非公平锁</h3><p>&emsp;&emsp;前面一篇讲的时候，我说过了，我们当时做的是一个公平锁。这个公平锁和非公平锁的主要区别就是在这个队列。</p><p>&emsp;&emsp;我们前文讲过了，线程1拿到了锁，线程2，3，4就全部放进队列中等待，那么，流程图如下：</p><p><img src="/uploads/article/2021-07-27/等待流程图1.png" alt="等待流程图1.png"></p><p>&emsp;&emsp;如上图，我们理想状态是：线程1释放锁的时候，队列中的第一个元素，也就是线程2拿到锁，然后，开始执行。</p><p>&emsp;&emsp;但是，往往不如意，谁规定的一共就只有4个线程呢？如果，我们正当1释放锁的同时，又有一个线程5进来了，我们要怎么操作呢？流程图如下：</p><p><img src="/uploads/article/2021-07-27/等待流程图2.png" alt="等待流程图2.png"></p><p>&emsp;&emsp;公平锁和非公平锁的区别就在这里：</p><ol><li>公平锁会把线程5放进队列中，放到线程4的后面，线程2获取到锁，然后执行自己的任务</li><li>非公平锁则是，线程1释放锁之后，状态变成了0，线程5去竞争锁，获取到锁之后，状态state又变成了1，线程2被唤醒之后，正准备去获取锁的时候，一看，状态state是1，又进入等待状态。</li></ol><p>&emsp;&emsp;所以，公平锁就是释放锁之后，谁等待得时间长，谁先执行。非公平锁则是，释放锁之后，谁先获取到锁，谁先执行。可能后进的执行，也可能先进的先执行。</p><p>&emsp;&emsp;<strong>ReentrantLock</strong>，初始化的时候传true就是公平锁，传false就是非公平锁，默认是非公平锁。下面就是ReentrantLock的构造方法。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125;.</span><br><span class="line"> * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line"> */</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line"> * given fairness policy.</span><br><span class="line"> *</span><br><span class="line"> * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line"> */</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="悲观锁锁，乐观锁"><a href="#悲观锁锁，乐观锁" class="headerlink" title="悲观锁锁，乐观锁"></a>悲观锁锁，乐观锁</h3><p>&emsp;&emsp;<strong>悲观锁</strong>：操作之前加锁，操作完成之后解锁。我们前文讲的buy方法就是悲观锁，进入方法就加锁，方法执行完就解锁。还有我们常用的<strong>synchronized</strong>关键字，就是悲观锁的典型代表。</p><p>&emsp;&emsp;<strong>乐观锁</strong>：乐观锁是一种思想，比方说，我们前文提到的CAS机制，就是乐观锁的一种实现。当我们操作一个变量做加减操作的时候，我们多个线程可以同时做这个操作，但是到具体更新这个值的时候，去判断。典型代表就是Atomic原子类。这个原子类的实现也是CAS机制。</p><p>&emsp;&emsp;<strong>性能问题</strong>：多个线程同时执行，悲观锁，就只有一个线程操作，其他线程挂起等待，释放锁之后，再切换回来。乐观锁，所有的线程都一起执行，最后执行冲突检测和数据更新操作。没有挂起等待，上下文的切换，所以，乐观锁的性能肯定比悲观锁好。但是，实际上真的是这样吗？答案是否定的。乐观锁的性能不一定比悲观锁好。</p><p>&emsp;&emsp;前面，我们说到乐观锁是在最后更新得时候，去判断。那么怎么判断呢？早期1.5版本之前的CAS操作是有3个参数内存位置(V)、原值(A)、新值(B)。我们在更新的时候，先判断A是否满足，满足就更新成B上一篇文章已经说过了。不满足，那就再循环一边重复判断。极端情况下，要是线程足够的多，并且一直不满足，那是不是一直循环判断(CAS自旋)？那就一直占用CPU。这样性能肯定不好。</p><p>&emsp;&emsp;<strong>synchronized</strong>在JDK1.5之前的确性能很差，但是在1.6的时候就已经做了优化了，从无锁状态，到偏向锁状态，再到轻量级锁状态，最后到重量级锁状态。这几个状态会随着竞争情况逐渐升级（锁不但可以升级还可以降级）。现在synchronized的性能跟ReentrantLock差不多。</p><p>&emsp;&emsp;所以，悲观锁的性能不一定比乐观锁差，乐观锁的性能不一定比悲观锁好。根据实际情况去选择悲观锁和乐观锁。那到底怎么选择呢？</p><p>&emsp;&emsp;之前在网上看到过这么一组数据，启用多个线程进行计数相加到一亿，首先是synchronized方式</p><p><img src="/uploads/article/2021-07-27/synchronized时间图.png" alt="synchronized时间图.png"></p><p>&emsp;&emsp;当线程数为8时，性能明显提升，但是8到32个线程来说，每个线程的平均时间基本差不多，基本没有提升，到了64个线程的时候，性能又有一点提升。</p><p>如果换成CAS实现多线程累加数为一亿，时间又会怎么样呢？</p><p><img src="/uploads/article/2021-07-27/CAS时间图.png" alt="CAS时间图.png"></p><p>&emsp;&emsp;在线程数相对较少的时候，CAS实现比较快，性能优于synchronized,当线程数多于8后，CAS实现明显开始下降，反而时间消耗高于synchronized；</p><p>&emsp;&emsp;<strong>总结</strong>：synchronized是java提供的又简单方便，性能优化又非常好的功能，建议大家常用；CAS的话，线程数大于一定数量的话，多个线程在循环调用CAS接口，虽然不会让其他线程阻塞，但是这个时候竞争激烈，会导致CPU到达100%，同时比较耗时间，所以性能就不如synchronized了。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>&emsp;&emsp;死锁是指：多个进程在运行过程中因争夺某一种资源，而造成的僵持状态，若无外力作用，他们都将无法向前推进。</p><p><strong>举个栗子</strong>：</p><p>小明在看电视，小红在玩手机，小明对小红说：你把手机给我玩，我把点视给你看；小红却说：你把点视给我看，我再把手机给你玩。</p><p><strong>分析</strong>：</p><ol><li><strong>电视，手机</strong>都可以看作一种资源。</li><li><strong>小明在看电视，小红在玩手机</strong>：表示电视分配给小明了，小明对电视持有锁；手机分配给小红了，小红对手机持有锁</li><li><strong>小明对小红说，你把手机给我玩，我把点视给你看</strong>：小明想获取到手机的锁之后，再释放自己电视的锁。</li><li><strong>小红却说，你把点视给我看，我再把手机给你玩</strong>：小红想获取电视的锁之后，再释放自己手机的锁</li></ol><p>&emsp;&emsp;所以，小明和小红都在等待对方释放锁，自己拿到想要的资源之后，释放自己资源的锁。这里谁都拿不到锁，就无线的等待下去。这就是死锁。</p><h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><ol><li><strong>互斥条件</strong>：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。(就是这里的电视只能给小明看，手机只能给小红玩)</li><li><strong>占有且等待</strong>：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。（小明等着小红释放手机资源，小红等着小明释放电视资源）</li><li><strong>不剥夺条件</strong>：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来（小明在看电视的时候，小红不能说，我要看电视，你给我看。小红在玩手机的时候，小明不能说，我要玩手机，你把手机给我玩。我们要讲文明，不能耍流氓）</li><li><strong>环路等待条件</strong>：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源（小明等着小红释放手机资源，小红等着小明释放电视资源）</li></ol><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>&emsp;&emsp;如果产生死锁只能重启。所以，我们在开发过程中要尽量避免死锁，比方说：著名的<strong>银行家算法</strong>。只要上面四种中的任意一种不满足，就不可能造成死锁：比方说占有等待，我们可以用共享锁的方式AQS里面每个加锁的方法都有一个try开头的方法。可以看一下acquire和tryAcquire的区别。这就破坏了第二个条件，等待。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这几个锁都可以从前面一篇&lt;a href=&quot;http://haichenyi.com/2021/07/19/JAVA%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%99%A8AQS/#more&quot;&gt;线程同步器AQS&lt;/a&gt;里面找到影子,我先把前面一篇的加锁流程图拿过来用一用。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA -并发" scheme="https://haichenyi.com/categories/JAVA-%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA—线程同步器AQS</title>
    <link href="https://haichenyi.com/2021/07/19/JAVA%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%99%A8AQS/"/>
    <id>https://haichenyi.com/2021/07/19/JAVA—线程同步器AQS/</id>
    <published>2021-07-19T14:41:15.000Z</published>
    <updated>2021-08-03T15:12:01.151Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;每一项技术的提出都是为了解决某一个问题，带着问题来理解技术，使得印象你对这个技术的理解印象更加深刻。</p> <a id="more"></a><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>&emsp;&emsp;举个栗子：现在有一个需求，网络请求分两批（A,B两个批次），A批次并行请求，B批次串行请求按顺序一个一个请求，有一个总超时时间，B批次每一次请求都有一个超时时间，A批次并发请求先请求，在规定时间内没有返回，再开始请求B批次，谁先返回用谁的。</p><p>&emsp;&emsp;这个是我们项目里面简化过后的一个逻辑，实际逻辑，比这个还要复杂。怎么实现这个功能呢？</p><p>&emsp;&emsp;带着这个问题来进入我们的正题，什么是并发？</p><ol><li>并发是一种现象：同时运行多个程序或者多个任务需要被处理的现象。</li><li>这些任务可能是并行的，也可能是串行的，和CPU的核心数无关，是操作系统进程调度和CPU上下文切换达到的结果。</li><li>解决并发的思路就是把分解，把一个大任务分解成多个小任务来执行</li></ol><p>&emsp;&emsp;像我们上面所说的需求就是分解成一个一个的网络请求，一部分并行请求，一部分串行请求。并行请求简单来说，对应我们应用里面就是多线程，多线程同时执行；串行请求对应我们应用里面就是单线程，一个线程执行完了，另一个线程才开始。这里不考虑多进程的问题。</p><h3 id="并发为什么会造成线程不安全的问题"><a href="#并发为什么会造成线程不安全的问题" class="headerlink" title="并发为什么会造成线程不安全的问题"></a>并发为什么会造成线程不安全的问题</h3><p>&emsp;&emsp;我们先来聊聊cpu是怎么执行指令：</p><ol><li>首先，cpu执行指令的过程中，不可避免会执行读写操作，而这个操作都是从主存（也就是物理内存）中去读写</li><li>但是，cpu执行指令速度很快，程序运行过程中的临时变量都是放在主存当中的，如果全部都是从主存中去读写，读写很耗时，这样就浪费了cpu的性能</li><li>最后，为了解决这个问题，就出现了高速缓存的概念。我们先把变量读取到告诉缓存中，然后，再高速缓存中操作完之后，再刷新到主存当中。</li></ol><p>&emsp;&emsp;java的内存模型规定，所有的变量都在主存当中，类似于物理内存，每个线程都有自己的工作空间，也就是对应上面的高速缓存，每一个线程都有一个自己的高速缓存。</p><p>&emsp;&emsp;线程对变量的操作必须在自己的工作空间内，不能直接操作主存，而且，一个线程也不能访问另一个线程的工作空间。</p><p>&emsp;&emsp;那么，我们如果多个线程同时对一个变量做加1操作，如下面的add1方法。我们thread1和thread2把a的值同时复制到自己的工作空间中时，都是0，然后同时进行加1操作，同时刷新到主存当中，那最后，我们获取到的最终的值就是1，而不是我们想要的2.这就是并发造成的线程不安全的问题</p><h3 id="简单的同步器"><a href="#简单的同步器" class="headerlink" title="简单的同步器"></a>简单的同步器</h3><p>&emsp;&emsp;我们项目里面遇到的并发问题，基本上就是多线程访问同一变量的问题，比方说，简单的举个栗子，两个线程对同一个int值做加1操作，然后打印出来。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int a = 0;</span><br><span class="line">@org.junit.Test</span><br><span class="line">public void add1() &#123;</span><br><span class="line">    Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            a++;</span><br><span class="line">            System.out.println(&quot;thread1:a=&quot; + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            a++;</span><br><span class="line">            System.out.println(&quot;thread2:a=&quot; + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;因为这里直接用的基本类型，极端情况下，线程1，线程2同时执行，里面的a++操作也是同时执行，那这里两个打印都是1，虽然，这里我没有复现出来。但是，这种情况肯定是存在的。那么，怎么避免这种情况呢？</p><p>&emsp;&emsp;我们可以写一个简单的线程同步器，就是加锁操作，如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private Object lock = new Object();</span><br><span class="line">public int a = 0;</span><br><span class="line">@org.junit.Test</span><br><span class="line">public void add1()&#123;</span><br><span class="line">    Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //先获取到lock 对象的锁</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                 //在lock对象上执行wait()方法,让其进入休眠,等待有人唤醒自己</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                a++;</span><br><span class="line">                System.out.println(&quot;thread1:a=&quot; + a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">        //获取lock的锁</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                a++;</span><br><span class="line">                System.out.println(&quot;thread2:a=&quot; + a);</span><br><span class="line">                //唤醒正在lock对象上等待的线程</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里，我们用到的object类的wait和notify方法。等待和唤醒。当线程1执行到lock.wait();方法时，线程1会进入等待状态。当线程2执行lock.notify();时，会唤醒线程1，执行线程1的后续a++，打印操作。</p><p>&emsp;&emsp;那么，这里会有一个问题，如果线程2先执行，线程1后执行，那么线程1将永远的等待下去，这也是这样写的一个弊端。这还只是2个线程，实际项目中往往比这个复杂多了。为了解决这弊端，就引出了我们的<strong><em>线程同步器AQS(AbstractQueuedSynchronizer)</em></strong></p><p>&emsp;&emsp;并且，这个同步器，java.util包下面都已经给好了实现类，比方说：Semaphore，ReentrantLock，CountDownLatch等等都是，并且，我们用到的java线程池ThreadPoolExecutor中的Worker的实现也是。如下图：</p><p><img src="/uploads/article/2021-07-19/worker图片.png" alt="worker图片.png"></p><h3 id="线程同步器AQS-AbstractQueuedSynchronizer"><a href="#线程同步器AQS-AbstractQueuedSynchronizer" class="headerlink" title="线程同步器AQS(AbstractQueuedSynchronizer)"></a>线程同步器AQS(AbstractQueuedSynchronizer)</h3><p>&emsp;&emsp;线程同步器就是为了解决并发引起的线程不安全的问题。线程安全的三大特性：原子性，可见性，有序性。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>&emsp;&emsp;简单点来说就是，它维护一个状态state，还有一个CLH队列。</p><p>&emsp;&emsp;CLH时一个双端队列，队列中每一个节点都放着正在等待获取资源的线程。当线程现在通过CAS原子算法比较预期值的方式去获取资源，也就是判断这里的state状态，是不是有等待获取资源的线程可以使用，如果时有，那就直接使用，如果没有，那就会将这个线程封装成一个节点Node，插入到CLH队列的尾部等待被唤醒。其他线程执行完之后，调用release释放一部分资源，那么，正在等待的队列就会被唤醒，去执行自己的任务。大致是这个意思，当然，AQS还有中断等其他的操作</p><h4 id="简单的AQS同步器"><a href="#简单的AQS同步器" class="headerlink" title="简单的AQS同步器"></a>简单的AQS同步器</h4><p>&emsp;&emsp;还是类似于上面那个例子，不过，都是访问同一个变量，业务背景换一下，换成一个库存秒杀，通过访问服务器，一共10件物品，我现在有20个线程去同时请求，哪些能抢到，哪些不能抢到？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int count = 10;</span><br><span class="line"></span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 20; i++) &#123;</span><br><span class="line">            final int finalI = i;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    buy(finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void buy(int i) &#123;</span><br><span class="line">        if (count != 0) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;库存还剩:&quot; + count + &quot;件&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;已经被抢光了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就像上面这样模拟一个简单的秒杀场景，库存10件，20个用户抢，实际情况肯定不止。我们看一下这样写的打印，如下图：</p><p><img src="/uploads/article/2021-07-19/秒杀图1.png" alt="秒杀图1.png"></p><p>&emsp;&emsp;我们看到这个最终虽然有10个用户的确抢到了，但是，我们看一下打印，打印是从8个开始的，不是从9开始的。我们理想的应该是如下这个图：</p><p><img src="/uploads/article/2021-07-19/秒杀图2.png" alt="秒杀图2.png"></p><p>&emsp;&emsp;这个图是我把buy方法加上了<strong>synchronized</strong>关键字，我给它锁住了。当执行buy方法的时候，另一个线程如果也进来执行buy，它会等待，等待前一个buy方法执行完，它才开始执行。</p><p>&emsp;&emsp;那么，直接用这个关键字就好了呀，还要啥自行车？天真，存在即合理。synchronized关键字锁比较重，不适合这种秒杀场景。</p><p>&emsp;&emsp;言归正传，上面两个从8开始，结合我们前面说的并发的问题，是不是就可以联想到，如果，多个线程同时，同一时刻访问，然后，数据库的库存同时减1，是不是就会出现一件商品，卖给多个人的情况？</p><p>&emsp;&emsp;有同学就会想，那么这么巧，同时访问，同一时刻，那你想想天猫双十一，那些节假日的秒杀场景，会出现什么问题？</p><p>&emsp;&emsp;这个时候线程同步器就出现了，我们不能对用户做限制，我们不能说张三你必须在某一个时间内访问，李四在某一个时间内访问，所以，我们能控制的只有服务器，也就是这里的buy方法。</p><p>&emsp;&emsp;也就是说，我们这里用的是悲观锁的方式，进入buy方法就立刻加锁，运行完buy方法就解锁。后面应用里面再聊这个悲观锁，乐观锁之类的。我们就把buy方法改成如下这样了：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    MyOwnLock ownLock = new MyOwnLock();</span><br><span class="line"></span><br><span class="line">    public void buy(int i) &#123;</span><br><span class="line">        //加锁</span><br><span class="line">        ownLock.lock();</span><br><span class="line">        if (count != 0) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;库存还剩:&quot; + count + &quot;件&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;已经被抢光了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //解锁</span><br><span class="line">        ownLock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">/**</span><br><span class="line"> * @ClassName: MyOwnLock</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: 海晨忆</span><br><span class="line"> * @Date: 2021/7/15 11:07</span><br><span class="line"> */</span><br><span class="line">public class MyOwnLock &#123;</span><br><span class="line">    public void lock() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unLock() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;如上代码，现在，我们要做的就是完善MyOwnLock类的加锁和解锁方法。</p><p>&emsp;&emsp;我们想想这个流程，多个用户同时下单，实际上对于代码来讲，就是多个线程同时请求服务器，调用这里的buy方法，去减少库存，我们需要做的就是保证这里减少库存不能出问题。</p><p>&emsp;&emsp;怎么保证这个减少库存不能出问题呢？就是我们前面说的并发的问题，也就是这里的线程安全的问题。线程安全的三大特性：原子性，可见性，有序性。我们保证这三个特性就好了。</p><p>&emsp;&emsp;第一个线程进来，我们就标记一下，已经有线程进来在执行了，我们就改变这个标记，后面的线程感知到这个改变之后，就必须等待。那这个标记，怎么让其他线程感知到呢？</p><p>&emsp;&emsp;<strong>volatile</strong>关键字的两大特性：可见性，有序性</p><p>&emsp;&emsp;可见性，就是可以让其他线程感知到。那么，就解决了这个问题，我们用计数器的方式来做这个标记。我们是悲观锁的方式，始终只能有一个线程访问，必须等这个线程访问完了，其他线程才能访问。</p><p>&emsp;&emsp;对应成代码就是，这个计数器变量初始化是0，加锁成功之后，就加1，后面的线程进来的时候，判断这个计数器是不是0，如果不是0，就表示有线程正在访问，不能进行加锁操作；如果是0，就表示没有，可以进行加锁操作。那么我们就开始写代码：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.example.myapplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassName: MyOwnLock</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: 海晨忆</span><br><span class="line"> * @Date: 2021/7/15 11:07</span><br><span class="line"> */</span><br><span class="line">public class MyOwnLock &#123;</span><br><span class="line">    private volatile int state;</span><br><span class="line">    private Thread currentHolder;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        int state = getState();</span><br><span class="line">        if (state == 0) &#123;</span><br><span class="line">            setCurrentHolder(currentThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unLock() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(int state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Thread getCurrentHolder() &#123;</span><br><span class="line">        return currentHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCurrentHolder(Thread currentHolder) &#123;</span><br><span class="line">        this.currentHolder = currentHolder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;直接用if(state==0)来判断就可以了吗？volatile关键字只能保证可见性，有序性，并不能保证原子性，所以，volatile并不是真正的线程安全，只是大多数情况下还是比较有用的，而，我们这里要保证线程安全，就需要保证原子性，原子性怎么保证呢？</p><p>&emsp;&emsp;这里就出现了关键的<strong>CAS算法</strong>了，<strong>Compare And Swap</strong>比较互换。这个算法java里面是怎么实现的呢？我们java里面有一个Unsafe类，他的里面全是native方法，提供的都是硬件级别的原子操作。我们用到的就是这个类里面的几个方法，CAS的操作也是这些方法实现的<strong>compareAndSwapXXX</strong>。具体的可以在网上搜一下这个类，然后仔细的看一下，这里，我简单的介绍一个：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * Compares the value of the object field at the specified offset</span><br><span class="line"> * in the supplied object with the given expected value, and updates</span><br><span class="line"> * it if they match.  The operation of this method should be atomic,</span><br><span class="line"> * thus providing an uninterruptible way of updating an object field.</span><br><span class="line"> * 在obj的offset位置比较object field和期望的值，如果相同则更新。这个方法</span><br><span class="line"> * 的操作应该是原子的，因此提供了一种不可中断的方式更新object field。</span><br><span class="line"> * </span><br><span class="line"> * @param obj the object containing the field to modify.</span><br><span class="line"> *    包含要修改field的对象 </span><br><span class="line"> * @param offset the offset of the object field within &lt;code&gt;obj&lt;/code&gt;.</span><br><span class="line"> *         &lt;code&gt;obj&lt;/code&gt;中object型field的偏移量</span><br><span class="line"> * @param expect the expected value of the field.</span><br><span class="line"> *               希望field中存在的值</span><br><span class="line"> * @param update the new value of the field if it equals &lt;code&gt;expect&lt;/code&gt;.</span><br><span class="line"> *               如果期望值expect与field的当前值相同，设置filed的值为这个新值</span><br><span class="line"> * @return true if the field was changed.</span><br><span class="line"> *              如果field的值被更改</span><br><span class="line"> */</span><br><span class="line">public native boolean compareAndSwapObject(Object obj, long offset,</span><br><span class="line">                                           Object expect, Object update);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;所以，加锁流程就变成了如下图的样子，</p><p><img src="/uploads/article/2021-07-19/加锁流程图.png" alt="加锁流程图.png"></p><p>&emsp;&emsp;根据这个流程，代码就变成了如下的样子：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.example.myapplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassName: MyOwnLock</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: 海晨忆</span><br><span class="line"> * @Date: 2021/7/15 11:07</span><br><span class="line"> */</span><br><span class="line">public class MyOwnLock &#123;</span><br><span class="line">    private volatile int state;</span><br><span class="line">    private Thread currentHolder;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        if (acquire())&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean acquire()&#123;</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        int state = getState();</span><br><span class="line">        if (state == 0) &#123;</span><br><span class="line">            if (compareAndSwapState(0,1)) &#123;</span><br><span class="line">                setCurrentHolder(currentThread);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unLock() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(int state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Thread getCurrentHolder() &#123;</span><br><span class="line">        return currentHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCurrentHolder(Thread currentHolder) &#123;</span><br><span class="line">        this.currentHolder = currentHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;加锁流程就完了吗？这才哪到哪，我们现在加锁就第一个拿到锁的线程开始用了，那后面没有拿到锁的线程怎么办呢？难道全部丢掉不管吗？</p><p>&emsp;&emsp;当然不行。那怎么办呢？我们先用一个队列，把没有拿到锁的线程存起来，排好队，等第一个线程执行完了之后，释放锁的时候，再直接唤醒等待的线程即可；</p><p>&emsp;&emsp;把阻塞的线程全放进队列（并且要线程安全，高并发的情况下迅速 入队，出队）中，当T1释放锁是，直接唤醒T2。队列选择用ConcurrentLinkedQueue<thread>（基于CAS算法，保证入队，出队安全）</thread></p><p>&emsp;&emsp;那么，要怎么做呢？要怎么等待呢？最简单的就是写一个死循环，一直循环去判断锁有没有用完。但是，这样会一直占用CPU，消耗性能。</p><ol><li>用sleep？Thread.sleep可能造成等待时间过长，你没法知道休眠的时间，如果，线程1执行完只需要200毫秒，你这里休眠了1000毫秒，那就浪费了800毫秒了。</li><li>那用Thread.yield()可以了吧？答案是不行，这个线程让步，虽然把cpu的时间片让出去给其他线程用了，但是，最后，我们需要唤醒的时候，怎么办呢？</li></ol><p>&emsp;&emsp;我们最后唤醒，是要指定唤醒哪一个线程，这里我们还是用到刚才Unsafe里面的两个方法，park和unPark。park阻塞线程，让出cpu的使用权，unPark解除阻塞，唤醒某一个线程。</p><p>&emsp;&emsp;这里我们用它的包装类LockSupport。所以，加锁代码就变成这样子了：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private ConcurrentLinkedQueue&lt;Thread&gt; waiterQueue = new ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public void lock() &#123;</span><br><span class="line">    if (acquire()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    waiterQueue.add(currentThread);</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        if (currentThread != waiterQueue.peek() &amp;&amp; acquire()) &#123;</span><br><span class="line">            waiterQueue.poll();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.park(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;获取锁的方法也要做相应的调整，如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean acquire() &#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    int state = getState();</span><br><span class="line">    if (state == 0) &#123;</span><br><span class="line">        boolean temp = waiterQueue.size() == 0 || currentThread == waiterQueue.peek();</span><br><span class="line">        if (temp &amp;&amp; compareAndSwapState(0, 1)) &#123;</span><br><span class="line">            setCurrentHolder(currentThread);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;解锁就比较简单了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void unLock() &#123;</span><br><span class="line">    if (Thread.currentThread() != currentHolder) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;出错啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int state = getState();</span><br><span class="line">    if (compareAndSwapState(state, 0)) &#123;</span><br><span class="line">        setCurrentHolder(null);</span><br><span class="line">        Thread firstThread = waiterQueue.peek();</span><br><span class="line">        if (firstThread != null) &#123;</span><br><span class="line">            LockSupport.unpark(firstThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;判断当前线程是不是持有锁的线程，如果不是，那就抛异常<br>如果是，那就获取状态state，通过cas算法，置换为0的状态。</p><p>&emsp;&emsp;最后运行完，结果如下：</p><p><img src="/uploads/article/2021-07-19/最终运行结果图.png" alt="最终运行结果图.png"></p><p>总结：上面我说的简单的线程同步器，只是AQS的一个主要的思想，CAS算法，计数器，线程队列。还有线程中断，独占模式，共享模式，公平锁，不公平锁等等。看完我这个，然后再去看源码应该会更容易懂。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;每一项技术的提出都是为了解决某一个问题，带着问题来理解技术，使得印象你对这个技术的理解印象更加深刻。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA -并发" scheme="https://haichenyi.com/categories/JAVA-%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Android模拟点击</title>
    <link href="https://haichenyi.com/2021/07/07/Android%E6%A8%A1%E6%8B%9F%E7%82%B9%E5%87%BB/"/>
    <id>https://haichenyi.com/2021/07/07/Android模拟点击/</id>
    <published>2021-07-07T13:32:21.000Z</published>
    <updated>2021-08-03T15:09:57.530Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本篇介绍实现模拟点击的两种方式：</p><ol><li>performClick();</li><li><p>MotionEvent事件</p><a id="more"></a></li></ol><p>&emsp;&emsp;举个栗子：我们现在需要实现点击A按钮，触发B按钮点击事件的效果：两个按钮在布局里面随便创建就好了。</p><p>&emsp;&emsp;<strong><em>第一种方式就是：调用performClick事件</em></strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Button btn1 = findViewById(R.id.btn1);</span><br><span class="line">final Button btn2 = findViewById(R.id.btn2);</span><br><span class="line">btn1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn1&quot;);</span><br><span class="line">        btn2.performClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">btn2.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这种方式很简单，但是有一个弊端，就是不会传递触摸点坐标，只是模拟一下btn2的点击事件。</p><p>&emsp;&emsp;<strong><em>第二种方式就是：MotionEvent事件</em></strong><br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Button btn1 = findViewById(R.id.btn1);</span><br><span class="line">final Button btn2 = findViewById(R.id.btn2);</span><br><span class="line">btn1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn1&quot;);</span><br><span class="line">        long downTime = SystemClock.uptimeMillis();</span><br><span class="line">        long eventTime = SystemClock.uptimeMillis()+100;</span><br><span class="line">        float upX = btn2.getX()+50;</span><br><span class="line">        float upY = btn2.getY()+50;</span><br><span class="line">        MotionEvent obtainDown = MotionEvent.obtain(downTime, eventTime, ACTION_DOWN, upX, upY, 0);</span><br><span class="line"></span><br><span class="line">        long downTime1 = SystemClock.uptimeMillis();</span><br><span class="line">        long eventTime1 = SystemClock.uptimeMillis()+100;</span><br><span class="line">        float upX1 = btn2.getX()+50;</span><br><span class="line">        float upY1 = btn2.getY()+50;</span><br><span class="line">        MotionEvent obtainUp = MotionEvent.obtain(downTime1, eventTime1, MotionEvent.ACTION_UP, upX1, upY1, 0);</span><br><span class="line">        btn2.dispatchTouchEvent(obtainDown);</span><br><span class="line">        btn2.dispatchTouchEvent(obtainUp);</span><br><span class="line">        obtainDown.recycle();</span><br><span class="line">        obtainUp.recycle();</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;downTime:&quot;+downTime+&quot; ,eventTime:&quot;+eventTime+&quot; ,upX:&quot;+upX+&quot; ,upY:&quot;+upY+&quot; ,downTime1:&quot;+downTime1+&quot; ,eventTime1:&quot;+eventTime1+&quot; ,upX1:&quot;+upX1+&quot; ,upY1:&quot;+upY1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">btn2.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;这种方式比较麻烦，用到的就是view的事件分发，一个简单的点击事件的触发就是down和up组成，当然还有平移我们这里不考虑。</p><p>&emsp;&emsp;<strong>第一步</strong>，先用MotionEvent.obtain创建两个事件：一个down事件，一个up事件，创建的时候需要传递坐标点，传你目标view的范围内的坐标就行。</p><p>&emsp;&emsp;<strong>第二步</strong>，通过目标view，也就是这里的btn2去把这两个事件分发出去，通过dispatchTouchEvent分发，这样就完成了一次模拟点击事件，分发完记得回收</p><p>&emsp;&emsp;这样，就完成了一次模拟点击，并且坐标也传递了。因为，创建这两个事件的时候就传递了。解决了performClick的弊端。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本篇介绍实现模拟点击的两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;performClick();&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MotionEvent事件&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="https://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列-消息(RabbitMQ)（二十）</title>
    <link href="https://haichenyi.com/2019/11/27/SpringBoot%E7%B3%BB%E5%88%97-%E6%B6%88%E6%81%AF-RabbitMQ-%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/11/27/SpringBoot系列-消息-RabbitMQ-（二十）/</id>
    <published>2019-11-27T06:44:45.000Z</published>
    <updated>2021-08-03T15:15:09.589Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;大多数应用当中，可通过消息服务中间件来提升系统的异步通信和扩展解耦能力。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>消息服务中两个重要的概念</p><p>&emsp;&emsp;<strong>消息代理</strong>和<strong>目的地</strong>：当消息发送者发送消息之后，将由消息代理接管，消息代理保证消息发送到指定的目的地。</p><p>消息发送的两种方式：</p><ol><li>队列(Queue)：点对点消息通信(point-to-point)</li><li>主题(Topic)：发布(publish)/订阅(subscribe)式消息通信</li></ol><p>&emsp;&emsp;开始说了，消息可以提升系统的异步通信和扩展解耦能力。异步通信，我们之前讲异步任务的时候已经说过了。给用户发送邮件就是最好，最直接的例子。</p><p>&emsp;&emsp;至于，扩展解耦能力，最好最直接的例子就是流量削峰，举个例子：整点秒杀。库存只有100件，用户有10000个人，整点用户讲发送10000个请求，难道每个都请求数据库吗？这个时候，我们就可以做个限制，用户发送的请求先到消息队列，然后，再由消息队列统一管理，哪些请求时可以到数据库的，哪些请求时不可以到数据库的，这样就解决了数据库的抗压能力。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;点对点式</p><ul><li>消息发送者发送消息之后，消息代理将消息放在一个队列当中，消息接收者从队列中获取消息内容，消息读取后移除队列</li><li>消息只有唯一的发送者和接收者，但并不是说只能有一个接收者</li></ul><p>&emsp;&emsp;发布订阅式</p><ul><li>发送者(发布者)发送消息到主题(topic)，多个接收者(订阅者)监听(订阅)这个主题，那么，就会在消息到达的同时收到消息</li></ul><p><strong>JMS和AMQP</strong></p><ul><li>JMS:Java message service ：Java消息服务基于JVM消息代理规范，ActiveMQ,HornetMQ就是JMS的实现</li><li>AMQP:advanced message Queue Protocol：高级消息队列协议，也是消息代理的规范，兼容JMS，RabbitMQ就是AMQP的实现。</li></ul><p><strong>对比</strong></p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">JMS</th><th style="text-align:left">AMQP</th></tr></thead><tbody><tr><td style="text-align:left">定义</td><td style="text-align:left">Java api</td><td style="text-align:left">网络线级协议</td></tr><tr><td style="text-align:left">跨语言</td><td style="text-align:left">否</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">跨平台</td><td style="text-align:left">否</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">model</td><td style="text-align:left">提供两种消息模式：peer-2-peer，pub/sub</td><td style="text-align:left">提供五种消息模式：direct exchange，fanout exchange，topic change，headers exchange，system exchange。本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分</td></tr><tr><td style="text-align:left">支持消息类型</td><td style="text-align:left">多种消息类型：TextMessage，MapMessage，BytesMessage，StreamMessage，ObjectMessage，Message （只有消息头和属性）</td><td style="text-align:left">byte[]类型，当实际应用中有复杂消息时，可以序列化之后再发送</td></tr><tr><td style="text-align:left">综合评价</td><td style="text-align:left">JMS定义了java api层面的标准，在Java体系中，多个client均可通过JMS进行交互，不需要修改代码，但是其对跨平台支持较差</td><td style="text-align:left">AMQP天然具有跨平台，跨语言特性</td></tr></tbody></table><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>Message</strong></p><p>&emsp;&emsp;消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等</p><p><strong>Publisher</strong></p><p>&emsp;&emsp;消息的生产者，也是一个向交换器发布消息的客户端应用程序</p><p><strong>Exchange</strong></p><p>&emsp;&emsp;交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange有4种类型：direct(默认)，fanout,topic,和headers，不同类型的Exchange转发消息的策略有所区别。</p><p><strong>Queue</strong></p><p>&emsp;&emsp;消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><strong>Binding</strong></p><p>&emsp;&emsp;绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和Queue的绑定可以是多对多的关系。</p><p><strong>Connection</strong></p><p>&emsp;&emsp;网络连接，比如一个TCP连接。</p><p><strong>Channel</strong></p><p>&emsp;&emsp;信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><p><strong>Consumer</strong></p><p>&emsp;&emsp;消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><p><strong>Virtual Host</strong></p><p>&emsp;&emsp;虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><p><strong>Broker</strong></p><p>&emsp;&emsp;表示消息队列服务器实体</p><p><img src="/uploads/article/2019-11-27/RabbitMQ流程图.png" alt="RabbitMQ流程图.png"></p><p><strong>流程</strong></p><p>&emsp;&emsp;AMQP的消息路由过程跟JMS存在一些差异，增加了Exchange和Binding的角色</p><p>JMS流程：</p><ol><li>生产者(publisher)生成某个消息(Message)，发送到某个队列(Queue)上</li><li>消费者(Consumer)监听这个队列(Queue)，消费消息</li></ol><p>RabbitMQ流程：</p><ol><li>生产者(publisher)生成某个消息(Message)，把这个消息发送给我们的消息代理服务器上(Broker)</li><li>服务器收到消息之后，把这个消息给到一个合适的交换器(Exchange),(服务器有非常多的交换器)</li><li>交换器(Exchange)收到这个消息之后，根据路由键(Binding绑定关系)把这个消息给一个或者多个消息队列(Queue)(服务器有很多个消息队列)</li><li>消费者(Consumer)连接上队列之后取出消息</li></ol><p><strong><em>重点就是：交换器和队列的绑定</em></strong></p><p><strong><em>重点就是：交换器和队列的绑定</em></strong></p><p><strong><em>重点就是：交换器和队列的绑定</em></strong></p><p>&emsp;&emsp;我们上面说了Exchange有4种，不同类型转发的消息策略不同，那么，这个策略是什么呢？其中，header和direct交换器完全一致，但是header性能上差很多，基本上不用了</p><p><strong><em>重点start</em></strong></p><ul><li>direct交换器：当我们发送消息时的路由键和绑定中的key完全一致的时候，交换器就将消息发送到该队列当中。它时完全匹配单播模式</li><li>fanout交换器：当我们消息发送到fanout交换器时，不管交换器与队列绑定的路由键时什么，fanout交换器都会把这个消息发送给每一个队列，跟UDP广播类似，fanout交换器发送消息最快。</li><li>topic交换器：该交换器允许我们对路由键做模糊匹配，有选择性的发送给某一个或者多个队列。两个通配符:井号(#)和星号(*)。其中：井号：匹配0个或者多个单词。星号：匹配一个单词。</li></ul><p><strong><em>重点end</em></strong></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>&emsp;&emsp;首先，打开我们的虚拟机，用SecureCRT连接我们的虚拟机，我用的SecureCRT，至于你用的啥连接虚拟机，随便你。</p><p>&emsp;&emsp;然后，用docker安装带manager版本的rabbit，带manager的版本自带图形化界面，容易操作。从docker hub上面搜索，我安装的是</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3.8.1-management</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;接着，新建容器，记得带端口号,-d后台运行，映射两个端口号，起自己的名字，加上镜像id</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq 镜像id</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;接下来，就可以访问了，通过虚拟机的ip地址加上端口号，账号密码都是guest</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟机ip地址:15672</span><br></pre></td></tr></table></figure></div><p><img src="/uploads/article/2019-11-27/RabbitMQ管理界面图.png" alt="RabbitMQ管理界面图.png"></p><p>&emsp;&emsp;我们在图上，就能看到我们前面说过的：Connection，Channel，Exchange，Queue等等。</p><p>&emsp;&emsp;最后面那个admin，我们能够设置用户名和密码，就是我们前面登录的guest，并且，能够设置访问的Virtual Hosts。</p><p>&emsp;&emsp;我们看一下最上面的流程图和消息发送流程<br>，我就举一个例子：</p><ol><li>首先，我们先创建一个交换器名字叫：haichenyi</li></ol><p><img src="/uploads/article/2019-11-27/创建交换器.png" alt="创建交换器.png"></p><ol><li>其次，我们再创建一个队列，名字也叫：haichenyi</li></ol><p><img src="/uploads/article/2019-11-27/创建消息队列.png" alt="创建消息队列.png"></p><ol><li>接着，我们将这交换器和队列绑定到一起</li></ol><p><img src="/uploads/article/2019-11-27/交换器与队列绑定.png" alt="交换器与队列绑定.png"></p><ol><li><p>然后，我们随便发送一条消息</p></li><li><p>最后，查看消息队列</p></li></ol><p><img src="/uploads/article/2019-11-27/发送消息之后的queue.png" alt="发送消息之后的queue.png"></p><p>PS：</p><ul><li>我们在创建Exchange和Queue的时候，有一个选项：Durability，意思是是否可持久化，也就是，服务器重启之后这个东西是否还存在。就选默认的durable就行了，可持久化的</li><li>我们在Exchange和Queue绑定的时候，发送消息的时候，都要填一个Routing key，就是上文我们说的绑定规则。</li></ul><p>&emsp;&emsp;这就是整个流程，这都是页面操作，下面说一下代码里面怎么写，很简单。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;首先，添加依赖：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后，就是配置：两个可能出错的位置，我已经注释标明了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=192.168.113.22</span><br><span class="line">#这里端口号要用5672，不能用15672，15672是后台管理页面的端口号</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">#这里的用户民和密码还有virtual-host要对应上，新建的账号要记得给权限</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;代码怎么写呢？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class SellApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        //message需要自己构造一个；定义消息体内容和消息头</span><br><span class="line">        //rabbitTemplate.send(exchange,routingKey,message);</span><br><span class="line"></span><br><span class="line">        //Object默认当成消息体，只需传入要发送的对象，自动序列化发送给RabbitMQ</span><br><span class="line">        //rabbitTemplate.convertAndSend(exchange,routingKey,Object);</span><br><span class="line">        </span><br><span class="line">        //对象会被默认序列化之后发送</span><br><span class="line">        User user = new User(&quot;海晨忆&quot;,25);</span><br><span class="line">        rabbitTemplate.convertAndSend(&quot;haichenyi&quot;,&quot;haichenyi&quot;,user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void getMsg()&#123;</span><br><span class="line">        //queueName:需要从哪个队列中收消息</span><br><span class="line">        User user = (User) rabbitTemplate.receiveAndConvert(&quot;haichenyi&quot;);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        System.out.println(user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;可以向上面这样测试，发送和接收。实际应用中，我们要向下面这样写：</p><ul><li>启动类上添加@EnableRabbit注释，开启Rabbit监听功能</li><li>在我们接收的方法添加@RabbitListener注解，queues是一个数组，方法的参数是发送的数据类型。</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;haichenyi&quot;)</span><br><span class="line">    public void receive(User user)&#123;</span><br><span class="line">        System.out.println(&quot;收到消息：&quot;+user);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        System.out.println(user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;以上，就是RabbitMQ的简单使用了，上面的Exchange，Queue都是在管理界面创建绑定的，代码里面怎么创建绑定呢？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    RabbitAdmin rabbitAdmin;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void createExchange()&#123;</span><br><span class="line">        //以declare开头的都是创建，这里是创建一个Exchange，需要传一个Exchange对象</span><br><span class="line">        //我们点击过去看，是一个接口，我们就看它的实现类。可以看到5种实现类</span><br><span class="line">        rabbitAdmin.declareExchange(new DirectExchange(&quot;wang.exchange&quot;));</span><br><span class="line">        //创建一个queue队列</span><br><span class="line">        rabbitAdmin.declareQueue(new Queue(&quot;wang.queue&quot;));</span><br><span class="line">        //destination：目的地</span><br><span class="line">        //Binding.DestinationType destinationType：类型,枚举类：队列和交换器两种</span><br><span class="line">        //exchange：交换器</span><br><span class="line">        //routingKey：路由键</span><br><span class="line">        //arguments：头信息</span><br><span class="line">        //绑定有两种绑定方式，一种是把交换器往队列上面绑定，一种是把队列往交换器上面绑定</span><br><span class="line">        rabbitAdmin.declareBinding(new Binding(&quot;wang.queue&quot;,Binding.DestinationType.QUEUE,&quot;wang.exchange&quot;,&quot;wang.key&quot;,null));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后，发消息的操作就跟前面写的一样了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;大多数应用当中，可通过消息服务中间件来提升系统的异步通信和扩展解耦能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列-Docker（十九）</title>
    <link href="https://haichenyi.com/2019/11/13/SpringBoot%E7%B3%BB%E5%88%97-Docker%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/11/13/SpringBoot系列-Docker（十九）/</id>
    <published>2019-11-13T06:44:37.000Z</published>
    <updated>2021-08-03T15:13:36.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，<br>然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><a id="more"></a><p>&emsp;&emsp;容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。</p><p>&emsp;&emsp;我们spring boot项目，什么地方需要用到dockers呢？我们最后项目发布，发到服务器上面，环境怎么搭建？如果就用Linux命令会很麻烦，用Docker，简单的几行命令就可以了。</p><p>&emsp;&emsp;服务器其实就是一个操作系统，我们的项目跑在上面也是需要环境的，我们本地是windows系统，跑项目需要环境，服务器现在一般都是centOS系统，当然也需要环境。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>docker镜像(images)：Docker镜像用于创建Docker容器的模板</li><li>docker容器(container)：Docker容器是独立运行的一个或者一组应用</li><li>docker客户端(client)：客户端通过命令或者其他工具一起使用docker api与docker守护进程</li><li>docker主机(host)：一个物理或者虚拟的机器用于执行docker守护进程和容器</li><li>docker仓库(registry)：docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。docker hub提供了庞大的镜像集合供使用</li></ul><p>&emsp;&emsp;举个例子，我们一般操作流程是这样的：</p><ol><li>先用VirtualBox启动一个虚拟机，启动的是centOS系统，装上docker程序（docker主机）。这个对应的就是我们项目最后发布的服务器。</li><li>然后，用SecureCRT连上我们这个虚拟机。（docker客户端）。</li><li>接着，通过docker从docker 仓库中下载我们需要的镜像，比方说：mysql镜像，redis镜像等等。</li><li>最后，启动这个镜像，就相当于创建一个容器。启动镜像，就相当于配置好了环境。比方说：启动一个mysql镜像，就相当于创建了一个mysql容器，就可以用mysql数据库了。可以启动的那个多个镜像，并且，每个镜像都是独立运行的，互不干扰（沙箱机制）。</li></ol><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>查看centOS版本：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//docker要求CentOS系统内核版本要高于3.10</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure></div><p>升级软件包及内核：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//因为，我们安装的docker是最新版本的</span><br><span class="line">//但是，内核版本低可能不兼容，所以，要更新</span><br><span class="line">//如果，后面安装成功之后，启动的时候出错，那么就先卸载docker，更新内核</span><br><span class="line">//重启之后，再重新安装docker就行了</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure></div><p>安装docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure></div><p>卸载docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-*</span><br></pre></td></tr></table></figure></div><p>启动docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></div><p>将docker作为开机启动</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></div><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">检索</td><td style="text-align:left">docker search 关键字（eg：docker search redis）</td><td style="text-align:left">我们经常去docker hub上检索镜像的详细信息，不用再本地敲命令搜索。如镜像的TAG</td></tr><tr><td style="text-align:left">拉取</td><td style="text-align:left">docker pull 镜像名:tag</td><td style="text-align:left">:tag是可选的，tag表示标签，多为软件的版本，默认是latest版本</td></tr><tr><td style="text-align:left">列表</td><td style="text-align:left">docker images</td><td style="text-align:left">查看所有本地镜像</td></tr><tr><td style="text-align:left">删除</td><td style="text-align:left">docker rmi image-id</td><td style="text-align:left">删除指定的本地镜像，镜像id可以通过列表查看</td></tr><tr><td style="text-align:left">运行</td><td style="text-align:left">docker run -d –name 自定义名字  安装的容器名字（eg:docker run –d –name myredis redis）</td><td style="text-align:left">–name：自定义容器名 -d：后台运行</td></tr><tr><td style="text-align:left">列表</td><td style="text-align:left">docker ps（查看运行中的容器）</td><td style="text-align:left">加上-a；可以查看所有容器</td></tr><tr><td style="text-align:left">停止</td><td style="text-align:left">docker stop container-name/container-id</td><td style="text-align:left">停止当前你运行的容器</td></tr><tr><td style="text-align:left">启动</td><td style="text-align:left">docker start container-name/container-id</td><td style="text-align:left">启动容器</td></tr><tr><td style="text-align:left">删除</td><td style="text-align:left">docker rm container-id</td><td style="text-align:left">删除指定容器</td></tr><tr><td style="text-align:left">端口映射</td><td style="text-align:left">-p 6379:6379</td><td style="text-align:left">-p: 主机端口(映射到)容器内部的端口</td></tr><tr><td style="text-align:left">容器日志</td><td style="text-align:left">docker logs container-name/container-id</td></tr></tbody></table><p>PS:我们docker run的时候一般都是跟上端口映射，不然访问不到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。&lt;br&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，&lt;br&gt;然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Run启动原理（十八）</title>
    <link href="https://haichenyi.com/2019/11/11/SpringBoot%E7%B3%BB%E5%88%97-Run%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/11/11/SpringBoot系列-Run启动原理（十八）/</id>
    <published>2019-11-11T09:28:35.000Z</published>
    <updated>2021-08-03T15:14:04.690Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;需要搞清楚几个重要的事件回调机制</p><p>配置在META-INF/spring.factories</p><ul><li>ApplicationContextInitializer</li><li>SpringApplicationRunListener</li></ul><p>只需要放在ioc容器中</p><ul><li><p>ApplicationRunner </p></li><li><p>CommandLineRunner</p></li></ul><a id="more"></a><p>&emsp;&emsp;新建一个空项目，就勾选web，找到启动类，每个方法上面写的注释，可以看一下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SellApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SellApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上面run方法点进来</span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;</span><br><span class="line">return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;</span><br><span class="line">return new SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>看到这里，就应该看到了，启动流程分为两步</p><ol><li>创建SpringApplication对象</li><li>运行run方法</li></ol><h3 id="创建SpringApplication对象"><a href="#创建SpringApplication对象" class="headerlink" title="创建SpringApplication对象"></a>创建SpringApplication对象</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//上面的构造方法点进去</span><br><span class="line">//这里与1.5版本不一样的地方就是，</span><br><span class="line">//2.X这里调用了重载的构造方法，而1.5这里调用的是一个initialize()方法，这个方法里面的内容，与下面两个参数的重载方法差不多</span><br><span class="line">public SpringApplication(Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">this(null, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面这个就是this调用的重载的构造方法</span><br><span class="line">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">this.resourceLoader = resourceLoader;</span><br><span class="line">//保存主配置类，1.5里面这里有个非空判断，用if做的，这里换成的断言做判断</span><br><span class="line">Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">//判断当前是否一个web应用</span><br><span class="line">this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">//从类路径下找到META‐INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起 来</span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">//从类路径下找到ETA‐INF/spring.factories配置的所有ApplicationListener</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">//从多个配置类中找到有main方法的主配置类</span><br><span class="line">this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="setInitializers-方法"><a href="#setInitializers-方法" class="headerlink" title="setInitializers()方法"></a>setInitializers()方法</h4><p>&emsp;&emsp;看方法名就知道，这个是初始化方法，初始化什么东西呢？再看传的参数ApplicationContextInitializer，就是一开始我们提到的类。我们看这个是怎么获取的</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//第一步：</span><br><span class="line">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">return new SpringApplicationRunListeners(logger,</span><br><span class="line">getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二步：</span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line">// Use names and ensure unique to protect against duplicates</span><br><span class="line">//看这里的导入方法SpringFactoriesLoader.loadFactoryNames(type, classLoader)</span><br><span class="line">Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">return instances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三步：</span><br><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line">return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第四步，就是这里了。看这里面的实现</span><br><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">if (result != null) &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">//一眼看过去。很明显，这里就是classLoader.getResources()，导入的本地的资源。看这个传的参数,我放到这个方法下面去了</span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != null ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">//这里通过一个while循环，加载本地配置的ApplicationContextInitializer</span><br><span class="line">while (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = new UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException ex) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The location to look for factories.</span><br><span class="line"> * &lt;p&gt;Can be present in multiple JAR files.</span><br><span class="line"> */</span><br><span class="line">public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;所以，从上面的源码，我们一步一步点击进去看，我们就能发现，他最终都是加载到 <strong>META-INF/spring.factories</strong> 目录下的 <strong>ApplicationContextInitializer</strong> 当然，到目前为止这里只是初始化</p><h4 id="setListeners-方法"><a href="#setListeners-方法" class="headerlink" title="setListeners()方法"></a>setListeners()方法</h4><p>&emsp;&emsp;一眼就能看出来，这里是设置监听方法</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;一眼看过去，这个setListener方法传的参数熟不熟悉？就是我们上面初始化的时候传的参数是同一个方法。所以，这里设置监听设置哪些监听方法也是<strong>META-INF/spring.factories</strong> 目录下的listener方法，我们看一下这个文件内容：</p><p><img src="/uploads/article/2019-11-11/spring_factories.png" alt="spring_factories.png"></p><p>&emsp;&emsp;这些都是是自动配置类的内容</p><h3 id="运行Run方法"><a href="#运行Run方法" class="headerlink" title="运行Run方法"></a>运行Run方法</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">StopWatch stopWatch = new StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = null;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">//获取SpringApplicationRunListeners；从类路径下META‐INF/spring.factories</span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">//回调所有的获取SpringApplicationRunListener.starting()方法</span><br><span class="line">listeners.starting();</span><br><span class="line">try &#123;</span><br><span class="line">    //封装命令行参数</span><br><span class="line">ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">//准备环境，创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准 备完成</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">//这里是新增的，点击去看，就是再properties文件中配置你需要忽略的bean</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">//这个是打印spring的logo banner图</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">/创建ApplicationContext；这个下面有下介绍</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">//看一下参数，这个就是做异常报告处理的</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"></span><br><span class="line">//准备上下文环境;将environment保存到ioc中；而且applyInitializers()；</span><br><span class="line">//applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法</span><br><span class="line">//回调所有的SpringApplicationRunListener的contextPrepared()；</span><br><span class="line">//prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded()；</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">//s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版</span><br><span class="line">//扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）</span><br><span class="line">refreshContext(context);</span><br><span class="line">//2.x里面是空方法</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line"></span><br><span class="line">//从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">//返回这个IOC容器</span><br><span class="line">return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="getRunListeners-方法"><a href="#getRunListeners-方法" class="headerlink" title="getRunListeners()方法"></a>getRunListeners()方法</h4><p>&emsp;&emsp;我们看到上面第一个有注释的位置：getRunListeners方法</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">return new SpringApplicationRunListeners(logger,</span><br><span class="line">getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;方法熟悉吗？就是我们上面初始化的时候调用的那个方法，只是这里的参数传的是：<strong>SpringApplicationRunListener</strong>,我们看最开始说的，这就是我们要了解的第二个内容，回调都是怎么调用的</p><p>&emsp;&emsp;方法里面的注释也写了，先获取监听事件，然后回调starting方法，我们看一下这个接口有那些回调方法：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface SpringApplicationRunListener &#123;</span><br><span class="line"></span><br><span class="line">default void starting() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void environmentPrepared(ConfigurableEnvironment environment) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就这些回调，这里还用了1.8的新特性，<strong>default关键字</strong>，接口里面的方法可以有方法体</p><h4 id="prepareEnvironment"><a href="#prepareEnvironment" class="headerlink" title="prepareEnvironment()"></a>prepareEnvironment()</h4><p>&emsp;&emsp;看到第二个写注释的位置，眼熟吗？可不就是跟上面回调方法名字相同么？我们点进去看一下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,</span><br><span class="line">ApplicationArguments applicationArguments) &#123;</span><br><span class="line">// Create and configure the environment</span><br><span class="line">ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line"></span><br><span class="line">//这里划重点，这里就调用的environmentPrepared的回调方法</span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line">if (!this.isCustomEnvironment) &#123;</span><br><span class="line">environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line">return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;准备完环境之后，调用environmentPrepared的回调</p><h4 id="createApplicationContext"><a href="#createApplicationContext" class="headerlink" title="createApplicationContext()"></a>createApplicationContext()</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableApplicationContext createApplicationContext() &#123;</span><br><span class="line">Class&lt;?&gt; contextClass = this.applicationContextClass;</span><br><span class="line">if (contextClass == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">switch (this.webApplicationType) &#123;</span><br><span class="line">case SERVLET:</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">case REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex) &#123;</span><br><span class="line">throw new IllegalStateException(</span><br><span class="line">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;创建applicationContext，这里跟1.5不一样，1.5就只有两种：一种是web的ioc容器，一种是默认的ioc容器。2.X这里有三种：<strong>DEFAULT_CONTEXT_CLASS，DEFAULT_SERVLET_WEB_CONTEXT_CLASS，DEFAULT_REACTIVE_WEB_CONTEXT_CLASS</strong>，实际字符串比较长，可以去看一下源码。然后用BeanUtils通过反射创建。</p><h4 id="prepareContext-方法"><a href="#prepareContext-方法" class="headerlink" title="prepareContext()方法"></a>prepareContext()方法</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span><br><span class="line">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123;</span><br><span class="line">//将environment放到context中</span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">//初始化</span><br><span class="line">applyInitializers(context);</span><br><span class="line">//这里回调contextPrepared方法</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == null);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line">// Add boot specific singleton beans</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);</span><br><span class="line">if (printedBanner != null) &#123;</span><br><span class="line">beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line">if (beanFactory instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line">if (this.lazyInitialization) &#123;</span><br><span class="line">context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">&#125;</span><br><span class="line">// Load the sources</span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</span><br><span class="line">load(context, sources.toArray(new Object[0]));</span><br><span class="line">//这里回调contextLoaded()方法</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;准备上下文环境;将environment保存到ioc中；而且applyInitializers()</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void applyInitializers(ConfigurableApplicationContext context) &#123;</span><br><span class="line">for (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class="line">Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),</span><br><span class="line">ApplicationContextInitializer.class);</span><br><span class="line">Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);</span><br><span class="line">initializer.initialize(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里就将我们一开始从配置文件里面读取，然后创建ApplicationContextInitializer初始化。</p><p>&emsp;&emsp;当环境准备好之后，就回调了SpringApplicationRunListener的contextPrepared()；</p><p>&emsp;&emsp;当所有的都准备好了之后，回调SpringApplicationRunListener的contextLoaded()；</p><p>&emsp;&emsp;到这里，所有的环境都准备好了，需要打印的logo也加进去了。</p><h4 id="refreshContext"><a href="#refreshContext" class="headerlink" title="refreshContext()"></a>refreshContext()</h4><p>&emsp;&emsp;刷新容器这个方法，我们可以点到具体的功能实现里面，可以看到，这里就是扫描，创建，加载所有的组件，配置类，组件，自动配置等。</p><p>&emsp;&emsp;到这里，这个方法创建完之后，所有的控制器就创建完了，所有的组件，bean等，都在控制台打印出来了。如果是web应用，还会创建嵌入式的tomcat。我们spring boot项目内嵌tomcat，就是在这里创建的。</p><h4 id="afterRefresh"><a href="#afterRefresh" class="headerlink" title="afterRefresh()"></a>afterRefresh()</h4><p>&emsp;&emsp;1.5版本这个方法里面回调的是callRunners方法，而2.X版本，现在这是个空方法里面并没有实现。callRunners被提出来了，放到了最后面。</p><h4 id="started-running"><a href="#started-running" class="headerlink" title="started(),running()"></a>started(),running()</h4><p>&emsp;&emsp;在1.5版本这里，也就是afterRefresh()之后，应该是调用的SpringApplicationRunListeners的finished()方法。</p><p>&emsp;&emsp;在2.X版本之后，去掉了finished方法，改成了调用started方法，然后调用running方法。我们上面有一个starting方法，从这里名字就可以看出来，相当于，首先是正在启动当中，然后就是启动完成了，正在运行了。</p><h4 id="callRunners"><a href="#callRunners" class="headerlink" title="callRunners()"></a>callRunners()</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void callRunners(ApplicationContext context, ApplicationArguments args) &#123;</span><br><span class="line">List&lt;Object&gt; runners = new ArrayList&lt;&gt;();</span><br><span class="line">runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123;</span><br><span class="line">if (runner instanceof ApplicationRunner) &#123;</span><br><span class="line">callRunner((ApplicationRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line">if (runner instanceof CommandLineRunner) &#123;</span><br><span class="line">callRunner((CommandLineRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;从IOC容器中(不是配置文件)获取所有的的ApplicationRunner和CommandLineRunner进行回调。这也是最开始说的两个注意的地方</p><p>&emsp;&emsp;并且，这里有个先后顺序，先回调的ApplicationRunner，后回调的CommandLineRunner</p><p>&emsp;&emsp;这里也是run方法，最后执行的地方。从这里就是真正的开启了run。</p><p>&emsp;&emsp;最后一步，返回那个context就是返回IOC容器对象。到这里，我们的spring boot就启动完成了。</p><p>&emsp;&emsp;这就是我们的spring boot的启动原理。初始化，listener的回调，Runner的回调都说的很清楚。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;需要搞清楚几个重要的事件回调机制&lt;/p&gt;
&lt;p&gt;配置在META-INF/spring.factories&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ApplicationContextInitializer&lt;/li&gt;
&lt;li&gt;SpringApplicationRunListener&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只需要放在ioc容器中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ApplicationRunner &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CommandLineRunner&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Redis（十七）</title>
    <link href="https://haichenyi.com/2019/11/06/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Redis%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/11/06/SpringBoot系列—Redis（十七）/</id>
    <published>2019-11-06T08:40:38.000Z</published>
    <updated>2021-08-03T15:13:59.127Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前面一篇说到了spring boot自带的缓存SimpleCache，我们也聊到了他的底层实际上就是HashMap，并且这个缓存是放在内存当中的，这样弊端也是有的，比如：内存大小，当服务器关闭之后，缓存就没了等等。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;实际开发中，一般使用缓存中间件：Redis，EHCache，MemCache等等，今天，我们就来聊聊，经常听到的——Redis。</p><p>&emsp;&emsp;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）——来自官方介绍</p><p>&emsp;&emsp;不去追究原理，我们可以这样理解Redis：</p><ul><li>支持多种数据类型，redis支持set,zset,list,hash,string这五种数据类型，操作方便。</li><li>作为一个内存数据库，最担心的，就是万一机器死机宕机，数据就会消失掉。redis使用RDB和AOF做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。</li><li>与服务器解耦，缓存是一个单独的服务器，当我们项目重启的时候，缓存依然存在。</li><li>我们只用的话，它就是给我们提供了一系列方法的接口，我们只用调用它的API即可。</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;第一步，添加启动器：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第二步，配置你的服务器地址，不配置的话，默认是本地：配置信息一样在 <strong>自动配置类——data包——redis包——RedisProperties类</strong> 里面去找</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#指定redis服务器地址，指定的是本地</span><br><span class="line">spring.redis.host=127.0.0.1</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第三步，添加了redis的配置类，当数据库添加复杂数据的时候，也能以Json的格式正常显示。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport&#123;</span><br><span class="line">@Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        //key序列化方式</span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        //value序列化</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        //value hashmap序列化</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第四步，正常写接口，在service层里面，自己去把数据写进缓存里面，</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboottask.service;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboottask.Provider;</span><br><span class="line">import com.haichenyi.springboottask.mapper.ProviderMapper;</span><br><span class="line">import com.haichenyi.springboottask.utils.RedisClient;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Desc</span><br><span class="line"> * @Auther 海晨忆</span><br><span class="line"> * @Time 2019/11/6</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class ProviderService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    ProviderMapper providerMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    public Provider getProviderById(Integer pid) &#123;</span><br><span class="line">        Provider provider = (Provider) redisClient.get(pid);</span><br><span class="line">        if (provider != null) &#123;</span><br><span class="line">            return provider;</span><br><span class="line">        &#125;</span><br><span class="line">        Provider provider1 = providerMapper.getProviderByPid(pid);</span><br><span class="line">        redisClient.set(pid, provider1);</span><br><span class="line">        return provider1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;如上代码，我们通过id获取一个Provider，我们先从缓存去取，如果，取不到，说明缓存没有，那么，我们就去从数据库去取，取到之后，再把这条数据放进缓存里面。</p><p>&emsp;&emsp;就是上一篇讲默认缓存的注解的功能，redis里面需要我们自己去实现。</p><p>&emsp;&emsp;这里的 <strong>RedisClient</strong> 类，是自己封装的redis使用的类，至于redis怎么使用，redis的<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">中文官网</a>的命令页面写的很清楚。</p><p>&emsp;&emsp;记得本地电脑装一个Redis服务。然后再本地装一个redis可视化工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前面一篇说到了spring boot自带的缓存SimpleCache，我们也聊到了他的底层实际上就是HashMap，并且这个缓存是放在内存当中的，这样弊端也是有的，比如：内存大小，当服务器关闭之后，缓存就没了等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—缓存及其源码分析（十六）</title>
    <link href="https://haichenyi.com/2019/11/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E7%BC%93%E5%AD%98%E5%8F%8A%E5%85%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/11/05/SpringBoot系列—缓存及其源码分析（十六）/</id>
    <published>2019-11-05T02:52:46.000Z</published>
    <updated>2021-08-03T15:14:46.518Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;缓存是每个项目都用到的为了提高接口响应效率，降低数据库的查询压力，从而提高系统性能。所以，缓存对于一个项目来说是至关重要的。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;spring 3+之后，就定义了CacheManager和Cache接口来统一不同的缓存技术。</p><ul><li>CacheManager：缓存管理器，用于管理各种Cache缓存组件</li><li>Cahce：定义了各种操作，Spring在Cache接口下提供了各种xxCache的实现；比如：ConcurrentMapCache，RedisCache，JCacheCache等等</li></ul><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>&emsp;&emsp;这里我以默认缓存为例：ConcurrentMapCache</p><p>&emsp;&emsp;上面说了，缓存只用配置就可以直接使用，所以，配置，一说到配置，我们就会想到之前说的自动配置类AutoConfigure。如下图：</p><p><img src="/uploads/article/2019-11-05/缓存结构图.png" alt="缓存结构图.png"></p><p>&emsp;&emsp;我们看到，自动配置类目录下面有一个cache包，这就是缓存自动配置的包，我们熟悉的类就有CacheProperties这个类，我们点进去看：</p><p><img src="/uploads/article/2019-11-05/缓存配置类.png" alt="缓存配置类.png"></p><p>&emsp;&emsp;我们熟悉的prefix就在这里了，也就是我们在全局配置类里面的键。</p><p>&emsp;&emsp;这里，配置的一般都是这个类里面的全局变量，我把这个CacheType给框出来了（下面的cacheNames这个list变量也很重要），上面的注释的意思是说，缓存类型，默认情况下，是根据环境自动检测的。</p><p>&emsp;&emsp;我们上面说到CacheManager和Cache接口是用来同意管理不同的缓存技术。不同的，也就是指的我们这里的缓存类型。所以，我们这里的缓存类型肯定有好几种，然后，这里又讲是根据环境自动检测的。也就是我们配置好的。也就是我们在全局配置类里面配置好的</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.xxx=xxx</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;既然是配置，肯定是定义了之后才能配置的，没定义，怎么可能配置，spring又不是神。那，定义了那些种类的缓存技术呢？我们看一下CacheType类</p><p><img src="/uploads/article/2019-11-05/缓存枚举类.png" alt="缓存枚举类.png"></p><p>&emsp;&emsp;定义的，就这10种：GENERIC，JCACHE，EHCACHE，HAZELCAST，INFINISPAN，COUCHBASE，REDIS，CAFFEINE，SIMPLE，NONE。作为一个初学者，我想一眼看过去，我们能看到熟悉的Redis，学后天，Redis框架肯定要学。</p><p>&emsp;&emsp;我们现在，什么都没有配置，默认的缓存类型就是这个Simple，可以在Cache目录下面的CacheAutoConfiguration类中看到selectImports方法，在这里打断点，我们debug模式运行，我们就能看到它导入的缓存类型，然后，每个进行检测，看匹配哪一个。</p><p><img src="/uploads/article/2019-11-05/默认导入的缓存.png" alt="默认导入的缓存.png"></p><p>&emsp;&emsp;我们就看一下SimpleCacheConfiguration是怎么实现的</p><p><img src="/uploads/article/2019-11-05/SimpleCacheConfiguration图.png" alt="SimpleCacheConfiguration图.png"></p><p>&emsp;&emsp;我们看到了，SimpleCacheConfiguration默认使用的是：ConcurrentMapCacheManager，我们，看一下这个Manager是怎么实现的</p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCacheManager图1.png" alt="ConcurrentMapCacheManager图1.png"></p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCacheManager图2.png" alt="ConcurrentMapCacheManager图2.png"></p><p>&emsp;&emsp;这类，实现的就是CacheManager接口，而CacheManager接口就只有两个方法，就是上图中的两个方法<strong>setCacheNames</strong> 和 <strong>getCache</strong></p><p>&emsp;&emsp;先说一下数据是怎么缓存的，缓存是一个容器，这个容器怎么获取的呢？就是通过这里的name，name是获取这个容器的key，然后里面的数据存放形式，都是key-value的形式存放的。这个key也是我们定义的，value就是数据库查询的数据。如下图。</p><p><img src="/uploads/article/2019-11-05/缓存图.png" alt="缓存图.png"></p><p>&emsp;&emsp;这个setCacheNames，就是，我们配置的cacheNames的值，它会获取好之后，将这些值封装成list，通过setCacheNames方法赋值给这里的变量cacheMap。我们可以看一下这个变量：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final ConcurrentMap&lt;String, Cache&gt; cacheMap = new ConcurrentHashMap&lt;&gt;(16);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后就是这个getCache方法，上面的setCacheNames以cacheName为键去存这个Cache，这个就是刚好相反，获取方法，通过cacheName去获取这个Cache。</p><p>&emsp;&emsp;然后，我们现在是获取到了这个缓存容器，那么，我们要怎么从这个缓存容器中去获取我们对应的数据呢？</p><p>&emsp;&emsp;我们看到上面那个变量是Map是以String为键，以Cache为值，我们最开始说过了，Cache和CacheManager是用来管理不同缓存技术的接口，所以，这里的值不可能是一个接口对象，肯定是它的实现类，我们再仔细看上面两个方法的实现类，我们会看到</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//setCacheNames方法</span><br><span class="line">this.cacheMap.put(name, createConcurrentMapCache(name));</span><br><span class="line"></span><br><span class="line">//getCache方法</span><br><span class="line">cache = createConcurrentMapCache(name);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;很明显，这里就是Cache对象是怎么创建的，我们点到这个方法里面去看：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create a new ConcurrentMapCache instance for the specified cache name.</span><br><span class="line"> * @param name the name of the cache</span><br><span class="line"> * @return the ConcurrentMapCache (or a decorator thereof)</span><br><span class="line"> */</span><br><span class="line">protected Cache createConcurrentMapCache(String name) &#123;</span><br><span class="line">SerializationDelegate actualSerialization = (isStoreByValue() ? this.serialization : null);</span><br><span class="line">return new ConcurrentMapCache(name, new ConcurrentHashMap&lt;&gt;(256),</span><br><span class="line">isAllowNullValues(), actualSerialization);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;所以，它这里是new的ConcurrentMapCache肯定是Cache的实现类。我们看到这个构造方法，第二个参数是一个hashMap，而我们的缓存容器里面也是以键值对的方式存储数据的。我们再看这个ConcurrentMapCache</p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCache图.png" alt="ConcurrentMapCache图.png"></p><p>&emsp;&emsp;一共就只有三个全局变量，第一个name，是我们前面传过来的cacheName，第二个是Map<object,object>类型，第三个是SerializationDelegate类型的变量，序列化的一个什么东西。排除法判断，只可能这个Map就是用来存放我们的缓存数据的。我们搜索这个变量，我们会看到如下几个方法：</object,object></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   //获取缓存数据</span><br><span class="line">   @Override</span><br><span class="line">@Nullable</span><br><span class="line">protected Object lookup(Object key) &#123;</span><br><span class="line">return this.store.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   //存放</span><br><span class="line">   @Override</span><br><span class="line">public void put(Object key, @Nullable Object value) &#123;</span><br><span class="line">this.store.put(key, toStoreValue(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过key移除数据</span><br><span class="line">@Override</span><br><span class="line">public void evict(Object key) &#123;</span><br><span class="line">this.store.remove(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空所有数据</span><br><span class="line">@Override</span><br><span class="line">public void clear() &#123;</span><br><span class="line">this.store.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   //清空所有数据</span><br><span class="line">@Override</span><br><span class="line">public boolean invalidate() &#123;</span><br><span class="line">boolean notEmpty = !this.store.isEmpty();</span><br><span class="line">this.store.clear();</span><br><span class="line">return notEmpty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;至此，缓存怎么存放，怎么获取都说完了。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;与前面差不多，都是在启动类上面开启，在方法上面标记注解就行了</p><ol><li>@EnableCaching：在启动类上，开启基于注解的缓存</li><li>@Cacheable：标在方法上，返回的结果会进行缓存(先查缓存中的结果，没有则调用方法并将结果放到缓存中)</li><li>@CachePut：保证方法被调用后，又将对应缓存中的数据更新（先调用方法，调完方法再将结果放到缓存）</li><li>@CacheEvict：清除缓存</li></ol><p>&emsp;&emsp;@Cacheable，@CachePut，@CacheEvict三个注解都有几个重要的属性：</p><ul><li>cacheNames：缓存的名字。</li><li>key: 作为缓存中的Key值，可以使用SpEL表达式指定（不指定，key就是参数值），缓存结果是方法返回值</li></ul><p>&emsp;&emsp;上面两个属性是前面我们一直都在强调的比较重要的属性，然后，清除缓存的注解中还有两个属性需要了解:</p><ul><li>allEntries =true : 指定清除这个缓存中所有数据。</li><li>beforeInvocation = true : true在方法之前执行；默认false在方法之后执行,出现一场则不会清除缓存</li></ul><p>&emsp;&emsp;我这里值贴出来缓存相关的类：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Cacheable(cacheNames = &quot;user&quot;, key = &quot;#id&quot;)</span><br><span class="line">    public User getUser(Integer id) &#123;</span><br><span class="line">        return userMapper.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CachePut(cacheNames = &quot;user&quot;, key = &quot;#result.id&quot;)</span><br><span class="line">    public User updateUser(User user) &#123;</span><br><span class="line">        userMapper.updateUser(user);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CacheEvict(cacheNames = &quot;user&quot;, key = &quot;#result&quot;)</span><br><span class="line">    public Integer deleteUser(Integer id) &#123;</span><br><span class="line">        userMapper.deleteUserById(id);</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;第一步：默认采用的是SimpleCacheConfiguration 使用 ConcurrentMapCacheManager</p><p>&emsp;&emsp;第二步：getCache 获取的是 ConcurrentMapCache 缓存对象进行存取数据,它使用ConcurrentMap<object,object>对象进行缓存数据。</object,object></p><p>@Cacheable(cacheNames = “user”, key = “#id”)</p><p><strong>第一次请求时：</strong></p><p>&emsp;&emsp;第三步：当发送第一次请求时，会从getCache(name)中获取，看有没有ConcurrentMapCache缓存对象,如果没有 则创建出来, 并且创建出来的key就是通过</p><p>@Cacheable(cacheNames = “user”)标识的name值 </p><p>&emsp;&emsp;第四步：接着会从ConcurrentMapCache里面调用lookup获取缓存数据,通过key值获取的, </p><p>默认采用的是service方法中的参数值,如果缓存中没有获取到,则调用目标方法进行获取数据（即从数据库中查询）,获取之后则再将它 放到缓存中(key=参数值,value=返回值)</p><p><strong>第二次请求时：</strong></p><p>&emsp;&emsp;第五步：如果再次调用 则还是先ConcurrentMapCacheManager.getCache()获取缓存对象,如果有则直接返回, 如果没有则创建</p><p>&emsp;&emsp;第六步：然后再调用 ConcurrentMapCache.lookup方法从缓存中获取数据, 如果缓存有数据则直接响应回去,不 会再去调用目标方法</p><p><strong>第三次请求与第二次一样</strong></p><p>如果缓存中没有缓存管理器,则与第一次请求一致</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;缓存是每个项目都用到的为了提高接口响应效率，降低数据库的查询压力，从而提高系统性能。所以，缓存对于一个项目来说是至关重要的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—邮件（十五）</title>
    <link href="https://haichenyi.com/2019/10/31/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E9%82%AE%E4%BB%B6%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/10/31/SpringBoot系列—邮件（十五）/</id>
    <published>2019-10-31T09:12:19.000Z</published>
    <updated>2021-08-03T15:15:19.826Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;邮件发送是必不可少的，不管是注册邮件，还是广告。</p><a id="more"></a><p>&emsp;&emsp;spring boot中已经集成的mail的启动器，所以，我们只用配置好就行了。</p><p>&emsp;&emsp;引入启动器：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;那么，需要配置什么内容呢？我们之前讲过，需要配置的东西，spring boot都给我们提前准备好了，都在自动配置类AutoConfigure那个类里面，我们可以找一找，里面有个mail包，这个就是邮件的相关配置类。</p><p><img src="/uploads/article/2019-10-31/邮件配置.png" alt="邮件配置图.png"></p><p>&emsp;&emsp;我们可以看到上面的prefix中的spring.mail就是我们的配置文件中的前缀，这个类里面的公共变量，就是我们配置文件中的键。我们这里配置了四个值。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#配置邮箱账号</span><br><span class="line">spring.mail.username=371965177@qq.com</span><br><span class="line">spring.mail.password=XXXXXXX</span><br><span class="line">#配置发送邮件服务器</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">#配置ssl安全连接</span><br><span class="line">spring.mail.properties.smtp.ssl.enable = true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里的密码，我们不能填，我们的QQ号密码吧？需要在你的QQ邮箱去设置。生成授权码即可。直接百度一下：QQ邮箱怎么生成授权码，有教程。然后，把生成的授权码填到这里就行了。配置就这么多</p><p>&emsp;&emsp;怎么发送邮件呢？也很简单，分两种，一种是简单的文字邮件，一种是复杂带附件的邮件。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboottask;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.mail.SimpleMailMessage;</span><br><span class="line">import org.springframework.mail.javamail.JavaMailSenderImpl;</span><br><span class="line">import org.springframework.mail.javamail.MimeMessageHelper;</span><br><span class="line"></span><br><span class="line">import javax.mail.MessagingException;</span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class SpringBootTaskApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    JavaMailSenderImpl javaMailSender;</span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        //简单邮件</span><br><span class="line">        SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">        //邮件标题</span><br><span class="line">        message.setSubject(&quot;测试邮件功能标题&quot;);</span><br><span class="line">        //邮件内容</span><br><span class="line">        message.setText(&quot;测试邮件内容&quot;);</span><br><span class="line">        //发件人，必须要跟配置的相同</span><br><span class="line">        message.setFrom(&quot;371965177@qq.com&quot;);</span><br><span class="line">        //收件人</span><br><span class="line">        message.setTo(&quot;1640200266@qq.com&quot;);</span><br><span class="line">        javaMailSender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testMail() throws MessagingException &#123;</span><br><span class="line">        //带附件邮件，通过createMimeMessage()方法获取对象</span><br><span class="line">        MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">        //这里带附件的邮件需要用到这个帮助类</span><br><span class="line">        MimeMessageHelper messageHelper = new MimeMessageHelper(mimeMessage,true);</span><br><span class="line"></span><br><span class="line">        messageHelper.setSubject(&quot;测试邮件功能标题&quot;);</span><br><span class="line">        //可以发送html语句，第一个参数是内容，第二个参数设置为true即可。</span><br><span class="line">        messageHelper.setText(&quot;&lt;h1 style=&apos;color;blue&apos;&gt;测试邮件内容&lt;/h1&gt;&quot;,true);</span><br><span class="line">        //addAttachment添加附件的方法。第一个是名字，第二个是file</span><br><span class="line">        messageHelper.addAttachment(&quot;1.txt&quot;,new File(&quot;D:\\Download\\t.txt&quot;));</span><br><span class="line">        messageHelper.setFrom(&quot;371965177@qq.com&quot;);</span><br><span class="line">        messageHelper.setTo(&quot;1640200266@qq.com&quot;);</span><br><span class="line">        //这里发送的还是MimeMessage对象，并不是那个帮助类对象</span><br><span class="line">        javaMailSender.send(mimeMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;每一行都有注释，已经写的很清楚了，就不做过多的解释了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;邮件发送是必不可少的，不管是注册邮件，还是广告。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—异步任务与定时任务（十四）</title>
    <link href="https://haichenyi.com/2019/10/31/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/10/31/SpringBoot系列—异步任务与定时任务（十四）/</id>
    <published>2019-10-31T06:32:20.000Z</published>
    <updated>2021-08-03T15:15:14.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>&emsp;&emsp;什么时候用异步，就是耗时操作的时候就可以用到异步，比如：批量处理数据，批量发邮件等等。</p><a id="more"></a><p>&emsp;&emsp;用法与前面的事务管理类似，spring 3+之后，就已经内置了 <strong>@Async</strong> 来处理异步任务。我们使用两个注解即可。</p><ul><li>@EnableAysnc 启动类上开启基于注解的异步任务</li><li>@Aysnc 标识的方法会异步执行</li></ul><p>如：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@EnableAsync</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;批量操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        helloService.add();</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;当我们请求这个hello接口时，如果不使用@Async标记方法，那么，线程就会阻塞，我们会在add方法执行完之后，才会返回success。这显然不是我们想要的。</p><p>&emsp;&emsp;如果用@Async标记方法，那么，线程就不会阻塞，我们请求hello接口，会立刻返回success，过了三秒钟，才会批量处理完成。这才是我们想要的。</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>&emsp;&emsp;定时定点的执行某个任务，就需要用到定时任务。比如，当服务器启动之后，比如，每天晚上23点上传日志，每个月1号给用户发送邮件等等。</p><p>&emsp;&emsp;用法都类似：</p><ul><li>@EnableScheduling 启动类上开启基于注解的定时任务</li><li>@Scheduled 标识的方法会进行定时处理</li></ul><p>唯一不一样的地方，也是个难点就是cron表达式</p><p>先举个例子：在上面例子的基础上加上</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@EnableScheduling</span><br><span class="line">@EnableAsync</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;批量操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron = &quot;1-5 * * * * *&quot;)</span><br><span class="line">    public void scheduledTaskt() &#123;</span><br><span class="line">        System.out.println(&quot;执行定时任务&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这个定时任务就是,每分钟的1秒到5秒各执行一次，一共5次。</p><p>&emsp;&emsp;cron表达式一共六个值，每个值都要有。一个都不能少，分别代表的含义是：秒 分 时 日 月 星期几</p><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">取值范围</th><th style="text-align:center">可指定的特殊字符</th></tr></thead><tbody><tr><td style="text-align:center">秒</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">分</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">时</td><td style="text-align:center">0-23</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">日</td><td style="text-align:center">1-31</td><td style="text-align:center">, - * ? / L W C</td></tr><tr><td style="text-align:center">月</td><td style="text-align:center">1-12</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">星期</td><td style="text-align:center">0-7或SUN-SAT 0和7都是周日，1-6是周一到周六</td><td style="text-align:center">, - * ? / L C #</td></tr></tbody></table><p>&emsp;&emsp;特殊字符的含义：<br>|特殊字符|代表含义|<br>|:-:|:-:|<br>|,|枚举，一个位置上指定多个值，以逗号 ， 分隔|<br>|-|区间|<br>|*|任意|<br>|/|步长，每隔多久执行一次|<br>|?|日/星期冲突匹配 ,指定哪个值,另外个就是?|<br>|L|最后|<br>|W|工作日|<br>|C|和calendar联系后计算过的值|<br>|#|这个月的第几个星期几，4#2，第2个星期四|</p><p>比如：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1-5 * * * * 1到5秒，每秒都触发任务 */5 * * * * 每隔5秒执行一次</span><br><span class="line"></span><br><span class="line">0 */1 * * * 每隔1分钟执行一次 0 0 5-15 * * 每天5-15点整点触发</span><br><span class="line"></span><br><span class="line">0 0-5 14 * * 在每天下午2点到下午2:05期间的每1分钟触发</span><br><span class="line"></span><br><span class="line">0 0/5 14 * * 在每天下午2点到下午2:55期间的每5分钟触发</span><br><span class="line"></span><br><span class="line">0 0/5 14,18 * * 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</span><br><span class="line"></span><br><span class="line">0 0/30 9-17 * * 朝九晚五工作时间内每半小时</span><br><span class="line"></span><br><span class="line">0 0 12 ? * WED 表示每个星期三中午12点</span><br><span class="line"></span><br><span class="line">0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发</span><br><span class="line"></span><br><span class="line">0 0 23 L * ? 每月最后一天23点执行一次</span><br><span class="line"></span><br><span class="line">0 15 10 LW * ? 每个月最后一个工作日的10点15分0秒触发任务</span><br><span class="line"></span><br><span class="line">0 15 10 ? * 5#3 每个月第三周的星期五的10点15分0秒触发任务</span><br></pre></td></tr></table></figure></div><p>最后附上在线生成cron表达式的链接： <a href="http://cron.qqe2.com" target="_blank" rel="noopener">http://cron.qqe2.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;异步任务&quot;&gt;&lt;a href=&quot;#异步任务&quot; class=&quot;headerlink&quot; title=&quot;异步任务&quot;&gt;&lt;/a&gt;异步任务&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;什么时候用异步，就是耗时操作的时候就可以用到异步，比如：批量处理数据，批量发邮件等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—事务管理（十三）</title>
    <link href="https://haichenyi.com/2019/09/17/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/09/17/SpringBoot系列—事务管理（十三）/</id>
    <published>2019-09-17T05:37:31.000Z</published>
    <updated>2021-08-03T15:15:03.222Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;我们操作数据库，事务管理是必不可少的一部分。</p><a id="more"></a><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>&emsp;&emsp;我们在开发企业应用时，用户的一个操作对应数据库可能是多步操作相结合完成的。在这个多个步骤中，其中的一步，可能出现异常，导致后面的步骤无法向下进行，那么，用户的这个操作，可能就没有进行完，前面已经进行的步骤数据就需要回退。</p><p>举个总所周知的栗子：</p><p>&emsp;&emsp;银行的转账，A给B转账，转1000块钱，A的钱需要扣1000，B的钱需要加1000，而，银行的系统在A扣1000块钱之后，B加1000块钱的时候，出现的异常，A的钱扣了，B的钱没有加，这该怎么办？这就需要用到我们的事务管理了。</p><p>&emsp;&emsp;事务就是保证用户的每个操作都是可靠的，事务中的每一个步操作都必须成功执行，如果，其中某一个步骤出现了异常，那么就回退到事务开始未进行操作的状态。</p><p>&emsp;&emsp;事务管理是Spring框架中最为常见的功能之一，我们在SpringBoot开发应用时，大部分情况下也需要使用事务。</p><h3 id="事务管理操作步骤"><a href="#事务管理操作步骤" class="headerlink" title="事务管理操作步骤"></a>事务管理操作步骤</h3><p>&emsp;&emsp;理论上就只有两步：</p><ol><li>@EnableTransactionManagement：标记在启动类</li><li>@Transactional：标记的service层</li></ol><p>&emsp;&emsp;为什么说理论上只需要两步呢？因为，在SpringBoot中，当我们使用 <strong>spring-boot-starter-data-jdbc</strong> 或者是 <strong>spring-boot-starter-data-jpa</strong> 依赖的时候，框架会自动帮我们注入 <strong>入DataSourceTransactionManager</strong> 或者 <strong>JpaTransactionManager</strong> 。所以，我们不需要进行任何额外的配置，就直接可以使用 <strong>@Transactional</strong> 注解进行管理事务。</p><p>&emsp;&emsp;还有几点需要注意的地方：</p><ul><li>Hibernate创建表，默认类型是 <strong>MyISAM，</strong> 是非事务安全的，即使你加上了上面的注解，也不起作用。 <strong>Innodb</strong> 类型的表才是事务安全的。</li><li>需要在你的配置文件中指定： <strong>spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect</strong></li></ul><h3 id="事务的隔离级别和传播行为"><a href="#事务的隔离级别和传播行为" class="headerlink" title="事务的隔离级别和传播行为"></a>事务的隔离级别和传播行为</h3><p>&emsp;&emsp;除了指定事务管理器之后，还能对事务进行隔离级别和传播行为的控制，下面分别详细解释：</p><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>&emsp;&emsp;隔离级别是指在发生并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读、不可重复读、幻读。</p><ul><li><strong>脏读：A事务执行的过程中，修改了id=1的数据，这个时候还没有提交，此时，B读取了修改之后id=1的数据，而A事务却回滚了，这样B事务就形成了脏读。</strong> 比方说：A的银行卡里原来有1000块钱，买东西花了300，还有700，这个时候A的媳妇查银行卡的余额，一看只剩下700了，然后，A又不喜欢那个东西，把东西退掉了，买东西的钱又退回银行卡了，这个时候，A的媳妇查的钱这个事务就是脏读。回来之后一阵毒打，什么跪键盘，跪榴莲。唉，脏读，真惨。</li><li><strong>不可重复读：A事务先读取了id=1的数据，然后执行后面的逻辑，这个时候，B事务修改了id=1的数据，A在执行后面逻辑的时候，又读取了一遍id=1的数据，这个时候发现，两次读取的数据不相同，这就是不可重复读。</strong> 比方说：A发工资了，银行卡里发了1000块钱，每天早上查一遍，中午查一遍，好安心。早上9点上班的时候查了一遍余额有1000块钱，A的媳妇，十点多的时候买了个包包花了500块钱，A中午查的时候就剩下500了，他就去找他媳妇理论啊，你干啥了，咋就只剩下500了，他媳妇一听就来气啊，每个月挣这么点钱，我买个包包怎么了，然后就是一阵毒打，跪键盘，跪榴莲。唉，不可重复读，真惨。</li><li><strong>幻读：A事务先根据条件查询到了N条数据，然后，B事务新增了M条复合A事务查询条件的数据，导致A事务再次查询的时候，查询到了N+M条数据，就产生了幻觉。</strong> 比方说：A的媳妇查询A名下有多少张银行卡，一开始查询有2张（建行，农行），然后，A换了新工作，需要重新再邮政开工资卡。这一天，A的媳妇又查了一遍A名下的银行卡，咦，怎么多了一张邮政的，长能耐了，背着老娘藏私房钱了，于是，就把A一阵毒打，是跪键盘，跪榴莲。唉，幻读，真惨。</li></ul><p>&emsp;&emsp;怎么避免上面的三种情况呢？我们可以看  <strong>org.springframework.transaction.annotation.Isolation</strong>  枚举类中定义了五个表示隔离级<br>别的值：</p><ul><li><strong>DEFAULT：</strong> 这个是默认值，表示使用底层数据库的默认隔离级别，对绝大多数数据库而言，这个值通常就是 <strong>READ_COMMITTED。</strong></li><li><strong>READ_UNCOMMITTED：</strong> 该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。 <strong>该级别不<br>能防止脏读和不可重复读， 因此很少使用该隔离级别。</strong></li><li><strong>READ_COMMITTED：</strong> 该隔离级别表示一个事务只能读取另一个事务已经提交的数据。 <strong>该级别可以防止脏<br>读，这也是大多数情况下的推荐值，性能最好。</strong></li><li><strong>REPEATABLE_READ：</strong> 该隔离级别表示一个事务在整个执行过程中可以多次重复执行某个查询，并且每次返回的数据都相同，即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。 <strong>该级别可以<br>防止脏读和不可重复读。</strong></li><li><strong>SERIALIZABLE：</strong> 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说， <strong>该级别可<br>以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</strong> </li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定方式：</span><br><span class="line">@Transactional(isolation = Isolation.DEFAULT)</span><br></pre></td></tr></table></figure></div><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>&emsp;&emsp;传播行为是指，如果在开始当前事务之前，已经存在一个事务，此时可以指定这个要开始的这个事务的执行行为。</p><p>&emsp;&emsp;我们可以看  <strong>org.springframework.transaction.annotation.Propagation</strong>  枚举类中定义了6个表示传播行<br>为的枚举值：</p><ul><li>REQUIRED:（默认）如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li>SUPPORTS:如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>MANDATORY:如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>REQUIRES_NEW:创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>NOT_SUPPORTED:以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER:以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>NESTED:如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则<br>该取值等价于 REQUIRED 。</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定方式：</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRED)</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;关于这个事务的隔离级别和传播行为，我们一般都不用特别的去指定，用默认的就行了，除非有特别的要求，默认的隔离级别和传播行为满足绝大多数要求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;我们操作数据库，事务管理是必不可少的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Spring Data JPA（十二）</title>
    <link href="https://haichenyi.com/2019/09/11/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Spring-Data-JPA%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/09/11/SpringBoot系列—Spring-Data-JPA（十二）/</id>
    <published>2019-09-11T09:03:36.000Z</published>
    <updated>2021-08-03T15:14:15.575Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data"></a>什么是 Spring Data</h3><p>&emsp;&emsp;Spring Data 是 Spring Boot 底层默认进行数据访问的技术 , 为了简化构建基于 Spring 框架应用的数据访问技术，包<br>括非关系数据库、Map-Reduce 框架、云数据服务等；另外也包含对关系数据库的访问支持。</p><a id="more"></a><p>&emsp;&emsp;Spring Data 包含多个模块：</p><ul><li>Spring Data Commons 提供共享的基础框架，适合各个子项目使用，支持跨数据库持久化</li><li>Spring Data JPA</li><li>Spring Data KeyValue</li><li>Spring Data LDAP</li><li>Spring Data MongoDB</li><li>Spring Data Redis</li><li>Spring Data REST</li><li>Spring Data for Apache Cassandra</li><li>Spring Data for Apache Geode</li><li>Spring Data for Apache Solr</li><li>Spring Data for Pivotal GemFire</li><li>Spring Data Couchbase (community module)</li><li>Spring Data Elasticsearch (community module)</li><li>Spring Data Neo4j (community module)</li></ul><h3 id="Spring-Data统一的核心接口"><a href="#Spring-Data统一的核心接口" class="headerlink" title="Spring Data统一的核心接口"></a>Spring Data统一的核心接口</h3><p>&emsp;&emsp;Spring Data项目为大家提供统一的API来对不同的数据访问层进行操作。</p><p><img src="/uploads/article/2019-09-11/Repository.png" alt="Repository继承图.png"></p><ul><li>Repository<t, id="">：统一的根接口即所有接口的父接口，其他接口继承该接口</t,></li><li>CrudRepository<t, id="">：基本的增删改查接口,提供了最基本的对实体类CRUD操作</t,></li><li>PagingAndSortingRepository<t, id="">：增加了分页和排序操作</t,></li><li>JpaRepository<t, id="">：增加了批量操作，并重写了父接口一些方法的返回类型</t,></li></ul><p>&emsp;&emsp;Spring Data JPA、JPA与Hibernate 关系</p><p><img src="/uploads/article/2019-09-11/关系图.png" alt="关系图.png"></p><p>&emsp;&emsp;JPA是一种规范，而Hibernate是实现这种规范的底层实现，SpringData JPA对持久化接口JPA再抽象一层，针对持久化业务再进一步统一简化。</p><h3 id="SpringData-JPA的简单使用"><a href="#SpringData-JPA的简单使用" class="headerlink" title="SpringData JPA的简单使用"></a>SpringData JPA的简单使用</h3><p>&emsp;&emsp;JPA的底层遵守是ORM(对象关系映射)规范，因此JPA其实也就是java实体对象和关系型数据库建立起映射关系，通过<br>面向对象编程的思想操作关系型数据库的规范。</p><p><strong>首先，导包</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.haichenyi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-jpa&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;spring-boot-jpa&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--jdbc的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--jpa的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--web项目的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mysql的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--简化set/get的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></div><p><strong>其次，创建映射bean类</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.entity;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.persistence.*;</span><br><span class="line"></span><br><span class="line">//使用JPA注解配置映射关系</span><br><span class="line">@Entity//说明它是和数据表映射的类</span><br><span class="line">@Table(name = &quot;tbl_hobby&quot;)//指定对应映射的表名，省略默认表名就是类名</span><br><span class="line">@Data</span><br><span class="line">public class Hobby &#123;</span><br><span class="line">    @Id//标识主键</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)////标识自增长主键</span><br><span class="line">    private Integer id;</span><br><span class="line">    @Column(name = &quot;name&quot;, length = 10)//这是和数据表对应的一个列即字段名</span><br><span class="line">    private String name;</span><br><span class="line">    @Column//没有写，表字段名与这里的字段名相同</span><br><span class="line">    private Integer time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;需要注意的是，这里需要写set/get方法，不然，数据存不进去。这里我用了 <strong>@Data</strong> 注解，所以，就不需要写了。注释写的很清楚了，就不一一解释了。</p><p><strong>接着，写Repository</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.repository;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjpa.entity.Hobby;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义接口继承JpaRepository，就会crud及分页等基本功能</span><br><span class="line"> */</span><br><span class="line">//指定的泛型&lt;操作的实体类，主键的类型&gt;</span><br><span class="line">public interface HobbyRepository extends JpaRepository&lt;Hobby, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>再然后，就是Controller，跟之前写的一样</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjpa.entity.Hobby;</span><br><span class="line">import com.haichenyi.springbootjpa.repository.HobbyRepository;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HobbyController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    HobbyRepository hobbyRepository;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hobby/&#123;id&#125;&quot;)</span><br><span class="line">    public Hobby getHobbyInfo(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">        Optional&lt;Hobby&gt; hobbyOptional = hobbyRepository.findById(id);</span><br><span class="line">        return hobbyOptional.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/save&quot;)</span><br><span class="line">    public Hobby saveHobby(Hobby hobby) &#123;</span><br><span class="line">        System.out.println(hobby);</span><br><span class="line">        return hobbyRepository.save(hobby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>最后，就只配置了</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样写完就行了。就这四步：</p><ol><li>映射表</li><li>Repository接口</li><li>Controller</li><li>配置文件</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是-Spring-Data&quot;&gt;&lt;a href=&quot;#什么是-Spring-Data&quot; class=&quot;headerlink&quot; title=&quot;什么是 Spring Data&quot;&gt;&lt;/a&gt;什么是 Spring Data&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Spring Data 是 Spring Boot 底层默认进行数据访问的技术 , 为了简化构建基于 Spring 框架应用的数据访问技术，包&lt;br&gt;括非关系数据库、Map-Reduce 框架、云数据服务等；另外也包含对关系数据库的访问支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—MyBatis（十一）</title>
    <link href="https://haichenyi.com/2019/09/07/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94MyBatis%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/09/07/SpringBoot系列—MyBatis（十一）/</id>
    <published>2019-09-07T10:56:22.000Z</published>
    <updated>2021-08-03T15:13:53.289Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇，Druid是用于处理数据库连接池与后台监控。</p><a id="more"></a><p>&emsp;&emsp;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。——百度百科</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;MyBatis添加依赖跟SpringBoot的其他启动器不一样，MyBatis需要写版本号，因为，SpringBoot并没有MyBatis的启动器。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="注解的方式"><a href="#注解的方式" class="headerlink" title="注解的方式"></a>注解的方式</h4><p>&emsp;&emsp;先看一下项目结构：</p><p><img src="/uploads/article/2019-09-07/项目结构图.png" alt="项目结构图.png"></p><p>&emsp;&emsp;首先，我们先在连接的数据库里面创建表，添加几条数据。</p><p>&emsp;&emsp;然后，创建pojo类User，对应我的表</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    public Long UserId;</span><br><span class="line">    public String Username;</span><br><span class="line">    public String password;</span><br><span class="line">    public String nickName;</span><br><span class="line">    public String headImg;</span><br><span class="line">    public Integer age;</span><br><span class="line">    public Integer sex;</span><br><span class="line">    public String address;</span><br><span class="line">    public String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;接着，创建mapper接口</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.mapper;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    @Select(&quot;select * from userinfo&quot;)</span><br><span class="line">    List&lt;User&gt; getUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是一个普通的接口，用 <strong>@Mapper</strong> 标识了。然后写了一个获取用户信息的方法。 <strong>@Select</strong> 里面是sql语句。</p><p>&emsp;&emsp;用 <strong>@Mapper</strong> 标识的接口，在运行的过程中，会帮我们生成实现类，到时候，我们直接通过这个接口的引用调用这个方法即可。我们也可以在入口的位置用 <strong>@MapperScan</strong> 标识包名，应用启动的时候，会给这个包下面的所有接口都生成实现类。如下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc;</span><br><span class="line"></span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@MapperScan(&quot;com.haichenyi.springbootjdbc.mapper&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootJdbcApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootJdbcApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;最后，就是我们的controller层了。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.mapper.UserMapper;</span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/getUserInfo&quot;)</span><br><span class="line">    public List&lt;User&gt; getUserInfo() &#123;</span><br><span class="line">        return userMapper.getUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样，我们就可以通过 <a href="http://localhost:8080/getUserInfo" target="_blank" rel="noopener">http://localhost:8080/getUserInfo</a> 读到数据库中的数据了</p><p>&emsp;&emsp;只这样，我们读到的数据，如果表字段与pojo类的字段不一一对应，我们可能读到的数据为空，所以，我们要开启驼峰命名，开启之后MyBatis会帮我们一一对应好。怎么开启呢？就在我们前面的JdbcConfig中添加如下方法即可。就跟我们前面一篇Druid添加配置类似。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * MyBatis自定义配置</span><br><span class="line">  *</span><br><span class="line">  * @return ConfigurationCustomizer</span><br><span class="line">  */</span><br><span class="line"> @Bean</span><br><span class="line"> public ConfigurationCustomizer configurationCustomizer() &#123;</span><br><span class="line">     return configuration -&gt; &#123;</span><br><span class="line">         //开启驼峰命名</span><br><span class="line">         configuration.setMapUnderscoreToCamelCase(true);</span><br><span class="line">         //开启二级缓存</span><br><span class="line">         configuration.setCacheEnabled(true);</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样就可以了。</p><h4 id="xml的方式"><a href="#xml的方式" class="headerlink" title="xml的方式"></a>xml的方式</h4><p>&emsp;&emsp;前面和后面都是一样的，就是中间那不创建mapper接口不一样。xml中怎么创建mapper呢？</p><p>&emsp;&emsp;首先，还是创建一个正常的接口，定义方法。如下：注释写的很清楚了。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.mapper;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">//这里如果没有@Mapper注解，那就在启动类添加@MapperScan注解，上面已经说过怎么添加了。两种方式都可以，标记mapper的接口还是需要的</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">//这里的sql语句就不需要了，sql语句在xml里面配置。</span><br><span class="line">//    @Select(&quot;select * from userinfo&quot;)</span><br><span class="line">    List&lt;User&gt; getUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后，添加两个xml，一个是config，一个是写sql语句的。路径需要注意，先在resources目录下创建一个mybatis目录，在mybatis目录下创建mybatis-config.xml，在mybatis目录下创建mapper目录，然后在mapper目录下创建你的mapper.xml文件，如下：</p><p>&emsp;&emsp;这个是写mybatis配置文件的，名字我写的是：mybatis-config.xml，这个路径<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;!--开启驼峰命名--&gt;</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;然后就是创建mapper.xml，这里，我们以UserMapper.xml为例：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--namespace要是你前面创建mapper接口的全路径，这样才能对应--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.haichenyi.springbootjdbc.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;!--id：是你前面接口里面创建的方法名--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    resultType：这里的返回类型就是你接口读取数据对应的bean类，不管你需要的是集合，还是单个对象，这里都是你bean类，</span><br><span class="line">    如果你读取的是多条数据，它会自动帮你封装成list，拿到这个list，你再去做你其他的处理</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;getUserInfo&quot; resultType=&quot;com.haichenyi.springbootjdbc.pojo.User&quot;&gt;</span><br><span class="line">        select * from userinfo</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;注释写的很清楚了。</p><p>&emsp;&emsp;再就是配置这个两个xml路径了，你需要在你的全局配置文件中配置好，指定对应的路径：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  #核心配置文件路径</span><br><span class="line">  config-location: classpath:mybatis/mybatis-config.xml</span><br><span class="line">  #映射配置文件路径</span><br><span class="line">  mapper-locations: classpath:mybatis/mapper/*.xml</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;为啥非要创建一个mapper目录，再创建mapper文件呢？就是这里好指定。mapper文件肯定不止一个，难道你要一个一个的配置吗？这样写只用指定一个就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇，Druid是用于处理数据库连接池与后台监控。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Druid（十）</title>
    <link href="https://haichenyi.com/2019/09/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Druid%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/09/05/SpringBoot系列—Druid（十）/</id>
    <published>2019-09-05T08:05:30.000Z</published>
    <updated>2021-08-03T15:13:42.379Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;一个企业项目中最重要的部分那就是数据库了，对数据库的连接，读写是重中之重。在SpringBoot中数据库怎么连接呢？</p><a id="more"></a><h3 id="数据库的连接"><a href="#数据库的连接" class="headerlink" title="数据库的连接"></a>数据库的连接</h3><p>&emsp;&emsp;这里以MySql为例，还不会用MySql数据库的童鞋，可以看我之前的博客，<a href="https://blog.csdn.net/qq_27634797/article/category/8050256" target="_blank" rel="noopener">数据库相关</a>。</p><p>&emsp;&emsp; <strong>第一步，</strong> 我们首先在pom.xml中添加jdbc相关的启动器。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--jdbc启动器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--mysql驱动包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; <strong>第二步，</strong> 在配置文件中配置连接数据库的信息：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    #连接数据库的账号</span><br><span class="line">    username: root</span><br><span class="line">    #连接数据库的密码</span><br><span class="line">    password: 123456</span><br><span class="line">    #连接数据库的url</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    #连接数据库的驱动类</span><br><span class="line">    #mysql8之前用的是：com.mysql.jdbc.Driver。</span><br><span class="line">    #mysql8之后用的是：com.mysql.cj.jdbc.Driver</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 添加如上信息，就基本上完成了。测试一下连接就可以了。在我们的测试类中添加如下代码，看看打印的数据即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringBootJdbcApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() throws SQLException &#123;</span><br><span class="line">        System.out.println(&quot;dataSource: &quot; + dataSource.getClass());</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(&quot;connection: &quot; + connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 我们这里是测试数据库是否连接成功，我们才获取的这个连接，打印出来，我们项目里面实际操作数据库的时候，不需要我们获取这个连接，然后通过这个连接再去操作数据库。这是不需要，MyBatis通过Mapping注解直接操作数据库，我们只用写sql语句就可以了。</p><h3 id="Druid连接数据库"><a href="#Druid连接数据库" class="headerlink" title="Druid连接数据库"></a>Druid连接数据库</h3><p>&emsp;&emsp; DRUID是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是目前最好的连接池。</p><p>&emsp;&emsp; <strong>上面的配置继续保留。</strong></p><p>&emsp;&emsp; <strong>第一步：</strong> 我们在pom.xml里面添加druid的依赖：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.20&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; <strong>第二步：</strong> 在yml文件中添加如下代码：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  # 数据库访问配置</span><br><span class="line">  datasource:</span><br><span class="line">    #账号</span><br><span class="line">    username: root</span><br><span class="line">    #密码</span><br><span class="line">    password: 123456</span><br><span class="line">    #连接的url</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    #驱动类</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # 主数据源，默认的</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">    # 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line">    # 初始化大小，最小，最大</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    # 配置获取连接等待超时的时间</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    # 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 25</span><br><span class="line">    # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">    filters: stat,wall,logback</span><br><span class="line">    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="line">    # 合并多个DruidDataSource的监控数据</span><br><span class="line">    useGlobalDataSourceStat: true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 这样，就可以了。继续运行刚才的测试方法，你会发现，打印数据里面数据源已经变成了DruidDataSource。</p><p>&emsp;&emsp; 你如果是debug运行的，并且，你的断点打在connection那里，你会发现，我们yml文件中的补充配置，没起作用，是为什么呢？</p><p>&emsp;&emsp; 我们按住CTRL，鼠标左键点补充配置里面的任意一个变量，都点不动，我们点上面的type，url等等，都能点，我们点过去看，我们会发现跳到了 <strong>DataSourceProperties</strong> 。这个类，顾名思义这是数据源配置文件类。我们大致看一下这个类的代码：</p><p><img src="/uploads/article/2019-09-05/DataSourceProperties类.png" alt="DataSourceProperties类.png"></p><p>&emsp;&emsp; 用红色框框，框出来的地方是不是很眼熟？</p><p>&emsp;&emsp; 首先，我们先看注解 <strong>@ConfigurationProperties，</strong> 这个注解就是表示这个类是配置类，然后，我们看括号里面的参数 <strong>prefix，</strong> 顾名思义：前缀，前置代码。</p><p><img src="/uploads/article/2019-09-05/yml文件.png" alt="yml文件.png"></p><p>&emsp;&emsp; 如上图，上面的红色框框的内容，就由prefix决定，下面红色框框的内容，就由这个类的变量决定。我们上面的补充设置不起作用，就是因为这个配置文件里面没有这些变量，SpringBoot识别不了，所以，不起作用。SpringBoot不是万能的，它配置了的东西，可以识别，没有配置的，识别不了。</p><p>&emsp;&emsp; 怎么样让上面的补充配置起作用呢？有多种方式：</p><p>&emsp;&emsp; <strong>第一种方式如下：</strong> 简单粗暴，添加一个配置类即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource()&#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 这个方式就相当于，把我们上面的这个 <strong>DataSourceProperties</strong>配置类，换成了 <strong>DruidDataSource</strong>类。</p><p>&emsp;&emsp; <strong>第二种方式如下：</strong> 比较麻烦，也不算特别麻烦：说白了就是加载局部配置。</p><p>&emsp;&emsp;首先，在resources目录下，新建一个jdbc.properties文件</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#账号</span><br><span class="line">druid.datasource.username=root</span><br><span class="line">#密码</span><br><span class="line">druid.datasource.password=123456</span><br><span class="line">#连接的url</span><br><span class="line">druid.datasource.url=jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">#驱动类</span><br><span class="line">druid.datasource.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line"># 主数据源，默认的</span><br><span class="line"># druid.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"># 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line"># 初始化大小，最小，最大</span><br><span class="line">druid.datasource.initialSize=5</span><br><span class="line">druid.datasource.minIdle=5</span><br><span class="line">druid.datasource.maxActive=20</span><br><span class="line"># 配置获取连接等待超时的时间</span><br><span class="line">druid.datasource.maxWait=60000</span><br><span class="line"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">druid.datasource.timeBetweenEvictionRunsMillis=60000</span><br><span class="line"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">druid.datasource.minEvictableIdleTimeMillis=300000</span><br><span class="line">druid.datasource.validationQuery=SELECT 1 FROM DUAL</span><br><span class="line">druid.datasource.testWhileIdle=true</span><br><span class="line">druid.datasource.testOnBorrow=false</span><br><span class="line">druid.datasource.testOnReturn=false</span><br><span class="line"># 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">druid.datasource.poolPreparedStatements=true</span><br><span class="line">druid.datasource.maxPoolPreparedStatementPerConnectionSize=25</span><br><span class="line"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">druid.datasource.filters=stat,wall,logback</span><br><span class="line"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">druid.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="line"># 合并多个DruidDataSource的监控数据</span><br><span class="line">druid.datasource.useGlobalDataSourceStat=true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是把我们刚才在全局配置中配置的信息，在专门的jdbc的配置文件中配置一遍。然后，修改我们的JdbcConfig类。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@PropertySource(value = &quot;classpath:config/jdbc.properties&quot;, ignoreResourceNotFound = true)</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.driverClassName&#125;&quot;)</span><br><span class="line">    private String driverClassName;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.initialSize&#125;&quot;)</span><br><span class="line">    private Integer initialSize;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.minIdle&#125;&quot;)</span><br><span class="line">    private Integer minIdle;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxActive&#125;&quot;)</span><br><span class="line">    private Integer maxActive;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxWait&#125;&quot;)</span><br><span class="line">    private Long maxWait;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.timeBetweenEvictionRunsMillis&#125;&quot;)</span><br><span class="line">    private Long timeBetweenEvictionRunsMillis;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.minEvictableIdleTimeMillis&#125;&quot;)</span><br><span class="line">    private Long minEvictableIdleTimeMillis;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.validationQuery&#125;&quot;)</span><br><span class="line">    private String validationQuery;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testWhileIdle&#125;&quot;)</span><br><span class="line">    private Boolean testWhileIdle;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testOnBorrow&#125;&quot;)</span><br><span class="line">    private Boolean testOnBorrow;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testOnReturn&#125;&quot;)</span><br><span class="line">    private Boolean testOnReturn;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxPoolPreparedStatementPerConnectionSize&#125;&quot;)</span><br><span class="line">    private Integer maxPoolPreparedStatementPerConnectionSize;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.poolPreparedStatements&#125;&quot;)</span><br><span class="line">    private Boolean poolPreparedStatements;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.filters&#125;&quot;)</span><br><span class="line">    private String filters;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.connectionProperties&#125;&quot;)</span><br><span class="line">    private String connectionProperties;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.useGlobalDataSourceStat&#125;&quot;)</span><br><span class="line">    private Boolean useGlobalDataSourceStat;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() throws SQLException &#123;</span><br><span class="line">        DruidDataSource druidDataSource = new DruidDataSource();</span><br><span class="line">        druidDataSource.setUsername(username);</span><br><span class="line">        druidDataSource.setPassword(password);</span><br><span class="line">        druidDataSource.setUrl(url);</span><br><span class="line">        druidDataSource.setDriverClassName(driverClassName);</span><br><span class="line">        druidDataSource.setInitialSize(initialSize);</span><br><span class="line">        druidDataSource.setMinIdle(minIdle);</span><br><span class="line">        druidDataSource.setMaxActive(maxActive);</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);</span><br><span class="line">        druidDataSource.setValidationQuery(validationQuery);</span><br><span class="line">        druidDataSource.setTestOnBorrow(testOnBorrow);</span><br><span class="line">        druidDataSource.setTestOnReturn(testOnReturn);</span><br><span class="line">        druidDataSource.setTestWhileIdle(testWhileIdle);</span><br><span class="line">        druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);</span><br><span class="line">        druidDataSource.setPoolPreparedStatements(poolPreparedStatements);</span><br><span class="line">        druidDataSource.setFilters(filters);</span><br><span class="line">        druidDataSource.setConnectionProperties(connectionProperties);</span><br><span class="line">        druidDataSource.setUseGlobalDataSourceStat(useGlobalDataSourceStat);</span><br><span class="line">        return druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是加载配置文件，然后在DataSource里面赋值。这样，就可以了。</p><h3 id="Druid后台监控"><a href="#Druid后台监控" class="headerlink" title="Druid后台监控"></a>Druid后台监控</h3><p>&emsp;&emsp;之所以用Druid连接池，还有很大一部分原因就是它的监控功能。它能很好的监控DB连接池和SQL语句的执行情况。在上面的JdbcConfig类中添加如下两个方法即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 配置Druid监控</span><br><span class="line"> *</span><br><span class="line"> * @return StatViewServlet</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean servletRegistrationBean() &#123;</span><br><span class="line">    ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //访问的用户名密码</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_USERNAME, &quot;haichenyi&quot;);</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_PASSWORD, &quot;123456&quot;);</span><br><span class="line">    //允许访问的ip，默认是所有ip</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_ALLOW, &quot;&quot;);</span><br><span class="line">    //禁止访问的ip</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_DENY, &quot;192.168.1.1&quot;);</span><br><span class="line">    bean.setInitParameters(map);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 配置一个监控的filter</span><br><span class="line"> *</span><br><span class="line"> * @return WebStatFilter</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean filterRegistrationBean() &#123;</span><br><span class="line">    FilterRegistrationBean&lt;WebStatFilter&gt; bean = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">    bean.setFilter(new WebStatFilter());</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //移除这些监听</span><br><span class="line">    map.put(WebStatFilter.PARAM_NAME_EXCLUSIONS, &quot;*.js,*.css,/druid/*,*.gif,*.jpg,*.png&quot;);</span><br><span class="line">    bean.setInitParameters(map);</span><br><span class="line">    //拦截所有请求，全部都要走druid监听</span><br><span class="line">    bean.setUrlPatterns(Collections.singletonList(&quot;/*&quot;));</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;注释写的很清楚了，控制台怎么访问呢？ <strong><a href="http://localhost:8080/druid" target="_blank" rel="noopener">http://localhost:8080/druid</a></strong>。访问控制台</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;一个企业项目中最重要的部分那就是数据库了，对数据库的连接，读写是重中之重。在SpringBoot中数据库怎么连接呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
</feed>
