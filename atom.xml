<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haichenyi.com/"/>
  <updated>2021-07-07T13:38:38.262Z</updated>
  <id>http://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android模拟点击</title>
    <link href="http://haichenyi.com/2021/07/07/Android%E6%A8%A1%E6%8B%9F%E7%82%B9%E5%87%BB/"/>
    <id>http://haichenyi.com/2021/07/07/Android模拟点击/</id>
    <published>2021-07-07T13:32:21.000Z</published>
    <updated>2021-07-07T13:38:38.262Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本篇介绍实现模拟点击的两种方式：</p><ol><li>performClick();</li><li><p>MotionEvent事件</p><a id="more"></a></li></ol><p>&emsp;&emsp;举个栗子：我们现在需要实现点击A按钮，触发B按钮点击事件的效果：两个按钮在布局里面随便创建就好了。</p><p>&emsp;&emsp;<strong><em>第一种方式就是：调用performClick事件</em></strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Button btn1 = findViewById(R.id.btn1);</span><br><span class="line">final Button btn2 = findViewById(R.id.btn2);</span><br><span class="line">btn1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn1&quot;);</span><br><span class="line">        btn2.performClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">btn2.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这种方式很简单，但是有一个弊端，就是不会传递触摸点坐标，只是模拟一下btn2的点击事件。</p><p>&emsp;&emsp;<strong><em>第二种方式就是：MotionEvent事件</em></strong><br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Button btn1 = findViewById(R.id.btn1);</span><br><span class="line">final Button btn2 = findViewById(R.id.btn2);</span><br><span class="line">btn1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn1&quot;);</span><br><span class="line">        long downTime = SystemClock.uptimeMillis();</span><br><span class="line">        long eventTime = SystemClock.uptimeMillis()+100;</span><br><span class="line">        float upX = btn2.getX()+50;</span><br><span class="line">        float upY = btn2.getY()+50;</span><br><span class="line">        MotionEvent obtainDown = MotionEvent.obtain(downTime, eventTime, ACTION_DOWN, upX, upY, 0);</span><br><span class="line"></span><br><span class="line">        long downTime1 = SystemClock.uptimeMillis();</span><br><span class="line">        long eventTime1 = SystemClock.uptimeMillis()+100;</span><br><span class="line">        float upX1 = btn2.getX()+50;</span><br><span class="line">        float upY1 = btn2.getY()+50;</span><br><span class="line">        MotionEvent obtainUp = MotionEvent.obtain(downTime1, eventTime1, MotionEvent.ACTION_UP, upX1, upY1, 0);</span><br><span class="line">        btn2.dispatchTouchEvent(obtainDown);</span><br><span class="line">        btn2.dispatchTouchEvent(obtainUp);</span><br><span class="line">        obtainDown.recycle();</span><br><span class="line">        obtainUp.recycle();</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;downTime:&quot;+downTime+&quot; ,eventTime:&quot;+eventTime+&quot; ,upX:&quot;+upX+&quot; ,upY:&quot;+upY+&quot; ,downTime1:&quot;+downTime1+&quot; ,eventTime1:&quot;+eventTime1+&quot; ,upX1:&quot;+upX1+&quot; ,upY1:&quot;+upY1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">btn2.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;这种方式比较麻烦，用到的就是view的事件分发，一个简单的点击事件的触发就是down和up组成，当然还有平移我们这里不考虑。</p><p>&emsp;&emsp;<strong>第一步</strong>，先用MotionEvent.obtain创建两个事件：一个down事件，一个up事件，创建的时候需要传递坐标点，传你目标view的范围内的坐标就行。</p><p>&emsp;&emsp;<strong>第二步</strong>，通过目标view，也就是这里的btn2去把这两个事件分发出去，通过dispatchTouchEvent分发，这样就完成了一次模拟点击事件，分发完记得回收</p><p>&emsp;&emsp;这样，就完成了一次模拟点击，并且坐标也传递了。因为，创建这两个事件的时候就传递了。解决了performClick的弊端。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本篇介绍实现模拟点击的两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;performClick();&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MotionEvent事件&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列-消息(RabbitMQ)（二十）</title>
    <link href="http://haichenyi.com/2019/11/27/SpringBoot%E7%B3%BB%E5%88%97-%E6%B6%88%E6%81%AF-RabbitMQ-%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/11/27/SpringBoot系列-消息-RabbitMQ-（二十）/</id>
    <published>2019-11-27T06:44:45.000Z</published>
    <updated>2019-11-27T07:12:12.484Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;大多数应用当中，可通过消息服务中间件来提升系统的异步通信和扩展解耦能力。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>消息服务中两个重要的概念</p><p>&emsp;&emsp;<strong>消息代理</strong>和<strong>目的地</strong>：当消息发送者发送消息之后，将由消息代理接管，消息代理保证消息发送到指定的目的地。</p><p>消息发送的两种方式：</p><ol><li>队列(Queue)：点对点消息通信(point-to-point)</li><li>主题(Topic)：发布(publish)/订阅(subscribe)式消息通信</li></ol><p>&emsp;&emsp;开始说了，消息可以提升系统的异步通信和扩展解耦能力。异步通信，我们之前讲异步任务的时候已经说过了。给用户发送邮件就是最好，最直接的例子。</p><p>&emsp;&emsp;至于，扩展解耦能力，最好最直接的例子就是流量削峰，举个例子：整点秒杀。库存只有100件，用户有10000个人，整点用户讲发送10000个请求，难道每个都请求数据库吗？这个时候，我们就可以做个限制，用户发送的请求先到消息队列，然后，再由消息队列统一管理，哪些请求时可以到数据库的，哪些请求时不可以到数据库的，这样就解决了数据库的抗压能力。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;点对点式</p><ul><li>消息发送者发送消息之后，消息代理将消息放在一个队列当中，消息接收者从队列中获取消息内容，消息读取后移除队列</li><li>消息只有唯一的发送者和接收者，但并不是说只能有一个接收者</li></ul><p>&emsp;&emsp;发布订阅式</p><ul><li>发送者(发布者)发送消息到主题(topic)，多个接收者(订阅者)监听(订阅)这个主题，那么，就会在消息到达的同时收到消息</li></ul><p><strong>JMS和AMQP</strong></p><ul><li>JMS:Java message service ：Java消息服务基于JVM消息代理规范，ActiveMQ,HornetMQ就是JMS的实现</li><li>AMQP:advanced message Queue Protocol：高级消息队列协议，也是消息代理的规范，兼容JMS，RabbitMQ就是AMQP的实现。</li></ul><p><strong>对比</strong></p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">JMS</th><th style="text-align:left">AMQP</th></tr></thead><tbody><tr><td style="text-align:left">定义</td><td style="text-align:left">Java api</td><td style="text-align:left">网络线级协议</td></tr><tr><td style="text-align:left">跨语言</td><td style="text-align:left">否</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">跨平台</td><td style="text-align:left">否</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">model</td><td style="text-align:left">提供两种消息模式：peer-2-peer，pub/sub</td><td style="text-align:left">提供五种消息模式：direct exchange，fanout exchange，topic change，headers exchange，system exchange。本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分</td></tr><tr><td style="text-align:left">支持消息类型</td><td style="text-align:left">多种消息类型：TextMessage，MapMessage，BytesMessage，StreamMessage，ObjectMessage，Message （只有消息头和属性）</td><td style="text-align:left">byte[]类型，当实际应用中有复杂消息时，可以序列化之后再发送</td></tr><tr><td style="text-align:left">综合评价</td><td style="text-align:left">JMS定义了java api层面的标准，在Java体系中，多个client均可通过JMS进行交互，不需要修改代码，但是其对跨平台支持较差</td><td style="text-align:left">AMQP天然具有跨平台，跨语言特性</td></tr></tbody></table><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>Message</strong></p><p>&emsp;&emsp;消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等</p><p><strong>Publisher</strong></p><p>&emsp;&emsp;消息的生产者，也是一个向交换器发布消息的客户端应用程序</p><p><strong>Exchange</strong></p><p>&emsp;&emsp;交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange有4种类型：direct(默认)，fanout,topic,和headers，不同类型的Exchange转发消息的策略有所区别。</p><p><strong>Queue</strong></p><p>&emsp;&emsp;消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><strong>Binding</strong></p><p>&emsp;&emsp;绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和Queue的绑定可以是多对多的关系。</p><p><strong>Connection</strong></p><p>&emsp;&emsp;网络连接，比如一个TCP连接。</p><p><strong>Channel</strong></p><p>&emsp;&emsp;信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><p><strong>Consumer</strong></p><p>&emsp;&emsp;消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><p><strong>Virtual Host</strong></p><p>&emsp;&emsp;虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><p><strong>Broker</strong></p><p>&emsp;&emsp;表示消息队列服务器实体</p><p><img src="/uploads/article/2019-11-27/RabbitMQ流程图.png" alt="RabbitMQ流程图.png"></p><p><strong>流程</strong></p><p>&emsp;&emsp;AMQP的消息路由过程跟JMS存在一些差异，增加了Exchange和Binding的角色</p><p>JMS流程：</p><ol><li>生产者(publisher)生成某个消息(Message)，发送到某个队列(Queue)上</li><li>消费者(Consumer)监听这个队列(Queue)，消费消息</li></ol><p>RabbitMQ流程：</p><ol><li>生产者(publisher)生成某个消息(Message)，把这个消息发送给我们的消息代理服务器上(Broker)</li><li>服务器收到消息之后，把这个消息给到一个合适的交换器(Exchange),(服务器有非常多的交换器)</li><li>交换器(Exchange)收到这个消息之后，根据路由键(Binding绑定关系)把这个消息给一个或者多个消息队列(Queue)(服务器有很多个消息队列)</li><li>消费者(Consumer)连接上队列之后取出消息</li></ol><p><strong><em>重点就是：交换器和队列的绑定</em></strong></p><p><strong><em>重点就是：交换器和队列的绑定</em></strong></p><p><strong><em>重点就是：交换器和队列的绑定</em></strong></p><p>&emsp;&emsp;我们上面说了Exchange有4种，不同类型转发的消息策略不同，那么，这个策略是什么呢？其中，header和direct交换器完全一致，但是header性能上差很多，基本上不用了</p><p><strong><em>重点start</em></strong></p><ul><li>direct交换器：当我们发送消息时的路由键和绑定中的key完全一致的时候，交换器就将消息发送到该队列当中。它时完全匹配单播模式</li><li>fanout交换器：当我们消息发送到fanout交换器时，不管交换器与队列绑定的路由键时什么，fanout交换器都会把这个消息发送给每一个队列，跟UDP广播类似，fanout交换器发送消息最快。</li><li>topic交换器：该交换器允许我们对路由键做模糊匹配，有选择性的发送给某一个或者多个队列。两个通配符:井号(#)和星号(*)。其中：井号：匹配0个或者多个单词。星号：匹配一个单词。</li></ul><p><strong><em>重点end</em></strong></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>&emsp;&emsp;首先，打开我们的虚拟机，用SecureCRT连接我们的虚拟机，我用的SecureCRT，至于你用的啥连接虚拟机，随便你。</p><p>&emsp;&emsp;然后，用docker安装带manager版本的rabbit，带manager的版本自带图形化界面，容易操作。从docker hub上面搜索，我安装的是</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3.8.1-management</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;接着，新建容器，记得带端口号,-d后台运行，映射两个端口号，起自己的名字，加上镜像id</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq 镜像id</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;接下来，就可以访问了，通过虚拟机的ip地址加上端口号，账号密码都是guest</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟机ip地址:15672</span><br></pre></td></tr></table></figure></div><p><img src="/uploads/article/2019-11-27/RabbitMQ管理界面图.png" alt="RabbitMQ管理界面图.png"></p><p>&emsp;&emsp;我们在图上，就能看到我们前面说过的：Connection，Channel，Exchange，Queue等等。</p><p>&emsp;&emsp;最后面那个admin，我们能够设置用户名和密码，就是我们前面登录的guest，并且，能够设置访问的Virtual Hosts。</p><p>&emsp;&emsp;我们看一下最上面的流程图和消息发送流程<br>，我就举一个例子：</p><ol><li>首先，我们先创建一个交换器名字叫：haichenyi</li></ol><p><img src="/uploads/article/2019-11-27/创建交换器.png" alt="创建交换器.png"></p><ol><li>其次，我们再创建一个队列，名字也叫：haichenyi</li></ol><p><img src="/uploads/article/2019-11-27/创建消息队列.png" alt="创建消息队列.png"></p><ol><li>接着，我们将这交换器和队列绑定到一起</li></ol><p><img src="/uploads/article/2019-11-27/交换器与队列绑定.png" alt="交换器与队列绑定.png"></p><ol><li><p>然后，我们随便发送一条消息</p></li><li><p>最后，查看消息队列</p></li></ol><p><img src="/uploads/article/2019-11-27/发送消息之后的queue.png" alt="发送消息之后的queue.png"></p><p>PS：</p><ul><li>我们在创建Exchange和Queue的时候，有一个选项：Durability，意思是是否可持久化，也就是，服务器重启之后这个东西是否还存在。就选默认的durable就行了，可持久化的</li><li>我们在Exchange和Queue绑定的时候，发送消息的时候，都要填一个Routing key，就是上文我们说的绑定规则。</li></ul><p>&emsp;&emsp;这就是整个流程，这都是页面操作，下面说一下代码里面怎么写，很简单。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;首先，添加依赖：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后，就是配置：两个可能出错的位置，我已经注释标明了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=192.168.113.22</span><br><span class="line">#这里端口号要用5672，不能用15672，15672是后台管理页面的端口号</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">#这里的用户民和密码还有virtual-host要对应上，新建的账号要记得给权限</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;代码怎么写呢？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class SellApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        //message需要自己构造一个；定义消息体内容和消息头</span><br><span class="line">        //rabbitTemplate.send(exchange,routingKey,message);</span><br><span class="line"></span><br><span class="line">        //Object默认当成消息体，只需传入要发送的对象，自动序列化发送给RabbitMQ</span><br><span class="line">        //rabbitTemplate.convertAndSend(exchange,routingKey,Object);</span><br><span class="line">        </span><br><span class="line">        //对象会被默认序列化之后发送</span><br><span class="line">        User user = new User(&quot;海晨忆&quot;,25);</span><br><span class="line">        rabbitTemplate.convertAndSend(&quot;haichenyi&quot;,&quot;haichenyi&quot;,user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void getMsg()&#123;</span><br><span class="line">        //queueName:需要从哪个队列中收消息</span><br><span class="line">        User user = (User) rabbitTemplate.receiveAndConvert(&quot;haichenyi&quot;);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        System.out.println(user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;可以向上面这样测试，发送和接收。实际应用中，我们要向下面这样写：</p><ul><li>启动类上添加@EnableRabbit注释，开启Rabbit监听功能</li><li>在我们接收的方法添加@RabbitListener注解，queues是一个数组，方法的参数是发送的数据类型。</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;haichenyi&quot;)</span><br><span class="line">    public void receive(User user)&#123;</span><br><span class="line">        System.out.println(&quot;收到消息：&quot;+user);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        System.out.println(user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;以上，就是RabbitMQ的简单使用了，上面的Exchange，Queue都是在管理界面创建绑定的，代码里面怎么创建绑定呢？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    RabbitAdmin rabbitAdmin;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void createExchange()&#123;</span><br><span class="line">        //以declare开头的都是创建，这里是创建一个Exchange，需要传一个Exchange对象</span><br><span class="line">        //我们点击过去看，是一个接口，我们就看它的实现类。可以看到5种实现类</span><br><span class="line">        rabbitAdmin.declareExchange(new DirectExchange(&quot;wang.exchange&quot;));</span><br><span class="line">        //创建一个queue队列</span><br><span class="line">        rabbitAdmin.declareQueue(new Queue(&quot;wang.queue&quot;));</span><br><span class="line">        //destination：目的地</span><br><span class="line">        //Binding.DestinationType destinationType：类型,枚举类：队列和交换器两种</span><br><span class="line">        //exchange：交换器</span><br><span class="line">        //routingKey：路由键</span><br><span class="line">        //arguments：头信息</span><br><span class="line">        //绑定有两种绑定方式，一种是把交换器往队列上面绑定，一种是把队列往交换器上面绑定</span><br><span class="line">        rabbitAdmin.declareBinding(new Binding(&quot;wang.queue&quot;,Binding.DestinationType.QUEUE,&quot;wang.exchange&quot;,&quot;wang.key&quot;,null));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后，发消息的操作就跟前面写的一样了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;大多数应用当中，可通过消息服务中间件来提升系统的异步通信和扩展解耦能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列-Docker（十九）</title>
    <link href="http://haichenyi.com/2019/11/13/SpringBoot%E7%B3%BB%E5%88%97-Docker%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/11/13/SpringBoot系列-Docker（十九）/</id>
    <published>2019-11-13T06:44:37.000Z</published>
    <updated>2019-11-13T06:45:42.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，<br>然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><a id="more"></a><p>&emsp;&emsp;容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。</p><p>&emsp;&emsp;我们spring boot项目，什么地方需要用到dockers呢？我们最后项目发布，发到服务器上面，环境怎么搭建？如果就用Linux命令会很麻烦，用Docker，简单的几行命令就可以了。</p><p>&emsp;&emsp;服务器其实就是一个操作系统，我们的项目跑在上面也是需要环境的，我们本地是windows系统，跑项目需要环境，服务器现在一般都是centOS系统，当然也需要环境。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>docker镜像(images)：Docker镜像用于创建Docker容器的模板</li><li>docker容器(container)：Docker容器是独立运行的一个或者一组应用</li><li>docker客户端(client)：客户端通过命令或者其他工具一起使用docker api与docker守护进程</li><li>docker主机(host)：一个物理或者虚拟的机器用于执行docker守护进程和容器</li><li>docker仓库(registry)：docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。docker hub提供了庞大的镜像集合供使用</li></ul><p>&emsp;&emsp;举个例子，我们一般操作流程是这样的：</p><ol><li>先用VirtualBox启动一个虚拟机，启动的是centOS系统，装上docker程序（docker主机）。这个对应的就是我们项目最后发布的服务器。</li><li>然后，用SecureCRT连上我们这个虚拟机。（docker客户端）。</li><li>接着，通过docker从docker 仓库中下载我们需要的镜像，比方说：mysql镜像，redis镜像等等。</li><li>最后，启动这个镜像，就相当于创建一个容器。启动镜像，就相当于配置好了环境。比方说：启动一个mysql镜像，就相当于创建了一个mysql容器，就可以用mysql数据库了。可以启动的那个多个镜像，并且，每个镜像都是独立运行的，互不干扰（沙箱机制）。</li></ol><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>查看centOS版本：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//docker要求CentOS系统内核版本要高于3.10</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure></div><p>升级软件包及内核：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//因为，我们安装的docker是最新版本的</span><br><span class="line">//但是，内核版本低可能不兼容，所以，要更新</span><br><span class="line">//如果，后面安装成功之后，启动的时候出错，那么就先卸载docker，更新内核</span><br><span class="line">//重启之后，再重新安装docker就行了</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure></div><p>安装docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure></div><p>卸载docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-*</span><br></pre></td></tr></table></figure></div><p>启动docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></div><p>将docker作为开机启动</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></div><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">检索</td><td style="text-align:left">docker search 关键字（eg：docker search redis）</td><td style="text-align:left">我们经常去docker hub上检索镜像的详细信息，不用再本地敲命令搜索。如镜像的TAG</td></tr><tr><td style="text-align:left">拉取</td><td style="text-align:left">docker pull 镜像名:tag</td><td style="text-align:left">:tag是可选的，tag表示标签，多为软件的版本，默认是latest版本</td></tr><tr><td style="text-align:left">列表</td><td style="text-align:left">docker images</td><td style="text-align:left">查看所有本地镜像</td></tr><tr><td style="text-align:left">删除</td><td style="text-align:left">docker rmi image-id</td><td style="text-align:left">删除指定的本地镜像，镜像id可以通过列表查看</td></tr><tr><td style="text-align:left">运行</td><td style="text-align:left">docker run -d –name 自定义名字  安装的容器名字（eg:docker run –d –name myredis redis）</td><td style="text-align:left">–name：自定义容器名 -d：后台运行</td></tr><tr><td style="text-align:left">列表</td><td style="text-align:left">docker ps（查看运行中的容器）</td><td style="text-align:left">加上-a；可以查看所有容器</td></tr><tr><td style="text-align:left">停止</td><td style="text-align:left">docker stop container-name/container-id</td><td style="text-align:left">停止当前你运行的容器</td></tr><tr><td style="text-align:left">启动</td><td style="text-align:left">docker start container-name/container-id</td><td style="text-align:left">启动容器</td></tr><tr><td style="text-align:left">删除</td><td style="text-align:left">docker rm container-id</td><td style="text-align:left">删除指定容器</td></tr><tr><td style="text-align:left">端口映射</td><td style="text-align:left">-p 6379:6379</td><td style="text-align:left">-p: 主机端口(映射到)容器内部的端口</td></tr><tr><td style="text-align:left">容器日志</td><td style="text-align:left">docker logs container-name/container-id</td></tr></tbody></table><p>PS:我们docker run的时候一般都是跟上端口映射，不然访问不到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。&lt;br&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，&lt;br&gt;然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Run启动原理（十八）</title>
    <link href="http://haichenyi.com/2019/11/11/SpringBoot%E7%B3%BB%E5%88%97-Run%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/11/11/SpringBoot系列-Run启动原理（十八）/</id>
    <published>2019-11-11T09:28:35.000Z</published>
    <updated>2019-11-11T09:32:08.591Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;需要搞清楚几个重要的事件回调机制</p><p>配置在META-INF/spring.factories</p><ul><li>ApplicationContextInitializer</li><li>SpringApplicationRunListener</li></ul><p>只需要放在ioc容器中</p><ul><li><p>ApplicationRunner </p></li><li><p>CommandLineRunner</p></li></ul><a id="more"></a><p>&emsp;&emsp;新建一个空项目，就勾选web，找到启动类，每个方法上面写的注释，可以看一下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SellApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SellApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上面run方法点进来</span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;</span><br><span class="line">return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;</span><br><span class="line">return new SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>看到这里，就应该看到了，启动流程分为两步</p><ol><li>创建SpringApplication对象</li><li>运行run方法</li></ol><h3 id="创建SpringApplication对象"><a href="#创建SpringApplication对象" class="headerlink" title="创建SpringApplication对象"></a>创建SpringApplication对象</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//上面的构造方法点进去</span><br><span class="line">//这里与1.5版本不一样的地方就是，</span><br><span class="line">//2.X这里调用了重载的构造方法，而1.5这里调用的是一个initialize()方法，这个方法里面的内容，与下面两个参数的重载方法差不多</span><br><span class="line">public SpringApplication(Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">this(null, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面这个就是this调用的重载的构造方法</span><br><span class="line">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">this.resourceLoader = resourceLoader;</span><br><span class="line">//保存主配置类，1.5里面这里有个非空判断，用if做的，这里换成的断言做判断</span><br><span class="line">Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">//判断当前是否一个web应用</span><br><span class="line">this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">//从类路径下找到META‐INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起 来</span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">//从类路径下找到ETA‐INF/spring.factories配置的所有ApplicationListener</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">//从多个配置类中找到有main方法的主配置类</span><br><span class="line">this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="setInitializers-方法"><a href="#setInitializers-方法" class="headerlink" title="setInitializers()方法"></a>setInitializers()方法</h4><p>&emsp;&emsp;看方法名就知道，这个是初始化方法，初始化什么东西呢？再看传的参数ApplicationContextInitializer，就是一开始我们提到的类。我们看这个是怎么获取的</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//第一步：</span><br><span class="line">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">return new SpringApplicationRunListeners(logger,</span><br><span class="line">getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二步：</span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line">// Use names and ensure unique to protect against duplicates</span><br><span class="line">//看这里的导入方法SpringFactoriesLoader.loadFactoryNames(type, classLoader)</span><br><span class="line">Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">return instances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三步：</span><br><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line">return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第四步，就是这里了。看这里面的实现</span><br><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">if (result != null) &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">//一眼看过去。很明显，这里就是classLoader.getResources()，导入的本地的资源。看这个传的参数,我放到这个方法下面去了</span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != null ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">//这里通过一个while循环，加载本地配置的ApplicationContextInitializer</span><br><span class="line">while (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = new UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException ex) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The location to look for factories.</span><br><span class="line"> * &lt;p&gt;Can be present in multiple JAR files.</span><br><span class="line"> */</span><br><span class="line">public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;所以，从上面的源码，我们一步一步点击进去看，我们就能发现，他最终都是加载到 <strong>META-INF/spring.factories</strong> 目录下的 <strong>ApplicationContextInitializer</strong> 当然，到目前为止这里只是初始化</p><h4 id="setListeners-方法"><a href="#setListeners-方法" class="headerlink" title="setListeners()方法"></a>setListeners()方法</h4><p>&emsp;&emsp;一眼就能看出来，这里是设置监听方法</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;一眼看过去，这个setListener方法传的参数熟不熟悉？就是我们上面初始化的时候传的参数是同一个方法。所以，这里设置监听设置哪些监听方法也是<strong>META-INF/spring.factories</strong> 目录下的listener方法，我们看一下这个文件内容：</p><p><img src="/uploads/article/2019-11-11/spring_factories.png" alt="spring_factories.png"></p><p>&emsp;&emsp;这些都是是自动配置类的内容</p><h3 id="运行Run方法"><a href="#运行Run方法" class="headerlink" title="运行Run方法"></a>运行Run方法</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">StopWatch stopWatch = new StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = null;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">//获取SpringApplicationRunListeners；从类路径下META‐INF/spring.factories</span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">//回调所有的获取SpringApplicationRunListener.starting()方法</span><br><span class="line">listeners.starting();</span><br><span class="line">try &#123;</span><br><span class="line">    //封装命令行参数</span><br><span class="line">ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">//准备环境，创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准 备完成</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">//这里是新增的，点击去看，就是再properties文件中配置你需要忽略的bean</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">//这个是打印spring的logo banner图</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">/创建ApplicationContext；这个下面有下介绍</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">//看一下参数，这个就是做异常报告处理的</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"></span><br><span class="line">//准备上下文环境;将environment保存到ioc中；而且applyInitializers()；</span><br><span class="line">//applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法</span><br><span class="line">//回调所有的SpringApplicationRunListener的contextPrepared()；</span><br><span class="line">//prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded()；</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">//s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版</span><br><span class="line">//扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）</span><br><span class="line">refreshContext(context);</span><br><span class="line">//2.x里面是空方法</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line"></span><br><span class="line">//从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">//返回这个IOC容器</span><br><span class="line">return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="getRunListeners-方法"><a href="#getRunListeners-方法" class="headerlink" title="getRunListeners()方法"></a>getRunListeners()方法</h4><p>&emsp;&emsp;我们看到上面第一个有注释的位置：getRunListeners方法</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">return new SpringApplicationRunListeners(logger,</span><br><span class="line">getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;方法熟悉吗？就是我们上面初始化的时候调用的那个方法，只是这里的参数传的是：<strong>SpringApplicationRunListener</strong>,我们看最开始说的，这就是我们要了解的第二个内容，回调都是怎么调用的</p><p>&emsp;&emsp;方法里面的注释也写了，先获取监听事件，然后回调starting方法，我们看一下这个接口有那些回调方法：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface SpringApplicationRunListener &#123;</span><br><span class="line"></span><br><span class="line">default void starting() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void environmentPrepared(ConfigurableEnvironment environment) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就这些回调，这里还用了1.8的新特性，<strong>default关键字</strong>，接口里面的方法可以有方法体</p><h4 id="prepareEnvironment"><a href="#prepareEnvironment" class="headerlink" title="prepareEnvironment()"></a>prepareEnvironment()</h4><p>&emsp;&emsp;看到第二个写注释的位置，眼熟吗？可不就是跟上面回调方法名字相同么？我们点进去看一下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,</span><br><span class="line">ApplicationArguments applicationArguments) &#123;</span><br><span class="line">// Create and configure the environment</span><br><span class="line">ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line"></span><br><span class="line">//这里划重点，这里就调用的environmentPrepared的回调方法</span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line">if (!this.isCustomEnvironment) &#123;</span><br><span class="line">environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line">return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;准备完环境之后，调用environmentPrepared的回调</p><h4 id="createApplicationContext"><a href="#createApplicationContext" class="headerlink" title="createApplicationContext()"></a>createApplicationContext()</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableApplicationContext createApplicationContext() &#123;</span><br><span class="line">Class&lt;?&gt; contextClass = this.applicationContextClass;</span><br><span class="line">if (contextClass == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">switch (this.webApplicationType) &#123;</span><br><span class="line">case SERVLET:</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">case REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex) &#123;</span><br><span class="line">throw new IllegalStateException(</span><br><span class="line">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;创建applicationContext，这里跟1.5不一样，1.5就只有两种：一种是web的ioc容器，一种是默认的ioc容器。2.X这里有三种：<strong>DEFAULT_CONTEXT_CLASS，DEFAULT_SERVLET_WEB_CONTEXT_CLASS，DEFAULT_REACTIVE_WEB_CONTEXT_CLASS</strong>，实际字符串比较长，可以去看一下源码。然后用BeanUtils通过反射创建。</p><h4 id="prepareContext-方法"><a href="#prepareContext-方法" class="headerlink" title="prepareContext()方法"></a>prepareContext()方法</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span><br><span class="line">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123;</span><br><span class="line">//将environment放到context中</span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">//初始化</span><br><span class="line">applyInitializers(context);</span><br><span class="line">//这里回调contextPrepared方法</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == null);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line">// Add boot specific singleton beans</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);</span><br><span class="line">if (printedBanner != null) &#123;</span><br><span class="line">beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line">if (beanFactory instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line">if (this.lazyInitialization) &#123;</span><br><span class="line">context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">&#125;</span><br><span class="line">// Load the sources</span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</span><br><span class="line">load(context, sources.toArray(new Object[0]));</span><br><span class="line">//这里回调contextLoaded()方法</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;准备上下文环境;将environment保存到ioc中；而且applyInitializers()</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void applyInitializers(ConfigurableApplicationContext context) &#123;</span><br><span class="line">for (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class="line">Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),</span><br><span class="line">ApplicationContextInitializer.class);</span><br><span class="line">Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);</span><br><span class="line">initializer.initialize(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里就将我们一开始从配置文件里面读取，然后创建ApplicationContextInitializer初始化。</p><p>&emsp;&emsp;当环境准备好之后，就回调了SpringApplicationRunListener的contextPrepared()；</p><p>&emsp;&emsp;当所有的都准备好了之后，回调SpringApplicationRunListener的contextLoaded()；</p><p>&emsp;&emsp;到这里，所有的环境都准备好了，需要打印的logo也加进去了。</p><h4 id="refreshContext"><a href="#refreshContext" class="headerlink" title="refreshContext()"></a>refreshContext()</h4><p>&emsp;&emsp;刷新容器这个方法，我们可以点到具体的功能实现里面，可以看到，这里就是扫描，创建，加载所有的组件，配置类，组件，自动配置等。</p><p>&emsp;&emsp;到这里，这个方法创建完之后，所有的控制器就创建完了，所有的组件，bean等，都在控制台打印出来了。如果是web应用，还会创建嵌入式的tomcat。我们spring boot项目内嵌tomcat，就是在这里创建的。</p><h4 id="afterRefresh"><a href="#afterRefresh" class="headerlink" title="afterRefresh()"></a>afterRefresh()</h4><p>&emsp;&emsp;1.5版本这个方法里面回调的是callRunners方法，而2.X版本，现在这是个空方法里面并没有实现。callRunners被提出来了，放到了最后面。</p><h4 id="started-running"><a href="#started-running" class="headerlink" title="started(),running()"></a>started(),running()</h4><p>&emsp;&emsp;在1.5版本这里，也就是afterRefresh()之后，应该是调用的SpringApplicationRunListeners的finished()方法。</p><p>&emsp;&emsp;在2.X版本之后，去掉了finished方法，改成了调用started方法，然后调用running方法。我们上面有一个starting方法，从这里名字就可以看出来，相当于，首先是正在启动当中，然后就是启动完成了，正在运行了。</p><h4 id="callRunners"><a href="#callRunners" class="headerlink" title="callRunners()"></a>callRunners()</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void callRunners(ApplicationContext context, ApplicationArguments args) &#123;</span><br><span class="line">List&lt;Object&gt; runners = new ArrayList&lt;&gt;();</span><br><span class="line">runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123;</span><br><span class="line">if (runner instanceof ApplicationRunner) &#123;</span><br><span class="line">callRunner((ApplicationRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line">if (runner instanceof CommandLineRunner) &#123;</span><br><span class="line">callRunner((CommandLineRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;从IOC容器中(不是配置文件)获取所有的的ApplicationRunner和CommandLineRunner进行回调。这也是最开始说的两个注意的地方</p><p>&emsp;&emsp;并且，这里有个先后顺序，先回调的ApplicationRunner，后回调的CommandLineRunner</p><p>&emsp;&emsp;这里也是run方法，最后执行的地方。从这里就是真正的开启了run。</p><p>&emsp;&emsp;最后一步，返回那个context就是返回IOC容器对象。到这里，我们的spring boot就启动完成了。</p><p>&emsp;&emsp;这就是我们的spring boot的启动原理。初始化，listener的回调，Runner的回调都说的很清楚。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;需要搞清楚几个重要的事件回调机制&lt;/p&gt;
&lt;p&gt;配置在META-INF/spring.factories&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ApplicationContextInitializer&lt;/li&gt;
&lt;li&gt;SpringApplicationRunListener&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只需要放在ioc容器中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ApplicationRunner &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CommandLineRunner&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Redis（十七）</title>
    <link href="http://haichenyi.com/2019/11/06/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Redis%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/11/06/SpringBoot系列—Redis（十七）/</id>
    <published>2019-11-06T08:40:38.000Z</published>
    <updated>2019-11-06T08:42:54.420Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前面一篇说到了spring boot自带的缓存SimpleCache，我们也聊到了他的底层实际上就是HashMap，并且这个缓存是放在内存当中的，这样弊端也是有的，比如：内存大小，当服务器关闭之后，缓存就没了等等。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;实际开发中，一般使用缓存中间件：Redis，EHCache，MemCache等等，今天，我们就来聊聊，经常听到的——Redis。</p><p>&emsp;&emsp;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）——来自官方介绍</p><p>&emsp;&emsp;不去追究原理，我们可以这样理解Redis：</p><ul><li>支持多种数据类型，redis支持set,zset,list,hash,string这五种数据类型，操作方便。</li><li>作为一个内存数据库，最担心的，就是万一机器死机宕机，数据就会消失掉。redis使用RDB和AOF做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。</li><li>与服务器解耦，缓存是一个单独的服务器，当我们项目重启的时候，缓存依然存在。</li><li>我们只用的话，它就是给我们提供了一系列方法的接口，我们只用调用它的API即可。</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;第一步，添加启动器：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第二步，配置你的服务器地址，不配置的话，默认是本地：配置信息一样在 <strong>自动配置类——data包——redis包——RedisProperties类</strong> 里面去找</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#指定redis服务器地址，指定的是本地</span><br><span class="line">spring.redis.host=127.0.0.1</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第三步，添加了redis的配置类，当数据库添加复杂数据的时候，也能以Json的格式正常显示。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport&#123;</span><br><span class="line">@Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        //key序列化方式</span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        //value序列化</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        //value hashmap序列化</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第四步，正常写接口，在service层里面，自己去把数据写进缓存里面，</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboottask.service;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboottask.Provider;</span><br><span class="line">import com.haichenyi.springboottask.mapper.ProviderMapper;</span><br><span class="line">import com.haichenyi.springboottask.utils.RedisClient;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Desc</span><br><span class="line"> * @Auther 海晨忆</span><br><span class="line"> * @Time 2019/11/6</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class ProviderService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    ProviderMapper providerMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    public Provider getProviderById(Integer pid) &#123;</span><br><span class="line">        Provider provider = (Provider) redisClient.get(pid);</span><br><span class="line">        if (provider != null) &#123;</span><br><span class="line">            return provider;</span><br><span class="line">        &#125;</span><br><span class="line">        Provider provider1 = providerMapper.getProviderByPid(pid);</span><br><span class="line">        redisClient.set(pid, provider1);</span><br><span class="line">        return provider1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;如上代码，我们通过id获取一个Provider，我们先从缓存去取，如果，取不到，说明缓存没有，那么，我们就去从数据库去取，取到之后，再把这条数据放进缓存里面。</p><p>&emsp;&emsp;就是上一篇讲默认缓存的注解的功能，redis里面需要我们自己去实现。</p><p>&emsp;&emsp;这里的 <strong>RedisClient</strong> 类，是自己封装的redis使用的类，至于redis怎么使用，redis的<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">中文官网</a>的命令页面写的很清楚。</p><p>&emsp;&emsp;记得本地电脑装一个Redis服务。然后再本地装一个redis可视化工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前面一篇说到了spring boot自带的缓存SimpleCache，我们也聊到了他的底层实际上就是HashMap，并且这个缓存是放在内存当中的，这样弊端也是有的，比如：内存大小，当服务器关闭之后，缓存就没了等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—缓存及其源码分析（十六）</title>
    <link href="http://haichenyi.com/2019/11/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E7%BC%93%E5%AD%98%E5%8F%8A%E5%85%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/11/05/SpringBoot系列—缓存及其源码分析（十六）/</id>
    <published>2019-11-05T02:52:46.000Z</published>
    <updated>2019-11-05T03:04:13.544Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;缓存是每个项目都用到的为了提高接口响应效率，降低数据库的查询压力，从而提高系统性能。所以，缓存对于一个项目来说是至关重要的。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;spring 3+之后，就定义了CacheManager和Cache接口来统一不同的缓存技术。</p><ul><li>CacheManager：缓存管理器，用于管理各种Cache缓存组件</li><li>Cahce：定义了各种操作，Spring在Cache接口下提供了各种xxCache的实现；比如：ConcurrentMapCache，RedisCache，JCacheCache等等</li></ul><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>&emsp;&emsp;这里我以默认缓存为例：ConcurrentMapCache</p><p>&emsp;&emsp;上面说了，缓存只用配置就可以直接使用，所以，配置，一说到配置，我们就会想到之前说的自动配置类AutoConfigure。如下图：</p><p><img src="/uploads/article/2019-11-05/缓存结构图.png" alt="缓存结构图.png"></p><p>&emsp;&emsp;我们看到，自动配置类目录下面有一个cache包，这就是缓存自动配置的包，我们熟悉的类就有CacheProperties这个类，我们点进去看：</p><p><img src="/uploads/article/2019-11-05/缓存配置类.png" alt="缓存配置类.png"></p><p>&emsp;&emsp;我们熟悉的prefix就在这里了，也就是我们在全局配置类里面的键。</p><p>&emsp;&emsp;这里，配置的一般都是这个类里面的全局变量，我把这个CacheType给框出来了（下面的cacheNames这个list变量也很重要），上面的注释的意思是说，缓存类型，默认情况下，是根据环境自动检测的。</p><p>&emsp;&emsp;我们上面说到CacheManager和Cache接口是用来同意管理不同的缓存技术。不同的，也就是指的我们这里的缓存类型。所以，我们这里的缓存类型肯定有好几种，然后，这里又讲是根据环境自动检测的。也就是我们配置好的。也就是我们在全局配置类里面配置好的</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.xxx=xxx</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;既然是配置，肯定是定义了之后才能配置的，没定义，怎么可能配置，spring又不是神。那，定义了那些种类的缓存技术呢？我们看一下CacheType类</p><p><img src="/uploads/article/2019-11-05/缓存枚举类.png" alt="缓存枚举类.png"></p><p>&emsp;&emsp;定义的，就这10种：GENERIC，JCACHE，EHCACHE，HAZELCAST，INFINISPAN，COUCHBASE，REDIS，CAFFEINE，SIMPLE，NONE。作为一个初学者，我想一眼看过去，我们能看到熟悉的Redis，学后天，Redis框架肯定要学。</p><p>&emsp;&emsp;我们现在，什么都没有配置，默认的缓存类型就是这个Simple，可以在Cache目录下面的CacheAutoConfiguration类中看到selectImports方法，在这里打断点，我们debug模式运行，我们就能看到它导入的缓存类型，然后，每个进行检测，看匹配哪一个。</p><p><img src="/uploads/article/2019-11-05/默认导入的缓存.png" alt="默认导入的缓存.png"></p><p>&emsp;&emsp;我们就看一下SimpleCacheConfiguration是怎么实现的</p><p><img src="/uploads/article/2019-11-05/SimpleCacheConfiguration图.png" alt="SimpleCacheConfiguration图.png"></p><p>&emsp;&emsp;我们看到了，SimpleCacheConfiguration默认使用的是：ConcurrentMapCacheManager，我们，看一下这个Manager是怎么实现的</p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCacheManager图1.png" alt="ConcurrentMapCacheManager图1.png"></p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCacheManager图2.png" alt="ConcurrentMapCacheManager图2.png"></p><p>&emsp;&emsp;这类，实现的就是CacheManager接口，而CacheManager接口就只有两个方法，就是上图中的两个方法<strong>setCacheNames</strong> 和 <strong>getCache</strong></p><p>&emsp;&emsp;先说一下数据是怎么缓存的，缓存是一个容器，这个容器怎么获取的呢？就是通过这里的name，name是获取这个容器的key，然后里面的数据存放形式，都是key-value的形式存放的。这个key也是我们定义的，value就是数据库查询的数据。如下图。</p><p><img src="/uploads/article/2019-11-05/缓存图.png" alt="缓存图.png"></p><p>&emsp;&emsp;这个setCacheNames，就是，我们配置的cacheNames的值，它会获取好之后，将这些值封装成list，通过setCacheNames方法赋值给这里的变量cacheMap。我们可以看一下这个变量：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final ConcurrentMap&lt;String, Cache&gt; cacheMap = new ConcurrentHashMap&lt;&gt;(16);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后就是这个getCache方法，上面的setCacheNames以cacheName为键去存这个Cache，这个就是刚好相反，获取方法，通过cacheName去获取这个Cache。</p><p>&emsp;&emsp;然后，我们现在是获取到了这个缓存容器，那么，我们要怎么从这个缓存容器中去获取我们对应的数据呢？</p><p>&emsp;&emsp;我们看到上面那个变量是Map是以String为键，以Cache为值，我们最开始说过了，Cache和CacheManager是用来管理不同缓存技术的接口，所以，这里的值不可能是一个接口对象，肯定是它的实现类，我们再仔细看上面两个方法的实现类，我们会看到</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//setCacheNames方法</span><br><span class="line">this.cacheMap.put(name, createConcurrentMapCache(name));</span><br><span class="line"></span><br><span class="line">//getCache方法</span><br><span class="line">cache = createConcurrentMapCache(name);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;很明显，这里就是Cache对象是怎么创建的，我们点到这个方法里面去看：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create a new ConcurrentMapCache instance for the specified cache name.</span><br><span class="line"> * @param name the name of the cache</span><br><span class="line"> * @return the ConcurrentMapCache (or a decorator thereof)</span><br><span class="line"> */</span><br><span class="line">protected Cache createConcurrentMapCache(String name) &#123;</span><br><span class="line">SerializationDelegate actualSerialization = (isStoreByValue() ? this.serialization : null);</span><br><span class="line">return new ConcurrentMapCache(name, new ConcurrentHashMap&lt;&gt;(256),</span><br><span class="line">isAllowNullValues(), actualSerialization);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;所以，它这里是new的ConcurrentMapCache肯定是Cache的实现类。我们看到这个构造方法，第二个参数是一个hashMap，而我们的缓存容器里面也是以键值对的方式存储数据的。我们再看这个ConcurrentMapCache</p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCache图.png" alt="ConcurrentMapCache图.png"></p><p>&emsp;&emsp;一共就只有三个全局变量，第一个name，是我们前面传过来的cacheName，第二个是Map<object,object>类型，第三个是SerializationDelegate类型的变量，序列化的一个什么东西。排除法判断，只可能这个Map就是用来存放我们的缓存数据的。我们搜索这个变量，我们会看到如下几个方法：</object,object></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   //获取缓存数据</span><br><span class="line">   @Override</span><br><span class="line">@Nullable</span><br><span class="line">protected Object lookup(Object key) &#123;</span><br><span class="line">return this.store.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   //存放</span><br><span class="line">   @Override</span><br><span class="line">public void put(Object key, @Nullable Object value) &#123;</span><br><span class="line">this.store.put(key, toStoreValue(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过key移除数据</span><br><span class="line">@Override</span><br><span class="line">public void evict(Object key) &#123;</span><br><span class="line">this.store.remove(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空所有数据</span><br><span class="line">@Override</span><br><span class="line">public void clear() &#123;</span><br><span class="line">this.store.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   //清空所有数据</span><br><span class="line">@Override</span><br><span class="line">public boolean invalidate() &#123;</span><br><span class="line">boolean notEmpty = !this.store.isEmpty();</span><br><span class="line">this.store.clear();</span><br><span class="line">return notEmpty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;至此，缓存怎么存放，怎么获取都说完了。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;与前面差不多，都是在启动类上面开启，在方法上面标记注解就行了</p><ol><li>@EnableCaching：在启动类上，开启基于注解的缓存</li><li>@Cacheable：标在方法上，返回的结果会进行缓存(先查缓存中的结果，没有则调用方法并将结果放到缓存中)</li><li>@CachePut：保证方法被调用后，又将对应缓存中的数据更新（先调用方法，调完方法再将结果放到缓存）</li><li>@CacheEvict：清除缓存</li></ol><p>&emsp;&emsp;@Cacheable，@CachePut，@CacheEvict三个注解都有几个重要的属性：</p><ul><li>cacheNames：缓存的名字。</li><li>key: 作为缓存中的Key值，可以使用SpEL表达式指定（不指定，key就是参数值），缓存结果是方法返回值</li></ul><p>&emsp;&emsp;上面两个属性是前面我们一直都在强调的比较重要的属性，然后，清除缓存的注解中还有两个属性需要了解:</p><ul><li>allEntries =true : 指定清除这个缓存中所有数据。</li><li>beforeInvocation = true : true在方法之前执行；默认false在方法之后执行,出现一场则不会清除缓存</li></ul><p>&emsp;&emsp;我这里值贴出来缓存相关的类：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Cacheable(cacheNames = &quot;user&quot;, key = &quot;#id&quot;)</span><br><span class="line">    public User getUser(Integer id) &#123;</span><br><span class="line">        return userMapper.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CachePut(cacheNames = &quot;user&quot;, key = &quot;#result.id&quot;)</span><br><span class="line">    public User updateUser(User user) &#123;</span><br><span class="line">        userMapper.updateUser(user);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CacheEvict(cacheNames = &quot;user&quot;, key = &quot;#result&quot;)</span><br><span class="line">    public Integer deleteUser(Integer id) &#123;</span><br><span class="line">        userMapper.deleteUserById(id);</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;第一步：默认采用的是SimpleCacheConfiguration 使用 ConcurrentMapCacheManager</p><p>&emsp;&emsp;第二步：getCache 获取的是 ConcurrentMapCache 缓存对象进行存取数据,它使用ConcurrentMap<object,object>对象进行缓存数据。</object,object></p><p>@Cacheable(cacheNames = “user”, key = “#id”)</p><p><strong>第一次请求时：</strong></p><p>&emsp;&emsp;第三步：当发送第一次请求时，会从getCache(name)中获取，看有没有ConcurrentMapCache缓存对象,如果没有 则创建出来, 并且创建出来的key就是通过</p><p>@Cacheable(cacheNames = “user”)标识的name值 </p><p>&emsp;&emsp;第四步：接着会从ConcurrentMapCache里面调用lookup获取缓存数据,通过key值获取的, </p><p>默认采用的是service方法中的参数值,如果缓存中没有获取到,则调用目标方法进行获取数据（即从数据库中查询）,获取之后则再将它 放到缓存中(key=参数值,value=返回值)</p><p><strong>第二次请求时：</strong></p><p>&emsp;&emsp;第五步：如果再次调用 则还是先ConcurrentMapCacheManager.getCache()获取缓存对象,如果有则直接返回, 如果没有则创建</p><p>&emsp;&emsp;第六步：然后再调用 ConcurrentMapCache.lookup方法从缓存中获取数据, 如果缓存有数据则直接响应回去,不 会再去调用目标方法</p><p><strong>第三次请求与第二次一样</strong></p><p>如果缓存中没有缓存管理器,则与第一次请求一致</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;缓存是每个项目都用到的为了提高接口响应效率，降低数据库的查询压力，从而提高系统性能。所以，缓存对于一个项目来说是至关重要的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—邮件（十五）</title>
    <link href="http://haichenyi.com/2019/10/31/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E9%82%AE%E4%BB%B6%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/10/31/SpringBoot系列—邮件（十五）/</id>
    <published>2019-10-31T09:12:19.000Z</published>
    <updated>2019-11-05T02:58:07.873Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;邮件发送是必不可少的，不管是注册邮件，还是广告。</p><a id="more"></a><p>&emsp;&emsp;spring boot中已经集成的mail的启动器，所以，我们只用配置好就行了。</p><p>&emsp;&emsp;引入启动器：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;那么，需要配置什么内容呢？我们之前讲过，需要配置的东西，spring boot都给我们提前准备好了，都在自动配置类AutoConfigure那个类里面，我们可以找一找，里面有个mail包，这个就是邮件的相关配置类。</p><p><img src="/uploads/article/2019-10-31/邮件配置.png" alt="邮件配置图.png"></p><p>&emsp;&emsp;我们可以看到上面的prefix中的spring.mail就是我们的配置文件中的前缀，这个类里面的公共变量，就是我们配置文件中的键。我们这里配置了四个值。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#配置邮箱账号</span><br><span class="line">spring.mail.username=371965177@qq.com</span><br><span class="line">spring.mail.password=XXXXXXX</span><br><span class="line">#配置发送邮件服务器</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">#配置ssl安全连接</span><br><span class="line">spring.mail.properties.smtp.ssl.enable = true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里的密码，我们不能填，我们的QQ号密码吧？需要在你的QQ邮箱去设置。生成授权码即可。直接百度一下：QQ邮箱怎么生成授权码，有教程。然后，把生成的授权码填到这里就行了。配置就这么多</p><p>&emsp;&emsp;怎么发送邮件呢？也很简单，分两种，一种是简单的文字邮件，一种是复杂带附件的邮件。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboottask;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.mail.SimpleMailMessage;</span><br><span class="line">import org.springframework.mail.javamail.JavaMailSenderImpl;</span><br><span class="line">import org.springframework.mail.javamail.MimeMessageHelper;</span><br><span class="line"></span><br><span class="line">import javax.mail.MessagingException;</span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class SpringBootTaskApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    JavaMailSenderImpl javaMailSender;</span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        //简单邮件</span><br><span class="line">        SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">        //邮件标题</span><br><span class="line">        message.setSubject(&quot;测试邮件功能标题&quot;);</span><br><span class="line">        //邮件内容</span><br><span class="line">        message.setText(&quot;测试邮件内容&quot;);</span><br><span class="line">        //发件人，必须要跟配置的相同</span><br><span class="line">        message.setFrom(&quot;371965177@qq.com&quot;);</span><br><span class="line">        //收件人</span><br><span class="line">        message.setTo(&quot;1640200266@qq.com&quot;);</span><br><span class="line">        javaMailSender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testMail() throws MessagingException &#123;</span><br><span class="line">        //带附件邮件，通过createMimeMessage()方法获取对象</span><br><span class="line">        MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">        //这里带附件的邮件需要用到这个帮助类</span><br><span class="line">        MimeMessageHelper messageHelper = new MimeMessageHelper(mimeMessage,true);</span><br><span class="line"></span><br><span class="line">        messageHelper.setSubject(&quot;测试邮件功能标题&quot;);</span><br><span class="line">        //可以发送html语句，第一个参数是内容，第二个参数设置为true即可。</span><br><span class="line">        messageHelper.setText(&quot;&lt;h1 style=&apos;color;blue&apos;&gt;测试邮件内容&lt;/h1&gt;&quot;,true);</span><br><span class="line">        //addAttachment添加附件的方法。第一个是名字，第二个是file</span><br><span class="line">        messageHelper.addAttachment(&quot;1.txt&quot;,new File(&quot;D:\\Download\\t.txt&quot;));</span><br><span class="line">        messageHelper.setFrom(&quot;371965177@qq.com&quot;);</span><br><span class="line">        messageHelper.setTo(&quot;1640200266@qq.com&quot;);</span><br><span class="line">        //这里发送的还是MimeMessage对象，并不是那个帮助类对象</span><br><span class="line">        javaMailSender.send(mimeMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;每一行都有注释，已经写的很清楚了，就不做过多的解释了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;邮件发送是必不可少的，不管是注册邮件，还是广告。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—异步任务与定时任务（十四）</title>
    <link href="http://haichenyi.com/2019/10/31/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/10/31/SpringBoot系列—异步任务与定时任务（十四）/</id>
    <published>2019-10-31T06:32:20.000Z</published>
    <updated>2019-11-05T02:58:02.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>&emsp;&emsp;什么时候用异步，就是耗时操作的时候就可以用到异步，比如：批量处理数据，批量发邮件等等。</p><a id="more"></a><p>&emsp;&emsp;用法与前面的事务管理类似，spring 3+之后，就已经内置了 <strong>@Async</strong> 来处理异步任务。我们使用两个注解即可。</p><ul><li>@EnableAysnc 启动类上开启基于注解的异步任务</li><li>@Aysnc 标识的方法会异步执行</li></ul><p>如：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@EnableAsync</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;批量操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        helloService.add();</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;当我们请求这个hello接口时，如果不使用@Async标记方法，那么，线程就会阻塞，我们会在add方法执行完之后，才会返回success。这显然不是我们想要的。</p><p>&emsp;&emsp;如果用@Async标记方法，那么，线程就不会阻塞，我们请求hello接口，会立刻返回success，过了三秒钟，才会批量处理完成。这才是我们想要的。</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>&emsp;&emsp;定时定点的执行某个任务，就需要用到定时任务。比如，当服务器启动之后，比如，每天晚上23点上传日志，每个月1号给用户发送邮件等等。</p><p>&emsp;&emsp;用法都类似：</p><ul><li>@EnableScheduling 启动类上开启基于注解的定时任务</li><li>@Scheduled 标识的方法会进行定时处理</li></ul><p>唯一不一样的地方，也是个难点就是cron表达式</p><p>先举个例子：在上面例子的基础上加上</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@EnableScheduling</span><br><span class="line">@EnableAsync</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;批量操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron = &quot;1-5 * * * * *&quot;)</span><br><span class="line">    public void scheduledTaskt() &#123;</span><br><span class="line">        System.out.println(&quot;执行定时任务&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这个定时任务就是,每分钟的1秒到5秒各执行一次，一共5次。</p><p>&emsp;&emsp;cron表达式一共六个值，每个值都要有。一个都不能少，分别代表的含义是：秒 分 时 日 月 星期几</p><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">取值范围</th><th style="text-align:center">可指定的特殊字符</th></tr></thead><tbody><tr><td style="text-align:center">秒</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">分</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">时</td><td style="text-align:center">0-23</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">日</td><td style="text-align:center">1-31</td><td style="text-align:center">, - * ? / L W C</td></tr><tr><td style="text-align:center">月</td><td style="text-align:center">1-12</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">星期</td><td style="text-align:center">0-7或SUN-SAT 0和7都是周日，1-6是周一到周六</td><td style="text-align:center">, - * ? / L C #</td></tr></tbody></table><p>&emsp;&emsp;特殊字符的含义：<br>|特殊字符|代表含义|<br>|:-:|:-:|<br>|,|枚举，一个位置上指定多个值，以逗号 ， 分隔|<br>|-|区间|<br>|*|任意|<br>|/|步长，每隔多久执行一次|<br>|?|日/星期冲突匹配 ,指定哪个值,另外个就是?|<br>|L|最后|<br>|W|工作日|<br>|C|和calendar联系后计算过的值|<br>|#|这个月的第几个星期几，4#2，第2个星期四|</p><p>比如：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1-5 * * * * 1到5秒，每秒都触发任务 */5 * * * * 每隔5秒执行一次</span><br><span class="line"></span><br><span class="line">0 */1 * * * 每隔1分钟执行一次 0 0 5-15 * * 每天5-15点整点触发</span><br><span class="line"></span><br><span class="line">0 0-5 14 * * 在每天下午2点到下午2:05期间的每1分钟触发</span><br><span class="line"></span><br><span class="line">0 0/5 14 * * 在每天下午2点到下午2:55期间的每5分钟触发</span><br><span class="line"></span><br><span class="line">0 0/5 14,18 * * 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</span><br><span class="line"></span><br><span class="line">0 0/30 9-17 * * 朝九晚五工作时间内每半小时</span><br><span class="line"></span><br><span class="line">0 0 12 ? * WED 表示每个星期三中午12点</span><br><span class="line"></span><br><span class="line">0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发</span><br><span class="line"></span><br><span class="line">0 0 23 L * ? 每月最后一天23点执行一次</span><br><span class="line"></span><br><span class="line">0 15 10 LW * ? 每个月最后一个工作日的10点15分0秒触发任务</span><br><span class="line"></span><br><span class="line">0 15 10 ? * 5#3 每个月第三周的星期五的10点15分0秒触发任务</span><br></pre></td></tr></table></figure></div><p>最后附上在线生成cron表达式的链接： <a href="http://cron.qqe2.com" target="_blank" rel="noopener">http://cron.qqe2.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;异步任务&quot;&gt;&lt;a href=&quot;#异步任务&quot; class=&quot;headerlink&quot; title=&quot;异步任务&quot;&gt;&lt;/a&gt;异步任务&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;什么时候用异步，就是耗时操作的时候就可以用到异步，比如：批量处理数据，批量发邮件等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—事务管理（十三）</title>
    <link href="http://haichenyi.com/2019/09/17/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/17/SpringBoot系列—事务管理（十三）/</id>
    <published>2019-09-17T05:37:31.000Z</published>
    <updated>2019-09-17T05:39:09.783Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;我们操作数据库，事务管理是必不可少的一部分。</p><a id="more"></a><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>&emsp;&emsp;我们在开发企业应用时，用户的一个操作对应数据库可能是多步操作相结合完成的。在这个多个步骤中，其中的一步，可能出现异常，导致后面的步骤无法向下进行，那么，用户的这个操作，可能就没有进行完，前面已经进行的步骤数据就需要回退。</p><p>举个总所周知的栗子：</p><p>&emsp;&emsp;银行的转账，A给B转账，转1000块钱，A的钱需要扣1000，B的钱需要加1000，而，银行的系统在A扣1000块钱之后，B加1000块钱的时候，出现的异常，A的钱扣了，B的钱没有加，这该怎么办？这就需要用到我们的事务管理了。</p><p>&emsp;&emsp;事务就是保证用户的每个操作都是可靠的，事务中的每一个步操作都必须成功执行，如果，其中某一个步骤出现了异常，那么就回退到事务开始未进行操作的状态。</p><p>&emsp;&emsp;事务管理是Spring框架中最为常见的功能之一，我们在SpringBoot开发应用时，大部分情况下也需要使用事务。</p><h3 id="事务管理操作步骤"><a href="#事务管理操作步骤" class="headerlink" title="事务管理操作步骤"></a>事务管理操作步骤</h3><p>&emsp;&emsp;理论上就只有两步：</p><ol><li>@EnableTransactionManagement：标记在启动类</li><li>@Transactional：标记的service层</li></ol><p>&emsp;&emsp;为什么说理论上只需要两步呢？因为，在SpringBoot中，当我们使用 <strong>spring-boot-starter-data-jdbc</strong> 或者是 <strong>spring-boot-starter-data-jpa</strong> 依赖的时候，框架会自动帮我们注入 <strong>入DataSourceTransactionManager</strong> 或者 <strong>JpaTransactionManager</strong> 。所以，我们不需要进行任何额外的配置，就直接可以使用 <strong>@Transactional</strong> 注解进行管理事务。</p><p>&emsp;&emsp;还有几点需要注意的地方：</p><ul><li>Hibernate创建表，默认类型是 <strong>MyISAM，</strong> 是非事务安全的，即使你加上了上面的注解，也不起作用。 <strong>Innodb</strong> 类型的表才是事务安全的。</li><li>需要在你的配置文件中指定： <strong>spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect</strong></li></ul><h3 id="事务的隔离级别和传播行为"><a href="#事务的隔离级别和传播行为" class="headerlink" title="事务的隔离级别和传播行为"></a>事务的隔离级别和传播行为</h3><p>&emsp;&emsp;除了指定事务管理器之后，还能对事务进行隔离级别和传播行为的控制，下面分别详细解释：</p><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>&emsp;&emsp;隔离级别是指在发生并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读、不可重复读、幻读。</p><ul><li><strong>脏读：A事务执行的过程中，修改了id=1的数据，这个时候还没有提交，此时，B读取了修改之后id=1的数据，而A事务却回滚了，这样B事务就形成了脏读。</strong> 比方说：A的银行卡里原来有1000块钱，买东西花了300，还有700，这个时候A的媳妇查银行卡的余额，一看只剩下700了，然后，A又不喜欢那个东西，把东西退掉了，买东西的钱又退回银行卡了，这个时候，A的媳妇查的钱这个事务就是脏读。回来之后一阵毒打，什么跪键盘，跪榴莲。唉，脏读，真惨。</li><li><strong>不可重复读：A事务先读取了id=1的数据，然后执行后面的逻辑，这个时候，B事务修改了id=1的数据，A在执行后面逻辑的时候，又读取了一遍id=1的数据，这个时候发现，两次读取的数据不相同，这就是不可重复读。</strong> 比方说：A发工资了，银行卡里发了1000块钱，每天早上查一遍，中午查一遍，好安心。早上9点上班的时候查了一遍余额有1000块钱，A的媳妇，十点多的时候买了个包包花了500块钱，A中午查的时候就剩下500了，他就去找他媳妇理论啊，你干啥了，咋就只剩下500了，他媳妇一听就来气啊，每个月挣这么点钱，我买个包包怎么了，然后就是一阵毒打，跪键盘，跪榴莲。唉，不可重复读，真惨。</li><li><strong>幻读：A事务先根据条件查询到了N条数据，然后，B事务新增了M条复合A事务查询条件的数据，导致A事务再次查询的时候，查询到了N+M条数据，就产生了幻觉。</strong> 比方说：A的媳妇查询A名下有多少张银行卡，一开始查询有2张（建行，农行），然后，A换了新工作，需要重新再邮政开工资卡。这一天，A的媳妇又查了一遍A名下的银行卡，咦，怎么多了一张邮政的，长能耐了，背着老娘藏私房钱了，于是，就把A一阵毒打，是跪键盘，跪榴莲。唉，幻读，真惨。</li></ul><p>&emsp;&emsp;怎么避免上面的三种情况呢？我们可以看  <strong>org.springframework.transaction.annotation.Isolation</strong>  枚举类中定义了五个表示隔离级<br>别的值：</p><ul><li><strong>DEFAULT：</strong> 这个是默认值，表示使用底层数据库的默认隔离级别，对绝大多数数据库而言，这个值通常就是 <strong>READ_COMMITTED。</strong></li><li><strong>READ_UNCOMMITTED：</strong> 该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。 <strong>该级别不<br>能防止脏读和不可重复读， 因此很少使用该隔离级别。</strong></li><li><strong>READ_COMMITTED：</strong> 该隔离级别表示一个事务只能读取另一个事务已经提交的数据。 <strong>该级别可以防止脏<br>读，这也是大多数情况下的推荐值，性能最好。</strong></li><li><strong>REPEATABLE_READ：</strong> 该隔离级别表示一个事务在整个执行过程中可以多次重复执行某个查询，并且每次返回的数据都相同，即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。 <strong>该级别可以<br>防止脏读和不可重复读。</strong></li><li><strong>SERIALIZABLE：</strong> 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说， <strong>该级别可<br>以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</strong> </li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定方式：</span><br><span class="line">@Transactional(isolation = Isolation.DEFAULT)</span><br></pre></td></tr></table></figure></div><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>&emsp;&emsp;传播行为是指，如果在开始当前事务之前，已经存在一个事务，此时可以指定这个要开始的这个事务的执行行为。</p><p>&emsp;&emsp;我们可以看  <strong>org.springframework.transaction.annotation.Propagation</strong>  枚举类中定义了6个表示传播行<br>为的枚举值：</p><ul><li>REQUIRED:（默认）如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li>SUPPORTS:如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>MANDATORY:如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>REQUIRES_NEW:创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>NOT_SUPPORTED:以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER:以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>NESTED:如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则<br>该取值等价于 REQUIRED 。</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定方式：</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRED)</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;关于这个事务的隔离级别和传播行为，我们一般都不用特别的去指定，用默认的就行了，除非有特别的要求，默认的隔离级别和传播行为满足绝大多数要求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;我们操作数据库，事务管理是必不可少的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Spring Data JPA（十二）</title>
    <link href="http://haichenyi.com/2019/09/11/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Spring-Data-JPA%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/11/SpringBoot系列—Spring-Data-JPA（十二）/</id>
    <published>2019-09-11T09:03:36.000Z</published>
    <updated>2019-09-18T08:47:57.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data"></a>什么是 Spring Data</h3><p>&emsp;&emsp;Spring Data 是 Spring Boot 底层默认进行数据访问的技术 , 为了简化构建基于 Spring 框架应用的数据访问技术，包<br>括非关系数据库、Map-Reduce 框架、云数据服务等；另外也包含对关系数据库的访问支持。</p><a id="more"></a><p>&emsp;&emsp;Spring Data 包含多个模块：</p><ul><li>Spring Data Commons 提供共享的基础框架，适合各个子项目使用，支持跨数据库持久化</li><li>Spring Data JPA</li><li>Spring Data KeyValue</li><li>Spring Data LDAP</li><li>Spring Data MongoDB</li><li>Spring Data Redis</li><li>Spring Data REST</li><li>Spring Data for Apache Cassandra</li><li>Spring Data for Apache Geode</li><li>Spring Data for Apache Solr</li><li>Spring Data for Pivotal GemFire</li><li>Spring Data Couchbase (community module)</li><li>Spring Data Elasticsearch (community module)</li><li>Spring Data Neo4j (community module)</li></ul><h3 id="Spring-Data统一的核心接口"><a href="#Spring-Data统一的核心接口" class="headerlink" title="Spring Data统一的核心接口"></a>Spring Data统一的核心接口</h3><p>&emsp;&emsp;Spring Data项目为大家提供统一的API来对不同的数据访问层进行操作。</p><p><img src="/uploads/article/2019-09-11/Repository.png" alt="Repository继承图.png"></p><ul><li>Repository<t, id="">：统一的根接口即所有接口的父接口，其他接口继承该接口</t,></li><li>CrudRepository<t, id="">：基本的增删改查接口,提供了最基本的对实体类CRUD操作</t,></li><li>PagingAndSortingRepository<t, id="">：增加了分页和排序操作</t,></li><li>JpaRepository<t, id="">：增加了批量操作，并重写了父接口一些方法的返回类型</t,></li></ul><p>&emsp;&emsp;Spring Data JPA、JPA与Hibernate 关系</p><p><img src="/uploads/article/2019-09-11/关系图.png" alt="关系图.png"></p><p>&emsp;&emsp;JPA是一种规范，而Hibernate是实现这种规范的底层实现，SpringData JPA对持久化接口JPA再抽象一层，针对持久化业务再进一步统一简化。</p><h3 id="SpringData-JPA的简单使用"><a href="#SpringData-JPA的简单使用" class="headerlink" title="SpringData JPA的简单使用"></a>SpringData JPA的简单使用</h3><p>&emsp;&emsp;JPA的底层遵守是ORM(对象关系映射)规范，因此JPA其实也就是java实体对象和关系型数据库建立起映射关系，通过<br>面向对象编程的思想操作关系型数据库的规范。</p><p><strong>首先，导包</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.haichenyi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-jpa&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;spring-boot-jpa&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--jdbc的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--jpa的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--web项目的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mysql的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--简化set/get的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></div><p><strong>其次，创建映射bean类</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.entity;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.persistence.*;</span><br><span class="line"></span><br><span class="line">//使用JPA注解配置映射关系</span><br><span class="line">@Entity//说明它是和数据表映射的类</span><br><span class="line">@Table(name = &quot;tbl_hobby&quot;)//指定对应映射的表名，省略默认表名就是类名</span><br><span class="line">@Data</span><br><span class="line">public class Hobby &#123;</span><br><span class="line">    @Id//标识主键</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)////标识自增长主键</span><br><span class="line">    private Integer id;</span><br><span class="line">    @Column(name = &quot;name&quot;, length = 10)//这是和数据表对应的一个列即字段名</span><br><span class="line">    private String name;</span><br><span class="line">    @Column//没有写，表字段名与这里的字段名相同</span><br><span class="line">    private Integer time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;需要注意的是，这里需要写set/get方法，不然，数据存不进去。这里我用了 <strong>@Data</strong> 注解，所以，就不需要写了。注释写的很清楚了，就不一一解释了。</p><p><strong>接着，写Repository</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.repository;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjpa.entity.Hobby;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义接口继承JpaRepository，就会crud及分页等基本功能</span><br><span class="line"> */</span><br><span class="line">//指定的泛型&lt;操作的实体类，主键的类型&gt;</span><br><span class="line">public interface HobbyRepository extends JpaRepository&lt;Hobby, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>再然后，就是Controller，跟之前写的一样</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjpa.entity.Hobby;</span><br><span class="line">import com.haichenyi.springbootjpa.repository.HobbyRepository;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HobbyController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    HobbyRepository hobbyRepository;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hobby/&#123;id&#125;&quot;)</span><br><span class="line">    public Hobby getHobbyInfo(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">        Optional&lt;Hobby&gt; hobbyOptional = hobbyRepository.findById(id);</span><br><span class="line">        return hobbyOptional.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/save&quot;)</span><br><span class="line">    public Hobby saveHobby(Hobby hobby) &#123;</span><br><span class="line">        System.out.println(hobby);</span><br><span class="line">        return hobbyRepository.save(hobby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>最后，就只配置了</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样写完就行了。就这四步：</p><ol><li>映射表</li><li>Repository接口</li><li>Controller</li><li>配置文件</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是-Spring-Data&quot;&gt;&lt;a href=&quot;#什么是-Spring-Data&quot; class=&quot;headerlink&quot; title=&quot;什么是 Spring Data&quot;&gt;&lt;/a&gt;什么是 Spring Data&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Spring Data 是 Spring Boot 底层默认进行数据访问的技术 , 为了简化构建基于 Spring 框架应用的数据访问技术，包&lt;br&gt;括非关系数据库、Map-Reduce 框架、云数据服务等；另外也包含对关系数据库的访问支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—MyBatis（十一）</title>
    <link href="http://haichenyi.com/2019/09/07/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94MyBatis%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/07/SpringBoot系列—MyBatis（十一）/</id>
    <published>2019-09-07T10:56:22.000Z</published>
    <updated>2019-09-18T08:48:38.542Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇，Druid是用于处理数据库连接池与后台监控。</p><a id="more"></a><p>&emsp;&emsp;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。——百度百科</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;MyBatis添加依赖跟SpringBoot的其他启动器不一样，MyBatis需要写版本号，因为，SpringBoot并没有MyBatis的启动器。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="注解的方式"><a href="#注解的方式" class="headerlink" title="注解的方式"></a>注解的方式</h4><p>&emsp;&emsp;先看一下项目结构：</p><p><img src="/uploads/article/2019-09-07/项目结构图.png" alt="项目结构图.png"></p><p>&emsp;&emsp;首先，我们先在连接的数据库里面创建表，添加几条数据。</p><p>&emsp;&emsp;然后，创建pojo类User，对应我的表</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    public Long UserId;</span><br><span class="line">    public String Username;</span><br><span class="line">    public String password;</span><br><span class="line">    public String nickName;</span><br><span class="line">    public String headImg;</span><br><span class="line">    public Integer age;</span><br><span class="line">    public Integer sex;</span><br><span class="line">    public String address;</span><br><span class="line">    public String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;接着，创建mapper接口</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.mapper;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    @Select(&quot;select * from userinfo&quot;)</span><br><span class="line">    List&lt;User&gt; getUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是一个普通的接口，用 <strong>@Mapper</strong> 标识了。然后写了一个获取用户信息的方法。 <strong>@Select</strong> 里面是sql语句。</p><p>&emsp;&emsp;用 <strong>@Mapper</strong> 标识的接口，在运行的过程中，会帮我们生成实现类，到时候，我们直接通过这个接口的引用调用这个方法即可。我们也可以在入口的位置用 <strong>@MapperScan</strong> 标识包名，应用启动的时候，会给这个包下面的所有接口都生成实现类。如下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc;</span><br><span class="line"></span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@MapperScan(&quot;com.haichenyi.springbootjdbc.mapper&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootJdbcApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootJdbcApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;最后，就是我们的controller层了。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.mapper.UserMapper;</span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/getUserInfo&quot;)</span><br><span class="line">    public List&lt;User&gt; getUserInfo() &#123;</span><br><span class="line">        return userMapper.getUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样，我们就可以通过 <a href="http://localhost:8080/getUserInfo" target="_blank" rel="noopener">http://localhost:8080/getUserInfo</a> 读到数据库中的数据了</p><p>&emsp;&emsp;只这样，我们读到的数据，如果表字段与pojo类的字段不一一对应，我们可能读到的数据为空，所以，我们要开启驼峰命名，开启之后MyBatis会帮我们一一对应好。怎么开启呢？就在我们前面的JdbcConfig中添加如下方法即可。就跟我们前面一篇Druid添加配置类似。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * MyBatis自定义配置</span><br><span class="line">  *</span><br><span class="line">  * @return ConfigurationCustomizer</span><br><span class="line">  */</span><br><span class="line"> @Bean</span><br><span class="line"> public ConfigurationCustomizer configurationCustomizer() &#123;</span><br><span class="line">     return configuration -&gt; &#123;</span><br><span class="line">         //开启驼峰命名</span><br><span class="line">         configuration.setMapUnderscoreToCamelCase(true);</span><br><span class="line">         //开启二级缓存</span><br><span class="line">         configuration.setCacheEnabled(true);</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样就可以了。</p><h4 id="xml的方式"><a href="#xml的方式" class="headerlink" title="xml的方式"></a>xml的方式</h4><p>&emsp;&emsp;前面和后面都是一样的，就是中间那不创建mapper接口不一样。xml中怎么创建mapper呢？</p><p>&emsp;&emsp;首先，还是创建一个正常的接口，定义方法。如下：注释写的很清楚了。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.mapper;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">//这里如果没有@Mapper注解，那就在启动类添加@MapperScan注解，上面已经说过怎么添加了。两种方式都可以，标记mapper的接口还是需要的</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">//这里的sql语句就不需要了，sql语句在xml里面配置。</span><br><span class="line">//    @Select(&quot;select * from userinfo&quot;)</span><br><span class="line">    List&lt;User&gt; getUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后，添加两个xml，一个是config，一个是写sql语句的。路径需要注意，先在resources目录下创建一个mybatis目录，在mybatis目录下创建mybatis-config.xml，在mybatis目录下创建mapper目录，然后在mapper目录下创建你的mapper.xml文件，如下：</p><p>&emsp;&emsp;这个是写mybatis配置文件的，名字我写的是：mybatis-config.xml，这个路径<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;!--开启驼峰命名--&gt;</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;然后就是创建mapper.xml，这里，我们以UserMapper.xml为例：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--namespace要是你前面创建mapper接口的全路径，这样才能对应--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.haichenyi.springbootjdbc.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;!--id：是你前面接口里面创建的方法名--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    resultType：这里的返回类型就是你接口读取数据对应的bean类，不管你需要的是集合，还是单个对象，这里都是你bean类，</span><br><span class="line">    如果你读取的是多条数据，它会自动帮你封装成list，拿到这个list，你再去做你其他的处理</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;getUserInfo&quot; resultType=&quot;com.haichenyi.springbootjdbc.pojo.User&quot;&gt;</span><br><span class="line">        select * from userinfo</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;注释写的很清楚了。</p><p>&emsp;&emsp;再就是配置这个两个xml路径了，你需要在你的全局配置文件中配置好，指定对应的路径：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  #核心配置文件路径</span><br><span class="line">  config-location: classpath:mybatis/mybatis-config.xml</span><br><span class="line">  #映射配置文件路径</span><br><span class="line">  mapper-locations: classpath:mybatis/mapper/*.xml</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;为啥非要创建一个mapper目录，再创建mapper文件呢？就是这里好指定。mapper文件肯定不止一个，难道你要一个一个的配置吗？这样写只用指定一个就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇，Druid是用于处理数据库连接池与后台监控。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Druid（十）</title>
    <link href="http://haichenyi.com/2019/09/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Druid%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/05/SpringBoot系列—Druid（十）/</id>
    <published>2019-09-05T08:05:30.000Z</published>
    <updated>2019-09-18T09:10:27.945Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;一个企业项目中最重要的部分那就是数据库了，对数据库的连接，读写是重中之重。在SpringBoot中数据库怎么连接呢？</p><a id="more"></a><h3 id="数据库的连接"><a href="#数据库的连接" class="headerlink" title="数据库的连接"></a>数据库的连接</h3><p>&emsp;&emsp;这里以MySql为例，还不会用MySql数据库的童鞋，可以看我之前的博客，<a href="https://blog.csdn.net/qq_27634797/article/category/8050256" target="_blank" rel="noopener">数据库相关</a>。</p><p>&emsp;&emsp; <strong>第一步，</strong> 我们首先在pom.xml中添加jdbc相关的启动器。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--jdbc启动器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--mysql驱动包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; <strong>第二步，</strong> 在配置文件中配置连接数据库的信息：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    #连接数据库的账号</span><br><span class="line">    username: root</span><br><span class="line">    #连接数据库的密码</span><br><span class="line">    password: 123456</span><br><span class="line">    #连接数据库的url</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    #连接数据库的驱动类</span><br><span class="line">    #mysql8之前用的是：com.mysql.jdbc.Driver。</span><br><span class="line">    #mysql8之后用的是：com.mysql.cj.jdbc.Driver</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 添加如上信息，就基本上完成了。测试一下连接就可以了。在我们的测试类中添加如下代码，看看打印的数据即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringBootJdbcApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() throws SQLException &#123;</span><br><span class="line">        System.out.println(&quot;dataSource: &quot; + dataSource.getClass());</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(&quot;connection: &quot; + connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 我们这里是测试数据库是否连接成功，我们才获取的这个连接，打印出来，我们项目里面实际操作数据库的时候，不需要我们获取这个连接，然后通过这个连接再去操作数据库。这是不需要，MyBatis通过Mapping注解直接操作数据库，我们只用写sql语句就可以了。</p><h3 id="Druid连接数据库"><a href="#Druid连接数据库" class="headerlink" title="Druid连接数据库"></a>Druid连接数据库</h3><p>&emsp;&emsp; DRUID是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是目前最好的连接池。</p><p>&emsp;&emsp; <strong>上面的配置继续保留。</strong></p><p>&emsp;&emsp; <strong>第一步：</strong> 我们在pom.xml里面添加druid的依赖：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.20&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; <strong>第二步：</strong> 在yml文件中添加如下代码：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  # 数据库访问配置</span><br><span class="line">  datasource:</span><br><span class="line">    #账号</span><br><span class="line">    username: root</span><br><span class="line">    #密码</span><br><span class="line">    password: 123456</span><br><span class="line">    #连接的url</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    #驱动类</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # 主数据源，默认的</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">    # 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line">    # 初始化大小，最小，最大</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    # 配置获取连接等待超时的时间</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    # 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 25</span><br><span class="line">    # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">    filters: stat,wall,logback</span><br><span class="line">    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="line">    # 合并多个DruidDataSource的监控数据</span><br><span class="line">    useGlobalDataSourceStat: true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 这样，就可以了。继续运行刚才的测试方法，你会发现，打印数据里面数据源已经变成了DruidDataSource。</p><p>&emsp;&emsp; 你如果是debug运行的，并且，你的断点打在connection那里，你会发现，我们yml文件中的补充配置，没起作用，是为什么呢？</p><p>&emsp;&emsp; 我们按住CTRL，鼠标左键点补充配置里面的任意一个变量，都点不动，我们点上面的type，url等等，都能点，我们点过去看，我们会发现跳到了 <strong>DataSourceProperties</strong> 。这个类，顾名思义这是数据源配置文件类。我们大致看一下这个类的代码：</p><p><img src="/uploads/article/2019-09-05/DataSourceProperties类.png" alt="DataSourceProperties类.png"></p><p>&emsp;&emsp; 用红色框框，框出来的地方是不是很眼熟？</p><p>&emsp;&emsp; 首先，我们先看注解 <strong>@ConfigurationProperties，</strong> 这个注解就是表示这个类是配置类，然后，我们看括号里面的参数 <strong>prefix，</strong> 顾名思义：前缀，前置代码。</p><p><img src="/uploads/article/2019-09-05/yml文件.png" alt="yml文件.png"></p><p>&emsp;&emsp; 如上图，上面的红色框框的内容，就由prefix决定，下面红色框框的内容，就由这个类的变量决定。我们上面的补充设置不起作用，就是因为这个配置文件里面没有这些变量，SpringBoot识别不了，所以，不起作用。SpringBoot不是万能的，它配置了的东西，可以识别，没有配置的，识别不了。</p><p>&emsp;&emsp; 怎么样让上面的补充配置起作用呢？有多种方式：</p><p>&emsp;&emsp; <strong>第一种方式如下：</strong> 简单粗暴，添加一个配置类即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource()&#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 这个方式就相当于，把我们上面的这个 <strong>DataSourceProperties</strong>配置类，换成了 <strong>DruidDataSource</strong>类。</p><p>&emsp;&emsp; <strong>第二种方式如下：</strong> 比较麻烦，也不算特别麻烦：说白了就是加载局部配置。</p><p>&emsp;&emsp;首先，在resources目录下，新建一个jdbc.properties文件</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#账号</span><br><span class="line">druid.datasource.username=root</span><br><span class="line">#密码</span><br><span class="line">druid.datasource.password=123456</span><br><span class="line">#连接的url</span><br><span class="line">druid.datasource.url=jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">#驱动类</span><br><span class="line">druid.datasource.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line"># 主数据源，默认的</span><br><span class="line"># druid.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"># 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line"># 初始化大小，最小，最大</span><br><span class="line">druid.datasource.initialSize=5</span><br><span class="line">druid.datasource.minIdle=5</span><br><span class="line">druid.datasource.maxActive=20</span><br><span class="line"># 配置获取连接等待超时的时间</span><br><span class="line">druid.datasource.maxWait=60000</span><br><span class="line"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">druid.datasource.timeBetweenEvictionRunsMillis=60000</span><br><span class="line"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">druid.datasource.minEvictableIdleTimeMillis=300000</span><br><span class="line">druid.datasource.validationQuery=SELECT 1 FROM DUAL</span><br><span class="line">druid.datasource.testWhileIdle=true</span><br><span class="line">druid.datasource.testOnBorrow=false</span><br><span class="line">druid.datasource.testOnReturn=false</span><br><span class="line"># 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">druid.datasource.poolPreparedStatements=true</span><br><span class="line">druid.datasource.maxPoolPreparedStatementPerConnectionSize=25</span><br><span class="line"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">druid.datasource.filters=stat,wall,logback</span><br><span class="line"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">druid.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="line"># 合并多个DruidDataSource的监控数据</span><br><span class="line">druid.datasource.useGlobalDataSourceStat=true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是把我们刚才在全局配置中配置的信息，在专门的jdbc的配置文件中配置一遍。然后，修改我们的JdbcConfig类。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@PropertySource(value = &quot;classpath:config/jdbc.properties&quot;, ignoreResourceNotFound = true)</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.driverClassName&#125;&quot;)</span><br><span class="line">    private String driverClassName;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.initialSize&#125;&quot;)</span><br><span class="line">    private Integer initialSize;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.minIdle&#125;&quot;)</span><br><span class="line">    private Integer minIdle;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxActive&#125;&quot;)</span><br><span class="line">    private Integer maxActive;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxWait&#125;&quot;)</span><br><span class="line">    private Long maxWait;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.timeBetweenEvictionRunsMillis&#125;&quot;)</span><br><span class="line">    private Long timeBetweenEvictionRunsMillis;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.minEvictableIdleTimeMillis&#125;&quot;)</span><br><span class="line">    private Long minEvictableIdleTimeMillis;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.validationQuery&#125;&quot;)</span><br><span class="line">    private String validationQuery;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testWhileIdle&#125;&quot;)</span><br><span class="line">    private Boolean testWhileIdle;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testOnBorrow&#125;&quot;)</span><br><span class="line">    private Boolean testOnBorrow;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testOnReturn&#125;&quot;)</span><br><span class="line">    private Boolean testOnReturn;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxPoolPreparedStatementPerConnectionSize&#125;&quot;)</span><br><span class="line">    private Integer maxPoolPreparedStatementPerConnectionSize;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.poolPreparedStatements&#125;&quot;)</span><br><span class="line">    private Boolean poolPreparedStatements;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.filters&#125;&quot;)</span><br><span class="line">    private String filters;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.connectionProperties&#125;&quot;)</span><br><span class="line">    private String connectionProperties;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.useGlobalDataSourceStat&#125;&quot;)</span><br><span class="line">    private Boolean useGlobalDataSourceStat;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() throws SQLException &#123;</span><br><span class="line">        DruidDataSource druidDataSource = new DruidDataSource();</span><br><span class="line">        druidDataSource.setUsername(username);</span><br><span class="line">        druidDataSource.setPassword(password);</span><br><span class="line">        druidDataSource.setUrl(url);</span><br><span class="line">        druidDataSource.setDriverClassName(driverClassName);</span><br><span class="line">        druidDataSource.setInitialSize(initialSize);</span><br><span class="line">        druidDataSource.setMinIdle(minIdle);</span><br><span class="line">        druidDataSource.setMaxActive(maxActive);</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);</span><br><span class="line">        druidDataSource.setValidationQuery(validationQuery);</span><br><span class="line">        druidDataSource.setTestOnBorrow(testOnBorrow);</span><br><span class="line">        druidDataSource.setTestOnReturn(testOnReturn);</span><br><span class="line">        druidDataSource.setTestWhileIdle(testWhileIdle);</span><br><span class="line">        druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);</span><br><span class="line">        druidDataSource.setPoolPreparedStatements(poolPreparedStatements);</span><br><span class="line">        druidDataSource.setFilters(filters);</span><br><span class="line">        druidDataSource.setConnectionProperties(connectionProperties);</span><br><span class="line">        druidDataSource.setUseGlobalDataSourceStat(useGlobalDataSourceStat);</span><br><span class="line">        return druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是加载配置文件，然后在DataSource里面赋值。这样，就可以了。</p><h3 id="Druid后台监控"><a href="#Druid后台监控" class="headerlink" title="Druid后台监控"></a>Druid后台监控</h3><p>&emsp;&emsp;之所以用Druid连接池，还有很大一部分原因就是它的监控功能。它能很好的监控DB连接池和SQL语句的执行情况。在上面的JdbcConfig类中添加如下两个方法即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 配置Druid监控</span><br><span class="line"> *</span><br><span class="line"> * @return StatViewServlet</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean servletRegistrationBean() &#123;</span><br><span class="line">    ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //访问的用户名密码</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_USERNAME, &quot;haichenyi&quot;);</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_PASSWORD, &quot;123456&quot;);</span><br><span class="line">    //允许访问的ip，默认是所有ip</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_ALLOW, &quot;&quot;);</span><br><span class="line">    //禁止访问的ip</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_DENY, &quot;192.168.1.1&quot;);</span><br><span class="line">    bean.setInitParameters(map);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 配置一个监控的filter</span><br><span class="line"> *</span><br><span class="line"> * @return WebStatFilter</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean filterRegistrationBean() &#123;</span><br><span class="line">    FilterRegistrationBean&lt;WebStatFilter&gt; bean = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">    bean.setFilter(new WebStatFilter());</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //移除这些监听</span><br><span class="line">    map.put(WebStatFilter.PARAM_NAME_EXCLUSIONS, &quot;*.js,*.css,/druid/*,*.gif,*.jpg,*.png&quot;);</span><br><span class="line">    bean.setInitParameters(map);</span><br><span class="line">    //拦截所有请求，全部都要走druid监听</span><br><span class="line">    bean.setUrlPatterns(Collections.singletonList(&quot;/*&quot;));</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;注释写的很清楚了，控制台怎么访问呢？ <strong><a href="http://localhost:8080/druid" target="_blank" rel="noopener">http://localhost:8080/druid</a></strong>。访问控制台</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;一个企业项目中最重要的部分那就是数据库了，对数据库的连接，读写是重中之重。在SpringBoot中数据库怎么连接呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—自定义拦截器（九）</title>
    <link href="http://haichenyi.com/2019/09/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/05/SpringBoot系列—自定义拦截器（九）/</id>
    <published>2019-09-05T08:05:12.000Z</published>
    <updated>2019-09-05T08:07:12.816Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;拦截器拦截请求做额外的处理。</p><a id="more"></a><p><strong>举个栗子：登录拦截器，拦截所有的请求，必须登录之后才能访问。</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.interceptors;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 登录拦截器</span><br><span class="line"> */</span><br><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line">        if (user != null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(&quot;msg&quot;, &quot;您还没有登录，请先登录！&quot;);</span><br><span class="line">        request.getRequestDispatcher(&quot;/index.html&quot;).forward(request, response);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;新建LoginInterceptor实现HandlerInterceptor接口。这个接口有三个方法，<strong>pre，post，after，</strong>  看这个名字就可以想到这三个方法是怎么调用的，发送请求前，发送过程中，发送请求成功之后，所以，根据自己的需求，实现对应的方法即可。</p><p>&emsp;&emsp;我这里是登录拦截器，所以，在发送请求之前就要拦截，走自己的逻辑，如果，没有登陆过，就跳转登录界面，所以，我这里就实现了发送请求之前的回调，即preHandle方法。</p><p>&emsp;&emsp;然后，在你的SpringMvcConfiguration里面加上拦截器即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.config;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootbill.component.MyLocalResolver;</span><br><span class="line">import com.haichenyi.springbootbill.interceptors.LoginInterceptor;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.LocaleResolver;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class MySpringMvcConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebMvcConfigurer webMvcConfigurer() &#123;</span><br><span class="line">        return new WebMvcConfigurer() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">                registry.addViewController(&quot;/&quot;).setViewName(&quot;main/login&quot;);</span><br><span class="line">                registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;main/login&quot;);</span><br><span class="line">                registry.addViewController(&quot;/main/index.html&quot;).setViewName(&quot;main/index&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">                registry.addInterceptor(new LoginInterceptor())</span><br><span class="line">                        .addPathPatterns(&quot;/**&quot;)</span><br><span class="line">                        .excludePathPatterns(&quot;/&quot;, &quot;/index.html&quot;, &quot;/login&quot;)</span><br><span class="line">                        .excludePathPatterns(&quot;/css/*&quot;,&quot;/img/*&quot;,&quot;/images/*&quot;,&quot;/js/*&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LocaleResolver localeResolver() &#123;</span><br><span class="line">        return new MyLocalResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;实现addInterceptors方法，添加拦截器，然后添加了  <strong>addPathPatterns</strong> 拦截所有带这个参数的请求。接着，又添加了 <strong>excludePathPatterns</strong> 不拦截所有带这个参数的请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;拦截器拦截请求做额外的处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—国际化（八）</title>
    <link href="http://haichenyi.com/2019/09/02/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/02/SpringBoot系列—国际化（八）/</id>
    <published>2019-09-02T08:14:09.000Z</published>
    <updated>2019-09-18T09:10:15.500Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;所谓的国际化就是语言切换。中文切换到其他语种。</p><p>&emsp;&emsp;国际化的信息，这些都是需要开发人员在配置类中配置好的。SpringBoot会自动加载这些配置类。</p><a id="more"></a><p>举个栗子：以登录界面为例，我们的登录界面输入账号、密码框的左边，会有这两个提示，我们就自动修改这两个提示。</p><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>&emsp;&emsp;首先，你要在你的resources目录下面新建i18n目录，当然，不是必须的，可以不创建，直接创建文件。之所以创建这个目录，只是便于管理。</p><p>&emsp;&emsp;然后，在i18n目录下面创建配置文件，操作如下：</p><p><img src="/uploads/article/2019-09-02/创建配置文件1.png" alt="创建配置文件1.png"></p><p>&emsp;&emsp;在i18n的目录下面，新建一个Resources Bundle类型的文件，名字叫login</p><p><img src="/uploads/article/2019-09-02/创建配置文件2.png" alt="创建配置文件2.png"></p><p><img src="/uploads/article/2019-09-02/创建配置文件3.png" alt="创建配置文件3.png"></p><p>&emsp;&emsp;点击+号，创建中文，英文两种语言的配置文件。中文叫 <strong>zh_CN</strong>，英文叫 <strong>en_US</strong>，这两种类型是写死的。</p><p><img src="/uploads/article/2019-09-02/创建配置文件4.png" alt="创建配置文件4.png"></p><p><img src="/uploads/article/2019-09-02/创建配置文件5.png" alt="创建配置文件5.png"></p><p><img src="/uploads/article/2019-09-02/创建配置文件6.png" alt="创建配置文件6.png"></p><p>&emsp;&emsp;根据如上操作，分别创建key为login.username，login.password，并且分别创建好对应的内容。这个key，页面会用到。</p><p>PS：不要忘记了，在全局配置文件中配置好，<strong>spring.messages.basename=i18n.login</strong>，这里现在是只有一个登陆页面需要国际化，如果有多个页面需要，比方说注册页面，就在后面添加。如：spring.messages.basename=i18n.login,i19n.register这样的方式，中间用逗号隔开即可。</p><h3 id="修改页面显示内容"><a href="#修改页面显示内容" class="headerlink" title="修改页面显示内容"></a>修改页面显示内容</h3><p>&emsp;&emsp;按照上面的步骤，创建好了之后，在你页面需要国际化的view，分别按如下的方式获取值：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--th:text=&quot;#&#123;上面命名的key&#125;&quot;--&gt;</span><br><span class="line">&lt;div class=&quot;inputbox&quot;&gt;</span><br><span class="line">                &lt;label for=&quot;user&quot; th:text=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/label&gt;</span><br><span class="line">                &lt;input id=&quot;user&quot; type=&quot;text&quot; name=&quot;username&quot; required/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;inputbox&quot;&gt;</span><br><span class="line">                &lt;label for=&quot;mima&quot; th:text=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/label&gt;</span><br><span class="line">                &lt;input id=&quot;mima&quot; type=&quot;password&quot; name=&quot;password&quot; required/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br></pre></td></tr></table></figure></div><h3 id="自定义区域解析器"><a href="#自定义区域解析器" class="headerlink" title="自定义区域解析器"></a>自定义区域解析器</h3><p>&emsp;&emsp;区域解析器LocaleResolver，按如下的方式实现即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.component;</span><br><span class="line"></span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import org.springframework.web.servlet.LocaleResolver;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义区域解析器</span><br><span class="line"> */</span><br><span class="line">public class MyLocalResolver implements LocaleResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123;</span><br><span class="line">        String l = httpServletRequest.getParameter(&quot;l&quot;);</span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        if (!StringUtils.isEmpty(l)) &#123;</span><br><span class="line">            String[] s = l.split(&quot;_&quot;);</span><br><span class="line">            locale = new Locale(s[0], s[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;最后，在你对应的超链接的地方传 <strong>zh_CN</strong> 和 <strong>en_US</strong> 即可实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;所谓的国际化就是语言切换。中文切换到其他语种。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;国际化的信息，这些都是需要开发人员在配置类中配置好的。SpringBoot会自动加载这些配置类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—热部署与SpringMVC扩展功能（七）</title>
    <link href="http://haichenyi.com/2019/08/30/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E7%83%AD%E9%83%A8%E7%BD%B2%E4%B8%8ESpringMVC%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/30/SpringBoot系列—热部署与SpringMVC扩展功能（七）/</id>
    <published>2019-08-30T02:43:40.000Z</published>
    <updated>2019-08-30T02:44:40.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><p>&emsp;&emsp;默认情况下，在开发中我们修改一个项目文件后，想看到效果不得不重启应用，这会导致浪费大量时间，我们希望不重启应用的情况下，程序可以自动部署（热部署）。</p><a id="more"></a><p>&emsp;&emsp;<strong>第一步：禁用缓存</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#开发环境下关闭thymeleaf模板缓存，thymeleaf默认是开启状态。记得发布的时候要打开</span><br><span class="line">spring.thymeleaf.cache=false</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;<strong>第二步：添加热部署依赖</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--热部署--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;<strong>第三步：手动编译文件</strong></p><p>&emsp;&emsp;IDEA中，修改文件后都是自动保存的，并不会手动编译，所以，需要手动编译一下。Ctrl + F9 （推荐使用）或 Build -&gt; Build Project。</p><h3 id="SpringMVC-扩展功能"><a href="#SpringMVC-扩展功能" class="headerlink" title="SpringMVC 扩展功能"></a>SpringMVC 扩展功能</h3><p>举个栗子：我要访问前面都是在controller里面，写方法，方法里面可以写逻辑，跳转某一个页面。我现在不需要写逻辑，就直接跳转就行了。我可以这样写。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootwebthymeleaf.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        registry.addViewController(&quot;/success&quot;).setViewName(&quot;success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>新建一个类，继承WebMvcConfigurer，并用@Configuration标识</li><li>实现addViewControllers方法，里面registry里面像上面添加就行了，前面传链接名字，后面传视图名字即可。</li></ul><p>&emsp;&emsp;这只是添加控制层，还有其他的功能。可以看WebMvcConfigurer接口的方法。需要什么功能，实现什么方法就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;热部署&quot;&gt;&lt;a href=&quot;#热部署&quot; class=&quot;headerlink&quot; title=&quot;热部署&quot;&gt;&lt;/a&gt;热部署&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;默认情况下，在开发中我们修改一个项目文件后，想看到效果不得不重启应用，这会导致浪费大量时间，我们希望不重启应用的情况下，程序可以自动部署（热部署）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Thymeleaf（六）</title>
    <link href="http://haichenyi.com/2019/08/29/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Thymeleaf%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/29/SpringBoot系列—Thymeleaf（六）/</id>
    <published>2019-08-29T03:07:39.000Z</published>
    <updated>2019-09-18T09:10:19.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引用公共片段-th-fragment-th-replace-th-insert"><a href="#引用公共片段-th-fragment-th-replace-th-insert" class="headerlink" title="引用公共片段 th:fragment,th:replace,th:insert"></a>引用公共片段 th:fragment,th:replace,th:insert</h3><p>&emsp;&emsp;很多页面有很多相同的内容，比方说header和foot，这样的内容就需要公共片段引用了，修改一个地方就全部都改了。类似于android里面提取公共方法一样的道理。</p><a id="more"></a><p>方式如下图：</p><p><img src="/uploads/article/2019-08-29/公共片段1.png" alt="公共片段1.png"></p><p><img src="/uploads/article/2019-08-29/公共片段2.png" alt="公共片段2.png"></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;公共片段&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--通过th:fragment申明公共片段--&gt;</span><br><span class="line">&lt;div th:fragment=&quot;header_common&quot;&gt;这里是公共片段的内容&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--通过id申明公共片段--&gt;</span><br><span class="line">&lt;div id=&quot;header_common_id&quot;&gt;这里是公共片段的内容&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--引入公共片段--&gt;</span><br><span class="line">&lt;div th:replace=&quot;header :: header_common&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div th:replace=&quot;header :: #header_common_id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></div><p>总共分为两步：</p><ol><li>创建header.html的文件，里面定义公共片段的内容，用th:fragment标明，值为header_common</li><li>在你需要用到这个公共部分的位置，通过th:fragment申明的片段用th:relpace引入，值为 文件名 空格 双冒号 空格 th:fragment的值。也就是这里的 <strong>header :: header_common</strong></li><li>通过id申明的片段用th:replace引入，值为 文件名 空格 双冒号 空格 # th:fragment的值。也就是这里的 <strong>header :: #header_common_id</strong></li></ol><p><strong><em>th:insert 和 th:replace的区别</em></strong></p><p>&emsp;&emsp;th:insert和th:replace都可以引入片段，用的方式是一样的，两者的区别在于 th:insert： 保留引入时使用的标签 th:replace：不保留引入时使用的标签, 将声明片段直接覆盖当前引用标签 </p><h3 id="迭代器-th-each"><a href="#迭代器-th-each" class="headerlink" title="迭代器 th:each"></a>迭代器 th:each</h3><p>&emsp;&emsp; 首先，创建一个实体类User。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootwebthymeleaf.pojo;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private Integer age;</span><br><span class="line">    //1:女，2:男</span><br><span class="line">    private Integer sex;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String username, Integer age, Integer sex) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;其次，在controller创建一个获取User的方法。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/userInfo&quot;)</span><br><span class="line">public String getUserInfo(Model model) &#123;</span><br><span class="line">    List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">    userList.add(new User(&quot;小雪&quot;, 18, 1));</span><br><span class="line">    userList.add(new User(&quot;小红&quot;, 18, 1));</span><br><span class="line">    userList.add(new User(&quot;小东&quot;, 18, 2));</span><br><span class="line">    model.addAttribute(&quot;userList&quot;, userList);</span><br><span class="line">    return &quot;userInfo&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里，我用的model返回的数据，添加了一个属性以”userList”为键。页面直接获取这个键，就能拿到对应的值。之后返回userInfo页面。</p><p>&emsp;&emsp;最后页面的使用，如下，创建userInfo.html专门使用这个：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;用户信息&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;性别&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr th:each=&quot;user:$&#123;userList&#125;&quot;&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.sex==1?&apos;女&apos;:&apos;男&apos;&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li th:each=&quot;user:$&#123;userList&#125;&quot; th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    user : 第1个值,代表每次迭代出对象,名字任意取</span><br><span class="line">    iterStat : 第2个值,代表每次迭代器内置对象, 名字任意取, 并有如下属性:</span><br><span class="line">        index : 当前迭代下标 0 开始</span><br><span class="line">        count : 当前迭代下标 1 开始</span><br><span class="line">        size : 获取总记录数</span><br><span class="line">        current : 当前迭代出的对象</span><br><span class="line">        even/odd : 当前迭代是偶数还是奇数 (1开始算,返回布尔值)</span><br><span class="line">        first : 当前是否为第一个元素</span><br><span class="line">        last : 当前是否为最后一个元素</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;tr th:each=&quot;user,iterStat:$&#123;userList&#125;&quot;&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.sex==1?&apos;女&apos;:&apos;男&apos;&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.index&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.count&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.size&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.current&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.even&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.first&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.last&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;注意的地方就是：</p><ul><li><strong>th:each=”user:${userList}”</strong>，这里可以参考java里面的foreach循环，冒号前面是当前循环的变量(冒号前面可以有两个值)，冒号后面是集合。这个集合怎么获取到的？就是通过userList这个键。第二步存的。</li><li>拿到这个集合中的每一个变量值了，用就很简单了。</li></ul><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3 th:if=&quot;not $&#123;#lists.isEmpty(userList)&#125;&quot;&gt;th:if判断,如果此文字显示说明有值&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3 th:unless=&quot;$&#123;#lists.isEmpty(userList)&#125;&quot;&gt;th:unless判断,如果此文字显示说明有值&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;div th:switch=&quot;$&#123;flag&#125;&quot;&gt;</span><br><span class="line">        &lt;p th:case=&quot;1&quot; th:text=&quot;女&quot;&gt;&lt;/p&gt;</span><br><span class="line">        &lt;p th:case=&quot;2&quot; th:text=&quot;男&quot;&gt;&lt;/p&gt;</span><br><span class="line">        &lt;!--上面两条都不生效，则下面th:case=&quot;*&quot;生效，类似于default--&gt;</span><br><span class="line">        &lt;p th:case=&quot;*&quot; th:text=&quot;未知&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引用公共片段-th-fragment-th-replace-th-insert&quot;&gt;&lt;a href=&quot;#引用公共片段-th-fragment-th-replace-th-insert&quot; class=&quot;headerlink&quot; title=&quot;引用公共片段 th:fragment,th:replace,th:insert&quot;&gt;&lt;/a&gt;引用公共片段 th:fragment,th:replace,th:insert&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;很多页面有很多相同的内容，比方说header和foot，这样的内容就需要公共片段引用了，修改一个地方就全部都改了。类似于android里面提取公共方法一样的道理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Thymeleaf（五）</title>
    <link href="http://haichenyi.com/2019/08/27/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Thymeleaf%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/27/SpringBoot系列—Thymeleaf（五）/</id>
    <published>2019-08-27T03:23:20.000Z</published>
    <updated>2019-09-18T09:10:18.413Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;SpringBoot官方不推荐使用JSP，因为内嵌Tomcat，Jetty容器不支持以jar的方式运行JSP。SpringBoot中提供了大量模板引擎，包含Freemarker，Mastache，Thymeleaf等。而SpringBoot官方推荐使用Thymeleaf作为模板引擎，因为Thymeleaf提供了完美的SpringMVC的支持。</p><a id="more"></a><h3 id="添加启动器"><a href="#添加启动器" class="headerlink" title="添加启动器"></a>添加启动器</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- thymeleaf 模板启动器 --&gt; </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><h3 id="添加模板文件"><a href="#添加模板文件" class="headerlink" title="添加模板文件"></a>添加模板文件</h3><h4 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h4><p>&emsp;&emsp; 模板文件，就是我们创建的HTML文件，将创建好的 HTML 页面放到 <strong>classpath:/templates/</strong> 目录下， Thymeleaf 就能自动渲染。就是我们的 <strong>resources/templates/</strong>目录。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>&emsp;&emsp; 自动渲染数据从哪里来呢？跟写APP端的接口差不多，就是少了响应@ResponseBody注解。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootwebthymeleaf.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * APP接口</span><br><span class="line">     * @return 返回一个字符串</span><br><span class="line">     */</span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String sayHello() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回模板文件</span><br><span class="line">     * @return 返回名字叫success的HTML页面</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/hello1&quot;)</span><br><span class="line">    public String sayHello1() &#123;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>项目结构图如下：</p><p><img src="/uploads/article/2019-08-27/项目结构图.png" alt="项目结构图.png"></p><p>&emsp;&emsp; 如上所示，当访问 <strong><a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></strong>的时候，返回的是一个字符串叫hello。当访问<br><strong><a href="http://localhost:8080/hello1" target="_blank" rel="noopener">http://localhost:8080/hello1</a></strong>的时候，他会转到我们上面说的templates目录下的success.html页面。</p><h3 id="thymeleaf语法使用"><a href="#thymeleaf语法使用" class="headerlink" title="thymeleaf语法使用"></a>thymeleaf语法使用</h3><h4 id="HTML中添加命名空间"><a href="#HTML中添加命名空间" class="headerlink" title="HTML中添加命名空间"></a>HTML中添加命名空间</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:th=&quot;http://www.thymeleaf.org&quot;</span><br></pre></td></tr></table></figure></div><h4 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 返回模板文件</span><br><span class="line">     * @return 返回名字叫success的HTML页面</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/hello1&quot;)</span><br><span class="line">    public String sayHello1(Map&lt;String,Object&gt; map) &#123;</span><br><span class="line">        map.put(&quot;name&quot;,&quot;我是海晨忆&quot;);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;还上啊上面的那个方法，添加了一个map参数。这个参数就是返回给success界面的数据存放容器。存放了一个键值对，键是name</p><p>&emsp;&emsp;界面怎么使用呢？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;success模板文件&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;success 模板文件&lt;/p&gt;</span><br><span class="line">&lt;p2 th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/p2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就这样，直接使用这个键即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;SpringBoot官方不推荐使用JSP，因为内嵌Tomcat，Jetty容器不支持以jar的方式运行JSP。SpringBoot中提供了大量模板引擎，包含Freemarker，Mastache，Thymeleaf等。而SpringBoot官方推荐使用Thymeleaf作为模板引擎，因为Thymeleaf提供了完美的SpringMVC的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—全局配置（四）</title>
    <link href="http://haichenyi.com/2019/08/23/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/23/SpringBoot系列—全局配置（四）/</id>
    <published>2019-08-23T07:18:39.000Z</published>
    <updated>2019-09-18T09:10:13.925Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;用IDEA可以直接创建SpringBoot项目，创建Moudle的时候，在选Maven的地方，选择Sping Initializr即可，很简单。前面讲过了IDEA生成Maven项目，并且嵌入SpringBoot，直接创建Spring Boot项目就是IDEA直接帮我们依赖，并且生成Application和properties文件。其它，也没啥大的区别，就不多说了。</p><a id="more"></a><p>&emsp;&emsp;本篇要讲的是SpringBoot的配置文件，分为两种：</p><ul><li>properties</li><li>yml</li></ul><p>&emsp;&emsp;之前，搜SpringBoot的配置文件怎么写的时候，看到网上很多博客都有文件内容，但是有两种写法，就是这两种配置文件的不同写法。</p><p>&emsp;&emsp;举个栗子，我现在要修改服务器启动的端口号，用properties怎么修改呢？很简单：</p><p><img src="/uploads/article/2019-08-23/properties修改端口号.png" alt="properties修改端口号.png"></p><p>&emsp;&emsp;如上图所示，是不是很简单？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;用yml怎么修改呢？也不难：</p><p><img src="/uploads/article/2019-08-23/yml修改端口号.png" alt="yml修改端口号.png"></p><p>&emsp;&emsp;如上图所示：也不难</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 808</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;<strong>看到了上面两个图片，应该也已经发现了，两个配置文件存放位置都在resource目录下面。或者在类路径的”/config”路径下</strong></p><p>&emsp;&emsp;这两种写法要怎么写呢？</p><p><strong>properties：</strong> 等号连接，右边是值</p><p><strong>yml：key:</strong></p><ul><li>value 表示一对键值对（冒号后面必须要有空格）</li><li>使用空格缩进表示层级关系</li><li>左侧缩进的空格数目不重要，只要同一层级的元素左侧对齐即可</li><li>key 与 value 大小写敏感</li></ul><p>PS: yml不管是存map，还是list，都要记得<strong>key后面的冒号一定要跟空格，再写值</strong></p><p>&emsp;&emsp;举个栗子，我们定义一个bean类，在配置文件里面赋值，在项目里面取出来用。比方说：我们项目里面定义一个Userbean类。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.PropertySource;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;user&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String nickname;</span><br><span class="line">    private String password;</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里有几点需要注意：</p><ol><li>这里的bean类，必须要有写set/get方法，不然赋不了值，我这里没写是因为我用的@Data这个注解，它默认帮我们创建了set/get方法</li><li>@ConfigurationProperties注解就是 告诉SpringBoot将配置文件中对应属性的值，映射到这个组件类中,进行一 一绑定，prefix = “user”的作用就是配置文件中的前缀名，哪个前缀与下面的所有属性进行一一映射</li><li>@Component 注解就是将当前组件也就是这个bean类作为SpringBoot中的一个组件，才能使用容器提供的</li></ol><p>然后就是在配置文件中赋值，properties或者是yml，都可以：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">properties中：</span><br><span class="line"></span><br><span class="line"> server.port=8081</span><br><span class="line">user.username=s19734682s</span><br><span class="line">user.age=20</span><br><span class="line">user.password=123456</span><br><span class="line">user.nickname=林汐痕</span><br><span class="line"></span><br><span class="line">yml中：</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8088</span><br><span class="line">  </span><br><span class="line">//这个user就是上面说的配置文件中的前缀名</span><br><span class="line">user:</span><br><span class="line">  nickname: 海晨忆</span><br><span class="line">  username: pk19734682</span><br><span class="line">  password: 123456</span><br><span class="line">  age: 18</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;怎么使用呢？直接在controller中用这个user就可以了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboot.pojo.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class SayController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/say&quot;)</span><br><span class="line">    public String say() &#123;</span><br><span class="line">        return &quot;hello &quot; +user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就这样，请求这个接口就能打印值。</p><p>&emsp;&emsp;还有通过@Value指定值的方式</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class SayController &#123;</span><br><span class="line">    @Value(&quot;$&#123;user.nickname&#125;&quot;)</span><br><span class="line">    private String nickname;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/say&quot;)</span><br><span class="line">    public String say() &#123;</span><br><span class="line">        return &quot;hello &quot; + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="PropertySource-加载局部配置文件"><a href="#PropertySource-加载局部配置文件" class="headerlink" title="@PropertySource 加载局部配置文件"></a>@PropertySource 加载局部配置文件</h3><p>&emsp;&emsp;什么叫加载局部配置文件呢？就是加载指定的配置文件，并不是从properties或者是yml中加载。怎么加载呢？如下图：</p><p><img src="/uploads/article/2019-08-23/局部配置文件.png" alt="局部配置文件.png"></p><p><strong>第一步，</strong> 在resources目录下创建xxx.properties/xxx.yml，这个xxx你自己命名。我这里创建的是user.properties/user.yml。记得语法不要写错了</p><p><strong>第二步，</strong> 在你的组件的地方加上@PropertySource注解。图上有，可以导入多个局部配置，用逗号隔开，每个局部配置的写法就是 <strong>“classpath:文件名”</strong> 之前导入全局的配置的时候加的注解也需要，不能删除。</p><p><strong>第三步，</strong> 之前是怎么使用的，现在还是怎么使用。</p><h3 id="ImportResource加载xml配置文件"><a href="#ImportResource加载xml配置文件" class="headerlink" title="@ImportResource加载xml配置文件"></a>@ImportResource加载xml配置文件</h3><p>&emsp;&emsp;Spring Boot框架并不推荐用xml加载配置文件，这个是Spring加载文件的方式。项目中如果必须要用到xml加载文件，要怎么办呢？</p><p>举个栗子：我要加载一个Service类到项目中。Spring Boot有注解可以直接使用，这里，我们通过xml加载。</p><p><strong>第一步，</strong> 创建一个service。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.service;</span><br><span class="line"></span><br><span class="line">public class UserService &#123;</span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;xml...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>第二步，</strong> 在resources目录下，创建spring config的xml配置文件</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;userService&quot; class=&quot;com.haichenyi.springboot.service.UserService&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;如上，添加了一个bean类，两个属性，id和class。class指向刚才创建的类，id用于获取这个类。</p><p><strong>第三步，</strong> 在我们的引导类中加上 <strong>@ImportResource</strong> 注解</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line">@ImportResource(locations = &quot;classpath:springboot01.xml&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootInitApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootInitApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>第四步，</strong> 通过ApplicationContext的getBean方法获取，传的参数就是在xml中定义的id。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboot.pojo.User;</span><br><span class="line">import com.haichenyi.springboot.service.UserService;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringBootInitApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void textXml() &#123;</span><br><span class="line">        UserService userService = (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="自定义配置类向容器中注入组件-SpringBoot推荐"><a href="#自定义配置类向容器中注入组件-SpringBoot推荐" class="headerlink" title="自定义配置类向容器中注入组件(SpringBoot推荐)"></a>自定义配置类向容器中注入组件(SpringBoot推荐)</h3><p>举个栗子：跟上面xml的例子一样。</p><p><strong>第一步，</strong> 跟上面一样，创建一个service</p><p><strong>第二步，</strong> 创建配置类：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.custom;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboot.service.UserService;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userService2() &#123;</span><br><span class="line">        return new UserService();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>需要注意的地方：</strong></p><ul><li>@Configuration 用于标识当前类是一个配置类，用来表示对应spring配置文件</li><li>@Bean 标识的方法用于向容器注入组件</li><li>方法的返回值就是注入容器中的组件对象</li><li>方法名是这个组件对象的 id值</li></ul><p><strong>第三步，</strong> 就是使用了，跟上面第四步一样。不需要上面的第三步。</p><h3 id="Profile多环境支持"><a href="#Profile多环境支持" class="headerlink" title="Profile多环境支持"></a>Profile多环境支持</h3><p>&emsp;&emsp;profile是Sping用来针对不同的环境要求，提供不同的配置支持。什么不同的环境呢？比方说：开发环境，生产环境。</p><p>&emsp;&emsp;全局 Profile 配置使用的文件名可以是<br>application-{profile}.properties / application-{profile}.yml 。如：application-dev.properties / application-prod.properties</p><p><strong>举个栗子：</strong></p><p>&emsp;&emsp;我们的项目环境分为 开发 （dev）和 生产（prod）环境 ，开发环境下端口号为 8081，<br>生产环境下端口号为8082。</p><h4 id="通过properties文件指定"><a href="#通过properties文件指定" class="headerlink" title="通过properties文件指定"></a>通过properties文件指定</h4><p><img src="/uploads/article/2019-08-23/profile-properties.png" alt="profile-properties.png"></p><p>&emsp;&emsp;如上图，创建了两个文件：application-dev.properties，application-prod.properties，里面内容很简单，就是指定端口号。server.port=8081</p><p>&emsp;&emsp;然后，我们在application.properties文件中指定激活哪一个文件即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//激活application-dev.properties配置</span><br><span class="line">spring.profiles.active=dev</span><br><span class="line"></span><br><span class="line">//激活application-prod.properties配置</span><br><span class="line">spring.profiles.active=prod</span><br></pre></td></tr></table></figure></div><h4 id="通过yml文件指定"><a href="#通过yml文件指定" class="headerlink" title="通过yml文件指定"></a>通过yml文件指定</h4><p>&emsp;&emsp;不用新建文件，直接在application.yml写就可以了。</p><p><strong>PS:需要用三个减号隔开，表示不同的文档块。</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod #激活哪个profile , 当前激活的是 prod 开发环境</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: dev #指定属于哪个环境, dev 环境时使用</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: prod #指定属于哪个环境, prod 环境时使用</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;用IDEA可以直接创建SpringBoot项目，创建Moudle的时候，在选Maven的地方，选择Sping Initializr即可，很简单。前面讲过了IDEA生成Maven项目，并且嵌入SpringBoot，直接创建Spring Boot项目就是IDEA直接帮我们依赖，并且生成Application和properties文件。其它，也没啥大的区别，就不多说了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—@SpringBootApplication源码解析（三）</title>
    <link href="http://haichenyi.com/2019/08/22/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94-SpringBootApplication%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/22/SpringBoot系列—-SpringBootApplication源码解析（三）/</id>
    <published>2019-08-22T08:20:22.000Z</published>
    <updated>2019-09-18T09:10:23.418Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇，内容很少，说了一下SpringBoot的底层是怎么依赖的。这一篇讲一下SpringBoot底层源码是怎么实现的。</p><a id="more"></a><p>&emsp;&emsp;从SpringBoot的入口开始。第一篇的时候说过了，最好把入口文件放在最外层的包下面，至于原因就不多阐述了。</p><p>&emsp;&emsp;说说这个 <strong>@SpringBootApplication</strong>注解的原理,点进去看一下：</p><p>如下图：</p><p><img src="/uploads/article/2019-08-22/springbootapplication注解.png" alt="springbootapplication注解.png"></p><p>主要就是这三个注解：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>&emsp;&emsp;SpringBootConfiguration这个注解是由Configuration注解实现的。</p><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>&emsp;&emsp;从名字上就可以判断出，这个注解是跟SpringBoot配置相关的，<strong>@Configuration</strong>，这个注解是Spring底层的一个注解，之前都是配置xml，SpringBoot推荐我们用配置类来描述配置，配置类是什么呢？就用@Configuration标记的类。</p><p>&emsp;&emsp;Configuration这个注解是由Component注解实现。</p><h5 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h5><p>&emsp;&emsp;这个注解的意义就是，把当前的配置类添加到spring容器中，表示是一个组件。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>&emsp;&emsp;EnableAutoConfiguration这个注解是由<strong>AutoConfigurationPackage</strong>和<strong>@Import({AutoConfigurationImportSelector.class})</strong>注解实现</p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>&emsp;&emsp;这个注解从名字上面看出来是自动配置包，这是什么意思呢？在第一篇我们就说过了入口要放在最外层的包，至于原因，已经讲过了，因为SpringBoot会自动将引导类 <strong>@SpringBootApplication标注的类</strong>所在的包以及下面所有子包里面所有的组件扫描到Spring容器中统一管理。就是这个注解实现的。那么，这个注解是怎么实现的呢？就是通过它的这个 <strong>@Import({Registrar.class})</strong>，下面就是Registrar类的源码了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;</span><br><span class="line">        Registrar() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">            AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">            return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是通过下面这个代码注册进去的。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());</span><br></pre></td></tr></table></figure></div><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p>&emsp;&emsp;这个注解是干什么用的呢？</p><ol><li>它会把项目里面所有需要导入的组件以全类名的方式返回，将这些组件添加到容器中。</li><li>会给容器中注入非常多的自动配置类，就是导入并配置好当前项目中<br>所需要的组件,省去我们手动编写配置去注入组件。</li></ol><p>&emsp;&emsp;怎么实现的呢？打开AutoConfigurationImportSelector类，找到如下代码：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br></pre></td></tr></table></figure></div><p>找到getCandidateConfigurations方法，如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">        return configurations;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>找到loadFactoryNames方法，如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">        String factoryClassName = factoryClass.getName();</span><br><span class="line">        return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>找到loadSpringFactories方法，里面有</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);</span><br></pre></td></tr></table></figure></div><p>这里就是我们的配置，我们这个配置具体是在哪呢？如下图</p><p><img src="/uploads/article/2019-08-22/autoConfigure.png" alt="autoConfigure.png"></p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>&emsp;&emsp;这个注解的主要作用就是，被该注解标识的类会被Spring容器纳入管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇，内容很少，说了一下SpringBoot的底层是怎么依赖的。这一篇讲一下SpringBoot底层源码是怎么实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—底层依赖（二）</title>
    <link href="http://haichenyi.com/2019/08/22/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E5%B1%82%E4%BE%9D%E8%B5%96%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/22/SpringBoot系列—底层依赖（二）/</id>
    <published>2019-08-22T07:01:05.000Z</published>
    <updated>2019-09-18T09:10:16.941Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前面，我们创建了一个Spring Boot的hello world，我们仅仅添加了一个<strong>spring-boot-starter-parent</strong>，它是怎么帮我们实现这个依赖的呢？我们可以点进去看一下<strong>Ctrl+鼠标左键</strong>，如下图：</p><a id="more"></a><p><img src="/uploads/article/2019-08-22/parent的pom文件1.png" alt="parent的pom文件1.png"></p><p><img src="/uploads/article/2019-08-22/parent的pom文件2.png" alt="parent的pom文件2.png"></p><p>&emsp;&emsp;我们发现它，还有一个父级依赖<strong>spring-boot-dependencies</strong>，我们继续点进去看，如下图：</p><p><img src="/uploads/article/2019-08-22/dependencies的pom文件.png" alt="dependencies的pom文件.png"></p><p>&emsp;&emsp;在这个pom文件里面，我们发现了，它定义很多个框架的版本号，这里就是，我们在自己项目里面引入框架不需要加版本号的原因。因为，它帮我们定义好了，它会自动依赖这里定义的版本。spring测试通过的，不会有冲突。</p><p>&emsp;&emsp;我们后面还依赖了一个<strong>spring-boot-starter-web</strong>这个框架，这里分两部分：</p><ul><li>spring-boot-starter：spring boot的场景启动器</li><li>web：web相关的如：Tomcat、springMVC等等</li></ul><p>&emsp;&emsp;我们可以看一下，我们这里的web启动器的内容是什么。如下图：</p><p><img src="/uploads/article/2019-08-22/web场景启动器.png" alt="web场景启动器.png"></p><p>&emsp;&emsp;我们可以看到，它帮我们依赖了很多框架，这就是为什么，我们只添加了一个依赖，我们的项目就依赖的很多个框架的原因，这些都是spring boot帮我们依赖好的。所以，没什么特殊的，一切都是从最简单的开始的。</p><p>&emsp;&emsp;spring boot有很多的<a href="https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/html/using-boot-build-systems.html#using-boot-starter" target="_blank" rel="noopener">场景启动器</a>，如下图：</p><p><img src="/uploads/article/2019-08-22/场景启动器.png" alt="场景启动器.png"></p><p>&emsp;&emsp;你需要用到什么样的功能，依赖响应的场景启动器即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前面，我们创建了一个Spring Boot的hello world，我们仅仅添加了一个&lt;strong&gt;spring-boot-starter-parent&lt;/strong&gt;，它是怎么帮我们实现这个依赖的呢？我们可以点进去看一下&lt;strong&gt;Ctrl+鼠标左键&lt;/strong&gt;，如下图：&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
</feed>
