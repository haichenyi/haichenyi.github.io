<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haichenyi.com/"/>
  <updated>2021-11-21T03:37:54.851Z</updated>
  <id>https://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android--深入理解handler机制</title>
    <link href="https://haichenyi.com/2021/11/21/Android-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3handler%E6%9C%BA%E5%88%B6/"/>
    <id>https://haichenyi.com/2021/11/21/Android-深入理解handler机制/</id>
    <published>2021-11-21T03:33:57.000Z</published>
    <updated>2021-11-21T03:37:54.851Z</updated>
    
    <content type="html"><![CDATA[<p><span id="c1"></span></p><h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><ul><li><a href="#c1">1–目录</a></li><li><a href="#c2">2–前言</a></li><li><a href="#c3">3–简单总结</a></li><li><a href="#c4">4–Looper的区别：MainLooper和普通Looper</a></li><li><a href="#c5">5–handler发送的消息过程</a></li><li><a href="#c6">6–MessageQueue怎么把这条消息放进队列的</a></li><li><a href="#c7">7–Looper读取消息：loop()</a></li><li><a href="#c8">8–MessageQueue读取消息：next()</a></li><li><a href="#c9">9–如何提高消息的优先级？同步消息，屏障消息，异步消息</a></li><li><a href="#c10">10–handler知识点总结</a></li></ul><p><span id="c2"></span></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;Android程序是一个以消息驱动的程序，页面的跟新，Activity生命周期的变化，点击事件等等都与消息息息相关。</p><a id="more"></a><p><span id="c3"></span></p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>&emsp;&emsp;<strong>简单的理解Handler发送消息的流程</strong>：Handler发送消息(message)到MessageQueue，然后，Looper通过loop()方法循环从MessageQueue里面读取消息。然后，发送给对应的target(Handler)。</p><p><img src="/uploads/article/2021-11-21/简单的理解send消息图.png" alt="简单的理解send消息图.png"></p><p>我们带着问题来理解这个流程，最后，我们在重新总结一下。辣么问题就来了：</p><ol><li>handler都是一样的，为什么Looper会分Looper.getMainLooper()和普通的Looper？</li><li>handler发送的消息过程是什么样子的？</li><li>Looper怎么读取消息的？</li><li>handler发送消息能发送延时消息，Looper读取到消息之后，怎么确定是立刻发送回去，还是隔多久发送回去？</li><li>怎么提升消息的优先级？</li><li>我们项目里面可能会用到的Looper.prepare()，Looper.loop()，这是做什么操作？</li></ol><p>&emsp;&emsp;我们结合源码一起来看一下这些问题：</p><p><span id="c4"></span></p><h3 id="Looper的区别：MainLooper和普通Looper"><a href="#Looper的区别：MainLooper和普通Looper" class="headerlink" title="Looper的区别：MainLooper和普通Looper"></a>Looper的区别：MainLooper和普通Looper</h3><p>第一个问题，handler都是一样的，为什么Looper会分Looper.getMainLooper()和普通的Looper？我们都知道</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler handler = new Handler(Looper.getMainLooper())</span><br></pre></td></tr></table></figure></div><p>通过这个Looper.getMainLooper()方式得到得Handler，可以改变UI，其他的不行，这是为什么呢？我们都知道，UI线程才能改变UI。</p><p><strong>ps：app的启动入口是在ActivityThread的main方法。</strong></p><p>捡一些 (<del>我看的懂的</del>),呸，是主要的，跟我们聊的这个相关的位置贴出来，源码如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        //loop调用了一个准备MainLooper方法（按照方法的名字意思翻译的）</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        //Looper调用loop()方法进入了循环模式</span><br><span class="line">        Looper.loop();</span><br><span class="line">        //如果走到这里，那就没有进入循环模式，就抛出异常了，异常字面意思很好理解，主线程的loop意外的退出了</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>注释应该写的比较清楚了吧？这里我想说的是，main启动的时候，这个线程就是UI线程，这个是系统给规定的，只有在这个线程里面才能改变UI。</p><p>我们再来看看这个Looper.prepareMainLooper()里面做了什么操作</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    //调用prepare方法，传了一个false的Boolean值</span><br><span class="line">    prepare(false);</span><br><span class="line">    //锁</span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        //sMainLooper不等于null，就抛异常</span><br><span class="line">        if (sMainLooper != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //等于null，就把myLooper()方法的返回值赋值给sMainLooper</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//prepare，一个Boolean类型的参数，看名字意思应该是：是否允许退出</span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    //sThreadLocal.get()值不等于null，就抛异常</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //sThreadLocal.get()值等于null，就new一个Looper，放到sThreadLocal中</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Looper的构造方法，我们此时主线程new的时候传的是false</span><br><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    //新建了一个消息队列，MsgQueue，并且把这个boolean传进去了，赋值给mQueue变量</span><br><span class="line">    mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">    //把当前线程赋值给了mThread变量</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line">//消息队列的构造方法，Boolean类型的参数，到这里就应该知道了，表示这个线程是否允许退出，true：允许退出。false：不允许退出</span><br><span class="line">MessageQueue(boolean quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    //nativeInit():native方法，不知道是啥，应该是一些需要的初始化</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br><span class="line">//sThreadLocal.get()的值返回回去</span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注释都有了，最开始调用的prepare(false)方法，看完上面的注释，我大致串一下。</p><p>ps:说一下这个sThreadLocal变量，我也不知道怎么说，反正就是它的类型是：<strong>ThreadLocal<looper></looper></strong>,它就是一个普通的类，然后泛型是Looper，所以，这个类就是用来放Looper的。大致这么理解</p><p>我们再说回这个方法，主要就是，</p><ol><li>先判断这个变量是不是空的，如果不是空的，就抛异常了，因为Looper是不允许我们自己手动创建的。</li><li>如果是空，就创建一个Looper，放进sThreadLocal变量里面；</li><li>然后，创建Looper的时候，顺道就创建了MessageQueue。主线程创建的MessageQueue是不允许主动退出的，如果消息队列退出了，退出app了。</li><li>并且，Looper的mQueue，mThread也都赋值好了，一个是消息队列，一个是当前线程(这两个变量用的也比较多)。</li></ol><p>prepare()方法，到这里就说完了，我们再看剩下的代码，往上面翻一下，再看一下。</p><p>ps：sMainLooper变量，类型就是Looper</p><p>剩下的代码就是一个锁方法，</p><ol><li>判断sMainLooper是不是不等于null，如果，不等于null就抛出了异常</li><li>如果等于null，就把上面创建的looper，赋值给sMainLooper</li></ol><p>&emsp;我们Looper.getMainLooper()获取的Looper就是这个sMainLooper，也就是我们当前线程(UI线程)的Looper，我们只有绑定了这个looper的handler才能改变UI，因为，这个handler是在给UI线程传递消息。</p><p>&emsp;&emsp;为什么不等于null就抛出异常了呢?因为sMainLooper只在系统的时候创建，不能在其他的时候创建，如果，在其他的时候创建，说明系统启动的时候没有创建Looper，那么，主线程就没法通信，这是有问题的。</p><p><strong>第一个问题我说明白了吧？Looper.getMainLooper()获取到的是主线程的Looper，跟它绑定的handler能改变UI，没有跟它绑定的hanler都不能改变UI</strong></p><p><span id="c5"></span></p><h3 id="handler发送的消息过程"><a href="#handler发送的消息过程" class="headerlink" title="handler发送的消息过程"></a>handler发送的消息过程</h3><p>第二个问题，handler发送的消息过程是什么样子的？</p><p>说到这里，我们<strong>先聊一下Message类</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class Message implements Parcelable &#123;</span><br><span class="line">    public int what;</span><br><span class="line">    public int arg1;</span><br><span class="line">    public int arg2;</span><br><span class="line">    public Object obj;</span><br><span class="line">    ...</span><br><span class="line">    public long when;</span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /*package*/ Handler target;</span><br><span class="line">    ...</span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /*package*/ Message next;</span><br><span class="line">    /** @hide */</span><br><span class="line">    public static final Object sPoolSync = new Object();</span><br><span class="line">    private static Message sPool;</span><br><span class="line">    private static int sPoolSize = 0;</span><br><span class="line">    private static final int MAX_POOL_SIZE = 50;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;写代码这么长时间，我们发了那么多消息，是不是都没有仔细看看Message的成员变量？看看上面这几个变量。</p><ol><li>what，arg1，arg2，obj可能我们用的比较多。</li><li>这个long 类型的when，很重要，是消息放在队列哪个位置的重要依据。是放在队头？还是队尾？（<strong>重点</strong>）</li><li>Handler类型的target变量，我们之前没注意过吧？字面意思：目标。目标handler（<strong>重点</strong>）</li><li>下面还有两个Message类型的变量，一个next，一个sPool；next字面意思：下一条消息。pool：水池。类型又是Message；那么，sPool：池子的消息</li><li>Object类型的sPoolSync：异步池子。根据经验来看，碰到过很多这种Object类型的东西，大部分都是加锁用的。synchronized(sPoolSync)，一般都是这样用</li><li>int类型的两个变量，sPoolSize值是0，再就是MAX_POOL_SIZE，值是50。字面的意思就是池子的大小是0，池子的最大值是50.</li></ol><p>&emsp;&emsp;什么池子啊，什么最大值啊。我相信很多人跟我的反应都是一样的，线程池，复用。所以这里就是消息池，消息能复用，消息池最大的消息个数是50个，异步。</p><p>&emsp;&emsp;延申到这里，引出我想问的第一个问题，消息的创建，消息创建的两种方式：一种是new出来，一种是obtain的方式，它有一系列的重载方法。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//第一种：new的方式</span><br><span class="line">Message msg1 = new Message();</span><br><span class="line">msg1.what = 1;</span><br><span class="line">msg1.arg1 = 20;</span><br><span class="line">handler.sendMessage(msg1);</span><br><span class="line"></span><br><span class="line">//第二种：obtain的方式</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.what =1;</span><br><span class="line">msg1.arg1 = 20;</span><br><span class="line">handler.sendMessage(msg);</span><br></pre></td></tr></table></figure></div><p>第一种没啥好说的，我们看第二种：Message.obtain()</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">        //加锁</span><br><span class="line">        synchronized (sPoolSync) &#123;</span><br><span class="line">            //判断sPool是否为空</span><br><span class="line">            if (sPool != null) &#123;</span><br><span class="line">                //sPool不为空，就复用sPool msg对象</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                //然后，把m的next赋值给sPool</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                //然后，把已经去出去的msg的额next置空</span><br><span class="line">                m.next = null;</span><br><span class="line">                m.flags = 0; // clear in-use flag</span><br><span class="line">                //这时候，消息池已经去出去了一条消息，消息池大小就减一</span><br><span class="line">                sPoolSize--;</span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //sPool为空，就new一个msg对象</span><br><span class="line">        return new Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>简单的理解就是，不需要重新创建消息，从消息池里面取出一条消息，赋值给我们需要创建的msg对象。</p><p>这里为什么要加锁？什么情况下需要加锁？当然是防止并发呀，handler可以随时随地的发消息，所以，为了防止并发，加锁。</p><p>问题来了，这个sPool是什么时候赋值的呢？我们创建消息的时候没有赋值。创建的时候没有赋值，我们在Message类里面，检索sPool对象，我们找到如下方法：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">    void recycleUnchecked() &#123;</span><br><span class="line">        //重置一些列的成员变量</span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = 0;</span><br><span class="line">        arg1 = 0;</span><br><span class="line">        arg2 = 0;</span><br><span class="line">        obj = null;</span><br><span class="line">        replyTo = null;</span><br><span class="line">        sendingUid = UID_NONE;</span><br><span class="line">        workSourceUid = UID_NONE;</span><br><span class="line">        when = 0;</span><br><span class="line">        target = null;</span><br><span class="line">        callback = null;</span><br><span class="line">        data = null;</span><br><span class="line">        //就是这里，加锁</span><br><span class="line">        synchronized (sPoolSync) &#123;</span><br><span class="line">            //当前消息池子是否小于限制的最大值</span><br><span class="line">            if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                //把sPool赋值给next</span><br><span class="line">                next = sPool;</span><br><span class="line">                //sPool赋值现在的消息</span><br><span class="line">                sPool = this;</span><br><span class="line">                //消息池子大小加1</span><br><span class="line">                sPoolSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>看这个方法名就应该能猜到，消息回收的时候调用的。所以，在消息回收的时候，就把这条消息重置，把这条回收的消息赋值给sPool，这里就是赋值的位置。在消息回收的时候赋值。</p><p>所以，只要你并发量不大，你每次都是obtain创建消息，基本上都是复用的，不会重新创建消息。</p><p><strong>消息说完了，跑题了，跑题了，言归正传</strong></p><p><strong>handler发送消息的流程</strong></p><p>欢迎来到走进科学之Android消息发送流程，我们来一步一步的剖析这条消息是怎么一步一步放进消息队列的。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.what =1;</span><br><span class="line">msg1.arg1 = 20;</span><br><span class="line">handler.sendMessage(msg);</span><br></pre></td></tr></table></figure></div><p>我们来看这个sendMessage的源码。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessage(@NonNull Message msg) &#123;</span><br><span class="line">        //是不是眼熟，没错，它实际上调用的就是我们延时消息的方法，只不过，这个延时的时间是0</span><br><span class="line">        return sendMessageDelayed(msg, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//我们再来看看这个sendMessageDelayed方法</span><br><span class="line">public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123;</span><br><span class="line">        //这里有个判断时间，小于0，就赋值给0，所以，发送延时消息的时候时间传递负数，会立马接收到消息，知道是为什么了吧？</span><br><span class="line">        if (delayMillis &lt; 0) &#123;</span><br><span class="line">            delayMillis = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里又调用的sendMessageAtTime方法</span><br><span class="line">        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里我想说的是SystemClock.uptimeMillis()：表示系统开机时间</span><br><span class="line">//我们再来看看这个sendMessageAtTime方法</span><br><span class="line"></span><br><span class="line">public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123;</span><br><span class="line">        //这里有一个消息队列的判断，这个消息队列是在Handler创建的时候赋值的。</span><br><span class="line">        //可以点进去看一下。Hander构造方法传递一个Looper，Looper构造方里面创建了msgQueue，就是这个。</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        //如果是空，就抛异常，因为消息队列都没有，循环啥？</span><br><span class="line">        if (queue == null) &#123;</span><br><span class="line">            RuntimeException e = new RuntimeException(</span><br><span class="line">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里又调用了enqueueMessage</span><br><span class="line">        return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,</span><br><span class="line">            long uptimeMillis) &#123;</span><br><span class="line">        //这里，我们前面说消息的时候，说很重要，就是在handler发送消息的这里赋值，这个值也是后面Looper发送给哪个handler的依据。</span><br><span class="line">        msg.target = this;</span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line">        //这个是判断你的这个消息是不是异步，提升消息优先级的位置。同步消息，同步屏障，异步消息。</span><br><span class="line">        if (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里就开始进入到消息队列了</span><br><span class="line">        return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;msg.target是后面Looper拿到这条消息之后，发送的目的地，不然，Looper怎么知道要发送给谁(handler)？</p><p>&emsp;&emsp;提升消息优先级的位置。同步消息，同步屏障，异步消息。也是比较重要，后面再细唠。</p><p><span id="c6"></span></p><h3 id="MessageQueue怎么把这条消息放进队列的"><a href="#MessageQueue怎么把这条消息放进队列的" class="headerlink" title="MessageQueue怎么把这条消息放进队列的"></a>MessageQueue怎么把这条消息放进队列的</h3><p>到这里handler的发送就完了，MessageQueue怎么把这条消息放进去的呢？方法如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        //判断有没有目标handler，如果没有，直接就抛异常，都没有这个目的地，我最后取出这条消息，我发给谁？所以，直接就抛异常</span><br><span class="line">        if (msg.target == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //加锁，不加锁，如果很多消息同时需要加紧队列就会出问题</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            //判断这条消息是否正在使用，如果正在使用，那也抛异常。为什么消息会正在使用呢？</span><br><span class="line">            //我们前面说了obtain方式消息是复用的，发送消息会并发，所以，是吧？</span><br><span class="line">            if (msg.isInUse()) &#123;</span><br><span class="line">                throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果，当前msgQueue正在退出，把消息回收了。</span><br><span class="line">            //比方说，你新建线程请求网络，网络请求完，线程一般就会死掉了，线程都没有了，MsgQueue当然要退出了。</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = new IllegalStateException(</span><br><span class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //走到这里，消息就准备放进消息队列了，就是放在那里的问题</span><br><span class="line">            //给消息加个标记，表示消息正在使用。跟前面那个判断正好对应</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            //这个时间，还记不记得？系统开机时间+你延时的时间</span><br><span class="line">            msg.when = when;</span><br><span class="line">            //把消息队列的当前消息赋值给p</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            //是否需要唤醒线程，唤醒跟休眠都是native方法。</span><br><span class="line">            boolean needWake;</span><br><span class="line">            //当前消息是空，说明当前消息队列没有消息，就直接把我们传递的这条消息加进队列</span><br><span class="line">            //我加进来的这条消息的执行时间是0，时间是不会有负数的，如果传进来是负数，都被改成0了，所以，我加的这条消息应该是最先执行的，所以，要加进队列</span><br><span class="line">            //加进来的这条消息的执行时间小于当前线程的执行时间，我加进来的这条消息执行的时间，比你当前消息队列循环的时间小，说明，我要在它的前面执行，要加进队列</span><br><span class="line">            //上面这个时间小的问题，你可以理解成，消息队列循环的时间是延时10秒处理的，我新进的这条消息是要延时5秒，所以，要放在它的前面</span><br><span class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">               //走到这里，说明新加消息需要放在队首 //我新加的消息放进来了之后，要把当前消息的后面，也就是我新加消息的next</span><br><span class="line">                //因为，我新加的消息要在它的前面执行</span><br><span class="line">                msg.next = p;</span><br><span class="line">                //然后，把我新加消息赋值给当前消息变量</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">         //走到这个else里面，就说明当前消息不需要放到队首，就循环判断看它要被放在哪 </span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                //进入死循环</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    //如果当前msg的下一个消息是空，表示没有消息了，for循环就要中止了，需要把新加消息放进来了</span><br><span class="line">                    //如果当前消息的下一条消息的执行时间在新加的执行时间的后面，说明，新加消息要在这条消息的前面执行。所以，for循环就要中止了，需要把新加消息放进来了</span><br><span class="line">                    if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //把当前消息放在新加消息的后面</span><br><span class="line">                msg.next = p; </span><br><span class="line">                //把新加消息，放在当前执行消息的后面。此时，消息就插件队列了</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">            //是否需要唤醒消息队列开始循环获取消息，是native层面做的事情。</span><br><span class="line">            if (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>总结下来就是：<strong>三个条件</strong></p><ol><li>根据当前队列是否空闲(p == null)</li><li>当前消息执行的时间when(when == 0)</li><li>当前队列执行的消息是否需要在新增消息的后面执行(when &lt; p.when)</li></ol><p>&emsp;&emsp;来判断当前消息是否需要插到队首，只要满足上面的任意一个条件，就需要放进队首；否则，for循环判断当前消息需要放到消息队列的哪个位置。需要插队的话就记得把队列中后面的消息放到当前消息的后面。</p><p>再重复一遍，这个时间是<strong>SystemClock.uptimeMillis() + delayMillis</strong>，系统开机时间+你传递的延时时间。</p><p>到这里，消息就被插件消息队列了。代码基本上每行都有注释，一遍没有看懂的话就多看几遍。</p><p><span id="c7"></span></p><h3 id="Looper读取消息：loop"><a href="#Looper读取消息：loop" class="headerlink" title="Looper读取消息：loop()"></a>Looper读取消息：loop()</h3><p>消息已经放进队列了，第二个问题就结束了，接下来就是第三个问题：<strong>Looper怎么读取消息的？</strong></p><p>Looper是通过loop()方法循环读取消息的。代码如下：</p><p>代码比较多，我把无关的(<del>看不懂的</del>)都去掉了<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">        //获取当前线程的looper</span><br><span class="line">        final Looper me = myLooper();</span><br><span class="line">        //如果，等于null，就抛异常，看异常的消息就应该看的出来，说没有在当前线程调用Looper.prepare()方法</span><br><span class="line">        //Looper.prepare()这个方法就是创建Looper的</span><br><span class="line">        if (me == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //获取当前线程的消息队列</span><br><span class="line">        final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        //进入死循环读取消息</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //读取队列中的下一条消息，可能会阻塞线程</span><br><span class="line">            Message msg = queue.next(); </span><br><span class="line">            //如果，没有消息了，就退出循环，进入休眠状态</span><br><span class="line">            if (msg == null) &#123;</span><br><span class="line">                // No message indicates that the message queue is quitting.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            //获取观察者模式的对象</span><br><span class="line">            final Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            Object token = null;</span><br><span class="line">            if (observer != null) &#123;</span><br><span class="line">                //这里应该是这个观察者对象发送了一个消息正在分发的消息</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            try &#123;</span><br><span class="line">            //msg.target：是不是很眼熟？就是需要接收这条消息的handler //通过这个handler调用dispatchMessage方法，发送消息 msg.target.dispatchMessage(msg);</span><br><span class="line">                if (observer != null) &#123;</span><br><span class="line">                   //然后，观察者发送一个消息分发完成的消息 observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">            &#125; catch (Exception exception) &#123;</span><br><span class="line">                if (observer != null) &#123;</span><br><span class="line">                   //如果出现了异常，这个观察者就发送一个消息分发异常的消息 observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                throw exception;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                if (traceTag != 0) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            //眼熟不？就是前面说的，消息回收，重复利用，就是在消息分发完成之后触发</span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></p><p>我们先看一下这个handler的dispatchMessage方法：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(@NonNull Message msg) &#123;</span><br><span class="line">        //这个Message的callback是什么时候赋值的呢？就是创建Message的时候，可以回过头去看一下</span><br><span class="line">        if (msg.callback != null) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mCallback != null) &#123;</span><br><span class="line">                if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //这个方法，眼熟吗？看下面，我们新建handler的时候，不就重写了这个方法吗？</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Handler handler = new Handler(Looper.getMainLooper())&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(@NonNull Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></div><p>到此，消息的发送，入队，取消息，处理，就形成了闭环了。整个流程：</p><ol><li>新建handler，发送消息sendMessage</li><li>此时消息的创建obtain复用模式，后面可能会造成正在使用的异常，所以，需要加锁同步一下</li><li>然后，消息进队，target(目的地的handler)和when(执行的时间系统开机时间+延时时间)</li><li>判断的三个条件，是放进队首(队列中是空的，时间是0，时间在队列消息时间的前面)，还是队中(需要循环判断队列中是否还有消息和时间)</li><li>通过loop方法取出来消息，通过这个消息的target发送消息</li></ol><p>我们接下来说第四个问题：<strong>handler发送消息能发送延时消息，Looper读取到消息之后，怎么确定是立刻发送回去，还是隔多久发送回去？</strong></p><p>我们上面分析完，好像并没有看到这个延时消息的问题啊，Looper的loop方法是，只要queue.next()返回给它消息了，它就直接发送回去了，没有什么延时。</p><p><span id="c8"></span></p><h3 id="MessageQueue读取消息：next"><a href="#MessageQueue读取消息：next" class="headerlink" title="MessageQueue读取消息：next()"></a>MessageQueue读取消息：next()</h3><p>重点就在这里queue.next()，读取消息。这里也是提升消息优先级的位置(同步屏障，异步消息)。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">    Message next() &#123;</span><br><span class="line">        </span><br><span class="line">        final long ptr = mPtr;</span><br><span class="line">        //通过注释翻译过来就是：loop已经退出了，或者应用正在尝试重启一个looper，就直接return null</span><br><span class="line">        if (ptr == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">        //下一次循环的时间，单位是：秒</span><br><span class="line">        int nextPollTimeoutMillis = 0;</span><br><span class="line">        //开始进入死循环去读取消息</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">                //不知道啥意思。</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line">            //这是一个native方法，看名字，大概的意思应该就是循环一次，经过nextPollTimeoutMillis长的时间</span><br><span class="line">            //就是底层C/C++经过这么长时间之后，触发一次循环</span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">            </span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                // Try to retrieve the next message.  Return if found.</span><br><span class="line">                final long now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = null;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                //屏障消息的实质就是创建一条target为null的消息</span><br><span class="line">                //看这里的if条件，正常的消息target不等于null，这里的判断是不会进入的。</span><br><span class="line">                if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                    // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                    //再看这里的do...while循环，退出的条件是找到一条不为空的异步消息。</span><br><span class="line">                    //msg.isAsynchronous():异步消息返回true，取反之后就是false，更前面&amp;&amp;，就是false，就退出do..while循环了</span><br><span class="line">                    do &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                //消息不为空</span><br><span class="line">                if (msg != null) &#123;</span><br><span class="line">                    //当前时间小于消息需要执行的时间，说明是延时消息。</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                        //修改这个下次循环的时间，前面说的native调用的时间，就是根据这个变量判断的。</span><br><span class="line">                        //时间就是消息执行的时间-系统开机时间=延时时间</span><br><span class="line">                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //否则就是一条实时消息，就是正常的赋值流程，返回这条消息给looper，然后发送出去</span><br><span class="line">                        // Got a message.</span><br><span class="line">                        mBlocked = false;</span><br><span class="line">                        if (prevMsg != null) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = null;</span><br><span class="line">                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        return msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //消息是空，就表示没有更多消息了</span><br><span class="line">                    nextPollTimeoutMillis = -1;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>流程就是：</p><ol><li>先判断looper有没有，系统有没有重启，如果重启了，looper没有，那就直接返回一个null对象，Looper接收到了一个null对象，会直接return</li><li>然后，判断是不是屏障消息(屏障消息消息的target等于null)，如果是屏障消息，就进行do..while循环，直到取出一条异步消息为止</li><li>正常的判断消息，是同步消息还是延时消息，同步消息立刻返回，延时消息，提醒底层多长时间之后再调用我</li></ol><p>&emsp;&emsp;看到了吗？MessageQueue取消息的流程，通过msg的执行时间与当前系统的开机时间进行比较，延时消息就是判断了延时多长时间之后，告诉底层多长时间之后，你还要调用一次这个取消息的方法。这就是延时消息的实现。</p><p><span id="c9"></span></p><h3 id="如何提高消息的优先级？同步消息，屏障消息，异步消息"><a href="#如何提高消息的优先级？同步消息，屏障消息，异步消息" class="headerlink" title="如何提高消息的优先级？同步消息，屏障消息，异步消息"></a>如何提高消息的优先级？同步消息，屏障消息，异步消息</h3><p>既然说到这里，我们就直接聊一下这个消息的优先级</p><p>ps：这里的异步消息，同步消息，并不是说多线程去处理消息。异步消息是有一个属性是true</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//同步消息</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">//异步消息，调用了一个setAsynchronous并且设置为true</span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.setAsynchronous(true);</span><br></pre></td></tr></table></figure></div><p>我们平时发消息是下面这个样子的：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Message msg1 = Message.obtain(handler,new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Log.v(&quot;hcy&quot;,&quot;这是一条延时3秒的消息&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">handler.sendMessageDelayed(msg1,3*1000);</span><br><span class="line"></span><br><span class="line">Message msg = Message.obtain(handler, new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Log.v(&quot;hcy&quot;,&quot;这是一条延时5秒的异步消息&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">handler.sendMessageDelayed(msg,5*1000);</span><br><span class="line">Log.v(&quot;hcy&quot;,&quot;两条消息都发送完了&quot;);</span><br></pre></td></tr></table></figure></div><p>上面就是new了两条消息，一条同步消息，一条异步消息，如果没有屏障消息的情况下，同步消息和异步消息是一样的，没啥区别。程序运行完，过三秒钟同步消息回调，再过两秒打印异步消息回调，上面消息的打印结果如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021-11-21 08:53:10.363 29452-29452/com.haichenyi.myapplication V/hcy: 两条消息都发送完了</span><br><span class="line">2021-11-21 08:53:13.366 29452-29452/com.haichenyi.myapplication V/hcy: 这是一条延时3秒的消息</span><br><span class="line">2021-11-21 08:53:15.365 29452-29452/com.haichenyi.myapplication V/hcy: 这是一条延时5秒的异步消息</span><br></pre></td></tr></table></figure></div><p>那么，什么是屏障消息呢？怎么实现呢？我们先说怎么实现的。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Message msg1 = Message.obtain(handler,new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;这是一条延时3秒的消息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">handler.sendMessageDelayed(msg1,3*1000);</span><br><span class="line"></span><br><span class="line">Message msg = Message.obtain(handler, new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;这是一条延时5秒的异步消息&quot;);</span><br><span class="line">        //异步消息处理完移除消息屏障</span><br><span class="line">        try &#123;</span><br><span class="line">            Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">            Method removeSyncBarrier = msgQueue.getDeclaredMethod(&quot;removeSyncBarrier&quot;, int.class);</span><br><span class="line">            removeSyncBarrier.invoke(Looper.myQueue(),token);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">    msg.setAsynchronous(true);</span><br><span class="line">&#125;</span><br><span class="line">handler.sendMessageDelayed(msg,5*1000);</span><br><span class="line">try &#123;</span><br><span class="line">    //启动消息屏障</span><br><span class="line">    Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">    Method postSyncBarrier = msgQueue.getDeclaredMethod(&quot;postSyncBarrier&quot;);</span><br><span class="line">    token = (int) postSyncBarrier.invoke(Looper.myQueue());</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">Log.v(&quot;hcy&quot;,&quot;两条消息都发送完了&quot;);</span><br></pre></td></tr></table></figure></div><p>打印结果如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021-11-21 09:05:36.915 29743-29743/com.haichenyi.myapplication V/hcy: 两条消息都发送完了</span><br><span class="line">2021-11-21 09:05:41.922 29743-29743/com.haichenyi.myapplication V/hcy: 这是一条延时5秒的异步消息</span><br><span class="line">2021-11-21 09:05:41.949 29743-29743/com.haichenyi.myapplication V/hcy: 这是一条延时3秒的消息</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;代码执行完之后，先是过了5秒回调了异步消息，然后立刻回调了同步消息，为什么呢？因为，同步消息是延时3秒执行呀，异步消息是延时5秒执行，因为加了消息屏障，会把异步消息的优先级提到同步消息的前面，所以，执行完异步消息，同步消息的执行时间早就过了，肯定要立刻执行呀。</p><p>说了这么多，那么，这个提升优先级是怎么实现的呢？透过现象去看本质。两段代码的区别，就是通过反射，执行了两个方法<strong>postSyncBarrier</strong>,<strong>removeSyncBarrier</strong>。其中还有一个带参数的方法。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//执行消息屏障</span><br><span class="line">try &#123;</span><br><span class="line">    Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">    Method postSyncBarrier = msgQueue.getDeclaredMethod(&quot;postSyncBarrier&quot;);</span><br><span class="line">    token = (int) postSyncBarrier.invoke(Looper.myQueue());</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除消息屏障</span><br><span class="line">try &#123;</span><br><span class="line">    Class&lt;?&gt; msgQueue = Class.forName(&quot;android.os.MessageQueue&quot;);</span><br><span class="line">    Method removeSyncBarrier = msgQueue.getDeclaredMethod(&quot;removeSyncBarrier&quot;, int.class);</span><br><span class="line">    removeSyncBarrier.invoke(Looper.myQueue(),token);</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们先来看看这个消息屏障的方法：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">@TestApi</span><br><span class="line">//我们反射调用的是这个方法，它最终执行的是一个同样名字的带参的重载方法</span><br><span class="line">public int postSyncBarrier() &#123;</span><br><span class="line">    return postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最终执行到这里</span><br><span class="line">private int postSyncBarrier(long when) &#123;</span><br><span class="line">//以来还是老规矩，加锁，防止多线程调用</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        //token比较重要，是移除屏障的标记</span><br><span class="line">        final int token = mNextBarrierToken++;</span><br><span class="line">        //常规的msg的创建，msg执行的时间是系统的开机时间</span><br><span class="line">        final Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        //把这个token值赋值给了msg的arg1变量</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line">        //说白了，下面就是链表操作了，不停的移动指针</span><br><span class="line">        //prev：上一条消息变量</span><br><span class="line">        Message prev = null;</span><br><span class="line">        //p：消息。</span><br><span class="line">        //mMessages：这个变量眼熟不？我们前面消息从队列中取的时候就是那个next()方法，</span><br><span class="line">        //在进入for循环里面，判断是否是屏障消息之前，是不是也同样是给一个成员变量赋值，赋值的值也是mMessages。</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        //执行时间不等于0，前面取的时候那三个条件，有一个时间等于0，就插进消息队首，这里我觉得也可以这样理解</span><br><span class="line">        if (when != 0) &#123;</span><br><span class="line">            //这里是一个while循环，字面理解就是当前消息不等于null，当前消息的执行时间，小于屏障消息的执行时间，就继续循环。直到这两个条件不满足为止</span><br><span class="line">            //结合上下文的意思就是，我执行这个屏障消息的时候，如果发现队列里面还有消息的执行时间在我这个屏障消息的前面，就继续让它先执行。</span><br><span class="line">            while (p != null &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                //把当前消息赋值给变量prev</span><br><span class="line">                prev = p;</span><br><span class="line">                //把当前消息的下一条消息，赋值给p变量(当前消息变量)</span><br><span class="line">                p = p.next;</span><br><span class="line">                //继续while循环</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //经过上面的while循环之后，就找准了屏障消息该插入的为止了</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">        //如果prev不等于null，表示，消息队列里面还有需要在屏障消息前面执行的消息</span><br><span class="line">        //队列就变成了：prev-屏障消息-当前消息</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果prev等于null，就表示消息队列里面没有需要在屏障消息执行前面执行的消息了</span><br><span class="line">            //队列也就变成了：屏障消息-当前消息</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回这个token值。移除屏障消息的时候需要用到</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面这个执行消息屏障说的很清楚了吧？多看注释，多理解。</p><p>我们再来看看这个移除消息屏障</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">@TestApi</span><br><span class="line">public void removeSyncBarrier(int token) &#123;</span><br><span class="line">    //加锁</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        //两个变量赋值</span><br><span class="line">        Message prev = null;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        //这个while循环，第一个条件：当前消息不等于null(当前消息队列还有消息)</span><br><span class="line">        //第二个条件：当前消息得目的地不为空(我们屏障消息这里是等于空的，这里应该是为了判断其他地方调用这个方法)</span><br><span class="line">        //然后就是第三个条件，我们传进来的token值，就是上面执行屏障消息时候的返回值，当时赋值给了arg1。这里比较，如果相同，那么，这条消息就是屏障消息</span><br><span class="line">        //第二个条件和第三个条件是或的关系，满足一条就行。</span><br><span class="line">        //屏障消息就要移除，链表的常规移除操作</span><br><span class="line">        while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            //其实就是：原来是：上一条消息——屏障消息——下一条消息</span><br><span class="line">            //变成了：上一条消息——下一条消息</span><br><span class="line">        &#125;</span><br><span class="line">        //到这里就移除完了</span><br><span class="line">        //上面while循环完，发现当前消息是空，说明消息队列中没有消息了，直接抛异常</span><br><span class="line">        if (p == null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The specified message queue synchronization &quot;</span><br><span class="line">                        + &quot; barrier token has not been posted or has already been removed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        final boolean needWake;</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == null || mMessages.target != null;</span><br><span class="line">        &#125;</span><br><span class="line">        //消息回收</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        // If the loop is quitting then it is already awake.</span><br><span class="line">        // We can assume mPtr != 0 when mQuitting is false.</span><br><span class="line">        //native层的是否需要唤醒服务</span><br><span class="line">        if (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>总结一下这个提升消息优先级的方式就是：把你想发送的消息定义view异步消息发送，光这样还不行，还要发送一条屏障消息，具体流程：</p><ol><li>往消息队列里面插入一条target为null的消息</li><li>MessageQueue.next()方法读取的时候，会先判断这条消息是不是屏障消息，如果是，他就会执行do..while循环，直到找到一条异步消息为止。</li><li>MessageQueue拿到消息之后，正常的取消息流程</li><li>在你执行完这条异步消息之后，记得要移除屏障消息，不然所有的异步消息都在同步消息前面执行。</li></ol><p>其实有个更简单的方法，handler发消息的api都给出来了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//发送消息到队列前面</span><br><span class="line">handler.sendMessageAtFrontOfQueue(msg1);</span><br></pre></td></tr></table></figure></div><p>经过上面的整个流程之后，最后一个问题就比较简单了，自己看一下源码吧，我给出结论:</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepare():给当前线程创建Looper，MessageQueue的过程，这个MessageQueue是可退出的</span><br><span class="line"></span><br><span class="line">Looper.loop():从头到尾都在说loop()，循环读取消息。</span><br></pre></td></tr></table></figure></div><p><span id="c10"></span></p><h3 id="handler知识点总结"><a href="#handler知识点总结" class="headerlink" title="handler知识点总结"></a>handler知识点总结</h3><p>总结一下handler的东西：整理了一个流程图：</p><p><img src="/uploads/article/2021-11-21/handler知识点.png" alt="handler知识点.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span id=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-目录&quot;&gt;&lt;a href=&quot;#1-目录&quot; class=&quot;headerlink&quot; title=&quot;1. 目录&quot;&gt;&lt;/a&gt;1. 目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#c1&quot;&gt;1–目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c2&quot;&gt;2–前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c3&quot;&gt;3–简单总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c4&quot;&gt;4–Looper的区别：MainLooper和普通Looper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c5&quot;&gt;5–handler发送的消息过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c6&quot;&gt;6–MessageQueue怎么把这条消息放进队列的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c7&quot;&gt;7–Looper读取消息：loop()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c8&quot;&gt;8–MessageQueue读取消息：next()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c9&quot;&gt;9–如何提高消息的优先级？同步消息，屏障消息，异步消息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c10&quot;&gt;10–handler知识点总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span id=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Android程序是一个以消息驱动的程序，页面的跟新，Activity生命周期的变化，点击事件等等都与消息息息相关。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="https://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Android——触摸事件传递机制</title>
    <link href="https://haichenyi.com/2021/11/20/Android%E2%80%94%E2%80%94%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/"/>
    <id>https://haichenyi.com/2021/11/20/Android——触摸事件传递机制/</id>
    <published>2021-11-19T17:22:11.000Z</published>
    <updated>2021-11-19T17:38:54.295Z</updated>
    
    <content type="html"><![CDATA[<p><span id="c1"></span></p><h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1.目录"></a>1.目录</h2><ul><li><a href="#c1">1–目录</a></li><li><a href="#c2">2–预知识点</a></li><li><a href="#c3">3–Android点击事件</a></li><li><a href="#c4">3.1–结论</a></li><li><a href="#c5">3.2–某一层不想要分发这次事件，怎么办呢？(dispatch)</a></li><li><a href="#c6">3.3–view group想要拦截这次事件，怎么办？(onIntercept)</a></li><li><a href="#c7">3.4–某一层想自己处理，不回传了，怎么办？(onTouchEvent)</a></li></ul><p><span id="c2"></span></p><h2 id="2-预知识点"><a href="#2-预知识点" class="headerlink" title="2.预知识点"></a>2.预知识点</h2><ol><li>Android的一次点击事件由三部分组成：</li></ol><ul><li>ACTION_DOWN(按下)：只能有一个</li><li>ACTION_UP(抬起)：只能有一个</li><li>ACTION_MOVE(移动)：一个或者多个</li></ul><p>&emsp;&emsp;<strong>为什么移动事件能有多个呢</strong>？因为你手指按在屏幕上滑动会触发多个MOVE事件，而这次点击事件的结束，是在你手指离开屏幕的那一刻，才结束。</p><ol><li><p><strong>Android的事件传递是责任链的模式</strong>，一层一层的向下传递，传递到最下层之后，没人认领，就一层一层的往回传（这就是很多人说的从外到内，再从内到外）</p><a id="more"></a></li></ol><p><span id="c3"></span></p><h2 id="3-Android点击事件"><a href="#3-Android点击事件" class="headerlink" title="3.Android点击事件"></a>3.Android点击事件</h2><p><span id="c4"></span></p><h3 id="3-1-结论"><a href="#3-1-结论" class="headerlink" title="3.1 结论"></a>3.1 结论</h3><p>&emsp;&emsp; 简单的分析成从 <strong>Activity——ViewGroup——View</strong>，结论：如下图</p><p><img src="/uploads/article/2021-11-20/不做任何处理的结论图.png" alt="不做任何处理的结论图.png"></p><p><strong>有几点要注意：</strong></p><ul><li><strong>dispatch分发方法，不做任何处理，表示向下分发</strong></li><li><strong>onIntercept拦截方法，不做任何处理，表示不拦截</strong></li><li><strong>onTouchEvent，不做任何处理，表示不处理事件</strong></li><li><strong>view group比activity和view多一个拦截方法</strong>。activity不需要拦截方法是因为，他要么向下分发，要么自己处理不需要拦截。view也类似，要么分发，要么回传。</li></ul><p>这个图就是我们不修改默认的返回值的情况下，全部都是super的方式一层一层传递的结论。最上层的activity，中间层的viewgroup，最下层的view。跟着箭头的方向看：</p><ol><li>activity的分发事件不做处理，分发给中间层view group去做分发</li><li>view group的分发事件也不做处理，传递给自己的拦截方法</li><li>view group的拦截事件不做处理，传递给最下层的view去做分发</li><li>view的分发事件不做处理，它也没有下一层了，所以，它就会传递给自己的onTouchEvent方法，去处理事件</li><li>view的onTouchEvent方法，不做任何处理，那么，它就会回传给中间层view group的onTouchEvent方法</li><li>view group的onTouchEvent方法不做处理，就会回传给最上层activity的onTouchEvent方法</li><li>如果，最上层的activity的onTouchEvent方法也不做处理，那么，系统就会抛弃这次点击事件，也就是 这次点击事件没有任何反应。</li></ol><p>以上就是一次点击事件不做处理的正常流程</p><p>上面的结论是怎么的出来的呢？就是新建一个view group，新建一个view，重写这几个方法，打印日志，其他啥也没动。</p><p><img src="/uploads/article/2021-11-20/activity图.png" alt="activity图.png"></p><p><img src="/uploads/article/2021-11-20/viewgroup图.png" alt="viewgroup图.png"></p><p><img src="/uploads/article/2021-11-20/view图.png" alt="view图.png"></p><p><img src="/uploads/article/2021-11-20/activity布局图.png" alt="activity布局图.png"></p><p>想要验证上面的结论，自己也可以去写了试一下，没有什么难点，就是打印日志，把view写到activity布局里面，然后点击view就行了</p><p><strong>埋个点</strong>：这里日志打印都在super前面。</p><p>那么，问题来了，如果：</p><ol><li>某一层不想要分发这次事件，怎么办呢？(dispatch)</li><li>view group想要拦截这次事件，怎么办？(onIntercept)</li><li>某一层想自己处理，不回传了，怎么办？(onTouchEvent)</li></ol><p><span id="c5"></span></p><h3 id="3-2-某一层不想要分发这次事件，怎么办呢？-dispatch"><a href="#3-2-某一层不想要分发这次事件，怎么办呢？-dispatch" class="headerlink" title="3.2 某一层不想要分发这次事件，怎么办呢？(dispatch)"></a>3.2 某一层不想要分发这次事件，怎么办呢？(dispatch)</h3><p>&emsp;&emsp;<strong>activity层如果想要不分发这次点击事件，自己的onTouchEvent直接处理</strong>。你只有不调用super方法，直接写死返回值，不管是true，还是false，都会直接调用自己的onTouchEvent方法。就像下面这样：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//activity的dispatchTouchEvent方法</span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;activity:dispatchTouchEvent:&quot;+ev.getAction());</span><br><span class="line">        //只要你调用了super方法，不管是返回true还是false，都会正常的向下传递</span><br><span class="line">//        super.dispatchTouchEvent(ev);</span><br><span class="line">        return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>运行的结论我就不贴出来了。最后再总结一张总图</p><p>&emsp;&emsp;view group不分发，此时，activity已经分发下来了，view group不想往下分发了，就需要回传回activity的onTouchEvent方法。写法如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//view group的dispatchTouchEvent方法</span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;viewGroup:dispatchTouchEvent:&quot;+ev.getAction());</span><br><span class="line">        //不调用super方法，返回true，流程就会在这里中断，分发方法就直接消费了这次事件</span><br><span class="line">//        return super.dispatchTouchEvent(ev);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;view 不想分发，就需要回传给view group的onTouchEvent方法，然后是否需要回传给activity的onTouchEvent方法，就需要view group的onTouchEvent方法的返回值去判断了，后面再说。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//view 的dispatchTouchEvent方法</span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;view:dispatchTouchEvent:&quot;+event.getAction());</span><br><span class="line">//        return super.dispatchTouchEvent(event);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>那么，结论就如下表格：<br>|return|true|false|super.dispatchTouchEvent(event)|<br>|:–:|:–:|:–:|:–:|<br>|activity|中断|中断|分发|<br>|view group|中断|不分发|分发|<br>|view|中断|不分发|分发|</p><p>ps：中断：表示整个流程就中断了，没有任何回调了</p><p>不分发：表示正常回调，符合预期</p><p>符合预期，需要去思考一下。我们这里是不分发，就把事件还给上一层，那么，</p><ol><li>view group，就是触发activity的onTouchEvent方法。</li><li>view，就是触发view group的onTouchEvent方法。</li></ol><p><span id="c6"></span></p><h3 id="3-3-view-group想要拦截这次事件，怎么办？-onIntercept"><a href="#3-3-view-group想要拦截这次事件，怎么办？-onIntercept" class="headerlink" title="3.3 view group想要拦截这次事件，怎么办？(onIntercept)"></a>3.3 view group想要拦截这次事件，怎么办？(onIntercept)</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//view group的拦截事件</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;viewGroup:onInterceptTouchEvent:&quot;+ev.getAction());</span><br><span class="line">//        return super.onInterceptTouchEvent(ev);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>拦截事件：表示拦截了自己处理</p><p>那么，结论就如下表格：<br>|return|true|false|super.onInterceptTouchEvent(event)|<br>|:–:|:–:|:–:|:–:|<br>|view group|拦截|不拦截|不拦截|</p><p>这里的拦截，会触发自己的onTouchEvent方法。</p><p>上面的不分发，是触发上一层的onTouchEvent方法。</p><p>这里的概念都不能死记硬背，需要结合上下文去理解。</p><p><span id="c7"></span></p><h3 id="3-4-某一层想自己处理，不回传了，怎么办？-onTouchEvent"><a href="#3-4-某一层想自己处理，不回传了，怎么办？-onTouchEvent" class="headerlink" title="3.4 某一层想自己处理，不回传了，怎么办？(onTouchEvent)"></a>3.4 某一层想自己处理，不回传了，怎么办？(onTouchEvent)</h3><p>onTouchEvent是从内向外回传，那么，我们先来看最内层view的onTouchEvent，代码如下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//view的onTouchEvent代码</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;view:onTouchEvent:&quot;+event.getAction());</span><br><span class="line">//        return super.onTouchEvent(event);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>true，表示自己处理，不会往上回传。false,super表示不自己处理，需要回传</p><p>view group的onTouchEvent，代码如下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//view group的onTouchEvent代码</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.v(&quot;hcy&quot;,&quot;viewGroup:onTouchEvent:&quot;+event.getAction());</span><br><span class="line">//        return super.onTouchEvent(event);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>view group的结论与view的相同。都是：true，表示自己处理，不会往上回传。false,super表示不自己处理，需要回传。<br>&emsp;&emsp;activity没有上一层，不需要回传。所以，activity的onTouchEvent，不需要去考虑</p><p>那么，结论就如下表格：<br>|return|true|false|super.onTouchEvent(event)|<br>|:–:|:–:|:–:|:–:|<br>|view|自己处理|不处理|不处理|<br>|view group|自己处理|不处理|不处理|</p><p>到这里，事件的传递基本上就说完了。完整的流程图如下：</p><p><img src="/uploads/article/2021-11-20/完整的流程图.png" alt="完整的流程图.png"></p><p>更简单的理解：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">true</th><th style="text-align:center">false</th><th style="text-align:center">super</th></tr></thead><tbody><tr><td style="text-align:center">dispatch</td><td style="text-align:center">中断</td><td style="text-align:center">不分发</td><td style="text-align:center">正常流程</td></tr><tr><td style="text-align:center">Intercept</td><td style="text-align:center">拦截</td><td style="text-align:center">不不拦截</td><td style="text-align:center">正常流程</td></tr><tr><td style="text-align:center">onTouchEvent</td><td style="text-align:center">处理</td><td style="text-align:center">不处理</td><td style="text-align:center">正常流程</td></tr></tbody></table><p>dispatch：是否分发</p><p>Intercept：是否拦截</p><p>onTouchEvent：是否自己处理</p><p>true：真的</p><p>false：假的</p><p>分发需要额外单独记忆。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span id=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-目录&quot;&gt;&lt;a href=&quot;#1-目录&quot; class=&quot;headerlink&quot; title=&quot;1.目录&quot;&gt;&lt;/a&gt;1.目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#c1&quot;&gt;1–目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c2&quot;&gt;2–预知识点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c3&quot;&gt;3–Android点击事件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c4&quot;&gt;3.1–结论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c5&quot;&gt;3.2–某一层不想要分发这次事件，怎么办呢？(dispatch)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c6&quot;&gt;3.3–view group想要拦截这次事件，怎么办？(onIntercept)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c7&quot;&gt;3.4–某一层想自己处理，不回传了，怎么办？(onTouchEvent)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span id=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-预知识点&quot;&gt;&lt;a href=&quot;#2-预知识点&quot; class=&quot;headerlink&quot; title=&quot;2.预知识点&quot;&gt;&lt;/a&gt;2.预知识点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Android的一次点击事件由三部分组成：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ACTION_DOWN(按下)：只能有一个&lt;/li&gt;
&lt;li&gt;ACTION_UP(抬起)：只能有一个&lt;/li&gt;
&lt;li&gt;ACTION_MOVE(移动)：一个或者多个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;为什么移动事件能有多个呢&lt;/strong&gt;？因为你手指按在屏幕上滑动会触发多个MOVE事件，而这次点击事件的结束，是在你手指离开屏幕的那一刻，才结束。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Android的事件传递是责任链的模式&lt;/strong&gt;，一层一层的向下传递，传递到最下层之后，没人认领，就一层一层的往回传（这就是很多人说的从外到内，再从内到外）&lt;/p&gt;
    
    </summary>
    
      <category term="Android -自定义view" scheme="https://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA-TCP，UDP</title>
    <link href="https://haichenyi.com/2021/08/09/JAVA-TCP%EF%BC%8CUDP/"/>
    <id>https://haichenyi.com/2021/08/09/JAVA-TCP，UDP/</id>
    <published>2021-08-09T14:02:40.000Z</published>
    <updated>2021-08-09T14:31:44.254Z</updated>
    
    <content type="html"><![CDATA[<p><span id="c1"></span></p><h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><ul><li><a href="#c1">1–目录</a></li><li><a href="#c2">2–概念</a></li><li><a href="#c3">3–优缺点</a></li><li><a href="#c4">4–三次握手</a></li><li><a href="#c5">5–四次握手</a></li><li><a href="#c6">6–通信流程</a></li></ul><p><span id="c2"></span></p> <a id="more"></a><h3 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h3><p>&emsp;&emsp;首先，需要确定的就是他们是socket通信的两种协议。</p><p>&emsp;&emsp;<strong>TCP</strong>:一种面向连接，全双工可靠信道的传输层协议</p><p>&emsp;&emsp;<strong>UDP</strong>:一种无连接的，不可靠的传输层协议</p><p><span id="c3"></span></p><h3 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">安全</th><th style="text-align:center">有序</th><th style="text-align:center">速度</th><th style="text-align:center">对象个数</th><th style="text-align:center">开销</th><th style="text-align:center">方式</th></tr></thead><tbody><tr><td style="text-align:center">TCP</td><td style="text-align:center">安全</td><td style="text-align:center">有序</td><td style="text-align:center">慢</td><td style="text-align:center">1:1</td><td style="text-align:center">大</td><td style="text-align:center">面向字节流</td></tr><tr><td style="text-align:center">UDP</td><td style="text-align:center">不安全</td><td style="text-align:center">无序</td><td style="text-align:center">快</td><td style="text-align:center">1:1，1:N，N:N，N:1</td><td style="text-align:center">小</td><td style="text-align:center">面向报文</td></tr></tbody></table><blockquote><p>是否安全：TCP是采用的全双工可靠信道，很安全。UDP采用得是不可靠得传输协议</p><p>是否有序：TCP：有序，一个传完下一个才能继续。UDP：无序，只管发送，不管有没有接收到</p><p>传输速度：TCP：慢。必须上一个传完，下一个才能传。UDP：快，它可以一直发，不管你有没有接收到</p><p>面向对象：TCP：面向连接1:1。UDP：无连接，1:N。一个很老得比喻，也很形象。你把TCP理解成个人视频，把UDP理解成群视频。</p><p>开销：TCP：开销大，首部20个字节。UDP开销小：首部8个字节</p></blockquote><p><span id="c4"></span></p><h3 id="4-三次握手"><a href="#4-三次握手" class="headerlink" title="4. 三次握手"></a>4. 三次握手</h3><p>&emsp;&emsp;我们都知道TCP是全双工可靠信道。什么是信道？感觉打字不如贴图，如图：</p><p><img src="/uploads/article/2021-08-09/信道图.png" alt="信道图.png"></p><p>&emsp;&emsp;然后，我们来看看这个TCP的通信图</p><p><img src="/uploads/article/2021-08-09/TCP通信图.png" alt="TCP通信图.png"></p><p>已知：两个对象A和B，两个信道：信道1和信道2。</p><p><strong>第一次握手</strong>：A从信道1中给B发消息：我要跟你连接了。（说明：A可以从信道1发消息）</p><p><strong>第二次握手</strong>：B从信道2中给A回消息：好的，我同意了。（说明：B可以从信道2发消息，B可以从信道1收消息）</p><p><strong>第三次握手</strong>：A从信道1中给B回消息：那我们开始连接吧（A可以从信道2收消息）。B收到之后就建立了连接。</p><p><strong>为什么必须要三次握手，2次不行吗？</strong></p><p>&emsp;&emsp;全双工信道只能单方向发消息。如果是2次握手：表示A可以从信道1发消息。B可以从信道1收消息，信道2发消息。但是，B并不知道A能不能从信道2收到消息。所以，2次没法建立建立。</p><p><span id="c5"></span></p><h3 id="5-四次挥手"><a href="#5-四次挥手" class="headerlink" title="5. 四次挥手"></a>5. 四次挥手</h3><p><strong>第一次挥手</strong>：A从信道1给B发消息：我的事情都处理完了，我要跟你断开连接了。</p><p><strong>第二次挥手</strong>：B从信道1收到消息后，从信道2给A回一个消息：我知道了。然后，B继续处理未处理完的事情。</p><p><strong>第三次挥手</strong>：B的事情处理完之后，B从信道2给A发消息：我的事情都处理完了，我要跟你断开连接了。</p><p><strong>第四次挥手</strong>：A从信道2收到B发来的断开连接的消息之后。A从信道1给B回复：好的，我知道了，我们都断开吧。然后，A断开1，2信道。B从信道1收到了A的确认消息之后。B也断开1，2信道。</p><p><span id="c6"></span></p><h3 id="5-通信流程"><a href="#5-通信流程" class="headerlink" title="5. 通信流程"></a>5. 通信流程</h3><ol><li>先获取Socket套接字对象，绑定端口号，新开线程连接服务器。</li><li>然后通过套接字获取它的输入流和输入流。</li><li>新开两个线程，监听outputstream，和inputstream。输入流负责读从服务器返回的数据，输出流负责本地向服务器发送数据。</li><li>这个时候就需要注意拆包，粘包的问题，返回数据需要统一格式，读数据的时候可以根据这个格式来区分是否是一条完整的数据。</li><li>再就是需要监听网络状态的变化，若切换网络导致连接中断，这个时候就需要捕获异常，释放资源，再重新连接。</li></ol><p>&emsp;&emsp;一般如果没有限制必须要用原生的写，我一般都是用Netty，之前也写过一篇Netty用法的文章：<a href="http://haichenyi.com/2018/02/08/Netty%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E8%AE%AF/">Netty的简单使用，实现socket通讯</a></p><p>&emsp;&emsp;<strong>解决粘包，拆包:约定好每一条消息的规则</strong>。怎么约定呢？</p><p>举个栗子：</p><ol><li>定长。每条消息都是固定长度，不够补0。每次只读取一个固定长度的信息，这样自然就把每条消息分开了。</li><li>设置特定的结束符。双方约定好，每条消息的结尾跟一个特殊的符号，表示这条消息结束。这样也能把每条消息分开</li><li>每条消息的头部，定义好这条消息的长度。每次解析的时候，先解析这个长度，再开始解析数据。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span id=&quot;c1&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-目录&quot;&gt;&lt;a href=&quot;#1-目录&quot; class=&quot;headerlink&quot; title=&quot;1. 目录&quot;&gt;&lt;/a&gt;1. 目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#c1&quot;&gt;1–目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c2&quot;&gt;2–概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c3&quot;&gt;3–优缺点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c4&quot;&gt;4–三次握手&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c5&quot;&gt;5–四次握手&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#c6&quot;&gt;6–通信流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span id=&quot;c2&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA -基础" scheme="https://haichenyi.com/categories/JAVA-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA—公平锁，非公平锁，悲观锁，乐观锁，死锁</title>
    <link href="https://haichenyi.com/2021/07/27/JAVA%E2%80%94%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81/"/>
    <id>https://haichenyi.com/2021/07/27/JAVA—公平锁，非公平锁，悲观锁，乐观锁，死锁/</id>
    <published>2021-07-27T13:44:50.000Z</published>
    <updated>2021-08-03T15:11:24.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这几个锁都可以从前面一篇<a href="http://haichenyi.com/2021/07/19/JAVA%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%99%A8AQS/#more">线程同步器AQS</a>里面找到影子,我先把前面一篇的加锁流程图拿过来用一用。</p> <a id="more"></a><p><img src="/uploads/article/2021-07-19/加锁流程图.png" alt="加锁流程图.png"></p><p>&emsp;&emsp;上面这个流程图是上一篇最开始讲的时候的一张流程图，后面写的时候，后面的流程图都没有画。这一片我们来画一下后面的流程图。</p><h3 id="公平锁，非公平锁"><a href="#公平锁，非公平锁" class="headerlink" title="公平锁，非公平锁"></a>公平锁，非公平锁</h3><p>&emsp;&emsp;前面一篇讲的时候，我说过了，我们当时做的是一个公平锁。这个公平锁和非公平锁的主要区别就是在这个队列。</p><p>&emsp;&emsp;我们前文讲过了，线程1拿到了锁，线程2，3，4就全部放进队列中等待，那么，流程图如下：</p><p><img src="/uploads/article/2021-07-27/等待流程图1.png" alt="等待流程图1.png"></p><p>&emsp;&emsp;如上图，我们理想状态是：线程1释放锁的时候，队列中的第一个元素，也就是线程2拿到锁，然后，开始执行。</p><p>&emsp;&emsp;但是，往往不如意，谁规定的一共就只有4个线程呢？如果，我们正当1释放锁的同时，又有一个线程5进来了，我们要怎么操作呢？流程图如下：</p><p><img src="/uploads/article/2021-07-27/等待流程图2.png" alt="等待流程图2.png"></p><p>&emsp;&emsp;公平锁和非公平锁的区别就在这里：</p><ol><li>公平锁会把线程5放进队列中，放到线程4的后面，线程2获取到锁，然后执行自己的任务</li><li>非公平锁则是，线程1释放锁之后，状态变成了0，线程5去竞争锁，获取到锁之后，状态state又变成了1，线程2被唤醒之后，正准备去获取锁的时候，一看，状态state是1，又进入等待状态。</li></ol><p>&emsp;&emsp;所以，公平锁就是释放锁之后，谁等待得时间长，谁先执行。非公平锁则是，释放锁之后，谁先获取到锁，谁先执行。可能后进的执行，也可能先进的先执行。</p><p>&emsp;&emsp;<strong>ReentrantLock</strong>，初始化的时候传true就是公平锁，传false就是非公平锁，默认是非公平锁。下面就是ReentrantLock的构造方法。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125;.</span><br><span class="line"> * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line"> */</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line"> * given fairness policy.</span><br><span class="line"> *</span><br><span class="line"> * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line"> */</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="悲观锁锁，乐观锁"><a href="#悲观锁锁，乐观锁" class="headerlink" title="悲观锁锁，乐观锁"></a>悲观锁锁，乐观锁</h3><p>&emsp;&emsp;<strong>悲观锁</strong>：操作之前加锁，操作完成之后解锁。我们前文讲的buy方法就是悲观锁，进入方法就加锁，方法执行完就解锁。还有我们常用的<strong>synchronized</strong>关键字，就是悲观锁的典型代表。</p><p>&emsp;&emsp;<strong>乐观锁</strong>：乐观锁是一种思想，比方说，我们前文提到的CAS机制，就是乐观锁的一种实现。当我们操作一个变量做加减操作的时候，我们多个线程可以同时做这个操作，但是到具体更新这个值的时候，去判断。典型代表就是Atomic原子类。这个原子类的实现也是CAS机制。</p><p>&emsp;&emsp;<strong>性能问题</strong>：多个线程同时执行，悲观锁，就只有一个线程操作，其他线程挂起等待，释放锁之后，再切换回来。乐观锁，所有的线程都一起执行，最后执行冲突检测和数据更新操作。没有挂起等待，上下文的切换，所以，乐观锁的性能肯定比悲观锁好。但是，实际上真的是这样吗？答案是否定的。乐观锁的性能不一定比悲观锁好。</p><p>&emsp;&emsp;前面，我们说到乐观锁是在最后更新得时候，去判断。那么怎么判断呢？早期1.5版本之前的CAS操作是有3个参数内存位置(V)、原值(A)、新值(B)。我们在更新的时候，先判断A是否满足，满足就更新成B上一篇文章已经说过了。不满足，那就再循环一边重复判断。极端情况下，要是线程足够的多，并且一直不满足，那是不是一直循环判断(CAS自旋)？那就一直占用CPU。这样性能肯定不好。</p><p>&emsp;&emsp;<strong>synchronized</strong>在JDK1.5之前的确性能很差，但是在1.6的时候就已经做了优化了，从无锁状态，到偏向锁状态，再到轻量级锁状态，最后到重量级锁状态。这几个状态会随着竞争情况逐渐升级（锁不但可以升级还可以降级）。现在synchronized的性能跟ReentrantLock差不多。</p><p>&emsp;&emsp;所以，悲观锁的性能不一定比乐观锁差，乐观锁的性能不一定比悲观锁好。根据实际情况去选择悲观锁和乐观锁。那到底怎么选择呢？</p><p>&emsp;&emsp;之前在网上看到过这么一组数据，启用多个线程进行计数相加到一亿，首先是synchronized方式</p><p><img src="/uploads/article/2021-07-27/synchronized时间图.png" alt="synchronized时间图.png"></p><p>&emsp;&emsp;当线程数为8时，性能明显提升，但是8到32个线程来说，每个线程的平均时间基本差不多，基本没有提升，到了64个线程的时候，性能又有一点提升。</p><p>如果换成CAS实现多线程累加数为一亿，时间又会怎么样呢？</p><p><img src="/uploads/article/2021-07-27/CAS时间图.png" alt="CAS时间图.png"></p><p>&emsp;&emsp;在线程数相对较少的时候，CAS实现比较快，性能优于synchronized,当线程数多于8后，CAS实现明显开始下降，反而时间消耗高于synchronized；</p><p>&emsp;&emsp;<strong>总结</strong>：synchronized是java提供的又简单方便，性能优化又非常好的功能，建议大家常用；CAS的话，线程数大于一定数量的话，多个线程在循环调用CAS接口，虽然不会让其他线程阻塞，但是这个时候竞争激烈，会导致CPU到达100%，同时比较耗时间，所以性能就不如synchronized了。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>&emsp;&emsp;死锁是指：多个进程在运行过程中因争夺某一种资源，而造成的僵持状态，若无外力作用，他们都将无法向前推进。</p><p><strong>举个栗子</strong>：</p><p>小明在看电视，小红在玩手机，小明对小红说：你把手机给我玩，我把点视给你看；小红却说：你把点视给我看，我再把手机给你玩。</p><p><strong>分析</strong>：</p><ol><li><strong>电视，手机</strong>都可以看作一种资源。</li><li><strong>小明在看电视，小红在玩手机</strong>：表示电视分配给小明了，小明对电视持有锁；手机分配给小红了，小红对手机持有锁</li><li><strong>小明对小红说，你把手机给我玩，我把点视给你看</strong>：小明想获取到手机的锁之后，再释放自己电视的锁。</li><li><strong>小红却说，你把点视给我看，我再把手机给你玩</strong>：小红想获取电视的锁之后，再释放自己手机的锁</li></ol><p>&emsp;&emsp;所以，小明和小红都在等待对方释放锁，自己拿到想要的资源之后，释放自己资源的锁。这里谁都拿不到锁，就无线的等待下去。这就是死锁。</p><h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><ol><li><strong>互斥条件</strong>：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。(就是这里的电视只能给小明看，手机只能给小红玩)</li><li><strong>占有且等待</strong>：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。（小明等着小红释放手机资源，小红等着小明释放电视资源）</li><li><strong>不剥夺条件</strong>：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来（小明在看电视的时候，小红不能说，我要看电视，你给我看。小红在玩手机的时候，小明不能说，我要玩手机，你把手机给我玩。我们要讲文明，不能耍流氓）</li><li><strong>环路等待条件</strong>：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源（小明等着小红释放手机资源，小红等着小明释放电视资源）</li></ol><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>&emsp;&emsp;如果产生死锁只能重启。所以，我们在开发过程中要尽量避免死锁，比方说：著名的<strong>银行家算法</strong>。只要上面四种中的任意一种不满足，就不可能造成死锁：比方说占有等待，我们可以用共享锁的方式AQS里面每个加锁的方法都有一个try开头的方法。可以看一下acquire和tryAcquire的区别。这就破坏了第二个条件，等待。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这几个锁都可以从前面一篇&lt;a href=&quot;http://haichenyi.com/2021/07/19/JAVA%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%99%A8AQS/#more&quot;&gt;线程同步器AQS&lt;/a&gt;里面找到影子,我先把前面一篇的加锁流程图拿过来用一用。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA -并发" scheme="https://haichenyi.com/categories/JAVA-%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA—线程同步器AQS</title>
    <link href="https://haichenyi.com/2021/07/19/JAVA%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%99%A8AQS/"/>
    <id>https://haichenyi.com/2021/07/19/JAVA—线程同步器AQS/</id>
    <published>2021-07-19T14:41:15.000Z</published>
    <updated>2021-08-03T15:12:01.151Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;每一项技术的提出都是为了解决某一个问题，带着问题来理解技术，使得印象你对这个技术的理解印象更加深刻。</p> <a id="more"></a><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>&emsp;&emsp;举个栗子：现在有一个需求，网络请求分两批（A,B两个批次），A批次并行请求，B批次串行请求按顺序一个一个请求，有一个总超时时间，B批次每一次请求都有一个超时时间，A批次并发请求先请求，在规定时间内没有返回，再开始请求B批次，谁先返回用谁的。</p><p>&emsp;&emsp;这个是我们项目里面简化过后的一个逻辑，实际逻辑，比这个还要复杂。怎么实现这个功能呢？</p><p>&emsp;&emsp;带着这个问题来进入我们的正题，什么是并发？</p><ol><li>并发是一种现象：同时运行多个程序或者多个任务需要被处理的现象。</li><li>这些任务可能是并行的，也可能是串行的，和CPU的核心数无关，是操作系统进程调度和CPU上下文切换达到的结果。</li><li>解决并发的思路就是把分解，把一个大任务分解成多个小任务来执行</li></ol><p>&emsp;&emsp;像我们上面所说的需求就是分解成一个一个的网络请求，一部分并行请求，一部分串行请求。并行请求简单来说，对应我们应用里面就是多线程，多线程同时执行；串行请求对应我们应用里面就是单线程，一个线程执行完了，另一个线程才开始。这里不考虑多进程的问题。</p><h3 id="并发为什么会造成线程不安全的问题"><a href="#并发为什么会造成线程不安全的问题" class="headerlink" title="并发为什么会造成线程不安全的问题"></a>并发为什么会造成线程不安全的问题</h3><p>&emsp;&emsp;我们先来聊聊cpu是怎么执行指令：</p><ol><li>首先，cpu执行指令的过程中，不可避免会执行读写操作，而这个操作都是从主存（也就是物理内存）中去读写</li><li>但是，cpu执行指令速度很快，程序运行过程中的临时变量都是放在主存当中的，如果全部都是从主存中去读写，读写很耗时，这样就浪费了cpu的性能</li><li>最后，为了解决这个问题，就出现了高速缓存的概念。我们先把变量读取到告诉缓存中，然后，再高速缓存中操作完之后，再刷新到主存当中。</li></ol><p>&emsp;&emsp;java的内存模型规定，所有的变量都在主存当中，类似于物理内存，每个线程都有自己的工作空间，也就是对应上面的高速缓存，每一个线程都有一个自己的高速缓存。</p><p>&emsp;&emsp;线程对变量的操作必须在自己的工作空间内，不能直接操作主存，而且，一个线程也不能访问另一个线程的工作空间。</p><p>&emsp;&emsp;那么，我们如果多个线程同时对一个变量做加1操作，如下面的add1方法。我们thread1和thread2把a的值同时复制到自己的工作空间中时，都是0，然后同时进行加1操作，同时刷新到主存当中，那最后，我们获取到的最终的值就是1，而不是我们想要的2.这就是并发造成的线程不安全的问题</p><h3 id="简单的同步器"><a href="#简单的同步器" class="headerlink" title="简单的同步器"></a>简单的同步器</h3><p>&emsp;&emsp;我们项目里面遇到的并发问题，基本上就是多线程访问同一变量的问题，比方说，简单的举个栗子，两个线程对同一个int值做加1操作，然后打印出来。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int a = 0;</span><br><span class="line">@org.junit.Test</span><br><span class="line">public void add1() &#123;</span><br><span class="line">    Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            a++;</span><br><span class="line">            System.out.println(&quot;thread1:a=&quot; + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            a++;</span><br><span class="line">            System.out.println(&quot;thread2:a=&quot; + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;因为这里直接用的基本类型，极端情况下，线程1，线程2同时执行，里面的a++操作也是同时执行，那这里两个打印都是1，虽然，这里我没有复现出来。但是，这种情况肯定是存在的。那么，怎么避免这种情况呢？</p><p>&emsp;&emsp;我们可以写一个简单的线程同步器，就是加锁操作，如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private Object lock = new Object();</span><br><span class="line">public int a = 0;</span><br><span class="line">@org.junit.Test</span><br><span class="line">public void add1()&#123;</span><br><span class="line">    Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //先获取到lock 对象的锁</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                 //在lock对象上执行wait()方法,让其进入休眠,等待有人唤醒自己</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                a++;</span><br><span class="line">                System.out.println(&quot;thread1:a=&quot; + a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">        //获取lock的锁</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                a++;</span><br><span class="line">                System.out.println(&quot;thread2:a=&quot; + a);</span><br><span class="line">                //唤醒正在lock对象上等待的线程</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里，我们用到的object类的wait和notify方法。等待和唤醒。当线程1执行到lock.wait();方法时，线程1会进入等待状态。当线程2执行lock.notify();时，会唤醒线程1，执行线程1的后续a++，打印操作。</p><p>&emsp;&emsp;那么，这里会有一个问题，如果线程2先执行，线程1后执行，那么线程1将永远的等待下去，这也是这样写的一个弊端。这还只是2个线程，实际项目中往往比这个复杂多了。为了解决这弊端，就引出了我们的<strong><em>线程同步器AQS(AbstractQueuedSynchronizer)</em></strong></p><p>&emsp;&emsp;并且，这个同步器，java.util包下面都已经给好了实现类，比方说：Semaphore，ReentrantLock，CountDownLatch等等都是，并且，我们用到的java线程池ThreadPoolExecutor中的Worker的实现也是。如下图：</p><p><img src="/uploads/article/2021-07-19/worker图片.png" alt="worker图片.png"></p><h3 id="线程同步器AQS-AbstractQueuedSynchronizer"><a href="#线程同步器AQS-AbstractQueuedSynchronizer" class="headerlink" title="线程同步器AQS(AbstractQueuedSynchronizer)"></a>线程同步器AQS(AbstractQueuedSynchronizer)</h3><p>&emsp;&emsp;线程同步器就是为了解决并发引起的线程不安全的问题。线程安全的三大特性：原子性，可见性，有序性。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>&emsp;&emsp;简单点来说就是，它维护一个状态state，还有一个CLH队列。</p><p>&emsp;&emsp;CLH时一个双端队列，队列中每一个节点都放着正在等待获取资源的线程。当线程现在通过CAS原子算法比较预期值的方式去获取资源，也就是判断这里的state状态，是不是有等待获取资源的线程可以使用，如果时有，那就直接使用，如果没有，那就会将这个线程封装成一个节点Node，插入到CLH队列的尾部等待被唤醒。其他线程执行完之后，调用release释放一部分资源，那么，正在等待的队列就会被唤醒，去执行自己的任务。大致是这个意思，当然，AQS还有中断等其他的操作</p><h4 id="简单的AQS同步器"><a href="#简单的AQS同步器" class="headerlink" title="简单的AQS同步器"></a>简单的AQS同步器</h4><p>&emsp;&emsp;还是类似于上面那个例子，不过，都是访问同一个变量，业务背景换一下，换成一个库存秒杀，通过访问服务器，一共10件物品，我现在有20个线程去同时请求，哪些能抢到，哪些不能抢到？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int count = 10;</span><br><span class="line"></span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 20; i++) &#123;</span><br><span class="line">            final int finalI = i;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    buy(finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void buy(int i) &#123;</span><br><span class="line">        if (count != 0) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;库存还剩:&quot; + count + &quot;件&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;已经被抢光了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就像上面这样模拟一个简单的秒杀场景，库存10件，20个用户抢，实际情况肯定不止。我们看一下这样写的打印，如下图：</p><p><img src="/uploads/article/2021-07-19/秒杀图1.png" alt="秒杀图1.png"></p><p>&emsp;&emsp;我们看到这个最终虽然有10个用户的确抢到了，但是，我们看一下打印，打印是从8个开始的，不是从9开始的。我们理想的应该是如下这个图：</p><p><img src="/uploads/article/2021-07-19/秒杀图2.png" alt="秒杀图2.png"></p><p>&emsp;&emsp;这个图是我把buy方法加上了<strong>synchronized</strong>关键字，我给它锁住了。当执行buy方法的时候，另一个线程如果也进来执行buy，它会等待，等待前一个buy方法执行完，它才开始执行。</p><p>&emsp;&emsp;那么，直接用这个关键字就好了呀，还要啥自行车？天真，存在即合理。synchronized关键字锁比较重，不适合这种秒杀场景。</p><p>&emsp;&emsp;言归正传，上面两个从8开始，结合我们前面说的并发的问题，是不是就可以联想到，如果，多个线程同时，同一时刻访问，然后，数据库的库存同时减1，是不是就会出现一件商品，卖给多个人的情况？</p><p>&emsp;&emsp;有同学就会想，那么这么巧，同时访问，同一时刻，那你想想天猫双十一，那些节假日的秒杀场景，会出现什么问题？</p><p>&emsp;&emsp;这个时候线程同步器就出现了，我们不能对用户做限制，我们不能说张三你必须在某一个时间内访问，李四在某一个时间内访问，所以，我们能控制的只有服务器，也就是这里的buy方法。</p><p>&emsp;&emsp;也就是说，我们这里用的是悲观锁的方式，进入buy方法就立刻加锁，运行完buy方法就解锁。后面应用里面再聊这个悲观锁，乐观锁之类的。我们就把buy方法改成如下这样了：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    MyOwnLock ownLock = new MyOwnLock();</span><br><span class="line"></span><br><span class="line">    public void buy(int i) &#123;</span><br><span class="line">        //加锁</span><br><span class="line">        ownLock.lock();</span><br><span class="line">        if (count != 0) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;库存还剩:&quot; + count + &quot;件&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;第&quot; + i + &quot;个用户抢到了，&quot; + &quot;已经被抢光了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //解锁</span><br><span class="line">        ownLock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">/**</span><br><span class="line"> * @ClassName: MyOwnLock</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: 海晨忆</span><br><span class="line"> * @Date: 2021/7/15 11:07</span><br><span class="line"> */</span><br><span class="line">public class MyOwnLock &#123;</span><br><span class="line">    public void lock() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unLock() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;如上代码，现在，我们要做的就是完善MyOwnLock类的加锁和解锁方法。</p><p>&emsp;&emsp;我们想想这个流程，多个用户同时下单，实际上对于代码来讲，就是多个线程同时请求服务器，调用这里的buy方法，去减少库存，我们需要做的就是保证这里减少库存不能出问题。</p><p>&emsp;&emsp;怎么保证这个减少库存不能出问题呢？就是我们前面说的并发的问题，也就是这里的线程安全的问题。线程安全的三大特性：原子性，可见性，有序性。我们保证这三个特性就好了。</p><p>&emsp;&emsp;第一个线程进来，我们就标记一下，已经有线程进来在执行了，我们就改变这个标记，后面的线程感知到这个改变之后，就必须等待。那这个标记，怎么让其他线程感知到呢？</p><p>&emsp;&emsp;<strong>volatile</strong>关键字的两大特性：可见性，有序性</p><p>&emsp;&emsp;可见性，就是可以让其他线程感知到。那么，就解决了这个问题，我们用计数器的方式来做这个标记。我们是悲观锁的方式，始终只能有一个线程访问，必须等这个线程访问完了，其他线程才能访问。</p><p>&emsp;&emsp;对应成代码就是，这个计数器变量初始化是0，加锁成功之后，就加1，后面的线程进来的时候，判断这个计数器是不是0，如果不是0，就表示有线程正在访问，不能进行加锁操作；如果是0，就表示没有，可以进行加锁操作。那么我们就开始写代码：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.example.myapplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassName: MyOwnLock</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: 海晨忆</span><br><span class="line"> * @Date: 2021/7/15 11:07</span><br><span class="line"> */</span><br><span class="line">public class MyOwnLock &#123;</span><br><span class="line">    private volatile int state;</span><br><span class="line">    private Thread currentHolder;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        int state = getState();</span><br><span class="line">        if (state == 0) &#123;</span><br><span class="line">            setCurrentHolder(currentThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unLock() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(int state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Thread getCurrentHolder() &#123;</span><br><span class="line">        return currentHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCurrentHolder(Thread currentHolder) &#123;</span><br><span class="line">        this.currentHolder = currentHolder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;直接用if(state==0)来判断就可以了吗？volatile关键字只能保证可见性，有序性，并不能保证原子性，所以，volatile并不是真正的线程安全，只是大多数情况下还是比较有用的，而，我们这里要保证线程安全，就需要保证原子性，原子性怎么保证呢？</p><p>&emsp;&emsp;这里就出现了关键的<strong>CAS算法</strong>了，<strong>Compare And Swap</strong>比较互换。这个算法java里面是怎么实现的呢？我们java里面有一个Unsafe类，他的里面全是native方法，提供的都是硬件级别的原子操作。我们用到的就是这个类里面的几个方法，CAS的操作也是这些方法实现的<strong>compareAndSwapXXX</strong>。具体的可以在网上搜一下这个类，然后仔细的看一下，这里，我简单的介绍一个：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * Compares the value of the object field at the specified offset</span><br><span class="line"> * in the supplied object with the given expected value, and updates</span><br><span class="line"> * it if they match.  The operation of this method should be atomic,</span><br><span class="line"> * thus providing an uninterruptible way of updating an object field.</span><br><span class="line"> * 在obj的offset位置比较object field和期望的值，如果相同则更新。这个方法</span><br><span class="line"> * 的操作应该是原子的，因此提供了一种不可中断的方式更新object field。</span><br><span class="line"> * </span><br><span class="line"> * @param obj the object containing the field to modify.</span><br><span class="line"> *    包含要修改field的对象 </span><br><span class="line"> * @param offset the offset of the object field within &lt;code&gt;obj&lt;/code&gt;.</span><br><span class="line"> *         &lt;code&gt;obj&lt;/code&gt;中object型field的偏移量</span><br><span class="line"> * @param expect the expected value of the field.</span><br><span class="line"> *               希望field中存在的值</span><br><span class="line"> * @param update the new value of the field if it equals &lt;code&gt;expect&lt;/code&gt;.</span><br><span class="line"> *               如果期望值expect与field的当前值相同，设置filed的值为这个新值</span><br><span class="line"> * @return true if the field was changed.</span><br><span class="line"> *              如果field的值被更改</span><br><span class="line"> */</span><br><span class="line">public native boolean compareAndSwapObject(Object obj, long offset,</span><br><span class="line">                                           Object expect, Object update);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;所以，加锁流程就变成了如下图的样子，</p><p><img src="/uploads/article/2021-07-19/加锁流程图.png" alt="加锁流程图.png"></p><p>&emsp;&emsp;根据这个流程，代码就变成了如下的样子：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.example.myapplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassName: MyOwnLock</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: 海晨忆</span><br><span class="line"> * @Date: 2021/7/15 11:07</span><br><span class="line"> */</span><br><span class="line">public class MyOwnLock &#123;</span><br><span class="line">    private volatile int state;</span><br><span class="line">    private Thread currentHolder;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        if (acquire())&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean acquire()&#123;</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        int state = getState();</span><br><span class="line">        if (state == 0) &#123;</span><br><span class="line">            if (compareAndSwapState(0,1)) &#123;</span><br><span class="line">                setCurrentHolder(currentThread);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unLock() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(int state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Thread getCurrentHolder() &#123;</span><br><span class="line">        return currentHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCurrentHolder(Thread currentHolder) &#123;</span><br><span class="line">        this.currentHolder = currentHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;加锁流程就完了吗？这才哪到哪，我们现在加锁就第一个拿到锁的线程开始用了，那后面没有拿到锁的线程怎么办呢？难道全部丢掉不管吗？</p><p>&emsp;&emsp;当然不行。那怎么办呢？我们先用一个队列，把没有拿到锁的线程存起来，排好队，等第一个线程执行完了之后，释放锁的时候，再直接唤醒等待的线程即可；</p><p>&emsp;&emsp;把阻塞的线程全放进队列（并且要线程安全，高并发的情况下迅速 入队，出队）中，当T1释放锁是，直接唤醒T2。队列选择用ConcurrentLinkedQueue<thread>（基于CAS算法，保证入队，出队安全）</thread></p><p>&emsp;&emsp;那么，要怎么做呢？要怎么等待呢？最简单的就是写一个死循环，一直循环去判断锁有没有用完。但是，这样会一直占用CPU，消耗性能。</p><ol><li>用sleep？Thread.sleep可能造成等待时间过长，你没法知道休眠的时间，如果，线程1执行完只需要200毫秒，你这里休眠了1000毫秒，那就浪费了800毫秒了。</li><li>那用Thread.yield()可以了吧？答案是不行，这个线程让步，虽然把cpu的时间片让出去给其他线程用了，但是，最后，我们需要唤醒的时候，怎么办呢？</li></ol><p>&emsp;&emsp;我们最后唤醒，是要指定唤醒哪一个线程，这里我们还是用到刚才Unsafe里面的两个方法，park和unPark。park阻塞线程，让出cpu的使用权，unPark解除阻塞，唤醒某一个线程。</p><p>&emsp;&emsp;这里我们用它的包装类LockSupport。所以，加锁代码就变成这样子了：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private ConcurrentLinkedQueue&lt;Thread&gt; waiterQueue = new ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public void lock() &#123;</span><br><span class="line">    if (acquire()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    waiterQueue.add(currentThread);</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        if (currentThread != waiterQueue.peek() &amp;&amp; acquire()) &#123;</span><br><span class="line">            waiterQueue.poll();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.park(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;获取锁的方法也要做相应的调整，如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean acquire() &#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    int state = getState();</span><br><span class="line">    if (state == 0) &#123;</span><br><span class="line">        boolean temp = waiterQueue.size() == 0 || currentThread == waiterQueue.peek();</span><br><span class="line">        if (temp &amp;&amp; compareAndSwapState(0, 1)) &#123;</span><br><span class="line">            setCurrentHolder(currentThread);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;解锁就比较简单了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void unLock() &#123;</span><br><span class="line">    if (Thread.currentThread() != currentHolder) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;出错啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int state = getState();</span><br><span class="line">    if (compareAndSwapState(state, 0)) &#123;</span><br><span class="line">        setCurrentHolder(null);</span><br><span class="line">        Thread firstThread = waiterQueue.peek();</span><br><span class="line">        if (firstThread != null) &#123;</span><br><span class="line">            LockSupport.unpark(firstThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;判断当前线程是不是持有锁的线程，如果不是，那就抛异常<br>如果是，那就获取状态state，通过cas算法，置换为0的状态。</p><p>&emsp;&emsp;最后运行完，结果如下：</p><p><img src="/uploads/article/2021-07-19/最终运行结果图.png" alt="最终运行结果图.png"></p><p>总结：上面我说的简单的线程同步器，只是AQS的一个主要的思想，CAS算法，计数器，线程队列。还有线程中断，独占模式，共享模式，公平锁，不公平锁等等。看完我这个，然后再去看源码应该会更容易懂。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;每一项技术的提出都是为了解决某一个问题，带着问题来理解技术，使得印象你对这个技术的理解印象更加深刻。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA -并发" scheme="https://haichenyi.com/categories/JAVA-%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Android模拟点击</title>
    <link href="https://haichenyi.com/2021/07/07/Android%E6%A8%A1%E6%8B%9F%E7%82%B9%E5%87%BB/"/>
    <id>https://haichenyi.com/2021/07/07/Android模拟点击/</id>
    <published>2021-07-07T13:32:21.000Z</published>
    <updated>2021-08-03T15:09:57.530Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本篇介绍实现模拟点击的两种方式：</p><ol><li>performClick();</li><li><p>MotionEvent事件</p><a id="more"></a></li></ol><p>&emsp;&emsp;举个栗子：我们现在需要实现点击A按钮，触发B按钮点击事件的效果：两个按钮在布局里面随便创建就好了。</p><p>&emsp;&emsp;<strong><em>第一种方式就是：调用performClick事件</em></strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Button btn1 = findViewById(R.id.btn1);</span><br><span class="line">final Button btn2 = findViewById(R.id.btn2);</span><br><span class="line">btn1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn1&quot;);</span><br><span class="line">        btn2.performClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">btn2.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这种方式很简单，但是有一个弊端，就是不会传递触摸点坐标，只是模拟一下btn2的点击事件。</p><p>&emsp;&emsp;<strong><em>第二种方式就是：MotionEvent事件</em></strong><br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Button btn1 = findViewById(R.id.btn1);</span><br><span class="line">final Button btn2 = findViewById(R.id.btn2);</span><br><span class="line">btn1.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn1&quot;);</span><br><span class="line">        long downTime = SystemClock.uptimeMillis();</span><br><span class="line">        long eventTime = SystemClock.uptimeMillis()+100;</span><br><span class="line">        float upX = btn2.getX()+50;</span><br><span class="line">        float upY = btn2.getY()+50;</span><br><span class="line">        MotionEvent obtainDown = MotionEvent.obtain(downTime, eventTime, ACTION_DOWN, upX, upY, 0);</span><br><span class="line"></span><br><span class="line">        long downTime1 = SystemClock.uptimeMillis();</span><br><span class="line">        long eventTime1 = SystemClock.uptimeMillis()+100;</span><br><span class="line">        float upX1 = btn2.getX()+50;</span><br><span class="line">        float upY1 = btn2.getY()+50;</span><br><span class="line">        MotionEvent obtainUp = MotionEvent.obtain(downTime1, eventTime1, MotionEvent.ACTION_UP, upX1, upY1, 0);</span><br><span class="line">        btn2.dispatchTouchEvent(obtainDown);</span><br><span class="line">        btn2.dispatchTouchEvent(obtainUp);</span><br><span class="line">        obtainDown.recycle();</span><br><span class="line">        obtainUp.recycle();</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;downTime:&quot;+downTime+&quot; ,eventTime:&quot;+eventTime+&quot; ,upX:&quot;+upX+&quot; ,upY:&quot;+upY+&quot; ,downTime1:&quot;+downTime1+&quot; ,eventTime1:&quot;+eventTime1+&quot; ,upX1:&quot;+upX1+&quot; ,upY1:&quot;+upY1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">btn2.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;btn2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;这种方式比较麻烦，用到的就是view的事件分发，一个简单的点击事件的触发就是down和up组成，当然还有平移我们这里不考虑。</p><p>&emsp;&emsp;<strong>第一步</strong>，先用MotionEvent.obtain创建两个事件：一个down事件，一个up事件，创建的时候需要传递坐标点，传你目标view的范围内的坐标就行。</p><p>&emsp;&emsp;<strong>第二步</strong>，通过目标view，也就是这里的btn2去把这两个事件分发出去，通过dispatchTouchEvent分发，这样就完成了一次模拟点击事件，分发完记得回收</p><p>&emsp;&emsp;这样，就完成了一次模拟点击，并且坐标也传递了。因为，创建这两个事件的时候就传递了。解决了performClick的弊端。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本篇介绍实现模拟点击的两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;performClick();&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MotionEvent事件&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="https://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列-消息(RabbitMQ)（二十）</title>
    <link href="https://haichenyi.com/2019/11/27/SpringBoot%E7%B3%BB%E5%88%97-%E6%B6%88%E6%81%AF-RabbitMQ-%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/11/27/SpringBoot系列-消息-RabbitMQ-（二十）/</id>
    <published>2019-11-27T06:44:45.000Z</published>
    <updated>2021-08-03T15:15:09.589Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;大多数应用当中，可通过消息服务中间件来提升系统的异步通信和扩展解耦能力。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>消息服务中两个重要的概念</p><p>&emsp;&emsp;<strong>消息代理</strong>和<strong>目的地</strong>：当消息发送者发送消息之后，将由消息代理接管，消息代理保证消息发送到指定的目的地。</p><p>消息发送的两种方式：</p><ol><li>队列(Queue)：点对点消息通信(point-to-point)</li><li>主题(Topic)：发布(publish)/订阅(subscribe)式消息通信</li></ol><p>&emsp;&emsp;开始说了，消息可以提升系统的异步通信和扩展解耦能力。异步通信，我们之前讲异步任务的时候已经说过了。给用户发送邮件就是最好，最直接的例子。</p><p>&emsp;&emsp;至于，扩展解耦能力，最好最直接的例子就是流量削峰，举个例子：整点秒杀。库存只有100件，用户有10000个人，整点用户讲发送10000个请求，难道每个都请求数据库吗？这个时候，我们就可以做个限制，用户发送的请求先到消息队列，然后，再由消息队列统一管理，哪些请求时可以到数据库的，哪些请求时不可以到数据库的，这样就解决了数据库的抗压能力。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;点对点式</p><ul><li>消息发送者发送消息之后，消息代理将消息放在一个队列当中，消息接收者从队列中获取消息内容，消息读取后移除队列</li><li>消息只有唯一的发送者和接收者，但并不是说只能有一个接收者</li></ul><p>&emsp;&emsp;发布订阅式</p><ul><li>发送者(发布者)发送消息到主题(topic)，多个接收者(订阅者)监听(订阅)这个主题，那么，就会在消息到达的同时收到消息</li></ul><p><strong>JMS和AMQP</strong></p><ul><li>JMS:Java message service ：Java消息服务基于JVM消息代理规范，ActiveMQ,HornetMQ就是JMS的实现</li><li>AMQP:advanced message Queue Protocol：高级消息队列协议，也是消息代理的规范，兼容JMS，RabbitMQ就是AMQP的实现。</li></ul><p><strong>对比</strong></p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">JMS</th><th style="text-align:left">AMQP</th></tr></thead><tbody><tr><td style="text-align:left">定义</td><td style="text-align:left">Java api</td><td style="text-align:left">网络线级协议</td></tr><tr><td style="text-align:left">跨语言</td><td style="text-align:left">否</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">跨平台</td><td style="text-align:left">否</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">model</td><td style="text-align:left">提供两种消息模式：peer-2-peer，pub/sub</td><td style="text-align:left">提供五种消息模式：direct exchange，fanout exchange，topic change，headers exchange，system exchange。本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分</td></tr><tr><td style="text-align:left">支持消息类型</td><td style="text-align:left">多种消息类型：TextMessage，MapMessage，BytesMessage，StreamMessage，ObjectMessage，Message （只有消息头和属性）</td><td style="text-align:left">byte[]类型，当实际应用中有复杂消息时，可以序列化之后再发送</td></tr><tr><td style="text-align:left">综合评价</td><td style="text-align:left">JMS定义了java api层面的标准，在Java体系中，多个client均可通过JMS进行交互，不需要修改代码，但是其对跨平台支持较差</td><td style="text-align:left">AMQP天然具有跨平台，跨语言特性</td></tr></tbody></table><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>Message</strong></p><p>&emsp;&emsp;消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等</p><p><strong>Publisher</strong></p><p>&emsp;&emsp;消息的生产者，也是一个向交换器发布消息的客户端应用程序</p><p><strong>Exchange</strong></p><p>&emsp;&emsp;交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange有4种类型：direct(默认)，fanout,topic,和headers，不同类型的Exchange转发消息的策略有所区别。</p><p><strong>Queue</strong></p><p>&emsp;&emsp;消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><strong>Binding</strong></p><p>&emsp;&emsp;绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和Queue的绑定可以是多对多的关系。</p><p><strong>Connection</strong></p><p>&emsp;&emsp;网络连接，比如一个TCP连接。</p><p><strong>Channel</strong></p><p>&emsp;&emsp;信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><p><strong>Consumer</strong></p><p>&emsp;&emsp;消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><p><strong>Virtual Host</strong></p><p>&emsp;&emsp;虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><p><strong>Broker</strong></p><p>&emsp;&emsp;表示消息队列服务器实体</p><p><img src="/uploads/article/2019-11-27/RabbitMQ流程图.png" alt="RabbitMQ流程图.png"></p><p><strong>流程</strong></p><p>&emsp;&emsp;AMQP的消息路由过程跟JMS存在一些差异，增加了Exchange和Binding的角色</p><p>JMS流程：</p><ol><li>生产者(publisher)生成某个消息(Message)，发送到某个队列(Queue)上</li><li>消费者(Consumer)监听这个队列(Queue)，消费消息</li></ol><p>RabbitMQ流程：</p><ol><li>生产者(publisher)生成某个消息(Message)，把这个消息发送给我们的消息代理服务器上(Broker)</li><li>服务器收到消息之后，把这个消息给到一个合适的交换器(Exchange),(服务器有非常多的交换器)</li><li>交换器(Exchange)收到这个消息之后，根据路由键(Binding绑定关系)把这个消息给一个或者多个消息队列(Queue)(服务器有很多个消息队列)</li><li>消费者(Consumer)连接上队列之后取出消息</li></ol><p><strong><em>重点就是：交换器和队列的绑定</em></strong></p><p><strong><em>重点就是：交换器和队列的绑定</em></strong></p><p><strong><em>重点就是：交换器和队列的绑定</em></strong></p><p>&emsp;&emsp;我们上面说了Exchange有4种，不同类型转发的消息策略不同，那么，这个策略是什么呢？其中，header和direct交换器完全一致，但是header性能上差很多，基本上不用了</p><p><strong><em>重点start</em></strong></p><ul><li>direct交换器：当我们发送消息时的路由键和绑定中的key完全一致的时候，交换器就将消息发送到该队列当中。它时完全匹配单播模式</li><li>fanout交换器：当我们消息发送到fanout交换器时，不管交换器与队列绑定的路由键时什么，fanout交换器都会把这个消息发送给每一个队列，跟UDP广播类似，fanout交换器发送消息最快。</li><li>topic交换器：该交换器允许我们对路由键做模糊匹配，有选择性的发送给某一个或者多个队列。两个通配符:井号(#)和星号(*)。其中：井号：匹配0个或者多个单词。星号：匹配一个单词。</li></ul><p><strong><em>重点end</em></strong></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>&emsp;&emsp;首先，打开我们的虚拟机，用SecureCRT连接我们的虚拟机，我用的SecureCRT，至于你用的啥连接虚拟机，随便你。</p><p>&emsp;&emsp;然后，用docker安装带manager版本的rabbit，带manager的版本自带图形化界面，容易操作。从docker hub上面搜索，我安装的是</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3.8.1-management</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;接着，新建容器，记得带端口号,-d后台运行，映射两个端口号，起自己的名字，加上镜像id</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5672:5672 -p 15672:15672 --name myrabbitmq 镜像id</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;接下来，就可以访问了，通过虚拟机的ip地址加上端口号，账号密码都是guest</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟机ip地址:15672</span><br></pre></td></tr></table></figure></div><p><img src="/uploads/article/2019-11-27/RabbitMQ管理界面图.png" alt="RabbitMQ管理界面图.png"></p><p>&emsp;&emsp;我们在图上，就能看到我们前面说过的：Connection，Channel，Exchange，Queue等等。</p><p>&emsp;&emsp;最后面那个admin，我们能够设置用户名和密码，就是我们前面登录的guest，并且，能够设置访问的Virtual Hosts。</p><p>&emsp;&emsp;我们看一下最上面的流程图和消息发送流程<br>，我就举一个例子：</p><ol><li>首先，我们先创建一个交换器名字叫：haichenyi</li></ol><p><img src="/uploads/article/2019-11-27/创建交换器.png" alt="创建交换器.png"></p><ol><li>其次，我们再创建一个队列，名字也叫：haichenyi</li></ol><p><img src="/uploads/article/2019-11-27/创建消息队列.png" alt="创建消息队列.png"></p><ol><li>接着，我们将这交换器和队列绑定到一起</li></ol><p><img src="/uploads/article/2019-11-27/交换器与队列绑定.png" alt="交换器与队列绑定.png"></p><ol><li><p>然后，我们随便发送一条消息</p></li><li><p>最后，查看消息队列</p></li></ol><p><img src="/uploads/article/2019-11-27/发送消息之后的queue.png" alt="发送消息之后的queue.png"></p><p>PS：</p><ul><li>我们在创建Exchange和Queue的时候，有一个选项：Durability，意思是是否可持久化，也就是，服务器重启之后这个东西是否还存在。就选默认的durable就行了，可持久化的</li><li>我们在Exchange和Queue绑定的时候，发送消息的时候，都要填一个Routing key，就是上文我们说的绑定规则。</li></ul><p>&emsp;&emsp;这就是整个流程，这都是页面操作，下面说一下代码里面怎么写，很简单。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;首先，添加依赖：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后，就是配置：两个可能出错的位置，我已经注释标明了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=192.168.113.22</span><br><span class="line">#这里端口号要用5672，不能用15672，15672是后台管理页面的端口号</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">#这里的用户民和密码还有virtual-host要对应上，新建的账号要记得给权限</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;代码怎么写呢？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class SellApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        //message需要自己构造一个；定义消息体内容和消息头</span><br><span class="line">        //rabbitTemplate.send(exchange,routingKey,message);</span><br><span class="line"></span><br><span class="line">        //Object默认当成消息体，只需传入要发送的对象，自动序列化发送给RabbitMQ</span><br><span class="line">        //rabbitTemplate.convertAndSend(exchange,routingKey,Object);</span><br><span class="line">        </span><br><span class="line">        //对象会被默认序列化之后发送</span><br><span class="line">        User user = new User(&quot;海晨忆&quot;,25);</span><br><span class="line">        rabbitTemplate.convertAndSend(&quot;haichenyi&quot;,&quot;haichenyi&quot;,user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void getMsg()&#123;</span><br><span class="line">        //queueName:需要从哪个队列中收消息</span><br><span class="line">        User user = (User) rabbitTemplate.receiveAndConvert(&quot;haichenyi&quot;);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        System.out.println(user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;可以向上面这样测试，发送和接收。实际应用中，我们要向下面这样写：</p><ul><li>启动类上添加@EnableRabbit注释，开启Rabbit监听功能</li><li>在我们接收的方法添加@RabbitListener注解，queues是一个数组，方法的参数是发送的数据类型。</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;haichenyi&quot;)</span><br><span class="line">    public void receive(User user)&#123;</span><br><span class="line">        System.out.println(&quot;收到消息：&quot;+user);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        System.out.println(user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;以上，就是RabbitMQ的简单使用了，上面的Exchange，Queue都是在管理界面创建绑定的，代码里面怎么创建绑定呢？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    RabbitAdmin rabbitAdmin;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void createExchange()&#123;</span><br><span class="line">        //以declare开头的都是创建，这里是创建一个Exchange，需要传一个Exchange对象</span><br><span class="line">        //我们点击过去看，是一个接口，我们就看它的实现类。可以看到5种实现类</span><br><span class="line">        rabbitAdmin.declareExchange(new DirectExchange(&quot;wang.exchange&quot;));</span><br><span class="line">        //创建一个queue队列</span><br><span class="line">        rabbitAdmin.declareQueue(new Queue(&quot;wang.queue&quot;));</span><br><span class="line">        //destination：目的地</span><br><span class="line">        //Binding.DestinationType destinationType：类型,枚举类：队列和交换器两种</span><br><span class="line">        //exchange：交换器</span><br><span class="line">        //routingKey：路由键</span><br><span class="line">        //arguments：头信息</span><br><span class="line">        //绑定有两种绑定方式，一种是把交换器往队列上面绑定，一种是把队列往交换器上面绑定</span><br><span class="line">        rabbitAdmin.declareBinding(new Binding(&quot;wang.queue&quot;,Binding.DestinationType.QUEUE,&quot;wang.exchange&quot;,&quot;wang.key&quot;,null));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后，发消息的操作就跟前面写的一样了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;大多数应用当中，可通过消息服务中间件来提升系统的异步通信和扩展解耦能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列-Docker（十九）</title>
    <link href="https://haichenyi.com/2019/11/13/SpringBoot%E7%B3%BB%E5%88%97-Docker%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/11/13/SpringBoot系列-Docker（十九）/</id>
    <published>2019-11-13T06:44:37.000Z</published>
    <updated>2021-08-03T15:13:36.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，<br>然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><a id="more"></a><p>&emsp;&emsp;容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。</p><p>&emsp;&emsp;我们spring boot项目，什么地方需要用到dockers呢？我们最后项目发布，发到服务器上面，环境怎么搭建？如果就用Linux命令会很麻烦，用Docker，简单的几行命令就可以了。</p><p>&emsp;&emsp;服务器其实就是一个操作系统，我们的项目跑在上面也是需要环境的，我们本地是windows系统，跑项目需要环境，服务器现在一般都是centOS系统，当然也需要环境。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>docker镜像(images)：Docker镜像用于创建Docker容器的模板</li><li>docker容器(container)：Docker容器是独立运行的一个或者一组应用</li><li>docker客户端(client)：客户端通过命令或者其他工具一起使用docker api与docker守护进程</li><li>docker主机(host)：一个物理或者虚拟的机器用于执行docker守护进程和容器</li><li>docker仓库(registry)：docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。docker hub提供了庞大的镜像集合供使用</li></ul><p>&emsp;&emsp;举个例子，我们一般操作流程是这样的：</p><ol><li>先用VirtualBox启动一个虚拟机，启动的是centOS系统，装上docker程序（docker主机）。这个对应的就是我们项目最后发布的服务器。</li><li>然后，用SecureCRT连上我们这个虚拟机。（docker客户端）。</li><li>接着，通过docker从docker 仓库中下载我们需要的镜像，比方说：mysql镜像，redis镜像等等。</li><li>最后，启动这个镜像，就相当于创建一个容器。启动镜像，就相当于配置好了环境。比方说：启动一个mysql镜像，就相当于创建了一个mysql容器，就可以用mysql数据库了。可以启动的那个多个镜像，并且，每个镜像都是独立运行的，互不干扰（沙箱机制）。</li></ol><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>查看centOS版本：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//docker要求CentOS系统内核版本要高于3.10</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure></div><p>升级软件包及内核：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//因为，我们安装的docker是最新版本的</span><br><span class="line">//但是，内核版本低可能不兼容，所以，要更新</span><br><span class="line">//如果，后面安装成功之后，启动的时候出错，那么就先卸载docker，更新内核</span><br><span class="line">//重启之后，再重新安装docker就行了</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure></div><p>安装docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure></div><p>卸载docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-*</span><br></pre></td></tr></table></figure></div><p>启动docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></div><p>将docker作为开机启动</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></div><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">检索</td><td style="text-align:left">docker search 关键字（eg：docker search redis）</td><td style="text-align:left">我们经常去docker hub上检索镜像的详细信息，不用再本地敲命令搜索。如镜像的TAG</td></tr><tr><td style="text-align:left">拉取</td><td style="text-align:left">docker pull 镜像名:tag</td><td style="text-align:left">:tag是可选的，tag表示标签，多为软件的版本，默认是latest版本</td></tr><tr><td style="text-align:left">列表</td><td style="text-align:left">docker images</td><td style="text-align:left">查看所有本地镜像</td></tr><tr><td style="text-align:left">删除</td><td style="text-align:left">docker rmi image-id</td><td style="text-align:left">删除指定的本地镜像，镜像id可以通过列表查看</td></tr><tr><td style="text-align:left">运行</td><td style="text-align:left">docker run -d –name 自定义名字  安装的容器名字（eg:docker run –d –name myredis redis）</td><td style="text-align:left">–name：自定义容器名 -d：后台运行</td></tr><tr><td style="text-align:left">列表</td><td style="text-align:left">docker ps（查看运行中的容器）</td><td style="text-align:left">加上-a；可以查看所有容器</td></tr><tr><td style="text-align:left">停止</td><td style="text-align:left">docker stop container-name/container-id</td><td style="text-align:left">停止当前你运行的容器</td></tr><tr><td style="text-align:left">启动</td><td style="text-align:left">docker start container-name/container-id</td><td style="text-align:left">启动容器</td></tr><tr><td style="text-align:left">删除</td><td style="text-align:left">docker rm container-id</td><td style="text-align:left">删除指定容器</td></tr><tr><td style="text-align:left">端口映射</td><td style="text-align:left">-p 6379:6379</td><td style="text-align:left">-p: 主机端口(映射到)容器内部的端口</td></tr><tr><td style="text-align:left">容器日志</td><td style="text-align:left">docker logs container-name/container-id</td></tr></tbody></table><p>PS:我们docker run的时候一般都是跟上端口映射，不然访问不到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。&lt;br&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，&lt;br&gt;然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Run启动原理（十八）</title>
    <link href="https://haichenyi.com/2019/11/11/SpringBoot%E7%B3%BB%E5%88%97-Run%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/11/11/SpringBoot系列-Run启动原理（十八）/</id>
    <published>2019-11-11T09:28:35.000Z</published>
    <updated>2021-08-03T15:14:04.690Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;需要搞清楚几个重要的事件回调机制</p><p>配置在META-INF/spring.factories</p><ul><li>ApplicationContextInitializer</li><li>SpringApplicationRunListener</li></ul><p>只需要放在ioc容器中</p><ul><li><p>ApplicationRunner </p></li><li><p>CommandLineRunner</p></li></ul><a id="more"></a><p>&emsp;&emsp;新建一个空项目，就勾选web，找到启动类，每个方法上面写的注释，可以看一下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SellApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SellApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上面run方法点进来</span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;</span><br><span class="line">return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;</span><br><span class="line">return new SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>看到这里，就应该看到了，启动流程分为两步</p><ol><li>创建SpringApplication对象</li><li>运行run方法</li></ol><h3 id="创建SpringApplication对象"><a href="#创建SpringApplication对象" class="headerlink" title="创建SpringApplication对象"></a>创建SpringApplication对象</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//上面的构造方法点进去</span><br><span class="line">//这里与1.5版本不一样的地方就是，</span><br><span class="line">//2.X这里调用了重载的构造方法，而1.5这里调用的是一个initialize()方法，这个方法里面的内容，与下面两个参数的重载方法差不多</span><br><span class="line">public SpringApplication(Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">this(null, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面这个就是this调用的重载的构造方法</span><br><span class="line">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">this.resourceLoader = resourceLoader;</span><br><span class="line">//保存主配置类，1.5里面这里有个非空判断，用if做的，这里换成的断言做判断</span><br><span class="line">Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">//判断当前是否一个web应用</span><br><span class="line">this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">//从类路径下找到META‐INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起 来</span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">//从类路径下找到ETA‐INF/spring.factories配置的所有ApplicationListener</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">//从多个配置类中找到有main方法的主配置类</span><br><span class="line">this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="setInitializers-方法"><a href="#setInitializers-方法" class="headerlink" title="setInitializers()方法"></a>setInitializers()方法</h4><p>&emsp;&emsp;看方法名就知道，这个是初始化方法，初始化什么东西呢？再看传的参数ApplicationContextInitializer，就是一开始我们提到的类。我们看这个是怎么获取的</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//第一步：</span><br><span class="line">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">return new SpringApplicationRunListeners(logger,</span><br><span class="line">getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二步：</span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line">// Use names and ensure unique to protect against duplicates</span><br><span class="line">//看这里的导入方法SpringFactoriesLoader.loadFactoryNames(type, classLoader)</span><br><span class="line">Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">return instances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三步：</span><br><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line">return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第四步，就是这里了。看这里面的实现</span><br><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">if (result != null) &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">//一眼看过去。很明显，这里就是classLoader.getResources()，导入的本地的资源。看这个传的参数,我放到这个方法下面去了</span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != null ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">//这里通过一个while循环，加载本地配置的ApplicationContextInitializer</span><br><span class="line">while (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = new UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException ex) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The location to look for factories.</span><br><span class="line"> * &lt;p&gt;Can be present in multiple JAR files.</span><br><span class="line"> */</span><br><span class="line">public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;所以，从上面的源码，我们一步一步点击进去看，我们就能发现，他最终都是加载到 <strong>META-INF/spring.factories</strong> 目录下的 <strong>ApplicationContextInitializer</strong> 当然，到目前为止这里只是初始化</p><h4 id="setListeners-方法"><a href="#setListeners-方法" class="headerlink" title="setListeners()方法"></a>setListeners()方法</h4><p>&emsp;&emsp;一眼就能看出来，这里是设置监听方法</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;一眼看过去，这个setListener方法传的参数熟不熟悉？就是我们上面初始化的时候传的参数是同一个方法。所以，这里设置监听设置哪些监听方法也是<strong>META-INF/spring.factories</strong> 目录下的listener方法，我们看一下这个文件内容：</p><p><img src="/uploads/article/2019-11-11/spring_factories.png" alt="spring_factories.png"></p><p>&emsp;&emsp;这些都是是自动配置类的内容</p><h3 id="运行Run方法"><a href="#运行Run方法" class="headerlink" title="运行Run方法"></a>运行Run方法</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">StopWatch stopWatch = new StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = null;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">//获取SpringApplicationRunListeners；从类路径下META‐INF/spring.factories</span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">//回调所有的获取SpringApplicationRunListener.starting()方法</span><br><span class="line">listeners.starting();</span><br><span class="line">try &#123;</span><br><span class="line">    //封装命令行参数</span><br><span class="line">ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">//准备环境，创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准 备完成</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">//这里是新增的，点击去看，就是再properties文件中配置你需要忽略的bean</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">//这个是打印spring的logo banner图</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">/创建ApplicationContext；这个下面有下介绍</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">//看一下参数，这个就是做异常报告处理的</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"></span><br><span class="line">//准备上下文环境;将environment保存到ioc中；而且applyInitializers()；</span><br><span class="line">//applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法</span><br><span class="line">//回调所有的SpringApplicationRunListener的contextPrepared()；</span><br><span class="line">//prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded()；</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">//s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版</span><br><span class="line">//扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）</span><br><span class="line">refreshContext(context);</span><br><span class="line">//2.x里面是空方法</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line"></span><br><span class="line">//从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">//返回这个IOC容器</span><br><span class="line">return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="getRunListeners-方法"><a href="#getRunListeners-方法" class="headerlink" title="getRunListeners()方法"></a>getRunListeners()方法</h4><p>&emsp;&emsp;我们看到上面第一个有注释的位置：getRunListeners方法</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">return new SpringApplicationRunListeners(logger,</span><br><span class="line">getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;方法熟悉吗？就是我们上面初始化的时候调用的那个方法，只是这里的参数传的是：<strong>SpringApplicationRunListener</strong>,我们看最开始说的，这就是我们要了解的第二个内容，回调都是怎么调用的</p><p>&emsp;&emsp;方法里面的注释也写了，先获取监听事件，然后回调starting方法，我们看一下这个接口有那些回调方法：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface SpringApplicationRunListener &#123;</span><br><span class="line"></span><br><span class="line">default void starting() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void environmentPrepared(ConfigurableEnvironment environment) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就这些回调，这里还用了1.8的新特性，<strong>default关键字</strong>，接口里面的方法可以有方法体</p><h4 id="prepareEnvironment"><a href="#prepareEnvironment" class="headerlink" title="prepareEnvironment()"></a>prepareEnvironment()</h4><p>&emsp;&emsp;看到第二个写注释的位置，眼熟吗？可不就是跟上面回调方法名字相同么？我们点进去看一下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,</span><br><span class="line">ApplicationArguments applicationArguments) &#123;</span><br><span class="line">// Create and configure the environment</span><br><span class="line">ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line"></span><br><span class="line">//这里划重点，这里就调用的environmentPrepared的回调方法</span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line">if (!this.isCustomEnvironment) &#123;</span><br><span class="line">environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line">return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;准备完环境之后，调用environmentPrepared的回调</p><h4 id="createApplicationContext"><a href="#createApplicationContext" class="headerlink" title="createApplicationContext()"></a>createApplicationContext()</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableApplicationContext createApplicationContext() &#123;</span><br><span class="line">Class&lt;?&gt; contextClass = this.applicationContextClass;</span><br><span class="line">if (contextClass == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">switch (this.webApplicationType) &#123;</span><br><span class="line">case SERVLET:</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">case REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex) &#123;</span><br><span class="line">throw new IllegalStateException(</span><br><span class="line">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;创建applicationContext，这里跟1.5不一样，1.5就只有两种：一种是web的ioc容器，一种是默认的ioc容器。2.X这里有三种：<strong>DEFAULT_CONTEXT_CLASS，DEFAULT_SERVLET_WEB_CONTEXT_CLASS，DEFAULT_REACTIVE_WEB_CONTEXT_CLASS</strong>，实际字符串比较长，可以去看一下源码。然后用BeanUtils通过反射创建。</p><h4 id="prepareContext-方法"><a href="#prepareContext-方法" class="headerlink" title="prepareContext()方法"></a>prepareContext()方法</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span><br><span class="line">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123;</span><br><span class="line">//将environment放到context中</span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">//初始化</span><br><span class="line">applyInitializers(context);</span><br><span class="line">//这里回调contextPrepared方法</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == null);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line">// Add boot specific singleton beans</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);</span><br><span class="line">if (printedBanner != null) &#123;</span><br><span class="line">beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line">if (beanFactory instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line">if (this.lazyInitialization) &#123;</span><br><span class="line">context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">&#125;</span><br><span class="line">// Load the sources</span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</span><br><span class="line">load(context, sources.toArray(new Object[0]));</span><br><span class="line">//这里回调contextLoaded()方法</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;准备上下文环境;将environment保存到ioc中；而且applyInitializers()</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void applyInitializers(ConfigurableApplicationContext context) &#123;</span><br><span class="line">for (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class="line">Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),</span><br><span class="line">ApplicationContextInitializer.class);</span><br><span class="line">Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);</span><br><span class="line">initializer.initialize(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里就将我们一开始从配置文件里面读取，然后创建ApplicationContextInitializer初始化。</p><p>&emsp;&emsp;当环境准备好之后，就回调了SpringApplicationRunListener的contextPrepared()；</p><p>&emsp;&emsp;当所有的都准备好了之后，回调SpringApplicationRunListener的contextLoaded()；</p><p>&emsp;&emsp;到这里，所有的环境都准备好了，需要打印的logo也加进去了。</p><h4 id="refreshContext"><a href="#refreshContext" class="headerlink" title="refreshContext()"></a>refreshContext()</h4><p>&emsp;&emsp;刷新容器这个方法，我们可以点到具体的功能实现里面，可以看到，这里就是扫描，创建，加载所有的组件，配置类，组件，自动配置等。</p><p>&emsp;&emsp;到这里，这个方法创建完之后，所有的控制器就创建完了，所有的组件，bean等，都在控制台打印出来了。如果是web应用，还会创建嵌入式的tomcat。我们spring boot项目内嵌tomcat，就是在这里创建的。</p><h4 id="afterRefresh"><a href="#afterRefresh" class="headerlink" title="afterRefresh()"></a>afterRefresh()</h4><p>&emsp;&emsp;1.5版本这个方法里面回调的是callRunners方法，而2.X版本，现在这是个空方法里面并没有实现。callRunners被提出来了，放到了最后面。</p><h4 id="started-running"><a href="#started-running" class="headerlink" title="started(),running()"></a>started(),running()</h4><p>&emsp;&emsp;在1.5版本这里，也就是afterRefresh()之后，应该是调用的SpringApplicationRunListeners的finished()方法。</p><p>&emsp;&emsp;在2.X版本之后，去掉了finished方法，改成了调用started方法，然后调用running方法。我们上面有一个starting方法，从这里名字就可以看出来，相当于，首先是正在启动当中，然后就是启动完成了，正在运行了。</p><h4 id="callRunners"><a href="#callRunners" class="headerlink" title="callRunners()"></a>callRunners()</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void callRunners(ApplicationContext context, ApplicationArguments args) &#123;</span><br><span class="line">List&lt;Object&gt; runners = new ArrayList&lt;&gt;();</span><br><span class="line">runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123;</span><br><span class="line">if (runner instanceof ApplicationRunner) &#123;</span><br><span class="line">callRunner((ApplicationRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line">if (runner instanceof CommandLineRunner) &#123;</span><br><span class="line">callRunner((CommandLineRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;从IOC容器中(不是配置文件)获取所有的的ApplicationRunner和CommandLineRunner进行回调。这也是最开始说的两个注意的地方</p><p>&emsp;&emsp;并且，这里有个先后顺序，先回调的ApplicationRunner，后回调的CommandLineRunner</p><p>&emsp;&emsp;这里也是run方法，最后执行的地方。从这里就是真正的开启了run。</p><p>&emsp;&emsp;最后一步，返回那个context就是返回IOC容器对象。到这里，我们的spring boot就启动完成了。</p><p>&emsp;&emsp;这就是我们的spring boot的启动原理。初始化，listener的回调，Runner的回调都说的很清楚。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;需要搞清楚几个重要的事件回调机制&lt;/p&gt;
&lt;p&gt;配置在META-INF/spring.factories&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ApplicationContextInitializer&lt;/li&gt;
&lt;li&gt;SpringApplicationRunListener&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只需要放在ioc容器中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ApplicationRunner &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CommandLineRunner&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Redis（十七）</title>
    <link href="https://haichenyi.com/2019/11/06/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Redis%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/11/06/SpringBoot系列—Redis（十七）/</id>
    <published>2019-11-06T08:40:38.000Z</published>
    <updated>2021-08-03T15:13:59.127Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前面一篇说到了spring boot自带的缓存SimpleCache，我们也聊到了他的底层实际上就是HashMap，并且这个缓存是放在内存当中的，这样弊端也是有的，比如：内存大小，当服务器关闭之后，缓存就没了等等。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;实际开发中，一般使用缓存中间件：Redis，EHCache，MemCache等等，今天，我们就来聊聊，经常听到的——Redis。</p><p>&emsp;&emsp;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）——来自官方介绍</p><p>&emsp;&emsp;不去追究原理，我们可以这样理解Redis：</p><ul><li>支持多种数据类型，redis支持set,zset,list,hash,string这五种数据类型，操作方便。</li><li>作为一个内存数据库，最担心的，就是万一机器死机宕机，数据就会消失掉。redis使用RDB和AOF做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。</li><li>与服务器解耦，缓存是一个单独的服务器，当我们项目重启的时候，缓存依然存在。</li><li>我们只用的话，它就是给我们提供了一系列方法的接口，我们只用调用它的API即可。</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;第一步，添加启动器：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第二步，配置你的服务器地址，不配置的话，默认是本地：配置信息一样在 <strong>自动配置类——data包——redis包——RedisProperties类</strong> 里面去找</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#指定redis服务器地址，指定的是本地</span><br><span class="line">spring.redis.host=127.0.0.1</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第三步，添加了redis的配置类，当数据库添加复杂数据的时候，也能以Json的格式正常显示。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport&#123;</span><br><span class="line">@Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        //key序列化方式</span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        //value序列化</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        //value hashmap序列化</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第四步，正常写接口，在service层里面，自己去把数据写进缓存里面，</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboottask.service;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboottask.Provider;</span><br><span class="line">import com.haichenyi.springboottask.mapper.ProviderMapper;</span><br><span class="line">import com.haichenyi.springboottask.utils.RedisClient;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Desc</span><br><span class="line"> * @Auther 海晨忆</span><br><span class="line"> * @Time 2019/11/6</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class ProviderService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    ProviderMapper providerMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    public Provider getProviderById(Integer pid) &#123;</span><br><span class="line">        Provider provider = (Provider) redisClient.get(pid);</span><br><span class="line">        if (provider != null) &#123;</span><br><span class="line">            return provider;</span><br><span class="line">        &#125;</span><br><span class="line">        Provider provider1 = providerMapper.getProviderByPid(pid);</span><br><span class="line">        redisClient.set(pid, provider1);</span><br><span class="line">        return provider1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;如上代码，我们通过id获取一个Provider，我们先从缓存去取，如果，取不到，说明缓存没有，那么，我们就去从数据库去取，取到之后，再把这条数据放进缓存里面。</p><p>&emsp;&emsp;就是上一篇讲默认缓存的注解的功能，redis里面需要我们自己去实现。</p><p>&emsp;&emsp;这里的 <strong>RedisClient</strong> 类，是自己封装的redis使用的类，至于redis怎么使用，redis的<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">中文官网</a>的命令页面写的很清楚。</p><p>&emsp;&emsp;记得本地电脑装一个Redis服务。然后再本地装一个redis可视化工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前面一篇说到了spring boot自带的缓存SimpleCache，我们也聊到了他的底层实际上就是HashMap，并且这个缓存是放在内存当中的，这样弊端也是有的，比如：内存大小，当服务器关闭之后，缓存就没了等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—缓存及其源码分析（十六）</title>
    <link href="https://haichenyi.com/2019/11/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E7%BC%93%E5%AD%98%E5%8F%8A%E5%85%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/11/05/SpringBoot系列—缓存及其源码分析（十六）/</id>
    <published>2019-11-05T02:52:46.000Z</published>
    <updated>2021-08-03T15:14:46.518Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;缓存是每个项目都用到的为了提高接口响应效率，降低数据库的查询压力，从而提高系统性能。所以，缓存对于一个项目来说是至关重要的。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;spring 3+之后，就定义了CacheManager和Cache接口来统一不同的缓存技术。</p><ul><li>CacheManager：缓存管理器，用于管理各种Cache缓存组件</li><li>Cahce：定义了各种操作，Spring在Cache接口下提供了各种xxCache的实现；比如：ConcurrentMapCache，RedisCache，JCacheCache等等</li></ul><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>&emsp;&emsp;这里我以默认缓存为例：ConcurrentMapCache</p><p>&emsp;&emsp;上面说了，缓存只用配置就可以直接使用，所以，配置，一说到配置，我们就会想到之前说的自动配置类AutoConfigure。如下图：</p><p><img src="/uploads/article/2019-11-05/缓存结构图.png" alt="缓存结构图.png"></p><p>&emsp;&emsp;我们看到，自动配置类目录下面有一个cache包，这就是缓存自动配置的包，我们熟悉的类就有CacheProperties这个类，我们点进去看：</p><p><img src="/uploads/article/2019-11-05/缓存配置类.png" alt="缓存配置类.png"></p><p>&emsp;&emsp;我们熟悉的prefix就在这里了，也就是我们在全局配置类里面的键。</p><p>&emsp;&emsp;这里，配置的一般都是这个类里面的全局变量，我把这个CacheType给框出来了（下面的cacheNames这个list变量也很重要），上面的注释的意思是说，缓存类型，默认情况下，是根据环境自动检测的。</p><p>&emsp;&emsp;我们上面说到CacheManager和Cache接口是用来同意管理不同的缓存技术。不同的，也就是指的我们这里的缓存类型。所以，我们这里的缓存类型肯定有好几种，然后，这里又讲是根据环境自动检测的。也就是我们配置好的。也就是我们在全局配置类里面配置好的</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.xxx=xxx</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;既然是配置，肯定是定义了之后才能配置的，没定义，怎么可能配置，spring又不是神。那，定义了那些种类的缓存技术呢？我们看一下CacheType类</p><p><img src="/uploads/article/2019-11-05/缓存枚举类.png" alt="缓存枚举类.png"></p><p>&emsp;&emsp;定义的，就这10种：GENERIC，JCACHE，EHCACHE，HAZELCAST，INFINISPAN，COUCHBASE，REDIS，CAFFEINE，SIMPLE，NONE。作为一个初学者，我想一眼看过去，我们能看到熟悉的Redis，学后天，Redis框架肯定要学。</p><p>&emsp;&emsp;我们现在，什么都没有配置，默认的缓存类型就是这个Simple，可以在Cache目录下面的CacheAutoConfiguration类中看到selectImports方法，在这里打断点，我们debug模式运行，我们就能看到它导入的缓存类型，然后，每个进行检测，看匹配哪一个。</p><p><img src="/uploads/article/2019-11-05/默认导入的缓存.png" alt="默认导入的缓存.png"></p><p>&emsp;&emsp;我们就看一下SimpleCacheConfiguration是怎么实现的</p><p><img src="/uploads/article/2019-11-05/SimpleCacheConfiguration图.png" alt="SimpleCacheConfiguration图.png"></p><p>&emsp;&emsp;我们看到了，SimpleCacheConfiguration默认使用的是：ConcurrentMapCacheManager，我们，看一下这个Manager是怎么实现的</p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCacheManager图1.png" alt="ConcurrentMapCacheManager图1.png"></p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCacheManager图2.png" alt="ConcurrentMapCacheManager图2.png"></p><p>&emsp;&emsp;这类，实现的就是CacheManager接口，而CacheManager接口就只有两个方法，就是上图中的两个方法<strong>setCacheNames</strong> 和 <strong>getCache</strong></p><p>&emsp;&emsp;先说一下数据是怎么缓存的，缓存是一个容器，这个容器怎么获取的呢？就是通过这里的name，name是获取这个容器的key，然后里面的数据存放形式，都是key-value的形式存放的。这个key也是我们定义的，value就是数据库查询的数据。如下图。</p><p><img src="/uploads/article/2019-11-05/缓存图.png" alt="缓存图.png"></p><p>&emsp;&emsp;这个setCacheNames，就是，我们配置的cacheNames的值，它会获取好之后，将这些值封装成list，通过setCacheNames方法赋值给这里的变量cacheMap。我们可以看一下这个变量：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final ConcurrentMap&lt;String, Cache&gt; cacheMap = new ConcurrentHashMap&lt;&gt;(16);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后就是这个getCache方法，上面的setCacheNames以cacheName为键去存这个Cache，这个就是刚好相反，获取方法，通过cacheName去获取这个Cache。</p><p>&emsp;&emsp;然后，我们现在是获取到了这个缓存容器，那么，我们要怎么从这个缓存容器中去获取我们对应的数据呢？</p><p>&emsp;&emsp;我们看到上面那个变量是Map是以String为键，以Cache为值，我们最开始说过了，Cache和CacheManager是用来管理不同缓存技术的接口，所以，这里的值不可能是一个接口对象，肯定是它的实现类，我们再仔细看上面两个方法的实现类，我们会看到</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//setCacheNames方法</span><br><span class="line">this.cacheMap.put(name, createConcurrentMapCache(name));</span><br><span class="line"></span><br><span class="line">//getCache方法</span><br><span class="line">cache = createConcurrentMapCache(name);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;很明显，这里就是Cache对象是怎么创建的，我们点到这个方法里面去看：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create a new ConcurrentMapCache instance for the specified cache name.</span><br><span class="line"> * @param name the name of the cache</span><br><span class="line"> * @return the ConcurrentMapCache (or a decorator thereof)</span><br><span class="line"> */</span><br><span class="line">protected Cache createConcurrentMapCache(String name) &#123;</span><br><span class="line">SerializationDelegate actualSerialization = (isStoreByValue() ? this.serialization : null);</span><br><span class="line">return new ConcurrentMapCache(name, new ConcurrentHashMap&lt;&gt;(256),</span><br><span class="line">isAllowNullValues(), actualSerialization);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;所以，它这里是new的ConcurrentMapCache肯定是Cache的实现类。我们看到这个构造方法，第二个参数是一个hashMap，而我们的缓存容器里面也是以键值对的方式存储数据的。我们再看这个ConcurrentMapCache</p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCache图.png" alt="ConcurrentMapCache图.png"></p><p>&emsp;&emsp;一共就只有三个全局变量，第一个name，是我们前面传过来的cacheName，第二个是Map<object,object>类型，第三个是SerializationDelegate类型的变量，序列化的一个什么东西。排除法判断，只可能这个Map就是用来存放我们的缓存数据的。我们搜索这个变量，我们会看到如下几个方法：</object,object></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   //获取缓存数据</span><br><span class="line">   @Override</span><br><span class="line">@Nullable</span><br><span class="line">protected Object lookup(Object key) &#123;</span><br><span class="line">return this.store.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   //存放</span><br><span class="line">   @Override</span><br><span class="line">public void put(Object key, @Nullable Object value) &#123;</span><br><span class="line">this.store.put(key, toStoreValue(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过key移除数据</span><br><span class="line">@Override</span><br><span class="line">public void evict(Object key) &#123;</span><br><span class="line">this.store.remove(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空所有数据</span><br><span class="line">@Override</span><br><span class="line">public void clear() &#123;</span><br><span class="line">this.store.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   //清空所有数据</span><br><span class="line">@Override</span><br><span class="line">public boolean invalidate() &#123;</span><br><span class="line">boolean notEmpty = !this.store.isEmpty();</span><br><span class="line">this.store.clear();</span><br><span class="line">return notEmpty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;至此，缓存怎么存放，怎么获取都说完了。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;与前面差不多，都是在启动类上面开启，在方法上面标记注解就行了</p><ol><li>@EnableCaching：在启动类上，开启基于注解的缓存</li><li>@Cacheable：标在方法上，返回的结果会进行缓存(先查缓存中的结果，没有则调用方法并将结果放到缓存中)</li><li>@CachePut：保证方法被调用后，又将对应缓存中的数据更新（先调用方法，调完方法再将结果放到缓存）</li><li>@CacheEvict：清除缓存</li></ol><p>&emsp;&emsp;@Cacheable，@CachePut，@CacheEvict三个注解都有几个重要的属性：</p><ul><li>cacheNames：缓存的名字。</li><li>key: 作为缓存中的Key值，可以使用SpEL表达式指定（不指定，key就是参数值），缓存结果是方法返回值</li></ul><p>&emsp;&emsp;上面两个属性是前面我们一直都在强调的比较重要的属性，然后，清除缓存的注解中还有两个属性需要了解:</p><ul><li>allEntries =true : 指定清除这个缓存中所有数据。</li><li>beforeInvocation = true : true在方法之前执行；默认false在方法之后执行,出现一场则不会清除缓存</li></ul><p>&emsp;&emsp;我这里值贴出来缓存相关的类：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Cacheable(cacheNames = &quot;user&quot;, key = &quot;#id&quot;)</span><br><span class="line">    public User getUser(Integer id) &#123;</span><br><span class="line">        return userMapper.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CachePut(cacheNames = &quot;user&quot;, key = &quot;#result.id&quot;)</span><br><span class="line">    public User updateUser(User user) &#123;</span><br><span class="line">        userMapper.updateUser(user);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CacheEvict(cacheNames = &quot;user&quot;, key = &quot;#result&quot;)</span><br><span class="line">    public Integer deleteUser(Integer id) &#123;</span><br><span class="line">        userMapper.deleteUserById(id);</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;第一步：默认采用的是SimpleCacheConfiguration 使用 ConcurrentMapCacheManager</p><p>&emsp;&emsp;第二步：getCache 获取的是 ConcurrentMapCache 缓存对象进行存取数据,它使用ConcurrentMap<object,object>对象进行缓存数据。</object,object></p><p>@Cacheable(cacheNames = “user”, key = “#id”)</p><p><strong>第一次请求时：</strong></p><p>&emsp;&emsp;第三步：当发送第一次请求时，会从getCache(name)中获取，看有没有ConcurrentMapCache缓存对象,如果没有 则创建出来, 并且创建出来的key就是通过</p><p>@Cacheable(cacheNames = “user”)标识的name值 </p><p>&emsp;&emsp;第四步：接着会从ConcurrentMapCache里面调用lookup获取缓存数据,通过key值获取的, </p><p>默认采用的是service方法中的参数值,如果缓存中没有获取到,则调用目标方法进行获取数据（即从数据库中查询）,获取之后则再将它 放到缓存中(key=参数值,value=返回值)</p><p><strong>第二次请求时：</strong></p><p>&emsp;&emsp;第五步：如果再次调用 则还是先ConcurrentMapCacheManager.getCache()获取缓存对象,如果有则直接返回, 如果没有则创建</p><p>&emsp;&emsp;第六步：然后再调用 ConcurrentMapCache.lookup方法从缓存中获取数据, 如果缓存有数据则直接响应回去,不 会再去调用目标方法</p><p><strong>第三次请求与第二次一样</strong></p><p>如果缓存中没有缓存管理器,则与第一次请求一致</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;缓存是每个项目都用到的为了提高接口响应效率，降低数据库的查询压力，从而提高系统性能。所以，缓存对于一个项目来说是至关重要的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—邮件（十五）</title>
    <link href="https://haichenyi.com/2019/10/31/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E9%82%AE%E4%BB%B6%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/10/31/SpringBoot系列—邮件（十五）/</id>
    <published>2019-10-31T09:12:19.000Z</published>
    <updated>2021-08-03T15:15:19.826Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;邮件发送是必不可少的，不管是注册邮件，还是广告。</p><a id="more"></a><p>&emsp;&emsp;spring boot中已经集成的mail的启动器，所以，我们只用配置好就行了。</p><p>&emsp;&emsp;引入启动器：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;那么，需要配置什么内容呢？我们之前讲过，需要配置的东西，spring boot都给我们提前准备好了，都在自动配置类AutoConfigure那个类里面，我们可以找一找，里面有个mail包，这个就是邮件的相关配置类。</p><p><img src="/uploads/article/2019-10-31/邮件配置.png" alt="邮件配置图.png"></p><p>&emsp;&emsp;我们可以看到上面的prefix中的spring.mail就是我们的配置文件中的前缀，这个类里面的公共变量，就是我们配置文件中的键。我们这里配置了四个值。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#配置邮箱账号</span><br><span class="line">spring.mail.username=371965177@qq.com</span><br><span class="line">spring.mail.password=XXXXXXX</span><br><span class="line">#配置发送邮件服务器</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">#配置ssl安全连接</span><br><span class="line">spring.mail.properties.smtp.ssl.enable = true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里的密码，我们不能填，我们的QQ号密码吧？需要在你的QQ邮箱去设置。生成授权码即可。直接百度一下：QQ邮箱怎么生成授权码，有教程。然后，把生成的授权码填到这里就行了。配置就这么多</p><p>&emsp;&emsp;怎么发送邮件呢？也很简单，分两种，一种是简单的文字邮件，一种是复杂带附件的邮件。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboottask;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.mail.SimpleMailMessage;</span><br><span class="line">import org.springframework.mail.javamail.JavaMailSenderImpl;</span><br><span class="line">import org.springframework.mail.javamail.MimeMessageHelper;</span><br><span class="line"></span><br><span class="line">import javax.mail.MessagingException;</span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class SpringBootTaskApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    JavaMailSenderImpl javaMailSender;</span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        //简单邮件</span><br><span class="line">        SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">        //邮件标题</span><br><span class="line">        message.setSubject(&quot;测试邮件功能标题&quot;);</span><br><span class="line">        //邮件内容</span><br><span class="line">        message.setText(&quot;测试邮件内容&quot;);</span><br><span class="line">        //发件人，必须要跟配置的相同</span><br><span class="line">        message.setFrom(&quot;371965177@qq.com&quot;);</span><br><span class="line">        //收件人</span><br><span class="line">        message.setTo(&quot;1640200266@qq.com&quot;);</span><br><span class="line">        javaMailSender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testMail() throws MessagingException &#123;</span><br><span class="line">        //带附件邮件，通过createMimeMessage()方法获取对象</span><br><span class="line">        MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">        //这里带附件的邮件需要用到这个帮助类</span><br><span class="line">        MimeMessageHelper messageHelper = new MimeMessageHelper(mimeMessage,true);</span><br><span class="line"></span><br><span class="line">        messageHelper.setSubject(&quot;测试邮件功能标题&quot;);</span><br><span class="line">        //可以发送html语句，第一个参数是内容，第二个参数设置为true即可。</span><br><span class="line">        messageHelper.setText(&quot;&lt;h1 style=&apos;color;blue&apos;&gt;测试邮件内容&lt;/h1&gt;&quot;,true);</span><br><span class="line">        //addAttachment添加附件的方法。第一个是名字，第二个是file</span><br><span class="line">        messageHelper.addAttachment(&quot;1.txt&quot;,new File(&quot;D:\\Download\\t.txt&quot;));</span><br><span class="line">        messageHelper.setFrom(&quot;371965177@qq.com&quot;);</span><br><span class="line">        messageHelper.setTo(&quot;1640200266@qq.com&quot;);</span><br><span class="line">        //这里发送的还是MimeMessage对象，并不是那个帮助类对象</span><br><span class="line">        javaMailSender.send(mimeMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;每一行都有注释，已经写的很清楚了，就不做过多的解释了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;邮件发送是必不可少的，不管是注册邮件，还是广告。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—异步任务与定时任务（十四）</title>
    <link href="https://haichenyi.com/2019/10/31/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/10/31/SpringBoot系列—异步任务与定时任务（十四）/</id>
    <published>2019-10-31T06:32:20.000Z</published>
    <updated>2021-08-03T15:15:14.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>&emsp;&emsp;什么时候用异步，就是耗时操作的时候就可以用到异步，比如：批量处理数据，批量发邮件等等。</p><a id="more"></a><p>&emsp;&emsp;用法与前面的事务管理类似，spring 3+之后，就已经内置了 <strong>@Async</strong> 来处理异步任务。我们使用两个注解即可。</p><ul><li>@EnableAysnc 启动类上开启基于注解的异步任务</li><li>@Aysnc 标识的方法会异步执行</li></ul><p>如：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@EnableAsync</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;批量操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        helloService.add();</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;当我们请求这个hello接口时，如果不使用@Async标记方法，那么，线程就会阻塞，我们会在add方法执行完之后，才会返回success。这显然不是我们想要的。</p><p>&emsp;&emsp;如果用@Async标记方法，那么，线程就不会阻塞，我们请求hello接口，会立刻返回success，过了三秒钟，才会批量处理完成。这才是我们想要的。</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>&emsp;&emsp;定时定点的执行某个任务，就需要用到定时任务。比如，当服务器启动之后，比如，每天晚上23点上传日志，每个月1号给用户发送邮件等等。</p><p>&emsp;&emsp;用法都类似：</p><ul><li>@EnableScheduling 启动类上开启基于注解的定时任务</li><li>@Scheduled 标识的方法会进行定时处理</li></ul><p>唯一不一样的地方，也是个难点就是cron表达式</p><p>先举个例子：在上面例子的基础上加上</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@EnableScheduling</span><br><span class="line">@EnableAsync</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;批量操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron = &quot;1-5 * * * * *&quot;)</span><br><span class="line">    public void scheduledTaskt() &#123;</span><br><span class="line">        System.out.println(&quot;执行定时任务&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这个定时任务就是,每分钟的1秒到5秒各执行一次，一共5次。</p><p>&emsp;&emsp;cron表达式一共六个值，每个值都要有。一个都不能少，分别代表的含义是：秒 分 时 日 月 星期几</p><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">取值范围</th><th style="text-align:center">可指定的特殊字符</th></tr></thead><tbody><tr><td style="text-align:center">秒</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">分</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">时</td><td style="text-align:center">0-23</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">日</td><td style="text-align:center">1-31</td><td style="text-align:center">, - * ? / L W C</td></tr><tr><td style="text-align:center">月</td><td style="text-align:center">1-12</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">星期</td><td style="text-align:center">0-7或SUN-SAT 0和7都是周日，1-6是周一到周六</td><td style="text-align:center">, - * ? / L C #</td></tr></tbody></table><p>&emsp;&emsp;特殊字符的含义：<br>|特殊字符|代表含义|<br>|:-:|:-:|<br>|,|枚举，一个位置上指定多个值，以逗号 ， 分隔|<br>|-|区间|<br>|*|任意|<br>|/|步长，每隔多久执行一次|<br>|?|日/星期冲突匹配 ,指定哪个值,另外个就是?|<br>|L|最后|<br>|W|工作日|<br>|C|和calendar联系后计算过的值|<br>|#|这个月的第几个星期几，4#2，第2个星期四|</p><p>比如：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1-5 * * * * 1到5秒，每秒都触发任务 */5 * * * * 每隔5秒执行一次</span><br><span class="line"></span><br><span class="line">0 */1 * * * 每隔1分钟执行一次 0 0 5-15 * * 每天5-15点整点触发</span><br><span class="line"></span><br><span class="line">0 0-5 14 * * 在每天下午2点到下午2:05期间的每1分钟触发</span><br><span class="line"></span><br><span class="line">0 0/5 14 * * 在每天下午2点到下午2:55期间的每5分钟触发</span><br><span class="line"></span><br><span class="line">0 0/5 14,18 * * 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</span><br><span class="line"></span><br><span class="line">0 0/30 9-17 * * 朝九晚五工作时间内每半小时</span><br><span class="line"></span><br><span class="line">0 0 12 ? * WED 表示每个星期三中午12点</span><br><span class="line"></span><br><span class="line">0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发</span><br><span class="line"></span><br><span class="line">0 0 23 L * ? 每月最后一天23点执行一次</span><br><span class="line"></span><br><span class="line">0 15 10 LW * ? 每个月最后一个工作日的10点15分0秒触发任务</span><br><span class="line"></span><br><span class="line">0 15 10 ? * 5#3 每个月第三周的星期五的10点15分0秒触发任务</span><br></pre></td></tr></table></figure></div><p>最后附上在线生成cron表达式的链接： <a href="http://cron.qqe2.com" target="_blank" rel="noopener">http://cron.qqe2.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;异步任务&quot;&gt;&lt;a href=&quot;#异步任务&quot; class=&quot;headerlink&quot; title=&quot;异步任务&quot;&gt;&lt;/a&gt;异步任务&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;什么时候用异步，就是耗时操作的时候就可以用到异步，比如：批量处理数据，批量发邮件等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—事务管理（十三）</title>
    <link href="https://haichenyi.com/2019/09/17/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/09/17/SpringBoot系列—事务管理（十三）/</id>
    <published>2019-09-17T05:37:31.000Z</published>
    <updated>2021-08-03T15:15:03.222Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;我们操作数据库，事务管理是必不可少的一部分。</p><a id="more"></a><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>&emsp;&emsp;我们在开发企业应用时，用户的一个操作对应数据库可能是多步操作相结合完成的。在这个多个步骤中，其中的一步，可能出现异常，导致后面的步骤无法向下进行，那么，用户的这个操作，可能就没有进行完，前面已经进行的步骤数据就需要回退。</p><p>举个总所周知的栗子：</p><p>&emsp;&emsp;银行的转账，A给B转账，转1000块钱，A的钱需要扣1000，B的钱需要加1000，而，银行的系统在A扣1000块钱之后，B加1000块钱的时候，出现的异常，A的钱扣了，B的钱没有加，这该怎么办？这就需要用到我们的事务管理了。</p><p>&emsp;&emsp;事务就是保证用户的每个操作都是可靠的，事务中的每一个步操作都必须成功执行，如果，其中某一个步骤出现了异常，那么就回退到事务开始未进行操作的状态。</p><p>&emsp;&emsp;事务管理是Spring框架中最为常见的功能之一，我们在SpringBoot开发应用时，大部分情况下也需要使用事务。</p><h3 id="事务管理操作步骤"><a href="#事务管理操作步骤" class="headerlink" title="事务管理操作步骤"></a>事务管理操作步骤</h3><p>&emsp;&emsp;理论上就只有两步：</p><ol><li>@EnableTransactionManagement：标记在启动类</li><li>@Transactional：标记的service层</li></ol><p>&emsp;&emsp;为什么说理论上只需要两步呢？因为，在SpringBoot中，当我们使用 <strong>spring-boot-starter-data-jdbc</strong> 或者是 <strong>spring-boot-starter-data-jpa</strong> 依赖的时候，框架会自动帮我们注入 <strong>入DataSourceTransactionManager</strong> 或者 <strong>JpaTransactionManager</strong> 。所以，我们不需要进行任何额外的配置，就直接可以使用 <strong>@Transactional</strong> 注解进行管理事务。</p><p>&emsp;&emsp;还有几点需要注意的地方：</p><ul><li>Hibernate创建表，默认类型是 <strong>MyISAM，</strong> 是非事务安全的，即使你加上了上面的注解，也不起作用。 <strong>Innodb</strong> 类型的表才是事务安全的。</li><li>需要在你的配置文件中指定： <strong>spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect</strong></li></ul><h3 id="事务的隔离级别和传播行为"><a href="#事务的隔离级别和传播行为" class="headerlink" title="事务的隔离级别和传播行为"></a>事务的隔离级别和传播行为</h3><p>&emsp;&emsp;除了指定事务管理器之后，还能对事务进行隔离级别和传播行为的控制，下面分别详细解释：</p><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>&emsp;&emsp;隔离级别是指在发生并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读、不可重复读、幻读。</p><ul><li><strong>脏读：A事务执行的过程中，修改了id=1的数据，这个时候还没有提交，此时，B读取了修改之后id=1的数据，而A事务却回滚了，这样B事务就形成了脏读。</strong> 比方说：A的银行卡里原来有1000块钱，买东西花了300，还有700，这个时候A的媳妇查银行卡的余额，一看只剩下700了，然后，A又不喜欢那个东西，把东西退掉了，买东西的钱又退回银行卡了，这个时候，A的媳妇查的钱这个事务就是脏读。回来之后一阵毒打，什么跪键盘，跪榴莲。唉，脏读，真惨。</li><li><strong>不可重复读：A事务先读取了id=1的数据，然后执行后面的逻辑，这个时候，B事务修改了id=1的数据，A在执行后面逻辑的时候，又读取了一遍id=1的数据，这个时候发现，两次读取的数据不相同，这就是不可重复读。</strong> 比方说：A发工资了，银行卡里发了1000块钱，每天早上查一遍，中午查一遍，好安心。早上9点上班的时候查了一遍余额有1000块钱，A的媳妇，十点多的时候买了个包包花了500块钱，A中午查的时候就剩下500了，他就去找他媳妇理论啊，你干啥了，咋就只剩下500了，他媳妇一听就来气啊，每个月挣这么点钱，我买个包包怎么了，然后就是一阵毒打，跪键盘，跪榴莲。唉，不可重复读，真惨。</li><li><strong>幻读：A事务先根据条件查询到了N条数据，然后，B事务新增了M条复合A事务查询条件的数据，导致A事务再次查询的时候，查询到了N+M条数据，就产生了幻觉。</strong> 比方说：A的媳妇查询A名下有多少张银行卡，一开始查询有2张（建行，农行），然后，A换了新工作，需要重新再邮政开工资卡。这一天，A的媳妇又查了一遍A名下的银行卡，咦，怎么多了一张邮政的，长能耐了，背着老娘藏私房钱了，于是，就把A一阵毒打，是跪键盘，跪榴莲。唉，幻读，真惨。</li></ul><p>&emsp;&emsp;怎么避免上面的三种情况呢？我们可以看  <strong>org.springframework.transaction.annotation.Isolation</strong>  枚举类中定义了五个表示隔离级<br>别的值：</p><ul><li><strong>DEFAULT：</strong> 这个是默认值，表示使用底层数据库的默认隔离级别，对绝大多数数据库而言，这个值通常就是 <strong>READ_COMMITTED。</strong></li><li><strong>READ_UNCOMMITTED：</strong> 该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。 <strong>该级别不<br>能防止脏读和不可重复读， 因此很少使用该隔离级别。</strong></li><li><strong>READ_COMMITTED：</strong> 该隔离级别表示一个事务只能读取另一个事务已经提交的数据。 <strong>该级别可以防止脏<br>读，这也是大多数情况下的推荐值，性能最好。</strong></li><li><strong>REPEATABLE_READ：</strong> 该隔离级别表示一个事务在整个执行过程中可以多次重复执行某个查询，并且每次返回的数据都相同，即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。 <strong>该级别可以<br>防止脏读和不可重复读。</strong></li><li><strong>SERIALIZABLE：</strong> 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说， <strong>该级别可<br>以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</strong> </li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定方式：</span><br><span class="line">@Transactional(isolation = Isolation.DEFAULT)</span><br></pre></td></tr></table></figure></div><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>&emsp;&emsp;传播行为是指，如果在开始当前事务之前，已经存在一个事务，此时可以指定这个要开始的这个事务的执行行为。</p><p>&emsp;&emsp;我们可以看  <strong>org.springframework.transaction.annotation.Propagation</strong>  枚举类中定义了6个表示传播行<br>为的枚举值：</p><ul><li>REQUIRED:（默认）如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li>SUPPORTS:如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>MANDATORY:如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>REQUIRES_NEW:创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>NOT_SUPPORTED:以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER:以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>NESTED:如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则<br>该取值等价于 REQUIRED 。</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定方式：</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRED)</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;关于这个事务的隔离级别和传播行为，我们一般都不用特别的去指定，用默认的就行了，除非有特别的要求，默认的隔离级别和传播行为满足绝大多数要求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;我们操作数据库，事务管理是必不可少的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Spring Data JPA（十二）</title>
    <link href="https://haichenyi.com/2019/09/11/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Spring-Data-JPA%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/09/11/SpringBoot系列—Spring-Data-JPA（十二）/</id>
    <published>2019-09-11T09:03:36.000Z</published>
    <updated>2021-08-03T15:14:15.575Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data"></a>什么是 Spring Data</h3><p>&emsp;&emsp;Spring Data 是 Spring Boot 底层默认进行数据访问的技术 , 为了简化构建基于 Spring 框架应用的数据访问技术，包<br>括非关系数据库、Map-Reduce 框架、云数据服务等；另外也包含对关系数据库的访问支持。</p><a id="more"></a><p>&emsp;&emsp;Spring Data 包含多个模块：</p><ul><li>Spring Data Commons 提供共享的基础框架，适合各个子项目使用，支持跨数据库持久化</li><li>Spring Data JPA</li><li>Spring Data KeyValue</li><li>Spring Data LDAP</li><li>Spring Data MongoDB</li><li>Spring Data Redis</li><li>Spring Data REST</li><li>Spring Data for Apache Cassandra</li><li>Spring Data for Apache Geode</li><li>Spring Data for Apache Solr</li><li>Spring Data for Pivotal GemFire</li><li>Spring Data Couchbase (community module)</li><li>Spring Data Elasticsearch (community module)</li><li>Spring Data Neo4j (community module)</li></ul><h3 id="Spring-Data统一的核心接口"><a href="#Spring-Data统一的核心接口" class="headerlink" title="Spring Data统一的核心接口"></a>Spring Data统一的核心接口</h3><p>&emsp;&emsp;Spring Data项目为大家提供统一的API来对不同的数据访问层进行操作。</p><p><img src="/uploads/article/2019-09-11/Repository.png" alt="Repository继承图.png"></p><ul><li>Repository<t, id="">：统一的根接口即所有接口的父接口，其他接口继承该接口</t,></li><li>CrudRepository<t, id="">：基本的增删改查接口,提供了最基本的对实体类CRUD操作</t,></li><li>PagingAndSortingRepository<t, id="">：增加了分页和排序操作</t,></li><li>JpaRepository<t, id="">：增加了批量操作，并重写了父接口一些方法的返回类型</t,></li></ul><p>&emsp;&emsp;Spring Data JPA、JPA与Hibernate 关系</p><p><img src="/uploads/article/2019-09-11/关系图.png" alt="关系图.png"></p><p>&emsp;&emsp;JPA是一种规范，而Hibernate是实现这种规范的底层实现，SpringData JPA对持久化接口JPA再抽象一层，针对持久化业务再进一步统一简化。</p><h3 id="SpringData-JPA的简单使用"><a href="#SpringData-JPA的简单使用" class="headerlink" title="SpringData JPA的简单使用"></a>SpringData JPA的简单使用</h3><p>&emsp;&emsp;JPA的底层遵守是ORM(对象关系映射)规范，因此JPA其实也就是java实体对象和关系型数据库建立起映射关系，通过<br>面向对象编程的思想操作关系型数据库的规范。</p><p><strong>首先，导包</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.haichenyi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-jpa&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;spring-boot-jpa&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--jdbc的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--jpa的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--web项目的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mysql的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--简化set/get的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></div><p><strong>其次，创建映射bean类</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.entity;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.persistence.*;</span><br><span class="line"></span><br><span class="line">//使用JPA注解配置映射关系</span><br><span class="line">@Entity//说明它是和数据表映射的类</span><br><span class="line">@Table(name = &quot;tbl_hobby&quot;)//指定对应映射的表名，省略默认表名就是类名</span><br><span class="line">@Data</span><br><span class="line">public class Hobby &#123;</span><br><span class="line">    @Id//标识主键</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)////标识自增长主键</span><br><span class="line">    private Integer id;</span><br><span class="line">    @Column(name = &quot;name&quot;, length = 10)//这是和数据表对应的一个列即字段名</span><br><span class="line">    private String name;</span><br><span class="line">    @Column//没有写，表字段名与这里的字段名相同</span><br><span class="line">    private Integer time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;需要注意的是，这里需要写set/get方法，不然，数据存不进去。这里我用了 <strong>@Data</strong> 注解，所以，就不需要写了。注释写的很清楚了，就不一一解释了。</p><p><strong>接着，写Repository</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.repository;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjpa.entity.Hobby;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义接口继承JpaRepository，就会crud及分页等基本功能</span><br><span class="line"> */</span><br><span class="line">//指定的泛型&lt;操作的实体类，主键的类型&gt;</span><br><span class="line">public interface HobbyRepository extends JpaRepository&lt;Hobby, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>再然后，就是Controller，跟之前写的一样</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjpa.entity.Hobby;</span><br><span class="line">import com.haichenyi.springbootjpa.repository.HobbyRepository;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HobbyController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    HobbyRepository hobbyRepository;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hobby/&#123;id&#125;&quot;)</span><br><span class="line">    public Hobby getHobbyInfo(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">        Optional&lt;Hobby&gt; hobbyOptional = hobbyRepository.findById(id);</span><br><span class="line">        return hobbyOptional.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/save&quot;)</span><br><span class="line">    public Hobby saveHobby(Hobby hobby) &#123;</span><br><span class="line">        System.out.println(hobby);</span><br><span class="line">        return hobbyRepository.save(hobby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>最后，就只配置了</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样写完就行了。就这四步：</p><ol><li>映射表</li><li>Repository接口</li><li>Controller</li><li>配置文件</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是-Spring-Data&quot;&gt;&lt;a href=&quot;#什么是-Spring-Data&quot; class=&quot;headerlink&quot; title=&quot;什么是 Spring Data&quot;&gt;&lt;/a&gt;什么是 Spring Data&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Spring Data 是 Spring Boot 底层默认进行数据访问的技术 , 为了简化构建基于 Spring 框架应用的数据访问技术，包&lt;br&gt;括非关系数据库、Map-Reduce 框架、云数据服务等；另外也包含对关系数据库的访问支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—MyBatis（十一）</title>
    <link href="https://haichenyi.com/2019/09/07/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94MyBatis%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/09/07/SpringBoot系列—MyBatis（十一）/</id>
    <published>2019-09-07T10:56:22.000Z</published>
    <updated>2021-08-03T15:13:53.289Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇，Druid是用于处理数据库连接池与后台监控。</p><a id="more"></a><p>&emsp;&emsp;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。——百度百科</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;MyBatis添加依赖跟SpringBoot的其他启动器不一样，MyBatis需要写版本号，因为，SpringBoot并没有MyBatis的启动器。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="注解的方式"><a href="#注解的方式" class="headerlink" title="注解的方式"></a>注解的方式</h4><p>&emsp;&emsp;先看一下项目结构：</p><p><img src="/uploads/article/2019-09-07/项目结构图.png" alt="项目结构图.png"></p><p>&emsp;&emsp;首先，我们先在连接的数据库里面创建表，添加几条数据。</p><p>&emsp;&emsp;然后，创建pojo类User，对应我的表</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    public Long UserId;</span><br><span class="line">    public String Username;</span><br><span class="line">    public String password;</span><br><span class="line">    public String nickName;</span><br><span class="line">    public String headImg;</span><br><span class="line">    public Integer age;</span><br><span class="line">    public Integer sex;</span><br><span class="line">    public String address;</span><br><span class="line">    public String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;接着，创建mapper接口</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.mapper;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    @Select(&quot;select * from userinfo&quot;)</span><br><span class="line">    List&lt;User&gt; getUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是一个普通的接口，用 <strong>@Mapper</strong> 标识了。然后写了一个获取用户信息的方法。 <strong>@Select</strong> 里面是sql语句。</p><p>&emsp;&emsp;用 <strong>@Mapper</strong> 标识的接口，在运行的过程中，会帮我们生成实现类，到时候，我们直接通过这个接口的引用调用这个方法即可。我们也可以在入口的位置用 <strong>@MapperScan</strong> 标识包名，应用启动的时候，会给这个包下面的所有接口都生成实现类。如下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc;</span><br><span class="line"></span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@MapperScan(&quot;com.haichenyi.springbootjdbc.mapper&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootJdbcApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootJdbcApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;最后，就是我们的controller层了。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.mapper.UserMapper;</span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/getUserInfo&quot;)</span><br><span class="line">    public List&lt;User&gt; getUserInfo() &#123;</span><br><span class="line">        return userMapper.getUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样，我们就可以通过 <a href="http://localhost:8080/getUserInfo" target="_blank" rel="noopener">http://localhost:8080/getUserInfo</a> 读到数据库中的数据了</p><p>&emsp;&emsp;只这样，我们读到的数据，如果表字段与pojo类的字段不一一对应，我们可能读到的数据为空，所以，我们要开启驼峰命名，开启之后MyBatis会帮我们一一对应好。怎么开启呢？就在我们前面的JdbcConfig中添加如下方法即可。就跟我们前面一篇Druid添加配置类似。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * MyBatis自定义配置</span><br><span class="line">  *</span><br><span class="line">  * @return ConfigurationCustomizer</span><br><span class="line">  */</span><br><span class="line"> @Bean</span><br><span class="line"> public ConfigurationCustomizer configurationCustomizer() &#123;</span><br><span class="line">     return configuration -&gt; &#123;</span><br><span class="line">         //开启驼峰命名</span><br><span class="line">         configuration.setMapUnderscoreToCamelCase(true);</span><br><span class="line">         //开启二级缓存</span><br><span class="line">         configuration.setCacheEnabled(true);</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样就可以了。</p><h4 id="xml的方式"><a href="#xml的方式" class="headerlink" title="xml的方式"></a>xml的方式</h4><p>&emsp;&emsp;前面和后面都是一样的，就是中间那不创建mapper接口不一样。xml中怎么创建mapper呢？</p><p>&emsp;&emsp;首先，还是创建一个正常的接口，定义方法。如下：注释写的很清楚了。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.mapper;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">//这里如果没有@Mapper注解，那就在启动类添加@MapperScan注解，上面已经说过怎么添加了。两种方式都可以，标记mapper的接口还是需要的</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">//这里的sql语句就不需要了，sql语句在xml里面配置。</span><br><span class="line">//    @Select(&quot;select * from userinfo&quot;)</span><br><span class="line">    List&lt;User&gt; getUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后，添加两个xml，一个是config，一个是写sql语句的。路径需要注意，先在resources目录下创建一个mybatis目录，在mybatis目录下创建mybatis-config.xml，在mybatis目录下创建mapper目录，然后在mapper目录下创建你的mapper.xml文件，如下：</p><p>&emsp;&emsp;这个是写mybatis配置文件的，名字我写的是：mybatis-config.xml，这个路径<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;!--开启驼峰命名--&gt;</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;然后就是创建mapper.xml，这里，我们以UserMapper.xml为例：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--namespace要是你前面创建mapper接口的全路径，这样才能对应--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.haichenyi.springbootjdbc.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;!--id：是你前面接口里面创建的方法名--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    resultType：这里的返回类型就是你接口读取数据对应的bean类，不管你需要的是集合，还是单个对象，这里都是你bean类，</span><br><span class="line">    如果你读取的是多条数据，它会自动帮你封装成list，拿到这个list，你再去做你其他的处理</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;getUserInfo&quot; resultType=&quot;com.haichenyi.springbootjdbc.pojo.User&quot;&gt;</span><br><span class="line">        select * from userinfo</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;注释写的很清楚了。</p><p>&emsp;&emsp;再就是配置这个两个xml路径了，你需要在你的全局配置文件中配置好，指定对应的路径：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  #核心配置文件路径</span><br><span class="line">  config-location: classpath:mybatis/mybatis-config.xml</span><br><span class="line">  #映射配置文件路径</span><br><span class="line">  mapper-locations: classpath:mybatis/mapper/*.xml</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;为啥非要创建一个mapper目录，再创建mapper文件呢？就是这里好指定。mapper文件肯定不止一个，难道你要一个一个的配置吗？这样写只用指定一个就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇，Druid是用于处理数据库连接池与后台监控。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Druid（十）</title>
    <link href="https://haichenyi.com/2019/09/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Druid%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/09/05/SpringBoot系列—Druid（十）/</id>
    <published>2019-09-05T08:05:30.000Z</published>
    <updated>2021-08-03T15:13:42.379Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;一个企业项目中最重要的部分那就是数据库了，对数据库的连接，读写是重中之重。在SpringBoot中数据库怎么连接呢？</p><a id="more"></a><h3 id="数据库的连接"><a href="#数据库的连接" class="headerlink" title="数据库的连接"></a>数据库的连接</h3><p>&emsp;&emsp;这里以MySql为例，还不会用MySql数据库的童鞋，可以看我之前的博客，<a href="https://blog.csdn.net/qq_27634797/article/category/8050256" target="_blank" rel="noopener">数据库相关</a>。</p><p>&emsp;&emsp; <strong>第一步，</strong> 我们首先在pom.xml中添加jdbc相关的启动器。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--jdbc启动器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--mysql驱动包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; <strong>第二步，</strong> 在配置文件中配置连接数据库的信息：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    #连接数据库的账号</span><br><span class="line">    username: root</span><br><span class="line">    #连接数据库的密码</span><br><span class="line">    password: 123456</span><br><span class="line">    #连接数据库的url</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    #连接数据库的驱动类</span><br><span class="line">    #mysql8之前用的是：com.mysql.jdbc.Driver。</span><br><span class="line">    #mysql8之后用的是：com.mysql.cj.jdbc.Driver</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 添加如上信息，就基本上完成了。测试一下连接就可以了。在我们的测试类中添加如下代码，看看打印的数据即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringBootJdbcApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() throws SQLException &#123;</span><br><span class="line">        System.out.println(&quot;dataSource: &quot; + dataSource.getClass());</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(&quot;connection: &quot; + connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 我们这里是测试数据库是否连接成功，我们才获取的这个连接，打印出来，我们项目里面实际操作数据库的时候，不需要我们获取这个连接，然后通过这个连接再去操作数据库。这是不需要，MyBatis通过Mapping注解直接操作数据库，我们只用写sql语句就可以了。</p><h3 id="Druid连接数据库"><a href="#Druid连接数据库" class="headerlink" title="Druid连接数据库"></a>Druid连接数据库</h3><p>&emsp;&emsp; DRUID是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是目前最好的连接池。</p><p>&emsp;&emsp; <strong>上面的配置继续保留。</strong></p><p>&emsp;&emsp; <strong>第一步：</strong> 我们在pom.xml里面添加druid的依赖：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.20&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; <strong>第二步：</strong> 在yml文件中添加如下代码：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  # 数据库访问配置</span><br><span class="line">  datasource:</span><br><span class="line">    #账号</span><br><span class="line">    username: root</span><br><span class="line">    #密码</span><br><span class="line">    password: 123456</span><br><span class="line">    #连接的url</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    #驱动类</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # 主数据源，默认的</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">    # 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line">    # 初始化大小，最小，最大</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    # 配置获取连接等待超时的时间</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    # 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 25</span><br><span class="line">    # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">    filters: stat,wall,logback</span><br><span class="line">    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="line">    # 合并多个DruidDataSource的监控数据</span><br><span class="line">    useGlobalDataSourceStat: true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 这样，就可以了。继续运行刚才的测试方法，你会发现，打印数据里面数据源已经变成了DruidDataSource。</p><p>&emsp;&emsp; 你如果是debug运行的，并且，你的断点打在connection那里，你会发现，我们yml文件中的补充配置，没起作用，是为什么呢？</p><p>&emsp;&emsp; 我们按住CTRL，鼠标左键点补充配置里面的任意一个变量，都点不动，我们点上面的type，url等等，都能点，我们点过去看，我们会发现跳到了 <strong>DataSourceProperties</strong> 。这个类，顾名思义这是数据源配置文件类。我们大致看一下这个类的代码：</p><p><img src="/uploads/article/2019-09-05/DataSourceProperties类.png" alt="DataSourceProperties类.png"></p><p>&emsp;&emsp; 用红色框框，框出来的地方是不是很眼熟？</p><p>&emsp;&emsp; 首先，我们先看注解 <strong>@ConfigurationProperties，</strong> 这个注解就是表示这个类是配置类，然后，我们看括号里面的参数 <strong>prefix，</strong> 顾名思义：前缀，前置代码。</p><p><img src="/uploads/article/2019-09-05/yml文件.png" alt="yml文件.png"></p><p>&emsp;&emsp; 如上图，上面的红色框框的内容，就由prefix决定，下面红色框框的内容，就由这个类的变量决定。我们上面的补充设置不起作用，就是因为这个配置文件里面没有这些变量，SpringBoot识别不了，所以，不起作用。SpringBoot不是万能的，它配置了的东西，可以识别，没有配置的，识别不了。</p><p>&emsp;&emsp; 怎么样让上面的补充配置起作用呢？有多种方式：</p><p>&emsp;&emsp; <strong>第一种方式如下：</strong> 简单粗暴，添加一个配置类即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource()&#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 这个方式就相当于，把我们上面的这个 <strong>DataSourceProperties</strong>配置类，换成了 <strong>DruidDataSource</strong>类。</p><p>&emsp;&emsp; <strong>第二种方式如下：</strong> 比较麻烦，也不算特别麻烦：说白了就是加载局部配置。</p><p>&emsp;&emsp;首先，在resources目录下，新建一个jdbc.properties文件</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#账号</span><br><span class="line">druid.datasource.username=root</span><br><span class="line">#密码</span><br><span class="line">druid.datasource.password=123456</span><br><span class="line">#连接的url</span><br><span class="line">druid.datasource.url=jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">#驱动类</span><br><span class="line">druid.datasource.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line"># 主数据源，默认的</span><br><span class="line"># druid.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"># 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line"># 初始化大小，最小，最大</span><br><span class="line">druid.datasource.initialSize=5</span><br><span class="line">druid.datasource.minIdle=5</span><br><span class="line">druid.datasource.maxActive=20</span><br><span class="line"># 配置获取连接等待超时的时间</span><br><span class="line">druid.datasource.maxWait=60000</span><br><span class="line"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">druid.datasource.timeBetweenEvictionRunsMillis=60000</span><br><span class="line"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">druid.datasource.minEvictableIdleTimeMillis=300000</span><br><span class="line">druid.datasource.validationQuery=SELECT 1 FROM DUAL</span><br><span class="line">druid.datasource.testWhileIdle=true</span><br><span class="line">druid.datasource.testOnBorrow=false</span><br><span class="line">druid.datasource.testOnReturn=false</span><br><span class="line"># 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">druid.datasource.poolPreparedStatements=true</span><br><span class="line">druid.datasource.maxPoolPreparedStatementPerConnectionSize=25</span><br><span class="line"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">druid.datasource.filters=stat,wall,logback</span><br><span class="line"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">druid.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="line"># 合并多个DruidDataSource的监控数据</span><br><span class="line">druid.datasource.useGlobalDataSourceStat=true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是把我们刚才在全局配置中配置的信息，在专门的jdbc的配置文件中配置一遍。然后，修改我们的JdbcConfig类。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@PropertySource(value = &quot;classpath:config/jdbc.properties&quot;, ignoreResourceNotFound = true)</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.driverClassName&#125;&quot;)</span><br><span class="line">    private String driverClassName;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.initialSize&#125;&quot;)</span><br><span class="line">    private Integer initialSize;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.minIdle&#125;&quot;)</span><br><span class="line">    private Integer minIdle;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxActive&#125;&quot;)</span><br><span class="line">    private Integer maxActive;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxWait&#125;&quot;)</span><br><span class="line">    private Long maxWait;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.timeBetweenEvictionRunsMillis&#125;&quot;)</span><br><span class="line">    private Long timeBetweenEvictionRunsMillis;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.minEvictableIdleTimeMillis&#125;&quot;)</span><br><span class="line">    private Long minEvictableIdleTimeMillis;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.validationQuery&#125;&quot;)</span><br><span class="line">    private String validationQuery;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testWhileIdle&#125;&quot;)</span><br><span class="line">    private Boolean testWhileIdle;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testOnBorrow&#125;&quot;)</span><br><span class="line">    private Boolean testOnBorrow;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testOnReturn&#125;&quot;)</span><br><span class="line">    private Boolean testOnReturn;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxPoolPreparedStatementPerConnectionSize&#125;&quot;)</span><br><span class="line">    private Integer maxPoolPreparedStatementPerConnectionSize;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.poolPreparedStatements&#125;&quot;)</span><br><span class="line">    private Boolean poolPreparedStatements;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.filters&#125;&quot;)</span><br><span class="line">    private String filters;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.connectionProperties&#125;&quot;)</span><br><span class="line">    private String connectionProperties;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.useGlobalDataSourceStat&#125;&quot;)</span><br><span class="line">    private Boolean useGlobalDataSourceStat;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() throws SQLException &#123;</span><br><span class="line">        DruidDataSource druidDataSource = new DruidDataSource();</span><br><span class="line">        druidDataSource.setUsername(username);</span><br><span class="line">        druidDataSource.setPassword(password);</span><br><span class="line">        druidDataSource.setUrl(url);</span><br><span class="line">        druidDataSource.setDriverClassName(driverClassName);</span><br><span class="line">        druidDataSource.setInitialSize(initialSize);</span><br><span class="line">        druidDataSource.setMinIdle(minIdle);</span><br><span class="line">        druidDataSource.setMaxActive(maxActive);</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);</span><br><span class="line">        druidDataSource.setValidationQuery(validationQuery);</span><br><span class="line">        druidDataSource.setTestOnBorrow(testOnBorrow);</span><br><span class="line">        druidDataSource.setTestOnReturn(testOnReturn);</span><br><span class="line">        druidDataSource.setTestWhileIdle(testWhileIdle);</span><br><span class="line">        druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);</span><br><span class="line">        druidDataSource.setPoolPreparedStatements(poolPreparedStatements);</span><br><span class="line">        druidDataSource.setFilters(filters);</span><br><span class="line">        druidDataSource.setConnectionProperties(connectionProperties);</span><br><span class="line">        druidDataSource.setUseGlobalDataSourceStat(useGlobalDataSourceStat);</span><br><span class="line">        return druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是加载配置文件，然后在DataSource里面赋值。这样，就可以了。</p><h3 id="Druid后台监控"><a href="#Druid后台监控" class="headerlink" title="Druid后台监控"></a>Druid后台监控</h3><p>&emsp;&emsp;之所以用Druid连接池，还有很大一部分原因就是它的监控功能。它能很好的监控DB连接池和SQL语句的执行情况。在上面的JdbcConfig类中添加如下两个方法即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 配置Druid监控</span><br><span class="line"> *</span><br><span class="line"> * @return StatViewServlet</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean servletRegistrationBean() &#123;</span><br><span class="line">    ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //访问的用户名密码</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_USERNAME, &quot;haichenyi&quot;);</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_PASSWORD, &quot;123456&quot;);</span><br><span class="line">    //允许访问的ip，默认是所有ip</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_ALLOW, &quot;&quot;);</span><br><span class="line">    //禁止访问的ip</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_DENY, &quot;192.168.1.1&quot;);</span><br><span class="line">    bean.setInitParameters(map);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 配置一个监控的filter</span><br><span class="line"> *</span><br><span class="line"> * @return WebStatFilter</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean filterRegistrationBean() &#123;</span><br><span class="line">    FilterRegistrationBean&lt;WebStatFilter&gt; bean = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">    bean.setFilter(new WebStatFilter());</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //移除这些监听</span><br><span class="line">    map.put(WebStatFilter.PARAM_NAME_EXCLUSIONS, &quot;*.js,*.css,/druid/*,*.gif,*.jpg,*.png&quot;);</span><br><span class="line">    bean.setInitParameters(map);</span><br><span class="line">    //拦截所有请求，全部都要走druid监听</span><br><span class="line">    bean.setUrlPatterns(Collections.singletonList(&quot;/*&quot;));</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;注释写的很清楚了，控制台怎么访问呢？ <strong><a href="http://localhost:8080/druid" target="_blank" rel="noopener">http://localhost:8080/druid</a></strong>。访问控制台</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;一个企业项目中最重要的部分那就是数据库了，对数据库的连接，读写是重中之重。在SpringBoot中数据库怎么连接呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—自定义拦截器（九）</title>
    <link href="https://haichenyi.com/2019/09/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/09/05/SpringBoot系列—自定义拦截器（九）/</id>
    <published>2019-09-05T08:05:12.000Z</published>
    <updated>2021-08-03T15:15:25.126Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;拦截器拦截请求做额外的处理。</p><a id="more"></a><p><strong>举个栗子：登录拦截器，拦截所有的请求，必须登录之后才能访问。</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.interceptors;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 登录拦截器</span><br><span class="line"> */</span><br><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line">        if (user != null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(&quot;msg&quot;, &quot;您还没有登录，请先登录！&quot;);</span><br><span class="line">        request.getRequestDispatcher(&quot;/index.html&quot;).forward(request, response);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;新建LoginInterceptor实现HandlerInterceptor接口。这个接口有三个方法，<strong>pre，post，after，</strong>  看这个名字就可以想到这三个方法是怎么调用的，发送请求前，发送过程中，发送请求成功之后，所以，根据自己的需求，实现对应的方法即可。</p><p>&emsp;&emsp;我这里是登录拦截器，所以，在发送请求之前就要拦截，走自己的逻辑，如果，没有登陆过，就跳转登录界面，所以，我这里就实现了发送请求之前的回调，即preHandle方法。</p><p>&emsp;&emsp;然后，在你的SpringMvcConfiguration里面加上拦截器即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.config;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootbill.component.MyLocalResolver;</span><br><span class="line">import com.haichenyi.springbootbill.interceptors.LoginInterceptor;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.LocaleResolver;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class MySpringMvcConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebMvcConfigurer webMvcConfigurer() &#123;</span><br><span class="line">        return new WebMvcConfigurer() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">                registry.addViewController(&quot;/&quot;).setViewName(&quot;main/login&quot;);</span><br><span class="line">                registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;main/login&quot;);</span><br><span class="line">                registry.addViewController(&quot;/main/index.html&quot;).setViewName(&quot;main/index&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">                registry.addInterceptor(new LoginInterceptor())</span><br><span class="line">                        .addPathPatterns(&quot;/**&quot;)</span><br><span class="line">                        .excludePathPatterns(&quot;/&quot;, &quot;/index.html&quot;, &quot;/login&quot;)</span><br><span class="line">                        .excludePathPatterns(&quot;/css/*&quot;,&quot;/img/*&quot;,&quot;/images/*&quot;,&quot;/js/*&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LocaleResolver localeResolver() &#123;</span><br><span class="line">        return new MyLocalResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;实现addInterceptors方法，添加拦截器，然后添加了  <strong>addPathPatterns</strong> 拦截所有带这个参数的请求。接着，又添加了 <strong>excludePathPatterns</strong> 不拦截所有带这个参数的请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;拦截器拦截请求做额外的处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—国际化（八）</title>
    <link href="https://haichenyi.com/2019/09/02/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/09/02/SpringBoot系列—国际化（八）/</id>
    <published>2019-09-02T08:14:09.000Z</published>
    <updated>2021-08-03T15:14:40.422Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;所谓的国际化就是语言切换。中文切换到其他语种。</p><p>&emsp;&emsp;国际化的信息，这些都是需要开发人员在配置类中配置好的。SpringBoot会自动加载这些配置类。</p><a id="more"></a><p>举个栗子：以登录界面为例，我们的登录界面输入账号、密码框的左边，会有这两个提示，我们就自动修改这两个提示。</p><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>&emsp;&emsp;首先，你要在你的resources目录下面新建i18n目录，当然，不是必须的，可以不创建，直接创建文件。之所以创建这个目录，只是便于管理。</p><p>&emsp;&emsp;然后，在i18n目录下面创建配置文件，操作如下：</p><p><img src="/uploads/article/2019-09-02/创建配置文件1.png" alt="创建配置文件1.png"></p><p>&emsp;&emsp;在i18n的目录下面，新建一个Resources Bundle类型的文件，名字叫login</p><p><img src="/uploads/article/2019-09-02/创建配置文件2.png" alt="创建配置文件2.png"></p><p><img src="/uploads/article/2019-09-02/创建配置文件3.png" alt="创建配置文件3.png"></p><p>&emsp;&emsp;点击+号，创建中文，英文两种语言的配置文件。中文叫 <strong>zh_CN</strong>，英文叫 <strong>en_US</strong>，这两种类型是写死的。</p><p><img src="/uploads/article/2019-09-02/创建配置文件4.png" alt="创建配置文件4.png"></p><p><img src="/uploads/article/2019-09-02/创建配置文件5.png" alt="创建配置文件5.png"></p><p><img src="/uploads/article/2019-09-02/创建配置文件6.png" alt="创建配置文件6.png"></p><p>&emsp;&emsp;根据如上操作，分别创建key为login.username，login.password，并且分别创建好对应的内容。这个key，页面会用到。</p><p>PS：不要忘记了，在全局配置文件中配置好，<strong>spring.messages.basename=i18n.login</strong>，这里现在是只有一个登陆页面需要国际化，如果有多个页面需要，比方说注册页面，就在后面添加。如：spring.messages.basename=i18n.login,i19n.register这样的方式，中间用逗号隔开即可。</p><h3 id="修改页面显示内容"><a href="#修改页面显示内容" class="headerlink" title="修改页面显示内容"></a>修改页面显示内容</h3><p>&emsp;&emsp;按照上面的步骤，创建好了之后，在你页面需要国际化的view，分别按如下的方式获取值：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--th:text=&quot;#&#123;上面命名的key&#125;&quot;--&gt;</span><br><span class="line">&lt;div class=&quot;inputbox&quot;&gt;</span><br><span class="line">                &lt;label for=&quot;user&quot; th:text=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/label&gt;</span><br><span class="line">                &lt;input id=&quot;user&quot; type=&quot;text&quot; name=&quot;username&quot; required/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;inputbox&quot;&gt;</span><br><span class="line">                &lt;label for=&quot;mima&quot; th:text=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/label&gt;</span><br><span class="line">                &lt;input id=&quot;mima&quot; type=&quot;password&quot; name=&quot;password&quot; required/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br></pre></td></tr></table></figure></div><h3 id="自定义区域解析器"><a href="#自定义区域解析器" class="headerlink" title="自定义区域解析器"></a>自定义区域解析器</h3><p>&emsp;&emsp;区域解析器LocaleResolver，按如下的方式实现即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.component;</span><br><span class="line"></span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import org.springframework.web.servlet.LocaleResolver;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义区域解析器</span><br><span class="line"> */</span><br><span class="line">public class MyLocalResolver implements LocaleResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123;</span><br><span class="line">        String l = httpServletRequest.getParameter(&quot;l&quot;);</span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        if (!StringUtils.isEmpty(l)) &#123;</span><br><span class="line">            String[] s = l.split(&quot;_&quot;);</span><br><span class="line">            locale = new Locale(s[0], s[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;最后，在你对应的超链接的地方传 <strong>zh_CN</strong> 和 <strong>en_US</strong> 即可实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;所谓的国际化就是语言切换。中文切换到其他语种。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;国际化的信息，这些都是需要开发人员在配置类中配置好的。SpringBoot会自动加载这些配置类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—热部署与SpringMVC扩展功能（七）</title>
    <link href="https://haichenyi.com/2019/08/30/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E7%83%AD%E9%83%A8%E7%BD%B2%E4%B8%8ESpringMVC%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>https://haichenyi.com/2019/08/30/SpringBoot系列—热部署与SpringMVC扩展功能（七）/</id>
    <published>2019-08-30T02:43:40.000Z</published>
    <updated>2021-08-03T15:14:57.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><p>&emsp;&emsp;默认情况下，在开发中我们修改一个项目文件后，想看到效果不得不重启应用，这会导致浪费大量时间，我们希望不重启应用的情况下，程序可以自动部署（热部署）。</p><a id="more"></a><p>&emsp;&emsp;<strong>第一步：禁用缓存</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#开发环境下关闭thymeleaf模板缓存，thymeleaf默认是开启状态。记得发布的时候要打开</span><br><span class="line">spring.thymeleaf.cache=false</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;<strong>第二步：添加热部署依赖</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--热部署--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;<strong>第三步：手动编译文件</strong></p><p>&emsp;&emsp;IDEA中，修改文件后都是自动保存的，并不会手动编译，所以，需要手动编译一下。Ctrl + F9 （推荐使用）或 Build -&gt; Build Project。</p><h3 id="SpringMVC-扩展功能"><a href="#SpringMVC-扩展功能" class="headerlink" title="SpringMVC 扩展功能"></a>SpringMVC 扩展功能</h3><p>举个栗子：我要访问前面都是在controller里面，写方法，方法里面可以写逻辑，跳转某一个页面。我现在不需要写逻辑，就直接跳转就行了。我可以这样写。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootwebthymeleaf.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        registry.addViewController(&quot;/success&quot;).setViewName(&quot;success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>新建一个类，继承WebMvcConfigurer，并用@Configuration标识</li><li>实现addViewControllers方法，里面registry里面像上面添加就行了，前面传链接名字，后面传视图名字即可。</li></ul><p>&emsp;&emsp;这只是添加控制层，还有其他的功能。可以看WebMvcConfigurer接口的方法。需要什么功能，实现什么方法就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;热部署&quot;&gt;&lt;a href=&quot;#热部署&quot; class=&quot;headerlink&quot; title=&quot;热部署&quot;&gt;&lt;/a&gt;热部署&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;默认情况下，在开发中我们修改一个项目文件后，想看到效果不得不重启应用，这会导致浪费大量时间，我们希望不重启应用的情况下，程序可以自动部署（热部署）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="https://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
</feed>
