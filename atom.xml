<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haichenyi.com/"/>
  <updated>2019-11-13T06:45:42.615Z</updated>
  <id>http://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot系列-Docker（十九）</title>
    <link href="http://haichenyi.com/2019/11/13/SpringBoot%E7%B3%BB%E5%88%97-Docker%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/11/13/SpringBoot系列-Docker（十九）/</id>
    <published>2019-11-13T06:44:37.000Z</published>
    <updated>2019-11-13T06:45:42.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，<br>然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><a id="more"></a><p>&emsp;&emsp;容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。</p><p>&emsp;&emsp;我们spring boot项目，什么地方需要用到dockers呢？我们最后项目发布，发到服务器上面，环境怎么搭建？如果就用Linux命令会很麻烦，用Docker，简单的几行命令就可以了。</p><p>&emsp;&emsp;服务器其实就是一个操作系统，我们的项目跑在上面也是需要环境的，我们本地是windows系统，跑项目需要环境，服务器现在一般都是centOS系统，当然也需要环境。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>docker镜像(images)：Docker镜像用于创建Docker容器的模板</li><li>docker容器(container)：Docker容器是独立运行的一个或者一组应用</li><li>docker客户端(client)：客户端通过命令或者其他工具一起使用docker api与docker守护进程</li><li>docker主机(host)：一个物理或者虚拟的机器用于执行docker守护进程和容器</li><li>docker仓库(registry)：docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。docker hub提供了庞大的镜像集合供使用</li></ul><p>&emsp;&emsp;举个例子，我们一般操作流程是这样的：</p><ol><li>先用VirtualBox启动一个虚拟机，启动的是centOS系统，装上docker程序（docker主机）。这个对应的就是我们项目最后发布的服务器。</li><li>然后，用SecureCRT连上我们这个虚拟机。（docker客户端）。</li><li>接着，通过docker从docker 仓库中下载我们需要的镜像，比方说：mysql镜像，redis镜像等等。</li><li>最后，启动这个镜像，就相当于创建一个容器。启动镜像，就相当于配置好了环境。比方说：启动一个mysql镜像，就相当于创建了一个mysql容器，就可以用mysql数据库了。可以启动的那个多个镜像，并且，每个镜像都是独立运行的，互不干扰（沙箱机制）。</li></ol><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>查看centOS版本：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//docker要求CentOS系统内核版本要高于3.10</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure></div><p>升级软件包及内核：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//因为，我们安装的docker是最新版本的</span><br><span class="line">//但是，内核版本低可能不兼容，所以，要更新</span><br><span class="line">//如果，后面安装成功之后，启动的时候出错，那么就先卸载docker，更新内核</span><br><span class="line">//重启之后，再重新安装docker就行了</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure></div><p>安装docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure></div><p>卸载docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-*</span><br></pre></td></tr></table></figure></div><p>启动docker</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></div><p>将docker作为开机启动</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></div><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">检索</td><td style="text-align:left">docker search 关键字（eg：docker search redis）</td><td style="text-align:left">我们经常去docker hub上检索镜像的详细信息，不用再本地敲命令搜索。如镜像的TAG</td></tr><tr><td style="text-align:left">拉取</td><td style="text-align:left">docker pull 镜像名:tag</td><td style="text-align:left">:tag是可选的，tag表示标签，多为软件的版本，默认是latest版本</td></tr><tr><td style="text-align:left">列表</td><td style="text-align:left">docker images</td><td style="text-align:left">查看所有本地镜像</td></tr><tr><td style="text-align:left">删除</td><td style="text-align:left">docker rmi image-id</td><td style="text-align:left">删除指定的本地镜像，镜像id可以通过列表查看</td></tr><tr><td style="text-align:left">运行</td><td style="text-align:left">docker run -d –name 自定义名字  安装的容器名字（eg:docker run –d –name myredis redis）</td><td style="text-align:left">–name：自定义容器名 -d：后台运行</td></tr><tr><td style="text-align:left">列表</td><td style="text-align:left">docker ps（查看运行中的容器）</td><td style="text-align:left">加上-a；可以查看所有容器</td></tr><tr><td style="text-align:left">停止</td><td style="text-align:left">docker stop container-name/container-id</td><td style="text-align:left">停止当前你运行的容器</td></tr><tr><td style="text-align:left">启动</td><td style="text-align:left">docker start container-name/container-id</td><td style="text-align:left">启动容器</td></tr><tr><td style="text-align:left">删除</td><td style="text-align:left">docker rm container-id</td><td style="text-align:left">删除指定容器</td></tr><tr><td style="text-align:left">端口映射</td><td style="text-align:left">-p 6379:6379</td><td style="text-align:left">-p: 主机端口(映射到)容器内部的端口</td></tr><tr><td style="text-align:left">容器日志</td><td style="text-align:left">docker logs container-name/container-id</td></tr></tbody></table><p>PS:我们docker run的时候一般都是跟上端口映射，不然访问不到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。&lt;br&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，&lt;br&gt;然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Run启动原理（十八）</title>
    <link href="http://haichenyi.com/2019/11/11/SpringBoot%E7%B3%BB%E5%88%97-Run%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/11/11/SpringBoot系列-Run启动原理（十八）/</id>
    <published>2019-11-11T09:28:35.000Z</published>
    <updated>2019-11-11T09:32:08.591Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;需要搞清楚几个重要的事件回调机制</p><p>配置在META-INF/spring.factories</p><ul><li>ApplicationContextInitializer</li><li>SpringApplicationRunListener</li></ul><p>只需要放在ioc容器中</p><ul><li><p>ApplicationRunner </p></li><li><p>CommandLineRunner</p></li></ul><a id="more"></a><p>&emsp;&emsp;新建一个空项目，就勾选web，找到启动类，每个方法上面写的注释，可以看一下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SellApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SellApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上面run方法点进来</span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;</span><br><span class="line">return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123;</span><br><span class="line">return new SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>看到这里，就应该看到了，启动流程分为两步</p><ol><li>创建SpringApplication对象</li><li>运行run方法</li></ol><h3 id="创建SpringApplication对象"><a href="#创建SpringApplication对象" class="headerlink" title="创建SpringApplication对象"></a>创建SpringApplication对象</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//上面的构造方法点进去</span><br><span class="line">//这里与1.5版本不一样的地方就是，</span><br><span class="line">//2.X这里调用了重载的构造方法，而1.5这里调用的是一个initialize()方法，这个方法里面的内容，与下面两个参数的重载方法差不多</span><br><span class="line">public SpringApplication(Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">this(null, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面这个就是this调用的重载的构造方法</span><br><span class="line">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">this.resourceLoader = resourceLoader;</span><br><span class="line">//保存主配置类，1.5里面这里有个非空判断，用if做的，这里换成的断言做判断</span><br><span class="line">Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">//判断当前是否一个web应用</span><br><span class="line">this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">//从类路径下找到META‐INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起 来</span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">//从类路径下找到ETA‐INF/spring.factories配置的所有ApplicationListener</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">//从多个配置类中找到有main方法的主配置类</span><br><span class="line">this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="setInitializers-方法"><a href="#setInitializers-方法" class="headerlink" title="setInitializers()方法"></a>setInitializers()方法</h4><p>&emsp;&emsp;看方法名就知道，这个是初始化方法，初始化什么东西呢？再看传的参数ApplicationContextInitializer，就是一开始我们提到的类。我们看这个是怎么获取的</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//第一步：</span><br><span class="line">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">return new SpringApplicationRunListeners(logger,</span><br><span class="line">getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二步：</span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line">// Use names and ensure unique to protect against duplicates</span><br><span class="line">//看这里的导入方法SpringFactoriesLoader.loadFactoryNames(type, classLoader)</span><br><span class="line">Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">return instances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三步：</span><br><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line">return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第四步，就是这里了。看这里面的实现</span><br><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">if (result != null) &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">//一眼看过去。很明显，这里就是classLoader.getResources()，导入的本地的资源。看这个传的参数,我放到这个方法下面去了</span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != null ?</span><br><span class="line">classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">result = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">//这里通过一个while循环，加载本地配置的ApplicationContextInitializer</span><br><span class="line">while (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">UrlResource resource = new UrlResource(url);</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException ex) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The location to look for factories.</span><br><span class="line"> * &lt;p&gt;Can be present in multiple JAR files.</span><br><span class="line"> */</span><br><span class="line">public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;所以，从上面的源码，我们一步一步点击进去看，我们就能发现，他最终都是加载到 <strong>META-INF/spring.factories</strong> 目录下的 <strong>ApplicationContextInitializer</strong> 当然，到目前为止这里只是初始化</p><h4 id="setListeners-方法"><a href="#setListeners-方法" class="headerlink" title="setListeners()方法"></a>setListeners()方法</h4><p>&emsp;&emsp;一眼就能看出来，这里是设置监听方法</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;一眼看过去，这个setListener方法传的参数熟不熟悉？就是我们上面初始化的时候传的参数是同一个方法。所以，这里设置监听设置哪些监听方法也是<strong>META-INF/spring.factories</strong> 目录下的listener方法，我们看一下这个文件内容：</p><p><img src="/uploads/article/2019-11-11/spring_factories.png" alt="spring_factories.png"></p><p>&emsp;&emsp;这些都是是自动配置类的内容</p><h3 id="运行Run方法"><a href="#运行Run方法" class="headerlink" title="运行Run方法"></a>运行Run方法</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">StopWatch stopWatch = new StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = null;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">//获取SpringApplicationRunListeners；从类路径下META‐INF/spring.factories</span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">//回调所有的获取SpringApplicationRunListener.starting()方法</span><br><span class="line">listeners.starting();</span><br><span class="line">try &#123;</span><br><span class="line">    //封装命令行参数</span><br><span class="line">ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">//准备环境，创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准 备完成</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">//这里是新增的，点击去看，就是再properties文件中配置你需要忽略的bean</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">//这个是打印spring的logo banner图</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">/创建ApplicationContext；这个下面有下介绍</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">//看一下参数，这个就是做异常报告处理的</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line"></span><br><span class="line">//准备上下文环境;将environment保存到ioc中；而且applyInitializers()；</span><br><span class="line">//applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法</span><br><span class="line">//回调所有的SpringApplicationRunListener的contextPrepared()；</span><br><span class="line">//prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded()；</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">//s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版</span><br><span class="line">//扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）</span><br><span class="line">refreshContext(context);</span><br><span class="line">//2.x里面是空方法</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line"></span><br><span class="line">//从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">//返回这个IOC容器</span><br><span class="line">return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="getRunListeners-方法"><a href="#getRunListeners-方法" class="headerlink" title="getRunListeners()方法"></a>getRunListeners()方法</h4><p>&emsp;&emsp;我们看到上面第一个有注释的位置：getRunListeners方法</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">return new SpringApplicationRunListeners(logger,</span><br><span class="line">getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;方法熟悉吗？就是我们上面初始化的时候调用的那个方法，只是这里的参数传的是：<strong>SpringApplicationRunListener</strong>,我们看最开始说的，这就是我们要了解的第二个内容，回调都是怎么调用的</p><p>&emsp;&emsp;方法里面的注释也写了，先获取监听事件，然后回调starting方法，我们看一下这个接口有那些回调方法：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface SpringApplicationRunListener &#123;</span><br><span class="line"></span><br><span class="line">default void starting() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void environmentPrepared(ConfigurableEnvironment environment) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就这些回调，这里还用了1.8的新特性，<strong>default关键字</strong>，接口里面的方法可以有方法体</p><h4 id="prepareEnvironment"><a href="#prepareEnvironment" class="headerlink" title="prepareEnvironment()"></a>prepareEnvironment()</h4><p>&emsp;&emsp;看到第二个写注释的位置，眼熟吗？可不就是跟上面回调方法名字相同么？我们点进去看一下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,</span><br><span class="line">ApplicationArguments applicationArguments) &#123;</span><br><span class="line">// Create and configure the environment</span><br><span class="line">ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line"></span><br><span class="line">//这里划重点，这里就调用的environmentPrepared的回调方法</span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line">if (!this.isCustomEnvironment) &#123;</span><br><span class="line">environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line">return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;准备完环境之后，调用environmentPrepared的回调</p><h4 id="createApplicationContext"><a href="#createApplicationContext" class="headerlink" title="createApplicationContext()"></a>createApplicationContext()</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableApplicationContext createApplicationContext() &#123;</span><br><span class="line">Class&lt;?&gt; contextClass = this.applicationContextClass;</span><br><span class="line">if (contextClass == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">switch (this.webApplicationType) &#123;</span><br><span class="line">case SERVLET:</span><br><span class="line">contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">case REACTIVE:</span><br><span class="line">contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex) &#123;</span><br><span class="line">throw new IllegalStateException(</span><br><span class="line">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;创建applicationContext，这里跟1.5不一样，1.5就只有两种：一种是web的ioc容器，一种是默认的ioc容器。2.X这里有三种：<strong>DEFAULT_CONTEXT_CLASS，DEFAULT_SERVLET_WEB_CONTEXT_CLASS，DEFAULT_REACTIVE_WEB_CONTEXT_CLASS</strong>，实际字符串比较长，可以去看一下源码。然后用BeanUtils通过反射创建。</p><h4 id="prepareContext-方法"><a href="#prepareContext-方法" class="headerlink" title="prepareContext()方法"></a>prepareContext()方法</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span><br><span class="line">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123;</span><br><span class="line">//将environment放到context中</span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">//初始化</span><br><span class="line">applyInitializers(context);</span><br><span class="line">//这里回调contextPrepared方法</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == null);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line">// Add boot specific singleton beans</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);</span><br><span class="line">if (printedBanner != null) &#123;</span><br><span class="line">beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line">if (beanFactory instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line">if (this.lazyInitialization) &#123;</span><br><span class="line">context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">&#125;</span><br><span class="line">// Load the sources</span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</span><br><span class="line">load(context, sources.toArray(new Object[0]));</span><br><span class="line">//这里回调contextLoaded()方法</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;准备上下文环境;将environment保存到ioc中；而且applyInitializers()</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void applyInitializers(ConfigurableApplicationContext context) &#123;</span><br><span class="line">for (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class="line">Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),</span><br><span class="line">ApplicationContextInitializer.class);</span><br><span class="line">Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);</span><br><span class="line">initializer.initialize(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里就将我们一开始从配置文件里面读取，然后创建ApplicationContextInitializer初始化。</p><p>&emsp;&emsp;当环境准备好之后，就回调了SpringApplicationRunListener的contextPrepared()；</p><p>&emsp;&emsp;当所有的都准备好了之后，回调SpringApplicationRunListener的contextLoaded()；</p><p>&emsp;&emsp;到这里，所有的环境都准备好了，需要打印的logo也加进去了。</p><h4 id="refreshContext"><a href="#refreshContext" class="headerlink" title="refreshContext()"></a>refreshContext()</h4><p>&emsp;&emsp;刷新容器这个方法，我们可以点到具体的功能实现里面，可以看到，这里就是扫描，创建，加载所有的组件，配置类，组件，自动配置等。</p><p>&emsp;&emsp;到这里，这个方法创建完之后，所有的控制器就创建完了，所有的组件，bean等，都在控制台打印出来了。如果是web应用，还会创建嵌入式的tomcat。我们spring boot项目内嵌tomcat，就是在这里创建的。</p><h4 id="afterRefresh"><a href="#afterRefresh" class="headerlink" title="afterRefresh()"></a>afterRefresh()</h4><p>&emsp;&emsp;1.5版本这个方法里面回调的是callRunners方法，而2.X版本，现在这是个空方法里面并没有实现。callRunners被提出来了，放到了最后面。</p><h4 id="started-running"><a href="#started-running" class="headerlink" title="started(),running()"></a>started(),running()</h4><p>&emsp;&emsp;在1.5版本这里，也就是afterRefresh()之后，应该是调用的SpringApplicationRunListeners的finished()方法。</p><p>&emsp;&emsp;在2.X版本之后，去掉了finished方法，改成了调用started方法，然后调用running方法。我们上面有一个starting方法，从这里名字就可以看出来，相当于，首先是正在启动当中，然后就是启动完成了，正在运行了。</p><h4 id="callRunners"><a href="#callRunners" class="headerlink" title="callRunners()"></a>callRunners()</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void callRunners(ApplicationContext context, ApplicationArguments args) &#123;</span><br><span class="line">List&lt;Object&gt; runners = new ArrayList&lt;&gt;();</span><br><span class="line">runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123;</span><br><span class="line">if (runner instanceof ApplicationRunner) &#123;</span><br><span class="line">callRunner((ApplicationRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line">if (runner instanceof CommandLineRunner) &#123;</span><br><span class="line">callRunner((CommandLineRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;从IOC容器中(不是配置文件)获取所有的的ApplicationRunner和CommandLineRunner进行回调。这也是最开始说的两个注意的地方</p><p>&emsp;&emsp;并且，这里有个先后顺序，先回调的ApplicationRunner，后回调的CommandLineRunner</p><p>&emsp;&emsp;这里也是run方法，最后执行的地方。从这里就是真正的开启了run。</p><p>&emsp;&emsp;最后一步，返回那个context就是返回IOC容器对象。到这里，我们的spring boot就启动完成了。</p><p>&emsp;&emsp;这就是我们的spring boot的启动原理。初始化，listener的回调，Runner的回调都说的很清楚。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;需要搞清楚几个重要的事件回调机制&lt;/p&gt;
&lt;p&gt;配置在META-INF/spring.factories&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ApplicationContextInitializer&lt;/li&gt;
&lt;li&gt;SpringApplicationRunListener&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只需要放在ioc容器中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ApplicationRunner &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CommandLineRunner&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Redis（十七）</title>
    <link href="http://haichenyi.com/2019/11/06/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Redis%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/11/06/SpringBoot系列—Redis（十七）/</id>
    <published>2019-11-06T08:40:38.000Z</published>
    <updated>2019-11-06T08:42:54.420Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前面一篇说到了spring boot自带的缓存SimpleCache，我们也聊到了他的底层实际上就是HashMap，并且这个缓存是放在内存当中的，这样弊端也是有的，比如：内存大小，当服务器关闭之后，缓存就没了等等。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;实际开发中，一般使用缓存中间件：Redis，EHCache，MemCache等等，今天，我们就来聊聊，经常听到的——Redis。</p><p>&emsp;&emsp;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）——来自官方介绍</p><p>&emsp;&emsp;不去追究原理，我们可以这样理解Redis：</p><ul><li>支持多种数据类型，redis支持set,zset,list,hash,string这五种数据类型，操作方便。</li><li>作为一个内存数据库，最担心的，就是万一机器死机宕机，数据就会消失掉。redis使用RDB和AOF做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。</li><li>与服务器解耦，缓存是一个单独的服务器，当我们项目重启的时候，缓存依然存在。</li><li>我们只用的话，它就是给我们提供了一系列方法的接口，我们只用调用它的API即可。</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;第一步，添加启动器：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第二步，配置你的服务器地址，不配置的话，默认是本地：配置信息一样在 <strong>自动配置类——data包——redis包——RedisProperties类</strong> 里面去找</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#指定redis服务器地址，指定的是本地</span><br><span class="line">spring.redis.host=127.0.0.1</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第三步，添加了redis的配置类，当数据库添加复杂数据的时候，也能以Json的格式正常显示。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport&#123;</span><br><span class="line">@Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        //key序列化方式</span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        //value序列化</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        //value hashmap序列化</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;第四步，正常写接口，在service层里面，自己去把数据写进缓存里面，</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboottask.service;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboottask.Provider;</span><br><span class="line">import com.haichenyi.springboottask.mapper.ProviderMapper;</span><br><span class="line">import com.haichenyi.springboottask.utils.RedisClient;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Desc</span><br><span class="line"> * @Auther 海晨忆</span><br><span class="line"> * @Time 2019/11/6</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class ProviderService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    ProviderMapper providerMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    public Provider getProviderById(Integer pid) &#123;</span><br><span class="line">        Provider provider = (Provider) redisClient.get(pid);</span><br><span class="line">        if (provider != null) &#123;</span><br><span class="line">            return provider;</span><br><span class="line">        &#125;</span><br><span class="line">        Provider provider1 = providerMapper.getProviderByPid(pid);</span><br><span class="line">        redisClient.set(pid, provider1);</span><br><span class="line">        return provider1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;如上代码，我们通过id获取一个Provider，我们先从缓存去取，如果，取不到，说明缓存没有，那么，我们就去从数据库去取，取到之后，再把这条数据放进缓存里面。</p><p>&emsp;&emsp;就是上一篇讲默认缓存的注解的功能，redis里面需要我们自己去实现。</p><p>&emsp;&emsp;这里的 <strong>RedisClient</strong> 类，是自己封装的redis使用的类，至于redis怎么使用，redis的<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">中文官网</a>的命令页面写的很清楚。</p><p>&emsp;&emsp;记得本地电脑装一个Redis服务。然后再本地装一个redis可视化工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前面一篇说到了spring boot自带的缓存SimpleCache，我们也聊到了他的底层实际上就是HashMap，并且这个缓存是放在内存当中的，这样弊端也是有的，比如：内存大小，当服务器关闭之后，缓存就没了等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—缓存及其源码分析（十六）</title>
    <link href="http://haichenyi.com/2019/11/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E7%BC%93%E5%AD%98%E5%8F%8A%E5%85%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/11/05/SpringBoot系列—缓存及其源码分析（十六）/</id>
    <published>2019-11-05T02:52:46.000Z</published>
    <updated>2019-11-05T03:04:13.544Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;缓存是每个项目都用到的为了提高接口响应效率，降低数据库的查询压力，从而提高系统性能。所以，缓存对于一个项目来说是至关重要的。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;spring 3+之后，就定义了CacheManager和Cache接口来统一不同的缓存技术。</p><ul><li>CacheManager：缓存管理器，用于管理各种Cache缓存组件</li><li>Cahce：定义了各种操作，Spring在Cache接口下提供了各种xxCache的实现；比如：ConcurrentMapCache，RedisCache，JCacheCache等等</li></ul><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>&emsp;&emsp;这里我以默认缓存为例：ConcurrentMapCache</p><p>&emsp;&emsp;上面说了，缓存只用配置就可以直接使用，所以，配置，一说到配置，我们就会想到之前说的自动配置类AutoConfigure。如下图：</p><p><img src="/uploads/article/2019-11-05/缓存结构图.png" alt="缓存结构图.png"></p><p>&emsp;&emsp;我们看到，自动配置类目录下面有一个cache包，这就是缓存自动配置的包，我们熟悉的类就有CacheProperties这个类，我们点进去看：</p><p><img src="/uploads/article/2019-11-05/缓存配置类.png" alt="缓存配置类.png"></p><p>&emsp;&emsp;我们熟悉的prefix就在这里了，也就是我们在全局配置类里面的键。</p><p>&emsp;&emsp;这里，配置的一般都是这个类里面的全局变量，我把这个CacheType给框出来了（下面的cacheNames这个list变量也很重要），上面的注释的意思是说，缓存类型，默认情况下，是根据环境自动检测的。</p><p>&emsp;&emsp;我们上面说到CacheManager和Cache接口是用来同意管理不同的缓存技术。不同的，也就是指的我们这里的缓存类型。所以，我们这里的缓存类型肯定有好几种，然后，这里又讲是根据环境自动检测的。也就是我们配置好的。也就是我们在全局配置类里面配置好的</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.xxx=xxx</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;既然是配置，肯定是定义了之后才能配置的，没定义，怎么可能配置，spring又不是神。那，定义了那些种类的缓存技术呢？我们看一下CacheType类</p><p><img src="/uploads/article/2019-11-05/缓存枚举类.png" alt="缓存枚举类.png"></p><p>&emsp;&emsp;定义的，就这10种：GENERIC，JCACHE，EHCACHE，HAZELCAST，INFINISPAN，COUCHBASE，REDIS，CAFFEINE，SIMPLE，NONE。作为一个初学者，我想一眼看过去，我们能看到熟悉的Redis，学后天，Redis框架肯定要学。</p><p>&emsp;&emsp;我们现在，什么都没有配置，默认的缓存类型就是这个Simple，可以在Cache目录下面的CacheAutoConfiguration类中看到selectImports方法，在这里打断点，我们debug模式运行，我们就能看到它导入的缓存类型，然后，每个进行检测，看匹配哪一个。</p><p><img src="/uploads/article/2019-11-05/默认导入的缓存.png" alt="默认导入的缓存.png"></p><p>&emsp;&emsp;我们就看一下SimpleCacheConfiguration是怎么实现的</p><p><img src="/uploads/article/2019-11-05/SimpleCacheConfiguration图.png" alt="SimpleCacheConfiguration图.png"></p><p>&emsp;&emsp;我们看到了，SimpleCacheConfiguration默认使用的是：ConcurrentMapCacheManager，我们，看一下这个Manager是怎么实现的</p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCacheManager图1.png" alt="ConcurrentMapCacheManager图1.png"></p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCacheManager图2.png" alt="ConcurrentMapCacheManager图2.png"></p><p>&emsp;&emsp;这类，实现的就是CacheManager接口，而CacheManager接口就只有两个方法，就是上图中的两个方法<strong>setCacheNames</strong> 和 <strong>getCache</strong></p><p>&emsp;&emsp;先说一下数据是怎么缓存的，缓存是一个容器，这个容器怎么获取的呢？就是通过这里的name，name是获取这个容器的key，然后里面的数据存放形式，都是key-value的形式存放的。这个key也是我们定义的，value就是数据库查询的数据。如下图。</p><p><img src="/uploads/article/2019-11-05/缓存图.png" alt="缓存图.png"></p><p>&emsp;&emsp;这个setCacheNames，就是，我们配置的cacheNames的值，它会获取好之后，将这些值封装成list，通过setCacheNames方法赋值给这里的变量cacheMap。我们可以看一下这个变量：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final ConcurrentMap&lt;String, Cache&gt; cacheMap = new ConcurrentHashMap&lt;&gt;(16);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后就是这个getCache方法，上面的setCacheNames以cacheName为键去存这个Cache，这个就是刚好相反，获取方法，通过cacheName去获取这个Cache。</p><p>&emsp;&emsp;然后，我们现在是获取到了这个缓存容器，那么，我们要怎么从这个缓存容器中去获取我们对应的数据呢？</p><p>&emsp;&emsp;我们看到上面那个变量是Map是以String为键，以Cache为值，我们最开始说过了，Cache和CacheManager是用来管理不同缓存技术的接口，所以，这里的值不可能是一个接口对象，肯定是它的实现类，我们再仔细看上面两个方法的实现类，我们会看到</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//setCacheNames方法</span><br><span class="line">this.cacheMap.put(name, createConcurrentMapCache(name));</span><br><span class="line"></span><br><span class="line">//getCache方法</span><br><span class="line">cache = createConcurrentMapCache(name);</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;很明显，这里就是Cache对象是怎么创建的，我们点到这个方法里面去看：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create a new ConcurrentMapCache instance for the specified cache name.</span><br><span class="line"> * @param name the name of the cache</span><br><span class="line"> * @return the ConcurrentMapCache (or a decorator thereof)</span><br><span class="line"> */</span><br><span class="line">protected Cache createConcurrentMapCache(String name) &#123;</span><br><span class="line">SerializationDelegate actualSerialization = (isStoreByValue() ? this.serialization : null);</span><br><span class="line">return new ConcurrentMapCache(name, new ConcurrentHashMap&lt;&gt;(256),</span><br><span class="line">isAllowNullValues(), actualSerialization);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;所以，它这里是new的ConcurrentMapCache肯定是Cache的实现类。我们看到这个构造方法，第二个参数是一个hashMap，而我们的缓存容器里面也是以键值对的方式存储数据的。我们再看这个ConcurrentMapCache</p><p><img src="/uploads/article/2019-11-05/ConcurrentMapCache图.png" alt="ConcurrentMapCache图.png"></p><p>&emsp;&emsp;一共就只有三个全局变量，第一个name，是我们前面传过来的cacheName，第二个是Map<object,object>类型，第三个是SerializationDelegate类型的变量，序列化的一个什么东西。排除法判断，只可能这个Map就是用来存放我们的缓存数据的。我们搜索这个变量，我们会看到如下几个方法：</object,object></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   //获取缓存数据</span><br><span class="line">   @Override</span><br><span class="line">@Nullable</span><br><span class="line">protected Object lookup(Object key) &#123;</span><br><span class="line">return this.store.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   //存放</span><br><span class="line">   @Override</span><br><span class="line">public void put(Object key, @Nullable Object value) &#123;</span><br><span class="line">this.store.put(key, toStoreValue(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过key移除数据</span><br><span class="line">@Override</span><br><span class="line">public void evict(Object key) &#123;</span><br><span class="line">this.store.remove(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空所有数据</span><br><span class="line">@Override</span><br><span class="line">public void clear() &#123;</span><br><span class="line">this.store.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   //清空所有数据</span><br><span class="line">@Override</span><br><span class="line">public boolean invalidate() &#123;</span><br><span class="line">boolean notEmpty = !this.store.isEmpty();</span><br><span class="line">this.store.clear();</span><br><span class="line">return notEmpty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;至此，缓存怎么存放，怎么获取都说完了。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;与前面差不多，都是在启动类上面开启，在方法上面标记注解就行了</p><ol><li>@EnableCaching：在启动类上，开启基于注解的缓存</li><li>@Cacheable：标在方法上，返回的结果会进行缓存(先查缓存中的结果，没有则调用方法并将结果放到缓存中)</li><li>@CachePut：保证方法被调用后，又将对应缓存中的数据更新（先调用方法，调完方法再将结果放到缓存）</li><li>@CacheEvict：清除缓存</li></ol><p>&emsp;&emsp;@Cacheable，@CachePut，@CacheEvict三个注解都有几个重要的属性：</p><ul><li>cacheNames：缓存的名字。</li><li>key: 作为缓存中的Key值，可以使用SpEL表达式指定（不指定，key就是参数值），缓存结果是方法返回值</li></ul><p>&emsp;&emsp;上面两个属性是前面我们一直都在强调的比较重要的属性，然后，清除缓存的注解中还有两个属性需要了解:</p><ul><li>allEntries =true : 指定清除这个缓存中所有数据。</li><li>beforeInvocation = true : true在方法之前执行；默认false在方法之后执行,出现一场则不会清除缓存</li></ul><p>&emsp;&emsp;我这里值贴出来缓存相关的类：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Cacheable(cacheNames = &quot;user&quot;, key = &quot;#id&quot;)</span><br><span class="line">    public User getUser(Integer id) &#123;</span><br><span class="line">        return userMapper.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CachePut(cacheNames = &quot;user&quot;, key = &quot;#result.id&quot;)</span><br><span class="line">    public User updateUser(User user) &#123;</span><br><span class="line">        userMapper.updateUser(user);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CacheEvict(cacheNames = &quot;user&quot;, key = &quot;#result&quot;)</span><br><span class="line">    public Integer deleteUser(Integer id) &#123;</span><br><span class="line">        userMapper.deleteUserById(id);</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;第一步：默认采用的是SimpleCacheConfiguration 使用 ConcurrentMapCacheManager</p><p>&emsp;&emsp;第二步：getCache 获取的是 ConcurrentMapCache 缓存对象进行存取数据,它使用ConcurrentMap<object,object>对象进行缓存数据。</object,object></p><p>@Cacheable(cacheNames = “user”, key = “#id”)</p><p><strong>第一次请求时：</strong></p><p>&emsp;&emsp;第三步：当发送第一次请求时，会从getCache(name)中获取，看有没有ConcurrentMapCache缓存对象,如果没有 则创建出来, 并且创建出来的key就是通过</p><p>@Cacheable(cacheNames = “user”)标识的name值 </p><p>&emsp;&emsp;第四步：接着会从ConcurrentMapCache里面调用lookup获取缓存数据,通过key值获取的, </p><p>默认采用的是service方法中的参数值,如果缓存中没有获取到,则调用目标方法进行获取数据（即从数据库中查询）,获取之后则再将它 放到缓存中(key=参数值,value=返回值)</p><p><strong>第二次请求时：</strong></p><p>&emsp;&emsp;第五步：如果再次调用 则还是先ConcurrentMapCacheManager.getCache()获取缓存对象,如果有则直接返回, 如果没有则创建</p><p>&emsp;&emsp;第六步：然后再调用 ConcurrentMapCache.lookup方法从缓存中获取数据, 如果缓存有数据则直接响应回去,不 会再去调用目标方法</p><p><strong>第三次请求与第二次一样</strong></p><p>如果缓存中没有缓存管理器,则与第一次请求一致</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;缓存是每个项目都用到的为了提高接口响应效率，降低数据库的查询压力，从而提高系统性能。所以，缓存对于一个项目来说是至关重要的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—邮件（十五）</title>
    <link href="http://haichenyi.com/2019/10/31/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E9%82%AE%E4%BB%B6%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/10/31/SpringBoot系列—邮件（十五）/</id>
    <published>2019-10-31T09:12:19.000Z</published>
    <updated>2019-11-05T02:58:07.873Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;邮件发送是必不可少的，不管是注册邮件，还是广告。</p><a id="more"></a><p>&emsp;&emsp;spring boot中已经集成的mail的启动器，所以，我们只用配置好就行了。</p><p>&emsp;&emsp;引入启动器：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;那么，需要配置什么内容呢？我们之前讲过，需要配置的东西，spring boot都给我们提前准备好了，都在自动配置类AutoConfigure那个类里面，我们可以找一找，里面有个mail包，这个就是邮件的相关配置类。</p><p><img src="/uploads/article/2019-10-31/邮件配置.png" alt="邮件配置图.png"></p><p>&emsp;&emsp;我们可以看到上面的prefix中的spring.mail就是我们的配置文件中的前缀，这个类里面的公共变量，就是我们配置文件中的键。我们这里配置了四个值。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#配置邮箱账号</span><br><span class="line">spring.mail.username=371965177@qq.com</span><br><span class="line">spring.mail.password=XXXXXXX</span><br><span class="line">#配置发送邮件服务器</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">#配置ssl安全连接</span><br><span class="line">spring.mail.properties.smtp.ssl.enable = true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里的密码，我们不能填，我们的QQ号密码吧？需要在你的QQ邮箱去设置。生成授权码即可。直接百度一下：QQ邮箱怎么生成授权码，有教程。然后，把生成的授权码填到这里就行了。配置就这么多</p><p>&emsp;&emsp;怎么发送邮件呢？也很简单，分两种，一种是简单的文字邮件，一种是复杂带附件的邮件。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboottask;</span><br><span class="line"></span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.mail.SimpleMailMessage;</span><br><span class="line">import org.springframework.mail.javamail.JavaMailSenderImpl;</span><br><span class="line">import org.springframework.mail.javamail.MimeMessageHelper;</span><br><span class="line"></span><br><span class="line">import javax.mail.MessagingException;</span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class SpringBootTaskApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    JavaMailSenderImpl javaMailSender;</span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        //简单邮件</span><br><span class="line">        SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">        //邮件标题</span><br><span class="line">        message.setSubject(&quot;测试邮件功能标题&quot;);</span><br><span class="line">        //邮件内容</span><br><span class="line">        message.setText(&quot;测试邮件内容&quot;);</span><br><span class="line">        //发件人，必须要跟配置的相同</span><br><span class="line">        message.setFrom(&quot;371965177@qq.com&quot;);</span><br><span class="line">        //收件人</span><br><span class="line">        message.setTo(&quot;1640200266@qq.com&quot;);</span><br><span class="line">        javaMailSender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testMail() throws MessagingException &#123;</span><br><span class="line">        //带附件邮件，通过createMimeMessage()方法获取对象</span><br><span class="line">        MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">        //这里带附件的邮件需要用到这个帮助类</span><br><span class="line">        MimeMessageHelper messageHelper = new MimeMessageHelper(mimeMessage,true);</span><br><span class="line"></span><br><span class="line">        messageHelper.setSubject(&quot;测试邮件功能标题&quot;);</span><br><span class="line">        //可以发送html语句，第一个参数是内容，第二个参数设置为true即可。</span><br><span class="line">        messageHelper.setText(&quot;&lt;h1 style=&apos;color;blue&apos;&gt;测试邮件内容&lt;/h1&gt;&quot;,true);</span><br><span class="line">        //addAttachment添加附件的方法。第一个是名字，第二个是file</span><br><span class="line">        messageHelper.addAttachment(&quot;1.txt&quot;,new File(&quot;D:\\Download\\t.txt&quot;));</span><br><span class="line">        messageHelper.setFrom(&quot;371965177@qq.com&quot;);</span><br><span class="line">        messageHelper.setTo(&quot;1640200266@qq.com&quot;);</span><br><span class="line">        //这里发送的还是MimeMessage对象，并不是那个帮助类对象</span><br><span class="line">        javaMailSender.send(mimeMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;每一行都有注释，已经写的很清楚了，就不做过多的解释了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;邮件发送是必不可少的，不管是注册邮件，还是广告。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—异步任务与定时任务（十四）</title>
    <link href="http://haichenyi.com/2019/10/31/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/10/31/SpringBoot系列—异步任务与定时任务（十四）/</id>
    <published>2019-10-31T06:32:20.000Z</published>
    <updated>2019-11-05T02:58:02.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>&emsp;&emsp;什么时候用异步，就是耗时操作的时候就可以用到异步，比如：批量处理数据，批量发邮件等等。</p><a id="more"></a><p>&emsp;&emsp;用法与前面的事务管理类似，spring 3+之后，就已经内置了 <strong>@Async</strong> 来处理异步任务。我们使用两个注解即可。</p><ul><li>@EnableAysnc 启动类上开启基于注解的异步任务</li><li>@Aysnc 标识的方法会异步执行</li></ul><p>如：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@EnableAsync</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;批量操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        helloService.add();</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;当我们请求这个hello接口时，如果不使用@Async标记方法，那么，线程就会阻塞，我们会在add方法执行完之后，才会返回success。这显然不是我们想要的。</p><p>&emsp;&emsp;如果用@Async标记方法，那么，线程就不会阻塞，我们请求hello接口，会立刻返回success，过了三秒钟，才会批量处理完成。这才是我们想要的。</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>&emsp;&emsp;定时定点的执行某个任务，就需要用到定时任务。比如，当服务器启动之后，比如，每天晚上23点上传日志，每个月1号给用户发送邮件等等。</p><p>&emsp;&emsp;用法都类似：</p><ul><li>@EnableScheduling 启动类上开启基于注解的定时任务</li><li>@Scheduled 标识的方法会进行定时处理</li></ul><p>唯一不一样的地方，也是个难点就是cron表达式</p><p>先举个例子：在上面例子的基础上加上</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@EnableScheduling</span><br><span class="line">@EnableAsync</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootTaskApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;批量操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron = &quot;1-5 * * * * *&quot;)</span><br><span class="line">    public void scheduledTaskt() &#123;</span><br><span class="line">        System.out.println(&quot;执行定时任务&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这个定时任务就是,每分钟的1秒到5秒各执行一次，一共5次。</p><p>&emsp;&emsp;cron表达式一共六个值，每个值都要有。一个都不能少，分别代表的含义是：秒 分 时 日 月 星期几</p><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">取值范围</th><th style="text-align:center">可指定的特殊字符</th></tr></thead><tbody><tr><td style="text-align:center">秒</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">分</td><td style="text-align:center">0-59</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">时</td><td style="text-align:center">0-23</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">日</td><td style="text-align:center">1-31</td><td style="text-align:center">, - * ? / L W C</td></tr><tr><td style="text-align:center">月</td><td style="text-align:center">1-12</td><td style="text-align:center">, - * /</td></tr><tr><td style="text-align:center">星期</td><td style="text-align:center">0-7或SUN-SAT 0和7都是周日，1-6是周一到周六</td><td style="text-align:center">, - * ? / L C #</td></tr></tbody></table><p>&emsp;&emsp;特殊字符的含义：<br>|特殊字符|代表含义|<br>|:-:|:-:|<br>|,|枚举，一个位置上指定多个值，以逗号 ， 分隔|<br>|-|区间|<br>|*|任意|<br>|/|步长，每隔多久执行一次|<br>|?|日/星期冲突匹配 ,指定哪个值,另外个就是?|<br>|L|最后|<br>|W|工作日|<br>|C|和calendar联系后计算过的值|<br>|#|这个月的第几个星期几，4#2，第2个星期四|</p><p>比如：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1-5 * * * * 1到5秒，每秒都触发任务 */5 * * * * 每隔5秒执行一次</span><br><span class="line"></span><br><span class="line">0 */1 * * * 每隔1分钟执行一次 0 0 5-15 * * 每天5-15点整点触发</span><br><span class="line"></span><br><span class="line">0 0-5 14 * * 在每天下午2点到下午2:05期间的每1分钟触发</span><br><span class="line"></span><br><span class="line">0 0/5 14 * * 在每天下午2点到下午2:55期间的每5分钟触发</span><br><span class="line"></span><br><span class="line">0 0/5 14,18 * * 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</span><br><span class="line"></span><br><span class="line">0 0/30 9-17 * * 朝九晚五工作时间内每半小时</span><br><span class="line"></span><br><span class="line">0 0 12 ? * WED 表示每个星期三中午12点</span><br><span class="line"></span><br><span class="line">0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发</span><br><span class="line"></span><br><span class="line">0 0 23 L * ? 每月最后一天23点执行一次</span><br><span class="line"></span><br><span class="line">0 15 10 LW * ? 每个月最后一个工作日的10点15分0秒触发任务</span><br><span class="line"></span><br><span class="line">0 15 10 ? * 5#3 每个月第三周的星期五的10点15分0秒触发任务</span><br></pre></td></tr></table></figure></div><p>最后附上在线生成cron表达式的链接： <a href="http://cron.qqe2.com" target="_blank" rel="noopener">http://cron.qqe2.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;异步任务&quot;&gt;&lt;a href=&quot;#异步任务&quot; class=&quot;headerlink&quot; title=&quot;异步任务&quot;&gt;&lt;/a&gt;异步任务&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;什么时候用异步，就是耗时操作的时候就可以用到异步，比如：批量处理数据，批量发邮件等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—事务管理（十三）</title>
    <link href="http://haichenyi.com/2019/09/17/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/17/SpringBoot系列—事务管理（十三）/</id>
    <published>2019-09-17T05:37:31.000Z</published>
    <updated>2019-09-17T05:39:09.783Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;我们操作数据库，事务管理是必不可少的一部分。</p><a id="more"></a><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>&emsp;&emsp;我们在开发企业应用时，用户的一个操作对应数据库可能是多步操作相结合完成的。在这个多个步骤中，其中的一步，可能出现异常，导致后面的步骤无法向下进行，那么，用户的这个操作，可能就没有进行完，前面已经进行的步骤数据就需要回退。</p><p>举个总所周知的栗子：</p><p>&emsp;&emsp;银行的转账，A给B转账，转1000块钱，A的钱需要扣1000，B的钱需要加1000，而，银行的系统在A扣1000块钱之后，B加1000块钱的时候，出现的异常，A的钱扣了，B的钱没有加，这该怎么办？这就需要用到我们的事务管理了。</p><p>&emsp;&emsp;事务就是保证用户的每个操作都是可靠的，事务中的每一个步操作都必须成功执行，如果，其中某一个步骤出现了异常，那么就回退到事务开始未进行操作的状态。</p><p>&emsp;&emsp;事务管理是Spring框架中最为常见的功能之一，我们在SpringBoot开发应用时，大部分情况下也需要使用事务。</p><h3 id="事务管理操作步骤"><a href="#事务管理操作步骤" class="headerlink" title="事务管理操作步骤"></a>事务管理操作步骤</h3><p>&emsp;&emsp;理论上就只有两步：</p><ol><li>@EnableTransactionManagement：标记在启动类</li><li>@Transactional：标记的service层</li></ol><p>&emsp;&emsp;为什么说理论上只需要两步呢？因为，在SpringBoot中，当我们使用 <strong>spring-boot-starter-data-jdbc</strong> 或者是 <strong>spring-boot-starter-data-jpa</strong> 依赖的时候，框架会自动帮我们注入 <strong>入DataSourceTransactionManager</strong> 或者 <strong>JpaTransactionManager</strong> 。所以，我们不需要进行任何额外的配置，就直接可以使用 <strong>@Transactional</strong> 注解进行管理事务。</p><p>&emsp;&emsp;还有几点需要注意的地方：</p><ul><li>Hibernate创建表，默认类型是 <strong>MyISAM，</strong> 是非事务安全的，即使你加上了上面的注解，也不起作用。 <strong>Innodb</strong> 类型的表才是事务安全的。</li><li>需要在你的配置文件中指定： <strong>spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect</strong></li></ul><h3 id="事务的隔离级别和传播行为"><a href="#事务的隔离级别和传播行为" class="headerlink" title="事务的隔离级别和传播行为"></a>事务的隔离级别和传播行为</h3><p>&emsp;&emsp;除了指定事务管理器之后，还能对事务进行隔离级别和传播行为的控制，下面分别详细解释：</p><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>&emsp;&emsp;隔离级别是指在发生并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读、不可重复读、幻读。</p><ul><li><strong>脏读：A事务执行的过程中，修改了id=1的数据，这个时候还没有提交，此时，B读取了修改之后id=1的数据，而A事务却回滚了，这样B事务就形成了脏读。</strong> 比方说：A的银行卡里原来有1000块钱，买东西花了300，还有700，这个时候A的媳妇查银行卡的余额，一看只剩下700了，然后，A又不喜欢那个东西，把东西退掉了，买东西的钱又退回银行卡了，这个时候，A的媳妇查的钱这个事务就是脏读。回来之后一阵毒打，什么跪键盘，跪榴莲。唉，脏读，真惨。</li><li><strong>不可重复读：A事务先读取了id=1的数据，然后执行后面的逻辑，这个时候，B事务修改了id=1的数据，A在执行后面逻辑的时候，又读取了一遍id=1的数据，这个时候发现，两次读取的数据不相同，这就是不可重复读。</strong> 比方说：A发工资了，银行卡里发了1000块钱，每天早上查一遍，中午查一遍，好安心。早上9点上班的时候查了一遍余额有1000块钱，A的媳妇，十点多的时候买了个包包花了500块钱，A中午查的时候就剩下500了，他就去找他媳妇理论啊，你干啥了，咋就只剩下500了，他媳妇一听就来气啊，每个月挣这么点钱，我买个包包怎么了，然后就是一阵毒打，跪键盘，跪榴莲。唉，不可重复读，真惨。</li><li><strong>幻读：A事务先根据条件查询到了N条数据，然后，B事务新增了M条复合A事务查询条件的数据，导致A事务再次查询的时候，查询到了N+M条数据，就产生了幻觉。</strong> 比方说：A的媳妇查询A名下有多少张银行卡，一开始查询有2张（建行，农行），然后，A换了新工作，需要重新再邮政开工资卡。这一天，A的媳妇又查了一遍A名下的银行卡，咦，怎么多了一张邮政的，长能耐了，背着老娘藏私房钱了，于是，就把A一阵毒打，是跪键盘，跪榴莲。唉，幻读，真惨。</li></ul><p>&emsp;&emsp;怎么避免上面的三种情况呢？我们可以看  <strong>org.springframework.transaction.annotation.Isolation</strong>  枚举类中定义了五个表示隔离级<br>别的值：</p><ul><li><strong>DEFAULT：</strong> 这个是默认值，表示使用底层数据库的默认隔离级别，对绝大多数数据库而言，这个值通常就是 <strong>READ_COMMITTED。</strong></li><li><strong>READ_UNCOMMITTED：</strong> 该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。 <strong>该级别不<br>能防止脏读和不可重复读， 因此很少使用该隔离级别。</strong></li><li><strong>READ_COMMITTED：</strong> 该隔离级别表示一个事务只能读取另一个事务已经提交的数据。 <strong>该级别可以防止脏<br>读，这也是大多数情况下的推荐值，性能最好。</strong></li><li><strong>REPEATABLE_READ：</strong> 该隔离级别表示一个事务在整个执行过程中可以多次重复执行某个查询，并且每次返回的数据都相同，即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。 <strong>该级别可以<br>防止脏读和不可重复读。</strong></li><li><strong>SERIALIZABLE：</strong> 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说， <strong>该级别可<br>以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</strong> </li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定方式：</span><br><span class="line">@Transactional(isolation = Isolation.DEFAULT)</span><br></pre></td></tr></table></figure></div><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>&emsp;&emsp;传播行为是指，如果在开始当前事务之前，已经存在一个事务，此时可以指定这个要开始的这个事务的执行行为。</p><p>&emsp;&emsp;我们可以看  <strong>org.springframework.transaction.annotation.Propagation</strong>  枚举类中定义了6个表示传播行<br>为的枚举值：</p><ul><li>REQUIRED:（默认）如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li>SUPPORTS:如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>MANDATORY:如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>REQUIRES_NEW:创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>NOT_SUPPORTED:以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER:以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>NESTED:如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则<br>该取值等价于 REQUIRED 。</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//指定方式：</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRED)</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;关于这个事务的隔离级别和传播行为，我们一般都不用特别的去指定，用默认的就行了，除非有特别的要求，默认的隔离级别和传播行为满足绝大多数要求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;我们操作数据库，事务管理是必不可少的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Spring Data JPA（十二）</title>
    <link href="http://haichenyi.com/2019/09/11/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Spring-Data-JPA%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/11/SpringBoot系列—Spring-Data-JPA（十二）/</id>
    <published>2019-09-11T09:03:36.000Z</published>
    <updated>2019-09-18T08:47:57.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data"></a>什么是 Spring Data</h3><p>&emsp;&emsp;Spring Data 是 Spring Boot 底层默认进行数据访问的技术 , 为了简化构建基于 Spring 框架应用的数据访问技术，包<br>括非关系数据库、Map-Reduce 框架、云数据服务等；另外也包含对关系数据库的访问支持。</p><a id="more"></a><p>&emsp;&emsp;Spring Data 包含多个模块：</p><ul><li>Spring Data Commons 提供共享的基础框架，适合各个子项目使用，支持跨数据库持久化</li><li>Spring Data JPA</li><li>Spring Data KeyValue</li><li>Spring Data LDAP</li><li>Spring Data MongoDB</li><li>Spring Data Redis</li><li>Spring Data REST</li><li>Spring Data for Apache Cassandra</li><li>Spring Data for Apache Geode</li><li>Spring Data for Apache Solr</li><li>Spring Data for Pivotal GemFire</li><li>Spring Data Couchbase (community module)</li><li>Spring Data Elasticsearch (community module)</li><li>Spring Data Neo4j (community module)</li></ul><h3 id="Spring-Data统一的核心接口"><a href="#Spring-Data统一的核心接口" class="headerlink" title="Spring Data统一的核心接口"></a>Spring Data统一的核心接口</h3><p>&emsp;&emsp;Spring Data项目为大家提供统一的API来对不同的数据访问层进行操作。</p><p><img src="/uploads/article/2019-09-11/Repository.png" alt="Repository继承图.png"></p><ul><li>Repository<t, id="">：统一的根接口即所有接口的父接口，其他接口继承该接口</t,></li><li>CrudRepository<t, id="">：基本的增删改查接口,提供了最基本的对实体类CRUD操作</t,></li><li>PagingAndSortingRepository<t, id="">：增加了分页和排序操作</t,></li><li>JpaRepository<t, id="">：增加了批量操作，并重写了父接口一些方法的返回类型</t,></li></ul><p>&emsp;&emsp;Spring Data JPA、JPA与Hibernate 关系</p><p><img src="/uploads/article/2019-09-11/关系图.png" alt="关系图.png"></p><p>&emsp;&emsp;JPA是一种规范，而Hibernate是实现这种规范的底层实现，SpringData JPA对持久化接口JPA再抽象一层，针对持久化业务再进一步统一简化。</p><h3 id="SpringData-JPA的简单使用"><a href="#SpringData-JPA的简单使用" class="headerlink" title="SpringData JPA的简单使用"></a>SpringData JPA的简单使用</h3><p>&emsp;&emsp;JPA的底层遵守是ORM(对象关系映射)规范，因此JPA其实也就是java实体对象和关系型数据库建立起映射关系，通过<br>面向对象编程的思想操作关系型数据库的规范。</p><p><strong>首先，导包</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.haichenyi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-jpa&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;spring-boot-jpa&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--jdbc的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--jpa的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--web项目的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mysql的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--简化set/get的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></div><p><strong>其次，创建映射bean类</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.entity;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.persistence.*;</span><br><span class="line"></span><br><span class="line">//使用JPA注解配置映射关系</span><br><span class="line">@Entity//说明它是和数据表映射的类</span><br><span class="line">@Table(name = &quot;tbl_hobby&quot;)//指定对应映射的表名，省略默认表名就是类名</span><br><span class="line">@Data</span><br><span class="line">public class Hobby &#123;</span><br><span class="line">    @Id//标识主键</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)////标识自增长主键</span><br><span class="line">    private Integer id;</span><br><span class="line">    @Column(name = &quot;name&quot;, length = 10)//这是和数据表对应的一个列即字段名</span><br><span class="line">    private String name;</span><br><span class="line">    @Column//没有写，表字段名与这里的字段名相同</span><br><span class="line">    private Integer time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;需要注意的是，这里需要写set/get方法，不然，数据存不进去。这里我用了 <strong>@Data</strong> 注解，所以，就不需要写了。注释写的很清楚了，就不一一解释了。</p><p><strong>接着，写Repository</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.repository;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjpa.entity.Hobby;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义接口继承JpaRepository，就会crud及分页等基本功能</span><br><span class="line"> */</span><br><span class="line">//指定的泛型&lt;操作的实体类，主键的类型&gt;</span><br><span class="line">public interface HobbyRepository extends JpaRepository&lt;Hobby, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>再然后，就是Controller，跟之前写的一样</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjpa.entity.Hobby;</span><br><span class="line">import com.haichenyi.springbootjpa.repository.HobbyRepository;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HobbyController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    HobbyRepository hobbyRepository;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hobby/&#123;id&#125;&quot;)</span><br><span class="line">    public Hobby getHobbyInfo(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">        Optional&lt;Hobby&gt; hobbyOptional = hobbyRepository.findById(id);</span><br><span class="line">        return hobbyOptional.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/save&quot;)</span><br><span class="line">    public Hobby saveHobby(Hobby hobby) &#123;</span><br><span class="line">        System.out.println(hobby);</span><br><span class="line">        return hobbyRepository.save(hobby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>最后，就只配置了</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样写完就行了。就这四步：</p><ol><li>映射表</li><li>Repository接口</li><li>Controller</li><li>配置文件</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是-Spring-Data&quot;&gt;&lt;a href=&quot;#什么是-Spring-Data&quot; class=&quot;headerlink&quot; title=&quot;什么是 Spring Data&quot;&gt;&lt;/a&gt;什么是 Spring Data&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Spring Data 是 Spring Boot 底层默认进行数据访问的技术 , 为了简化构建基于 Spring 框架应用的数据访问技术，包&lt;br&gt;括非关系数据库、Map-Reduce 框架、云数据服务等；另外也包含对关系数据库的访问支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—MyBatis（十一）</title>
    <link href="http://haichenyi.com/2019/09/07/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94MyBatis%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/07/SpringBoot系列—MyBatis（十一）/</id>
    <published>2019-09-07T10:56:22.000Z</published>
    <updated>2019-09-18T08:48:38.542Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇，Druid是用于处理数据库连接池与后台监控。</p><a id="more"></a><p>&emsp;&emsp;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。——百度百科</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;MyBatis添加依赖跟SpringBoot的其他启动器不一样，MyBatis需要写版本号，因为，SpringBoot并没有MyBatis的启动器。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="注解的方式"><a href="#注解的方式" class="headerlink" title="注解的方式"></a>注解的方式</h4><p>&emsp;&emsp;先看一下项目结构：</p><p><img src="/uploads/article/2019-09-07/项目结构图.png" alt="项目结构图.png"></p><p>&emsp;&emsp;首先，我们先在连接的数据库里面创建表，添加几条数据。</p><p>&emsp;&emsp;然后，创建pojo类User，对应我的表</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    public Long UserId;</span><br><span class="line">    public String Username;</span><br><span class="line">    public String password;</span><br><span class="line">    public String nickName;</span><br><span class="line">    public String headImg;</span><br><span class="line">    public Integer age;</span><br><span class="line">    public Integer sex;</span><br><span class="line">    public String address;</span><br><span class="line">    public String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;接着，创建mapper接口</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.mapper;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    @Select(&quot;select * from userinfo&quot;)</span><br><span class="line">    List&lt;User&gt; getUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是一个普通的接口，用 <strong>@Mapper</strong> 标识了。然后写了一个获取用户信息的方法。 <strong>@Select</strong> 里面是sql语句。</p><p>&emsp;&emsp;用 <strong>@Mapper</strong> 标识的接口，在运行的过程中，会帮我们生成实现类，到时候，我们直接通过这个接口的引用调用这个方法即可。我们也可以在入口的位置用 <strong>@MapperScan</strong> 标识包名，应用启动的时候，会给这个包下面的所有接口都生成实现类。如下</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc;</span><br><span class="line"></span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@MapperScan(&quot;com.haichenyi.springbootjdbc.mapper&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootJdbcApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootJdbcApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;最后，就是我们的controller层了。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.mapper.UserMapper;</span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/getUserInfo&quot;)</span><br><span class="line">    public List&lt;User&gt; getUserInfo() &#123;</span><br><span class="line">        return userMapper.getUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样，我们就可以通过 <a href="http://localhost:8080/getUserInfo" target="_blank" rel="noopener">http://localhost:8080/getUserInfo</a> 读到数据库中的数据了</p><p>&emsp;&emsp;只这样，我们读到的数据，如果表字段与pojo类的字段不一一对应，我们可能读到的数据为空，所以，我们要开启驼峰命名，开启之后MyBatis会帮我们一一对应好。怎么开启呢？就在我们前面的JdbcConfig中添加如下方法即可。就跟我们前面一篇Druid添加配置类似。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * MyBatis自定义配置</span><br><span class="line">  *</span><br><span class="line">  * @return ConfigurationCustomizer</span><br><span class="line">  */</span><br><span class="line"> @Bean</span><br><span class="line"> public ConfigurationCustomizer configurationCustomizer() &#123;</span><br><span class="line">     return configuration -&gt; &#123;</span><br><span class="line">         //开启驼峰命名</span><br><span class="line">         configuration.setMapUnderscoreToCamelCase(true);</span><br><span class="line">         //开启二级缓存</span><br><span class="line">         configuration.setCacheEnabled(true);</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这样就可以了。</p><h4 id="xml的方式"><a href="#xml的方式" class="headerlink" title="xml的方式"></a>xml的方式</h4><p>&emsp;&emsp;前面和后面都是一样的，就是中间那不创建mapper接口不一样。xml中怎么创建mapper呢？</p><p>&emsp;&emsp;首先，还是创建一个正常的接口，定义方法。如下：注释写的很清楚了。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.mapper;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">//这里如果没有@Mapper注解，那就在启动类添加@MapperScan注解，上面已经说过怎么添加了。两种方式都可以，标记mapper的接口还是需要的</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">//这里的sql语句就不需要了，sql语句在xml里面配置。</span><br><span class="line">//    @Select(&quot;select * from userinfo&quot;)</span><br><span class="line">    List&lt;User&gt; getUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;然后，添加两个xml，一个是config，一个是写sql语句的。路径需要注意，先在resources目录下创建一个mybatis目录，在mybatis目录下创建mybatis-config.xml，在mybatis目录下创建mapper目录，然后在mapper目录下创建你的mapper.xml文件，如下：</p><p>&emsp;&emsp;这个是写mybatis配置文件的，名字我写的是：mybatis-config.xml，这个路径<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;!--开启驼峰命名--&gt;</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;然后就是创建mapper.xml，这里，我们以UserMapper.xml为例：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--namespace要是你前面创建mapper接口的全路径，这样才能对应--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.haichenyi.springbootjdbc.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;!--id：是你前面接口里面创建的方法名--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    resultType：这里的返回类型就是你接口读取数据对应的bean类，不管你需要的是集合，还是单个对象，这里都是你bean类，</span><br><span class="line">    如果你读取的是多条数据，它会自动帮你封装成list，拿到这个list，你再去做你其他的处理</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;getUserInfo&quot; resultType=&quot;com.haichenyi.springbootjdbc.pojo.User&quot;&gt;</span><br><span class="line">        select * from userinfo</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;注释写的很清楚了。</p><p>&emsp;&emsp;再就是配置这个两个xml路径了，你需要在你的全局配置文件中配置好，指定对应的路径：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  #核心配置文件路径</span><br><span class="line">  config-location: classpath:mybatis/mybatis-config.xml</span><br><span class="line">  #映射配置文件路径</span><br><span class="line">  mapper-locations: classpath:mybatis/mapper/*.xml</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;为啥非要创建一个mapper目录，再创建mapper文件呢？就是这里好指定。mapper文件肯定不止一个，难道你要一个一个的配置吗？这样写只用指定一个就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇，Druid是用于处理数据库连接池与后台监控。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Druid（十）</title>
    <link href="http://haichenyi.com/2019/09/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Druid%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/05/SpringBoot系列—Druid（十）/</id>
    <published>2019-09-05T08:05:30.000Z</published>
    <updated>2019-09-18T09:10:27.945Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;一个企业项目中最重要的部分那就是数据库了，对数据库的连接，读写是重中之重。在SpringBoot中数据库怎么连接呢？</p><a id="more"></a><h3 id="数据库的连接"><a href="#数据库的连接" class="headerlink" title="数据库的连接"></a>数据库的连接</h3><p>&emsp;&emsp;这里以MySql为例，还不会用MySql数据库的童鞋，可以看我之前的博客，<a href="https://blog.csdn.net/qq_27634797/article/category/8050256" target="_blank" rel="noopener">数据库相关</a>。</p><p>&emsp;&emsp; <strong>第一步，</strong> 我们首先在pom.xml中添加jdbc相关的启动器。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--jdbc启动器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--mysql驱动包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; <strong>第二步，</strong> 在配置文件中配置连接数据库的信息：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    #连接数据库的账号</span><br><span class="line">    username: root</span><br><span class="line">    #连接数据库的密码</span><br><span class="line">    password: 123456</span><br><span class="line">    #连接数据库的url</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    #连接数据库的驱动类</span><br><span class="line">    #mysql8之前用的是：com.mysql.jdbc.Driver。</span><br><span class="line">    #mysql8之后用的是：com.mysql.cj.jdbc.Driver</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 添加如上信息，就基本上完成了。测试一下连接就可以了。在我们的测试类中添加如下代码，看看打印的数据即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringBootJdbcApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() throws SQLException &#123;</span><br><span class="line">        System.out.println(&quot;dataSource: &quot; + dataSource.getClass());</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(&quot;connection: &quot; + connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 我们这里是测试数据库是否连接成功，我们才获取的这个连接，打印出来，我们项目里面实际操作数据库的时候，不需要我们获取这个连接，然后通过这个连接再去操作数据库。这是不需要，MyBatis通过Mapping注解直接操作数据库，我们只用写sql语句就可以了。</p><h3 id="Druid连接数据库"><a href="#Druid连接数据库" class="headerlink" title="Druid连接数据库"></a>Druid连接数据库</h3><p>&emsp;&emsp; DRUID是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是目前最好的连接池。</p><p>&emsp;&emsp; <strong>上面的配置继续保留。</strong></p><p>&emsp;&emsp; <strong>第一步：</strong> 我们在pom.xml里面添加druid的依赖：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.20&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; <strong>第二步：</strong> 在yml文件中添加如下代码：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  # 数据库访问配置</span><br><span class="line">  datasource:</span><br><span class="line">    #账号</span><br><span class="line">    username: root</span><br><span class="line">    #密码</span><br><span class="line">    password: 123456</span><br><span class="line">    #连接的url</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    #驱动类</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # 主数据源，默认的</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">    # 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line">    # 初始化大小，最小，最大</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    # 配置获取连接等待超时的时间</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    # 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 25</span><br><span class="line">    # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">    filters: stat,wall,logback</span><br><span class="line">    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="line">    # 合并多个DruidDataSource的监控数据</span><br><span class="line">    useGlobalDataSourceStat: true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 这样，就可以了。继续运行刚才的测试方法，你会发现，打印数据里面数据源已经变成了DruidDataSource。</p><p>&emsp;&emsp; 你如果是debug运行的，并且，你的断点打在connection那里，你会发现，我们yml文件中的补充配置，没起作用，是为什么呢？</p><p>&emsp;&emsp; 我们按住CTRL，鼠标左键点补充配置里面的任意一个变量，都点不动，我们点上面的type，url等等，都能点，我们点过去看，我们会发现跳到了 <strong>DataSourceProperties</strong> 。这个类，顾名思义这是数据源配置文件类。我们大致看一下这个类的代码：</p><p><img src="/uploads/article/2019-09-05/DataSourceProperties类.png" alt="DataSourceProperties类.png"></p><p>&emsp;&emsp; 用红色框框，框出来的地方是不是很眼熟？</p><p>&emsp;&emsp; 首先，我们先看注解 <strong>@ConfigurationProperties，</strong> 这个注解就是表示这个类是配置类，然后，我们看括号里面的参数 <strong>prefix，</strong> 顾名思义：前缀，前置代码。</p><p><img src="/uploads/article/2019-09-05/yml文件.png" alt="yml文件.png"></p><p>&emsp;&emsp; 如上图，上面的红色框框的内容，就由prefix决定，下面红色框框的内容，就由这个类的变量决定。我们上面的补充设置不起作用，就是因为这个配置文件里面没有这些变量，SpringBoot识别不了，所以，不起作用。SpringBoot不是万能的，它配置了的东西，可以识别，没有配置的，识别不了。</p><p>&emsp;&emsp; 怎么样让上面的补充配置起作用呢？有多种方式：</p><p>&emsp;&emsp; <strong>第一种方式如下：</strong> 简单粗暴，添加一个配置类即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource()&#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp; 这个方式就相当于，把我们上面的这个 <strong>DataSourceProperties</strong>配置类，换成了 <strong>DruidDataSource</strong>类。</p><p>&emsp;&emsp; <strong>第二种方式如下：</strong> 比较麻烦，也不算特别麻烦：说白了就是加载局部配置。</p><p>&emsp;&emsp;首先，在resources目录下，新建一个jdbc.properties文件</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#账号</span><br><span class="line">druid.datasource.username=root</span><br><span class="line">#密码</span><br><span class="line">druid.datasource.password=123456</span><br><span class="line">#连接的url</span><br><span class="line">druid.datasource.url=jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">#驱动类</span><br><span class="line">druid.datasource.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line"># 主数据源，默认的</span><br><span class="line"># druid.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"># 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line"># 初始化大小，最小，最大</span><br><span class="line">druid.datasource.initialSize=5</span><br><span class="line">druid.datasource.minIdle=5</span><br><span class="line">druid.datasource.maxActive=20</span><br><span class="line"># 配置获取连接等待超时的时间</span><br><span class="line">druid.datasource.maxWait=60000</span><br><span class="line"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">druid.datasource.timeBetweenEvictionRunsMillis=60000</span><br><span class="line"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">druid.datasource.minEvictableIdleTimeMillis=300000</span><br><span class="line">druid.datasource.validationQuery=SELECT 1 FROM DUAL</span><br><span class="line">druid.datasource.testWhileIdle=true</span><br><span class="line">druid.datasource.testOnBorrow=false</span><br><span class="line">druid.datasource.testOnReturn=false</span><br><span class="line"># 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">druid.datasource.poolPreparedStatements=true</span><br><span class="line">druid.datasource.maxPoolPreparedStatementPerConnectionSize=25</span><br><span class="line"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">druid.datasource.filters=stat,wall,logback</span><br><span class="line"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">druid.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="line"># 合并多个DruidDataSource的监控数据</span><br><span class="line">druid.datasource.useGlobalDataSourceStat=true</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是把我们刚才在全局配置中配置的信息，在专门的jdbc的配置文件中配置一遍。然后，修改我们的JdbcConfig类。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@PropertySource(value = &quot;classpath:config/jdbc.properties&quot;, ignoreResourceNotFound = true)</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.driverClassName&#125;&quot;)</span><br><span class="line">    private String driverClassName;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.initialSize&#125;&quot;)</span><br><span class="line">    private Integer initialSize;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.minIdle&#125;&quot;)</span><br><span class="line">    private Integer minIdle;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxActive&#125;&quot;)</span><br><span class="line">    private Integer maxActive;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxWait&#125;&quot;)</span><br><span class="line">    private Long maxWait;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.timeBetweenEvictionRunsMillis&#125;&quot;)</span><br><span class="line">    private Long timeBetweenEvictionRunsMillis;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.minEvictableIdleTimeMillis&#125;&quot;)</span><br><span class="line">    private Long minEvictableIdleTimeMillis;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.validationQuery&#125;&quot;)</span><br><span class="line">    private String validationQuery;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testWhileIdle&#125;&quot;)</span><br><span class="line">    private Boolean testWhileIdle;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testOnBorrow&#125;&quot;)</span><br><span class="line">    private Boolean testOnBorrow;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testOnReturn&#125;&quot;)</span><br><span class="line">    private Boolean testOnReturn;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxPoolPreparedStatementPerConnectionSize&#125;&quot;)</span><br><span class="line">    private Integer maxPoolPreparedStatementPerConnectionSize;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.poolPreparedStatements&#125;&quot;)</span><br><span class="line">    private Boolean poolPreparedStatements;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.filters&#125;&quot;)</span><br><span class="line">    private String filters;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.connectionProperties&#125;&quot;)</span><br><span class="line">    private String connectionProperties;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.useGlobalDataSourceStat&#125;&quot;)</span><br><span class="line">    private Boolean useGlobalDataSourceStat;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() throws SQLException &#123;</span><br><span class="line">        DruidDataSource druidDataSource = new DruidDataSource();</span><br><span class="line">        druidDataSource.setUsername(username);</span><br><span class="line">        druidDataSource.setPassword(password);</span><br><span class="line">        druidDataSource.setUrl(url);</span><br><span class="line">        druidDataSource.setDriverClassName(driverClassName);</span><br><span class="line">        druidDataSource.setInitialSize(initialSize);</span><br><span class="line">        druidDataSource.setMinIdle(minIdle);</span><br><span class="line">        druidDataSource.setMaxActive(maxActive);</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);</span><br><span class="line">        druidDataSource.setValidationQuery(validationQuery);</span><br><span class="line">        druidDataSource.setTestOnBorrow(testOnBorrow);</span><br><span class="line">        druidDataSource.setTestOnReturn(testOnReturn);</span><br><span class="line">        druidDataSource.setTestWhileIdle(testWhileIdle);</span><br><span class="line">        druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);</span><br><span class="line">        druidDataSource.setPoolPreparedStatements(poolPreparedStatements);</span><br><span class="line">        druidDataSource.setFilters(filters);</span><br><span class="line">        druidDataSource.setConnectionProperties(connectionProperties);</span><br><span class="line">        druidDataSource.setUseGlobalDataSourceStat(useGlobalDataSourceStat);</span><br><span class="line">        return druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是加载配置文件，然后在DataSource里面赋值。这样，就可以了。</p><h3 id="Druid后台监控"><a href="#Druid后台监控" class="headerlink" title="Druid后台监控"></a>Druid后台监控</h3><p>&emsp;&emsp;之所以用Druid连接池，还有很大一部分原因就是它的监控功能。它能很好的监控DB连接池和SQL语句的执行情况。在上面的JdbcConfig类中添加如下两个方法即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 配置Druid监控</span><br><span class="line"> *</span><br><span class="line"> * @return StatViewServlet</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean servletRegistrationBean() &#123;</span><br><span class="line">    ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //访问的用户名密码</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_USERNAME, &quot;haichenyi&quot;);</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_PASSWORD, &quot;123456&quot;);</span><br><span class="line">    //允许访问的ip，默认是所有ip</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_ALLOW, &quot;&quot;);</span><br><span class="line">    //禁止访问的ip</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_DENY, &quot;192.168.1.1&quot;);</span><br><span class="line">    bean.setInitParameters(map);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 配置一个监控的filter</span><br><span class="line"> *</span><br><span class="line"> * @return WebStatFilter</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean filterRegistrationBean() &#123;</span><br><span class="line">    FilterRegistrationBean&lt;WebStatFilter&gt; bean = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">    bean.setFilter(new WebStatFilter());</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //移除这些监听</span><br><span class="line">    map.put(WebStatFilter.PARAM_NAME_EXCLUSIONS, &quot;*.js,*.css,/druid/*,*.gif,*.jpg,*.png&quot;);</span><br><span class="line">    bean.setInitParameters(map);</span><br><span class="line">    //拦截所有请求，全部都要走druid监听</span><br><span class="line">    bean.setUrlPatterns(Collections.singletonList(&quot;/*&quot;));</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;注释写的很清楚了，控制台怎么访问呢？ <strong><a href="http://localhost:8080/druid" target="_blank" rel="noopener">http://localhost:8080/druid</a></strong>。访问控制台</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;一个企业项目中最重要的部分那就是数据库了，对数据库的连接，读写是重中之重。在SpringBoot中数据库怎么连接呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—自定义拦截器（九）</title>
    <link href="http://haichenyi.com/2019/09/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/05/SpringBoot系列—自定义拦截器（九）/</id>
    <published>2019-09-05T08:05:12.000Z</published>
    <updated>2019-09-05T08:07:12.816Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;拦截器拦截请求做额外的处理。</p><a id="more"></a><p><strong>举个栗子：登录拦截器，拦截所有的请求，必须登录之后才能访问。</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.interceptors;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 登录拦截器</span><br><span class="line"> */</span><br><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line">        if (user != null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(&quot;msg&quot;, &quot;您还没有登录，请先登录！&quot;);</span><br><span class="line">        request.getRequestDispatcher(&quot;/index.html&quot;).forward(request, response);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;新建LoginInterceptor实现HandlerInterceptor接口。这个接口有三个方法，<strong>pre，post，after，</strong>  看这个名字就可以想到这三个方法是怎么调用的，发送请求前，发送过程中，发送请求成功之后，所以，根据自己的需求，实现对应的方法即可。</p><p>&emsp;&emsp;我这里是登录拦截器，所以，在发送请求之前就要拦截，走自己的逻辑，如果，没有登陆过，就跳转登录界面，所以，我这里就实现了发送请求之前的回调，即preHandle方法。</p><p>&emsp;&emsp;然后，在你的SpringMvcConfiguration里面加上拦截器即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.config;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootbill.component.MyLocalResolver;</span><br><span class="line">import com.haichenyi.springbootbill.interceptors.LoginInterceptor;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.LocaleResolver;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class MySpringMvcConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebMvcConfigurer webMvcConfigurer() &#123;</span><br><span class="line">        return new WebMvcConfigurer() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">                registry.addViewController(&quot;/&quot;).setViewName(&quot;main/login&quot;);</span><br><span class="line">                registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;main/login&quot;);</span><br><span class="line">                registry.addViewController(&quot;/main/index.html&quot;).setViewName(&quot;main/index&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">                registry.addInterceptor(new LoginInterceptor())</span><br><span class="line">                        .addPathPatterns(&quot;/**&quot;)</span><br><span class="line">                        .excludePathPatterns(&quot;/&quot;, &quot;/index.html&quot;, &quot;/login&quot;)</span><br><span class="line">                        .excludePathPatterns(&quot;/css/*&quot;,&quot;/img/*&quot;,&quot;/images/*&quot;,&quot;/js/*&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LocaleResolver localeResolver() &#123;</span><br><span class="line">        return new MyLocalResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;实现addInterceptors方法，添加拦截器，然后添加了  <strong>addPathPatterns</strong> 拦截所有带这个参数的请求。接着，又添加了 <strong>excludePathPatterns</strong> 不拦截所有带这个参数的请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;拦截器拦截请求做额外的处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—国际化（八）</title>
    <link href="http://haichenyi.com/2019/09/02/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/02/SpringBoot系列—国际化（八）/</id>
    <published>2019-09-02T08:14:09.000Z</published>
    <updated>2019-09-18T09:10:15.500Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;所谓的国际化就是语言切换。中文切换到其他语种。</p><p>&emsp;&emsp;国际化的信息，这些都是需要开发人员在配置类中配置好的。SpringBoot会自动加载这些配置类。</p><a id="more"></a><p>举个栗子：以登录界面为例，我们的登录界面输入账号、密码框的左边，会有这两个提示，我们就自动修改这两个提示。</p><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>&emsp;&emsp;首先，你要在你的resources目录下面新建i18n目录，当然，不是必须的，可以不创建，直接创建文件。之所以创建这个目录，只是便于管理。</p><p>&emsp;&emsp;然后，在i18n目录下面创建配置文件，操作如下：</p><p><img src="/uploads/article/2019-09-02/创建配置文件1.png" alt="创建配置文件1.png"></p><p>&emsp;&emsp;在i18n的目录下面，新建一个Resources Bundle类型的文件，名字叫login</p><p><img src="/uploads/article/2019-09-02/创建配置文件2.png" alt="创建配置文件2.png"></p><p><img src="/uploads/article/2019-09-02/创建配置文件3.png" alt="创建配置文件3.png"></p><p>&emsp;&emsp;点击+号，创建中文，英文两种语言的配置文件。中文叫 <strong>zh_CN</strong>，英文叫 <strong>en_US</strong>，这两种类型是写死的。</p><p><img src="/uploads/article/2019-09-02/创建配置文件4.png" alt="创建配置文件4.png"></p><p><img src="/uploads/article/2019-09-02/创建配置文件5.png" alt="创建配置文件5.png"></p><p><img src="/uploads/article/2019-09-02/创建配置文件6.png" alt="创建配置文件6.png"></p><p>&emsp;&emsp;根据如上操作，分别创建key为login.username，login.password，并且分别创建好对应的内容。这个key，页面会用到。</p><p>PS：不要忘记了，在全局配置文件中配置好，<strong>spring.messages.basename=i18n.login</strong>，这里现在是只有一个登陆页面需要国际化，如果有多个页面需要，比方说注册页面，就在后面添加。如：spring.messages.basename=i18n.login,i19n.register这样的方式，中间用逗号隔开即可。</p><h3 id="修改页面显示内容"><a href="#修改页面显示内容" class="headerlink" title="修改页面显示内容"></a>修改页面显示内容</h3><p>&emsp;&emsp;按照上面的步骤，创建好了之后，在你页面需要国际化的view，分别按如下的方式获取值：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--th:text=&quot;#&#123;上面命名的key&#125;&quot;--&gt;</span><br><span class="line">&lt;div class=&quot;inputbox&quot;&gt;</span><br><span class="line">                &lt;label for=&quot;user&quot; th:text=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/label&gt;</span><br><span class="line">                &lt;input id=&quot;user&quot; type=&quot;text&quot; name=&quot;username&quot; required/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;inputbox&quot;&gt;</span><br><span class="line">                &lt;label for=&quot;mima&quot; th:text=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/label&gt;</span><br><span class="line">                &lt;input id=&quot;mima&quot; type=&quot;password&quot; name=&quot;password&quot; required/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br></pre></td></tr></table></figure></div><h3 id="自定义区域解析器"><a href="#自定义区域解析器" class="headerlink" title="自定义区域解析器"></a>自定义区域解析器</h3><p>&emsp;&emsp;区域解析器LocaleResolver，按如下的方式实现即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.component;</span><br><span class="line"></span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import org.springframework.web.servlet.LocaleResolver;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义区域解析器</span><br><span class="line"> */</span><br><span class="line">public class MyLocalResolver implements LocaleResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123;</span><br><span class="line">        String l = httpServletRequest.getParameter(&quot;l&quot;);</span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        if (!StringUtils.isEmpty(l)) &#123;</span><br><span class="line">            String[] s = l.split(&quot;_&quot;);</span><br><span class="line">            locale = new Locale(s[0], s[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;最后，在你对应的超链接的地方传 <strong>zh_CN</strong> 和 <strong>en_US</strong> 即可实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;所谓的国际化就是语言切换。中文切换到其他语种。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;国际化的信息，这些都是需要开发人员在配置类中配置好的。SpringBoot会自动加载这些配置类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—热部署与SpringMVC扩展功能（七）</title>
    <link href="http://haichenyi.com/2019/08/30/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E7%83%AD%E9%83%A8%E7%BD%B2%E4%B8%8ESpringMVC%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/30/SpringBoot系列—热部署与SpringMVC扩展功能（七）/</id>
    <published>2019-08-30T02:43:40.000Z</published>
    <updated>2019-08-30T02:44:40.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><p>&emsp;&emsp;默认情况下，在开发中我们修改一个项目文件后，想看到效果不得不重启应用，这会导致浪费大量时间，我们希望不重启应用的情况下，程序可以自动部署（热部署）。</p><a id="more"></a><p>&emsp;&emsp;<strong>第一步：禁用缓存</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#开发环境下关闭thymeleaf模板缓存，thymeleaf默认是开启状态。记得发布的时候要打开</span><br><span class="line">spring.thymeleaf.cache=false</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;<strong>第二步：添加热部署依赖</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--热部署--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;<strong>第三步：手动编译文件</strong></p><p>&emsp;&emsp;IDEA中，修改文件后都是自动保存的，并不会手动编译，所以，需要手动编译一下。Ctrl + F9 （推荐使用）或 Build -&gt; Build Project。</p><h3 id="SpringMVC-扩展功能"><a href="#SpringMVC-扩展功能" class="headerlink" title="SpringMVC 扩展功能"></a>SpringMVC 扩展功能</h3><p>举个栗子：我要访问前面都是在controller里面，写方法，方法里面可以写逻辑，跳转某一个页面。我现在不需要写逻辑，就直接跳转就行了。我可以这样写。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootwebthymeleaf.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        registry.addViewController(&quot;/success&quot;).setViewName(&quot;success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>新建一个类，继承WebMvcConfigurer，并用@Configuration标识</li><li>实现addViewControllers方法，里面registry里面像上面添加就行了，前面传链接名字，后面传视图名字即可。</li></ul><p>&emsp;&emsp;这只是添加控制层，还有其他的功能。可以看WebMvcConfigurer接口的方法。需要什么功能，实现什么方法就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;热部署&quot;&gt;&lt;a href=&quot;#热部署&quot; class=&quot;headerlink&quot; title=&quot;热部署&quot;&gt;&lt;/a&gt;热部署&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;默认情况下，在开发中我们修改一个项目文件后，想看到效果不得不重启应用，这会导致浪费大量时间，我们希望不重启应用的情况下，程序可以自动部署（热部署）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Thymeleaf（六）</title>
    <link href="http://haichenyi.com/2019/08/29/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Thymeleaf%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/29/SpringBoot系列—Thymeleaf（六）/</id>
    <published>2019-08-29T03:07:39.000Z</published>
    <updated>2019-09-18T09:10:19.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引用公共片段-th-fragment-th-replace-th-insert"><a href="#引用公共片段-th-fragment-th-replace-th-insert" class="headerlink" title="引用公共片段 th:fragment,th:replace,th:insert"></a>引用公共片段 th:fragment,th:replace,th:insert</h3><p>&emsp;&emsp;很多页面有很多相同的内容，比方说header和foot，这样的内容就需要公共片段引用了，修改一个地方就全部都改了。类似于android里面提取公共方法一样的道理。</p><a id="more"></a><p>方式如下图：</p><p><img src="/uploads/article/2019-08-29/公共片段1.png" alt="公共片段1.png"></p><p><img src="/uploads/article/2019-08-29/公共片段2.png" alt="公共片段2.png"></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;公共片段&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--通过th:fragment申明公共片段--&gt;</span><br><span class="line">&lt;div th:fragment=&quot;header_common&quot;&gt;这里是公共片段的内容&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--通过id申明公共片段--&gt;</span><br><span class="line">&lt;div id=&quot;header_common_id&quot;&gt;这里是公共片段的内容&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--引入公共片段--&gt;</span><br><span class="line">&lt;div th:replace=&quot;header :: header_common&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div th:replace=&quot;header :: #header_common_id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></div><p>总共分为两步：</p><ol><li>创建header.html的文件，里面定义公共片段的内容，用th:fragment标明，值为header_common</li><li>在你需要用到这个公共部分的位置，通过th:fragment申明的片段用th:relpace引入，值为 文件名 空格 双冒号 空格 th:fragment的值。也就是这里的 <strong>header :: header_common</strong></li><li>通过id申明的片段用th:replace引入，值为 文件名 空格 双冒号 空格 # th:fragment的值。也就是这里的 <strong>header :: #header_common_id</strong></li></ol><p><strong><em>th:insert 和 th:replace的区别</em></strong></p><p>&emsp;&emsp;th:insert和th:replace都可以引入片段，用的方式是一样的，两者的区别在于 th:insert： 保留引入时使用的标签 th:replace：不保留引入时使用的标签, 将声明片段直接覆盖当前引用标签 </p><h3 id="迭代器-th-each"><a href="#迭代器-th-each" class="headerlink" title="迭代器 th:each"></a>迭代器 th:each</h3><p>&emsp;&emsp; 首先，创建一个实体类User。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootwebthymeleaf.pojo;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private Integer age;</span><br><span class="line">    //1:女，2:男</span><br><span class="line">    private Integer sex;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String username, Integer age, Integer sex) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;其次，在controller创建一个获取User的方法。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/userInfo&quot;)</span><br><span class="line">public String getUserInfo(Model model) &#123;</span><br><span class="line">    List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">    userList.add(new User(&quot;小雪&quot;, 18, 1));</span><br><span class="line">    userList.add(new User(&quot;小红&quot;, 18, 1));</span><br><span class="line">    userList.add(new User(&quot;小东&quot;, 18, 2));</span><br><span class="line">    model.addAttribute(&quot;userList&quot;, userList);</span><br><span class="line">    return &quot;userInfo&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里，我用的model返回的数据，添加了一个属性以”userList”为键。页面直接获取这个键，就能拿到对应的值。之后返回userInfo页面。</p><p>&emsp;&emsp;最后页面的使用，如下，创建userInfo.html专门使用这个：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;用户信息&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;性别&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr th:each=&quot;user:$&#123;userList&#125;&quot;&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.sex==1?&apos;女&apos;:&apos;男&apos;&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li th:each=&quot;user:$&#123;userList&#125;&quot; th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    user : 第1个值,代表每次迭代出对象,名字任意取</span><br><span class="line">    iterStat : 第2个值,代表每次迭代器内置对象, 名字任意取, 并有如下属性:</span><br><span class="line">        index : 当前迭代下标 0 开始</span><br><span class="line">        count : 当前迭代下标 1 开始</span><br><span class="line">        size : 获取总记录数</span><br><span class="line">        current : 当前迭代出的对象</span><br><span class="line">        even/odd : 当前迭代是偶数还是奇数 (1开始算,返回布尔值)</span><br><span class="line">        first : 当前是否为第一个元素</span><br><span class="line">        last : 当前是否为最后一个元素</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;tr th:each=&quot;user,iterStat:$&#123;userList&#125;&quot;&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.sex==1?&apos;女&apos;:&apos;男&apos;&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.index&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.count&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.size&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.current&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.even&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.first&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.last&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;注意的地方就是：</p><ul><li><strong>th:each=”user:${userList}”</strong>，这里可以参考java里面的foreach循环，冒号前面是当前循环的变量(冒号前面可以有两个值)，冒号后面是集合。这个集合怎么获取到的？就是通过userList这个键。第二步存的。</li><li>拿到这个集合中的每一个变量值了，用就很简单了。</li></ul><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3 th:if=&quot;not $&#123;#lists.isEmpty(userList)&#125;&quot;&gt;th:if判断,如果此文字显示说明有值&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3 th:unless=&quot;$&#123;#lists.isEmpty(userList)&#125;&quot;&gt;th:unless判断,如果此文字显示说明有值&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;div th:switch=&quot;$&#123;flag&#125;&quot;&gt;</span><br><span class="line">        &lt;p th:case=&quot;1&quot; th:text=&quot;女&quot;&gt;&lt;/p&gt;</span><br><span class="line">        &lt;p th:case=&quot;2&quot; th:text=&quot;男&quot;&gt;&lt;/p&gt;</span><br><span class="line">        &lt;!--上面两条都不生效，则下面th:case=&quot;*&quot;生效，类似于default--&gt;</span><br><span class="line">        &lt;p th:case=&quot;*&quot; th:text=&quot;未知&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引用公共片段-th-fragment-th-replace-th-insert&quot;&gt;&lt;a href=&quot;#引用公共片段-th-fragment-th-replace-th-insert&quot; class=&quot;headerlink&quot; title=&quot;引用公共片段 th:fragment,th:replace,th:insert&quot;&gt;&lt;/a&gt;引用公共片段 th:fragment,th:replace,th:insert&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;很多页面有很多相同的内容，比方说header和foot，这样的内容就需要公共片段引用了，修改一个地方就全部都改了。类似于android里面提取公共方法一样的道理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Thymeleaf（五）</title>
    <link href="http://haichenyi.com/2019/08/27/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Thymeleaf%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/27/SpringBoot系列—Thymeleaf（五）/</id>
    <published>2019-08-27T03:23:20.000Z</published>
    <updated>2019-09-18T09:10:18.413Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;SpringBoot官方不推荐使用JSP，因为内嵌Tomcat，Jetty容器不支持以jar的方式运行JSP。SpringBoot中提供了大量模板引擎，包含Freemarker，Mastache，Thymeleaf等。而SpringBoot官方推荐使用Thymeleaf作为模板引擎，因为Thymeleaf提供了完美的SpringMVC的支持。</p><a id="more"></a><h3 id="添加启动器"><a href="#添加启动器" class="headerlink" title="添加启动器"></a>添加启动器</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- thymeleaf 模板启动器 --&gt; </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div><h3 id="添加模板文件"><a href="#添加模板文件" class="headerlink" title="添加模板文件"></a>添加模板文件</h3><h4 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h4><p>&emsp;&emsp; 模板文件，就是我们创建的HTML文件，将创建好的 HTML 页面放到 <strong>classpath:/templates/</strong> 目录下， Thymeleaf 就能自动渲染。就是我们的 <strong>resources/templates/</strong>目录。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>&emsp;&emsp; 自动渲染数据从哪里来呢？跟写APP端的接口差不多，就是少了响应@ResponseBody注解。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootwebthymeleaf.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * APP接口</span><br><span class="line">     * @return 返回一个字符串</span><br><span class="line">     */</span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String sayHello() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回模板文件</span><br><span class="line">     * @return 返回名字叫success的HTML页面</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/hello1&quot;)</span><br><span class="line">    public String sayHello1() &#123;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>项目结构图如下：</p><p><img src="/uploads/article/2019-08-27/项目结构图.png" alt="项目结构图.png"></p><p>&emsp;&emsp; 如上所示，当访问 <strong><a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></strong>的时候，返回的是一个字符串叫hello。当访问<br><strong><a href="http://localhost:8080/hello1" target="_blank" rel="noopener">http://localhost:8080/hello1</a></strong>的时候，他会转到我们上面说的templates目录下的success.html页面。</p><h3 id="thymeleaf语法使用"><a href="#thymeleaf语法使用" class="headerlink" title="thymeleaf语法使用"></a>thymeleaf语法使用</h3><h4 id="HTML中添加命名空间"><a href="#HTML中添加命名空间" class="headerlink" title="HTML中添加命名空间"></a>HTML中添加命名空间</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:th=&quot;http://www.thymeleaf.org&quot;</span><br></pre></td></tr></table></figure></div><h4 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 返回模板文件</span><br><span class="line">     * @return 返回名字叫success的HTML页面</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/hello1&quot;)</span><br><span class="line">    public String sayHello1(Map&lt;String,Object&gt; map) &#123;</span><br><span class="line">        map.put(&quot;name&quot;,&quot;我是海晨忆&quot;);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;还上啊上面的那个方法，添加了一个map参数。这个参数就是返回给success界面的数据存放容器。存放了一个键值对，键是name</p><p>&emsp;&emsp;界面怎么使用呢？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;success模板文件&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;success 模板文件&lt;/p&gt;</span><br><span class="line">&lt;p2 th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/p2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就这样，直接使用这个键即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;SpringBoot官方不推荐使用JSP，因为内嵌Tomcat，Jetty容器不支持以jar的方式运行JSP。SpringBoot中提供了大量模板引擎，包含Freemarker，Mastache，Thymeleaf等。而SpringBoot官方推荐使用Thymeleaf作为模板引擎，因为Thymeleaf提供了完美的SpringMVC的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—全局配置（四）</title>
    <link href="http://haichenyi.com/2019/08/23/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/23/SpringBoot系列—全局配置（四）/</id>
    <published>2019-08-23T07:18:39.000Z</published>
    <updated>2019-09-18T09:10:13.925Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;用IDEA可以直接创建SpringBoot项目，创建Moudle的时候，在选Maven的地方，选择Sping Initializr即可，很简单。前面讲过了IDEA生成Maven项目，并且嵌入SpringBoot，直接创建Spring Boot项目就是IDEA直接帮我们依赖，并且生成Application和properties文件。其它，也没啥大的区别，就不多说了。</p><a id="more"></a><p>&emsp;&emsp;本篇要讲的是SpringBoot的配置文件，分为两种：</p><ul><li>properties</li><li>yml</li></ul><p>&emsp;&emsp;之前，搜SpringBoot的配置文件怎么写的时候，看到网上很多博客都有文件内容，但是有两种写法，就是这两种配置文件的不同写法。</p><p>&emsp;&emsp;举个栗子，我现在要修改服务器启动的端口号，用properties怎么修改呢？很简单：</p><p><img src="/uploads/article/2019-08-23/properties修改端口号.png" alt="properties修改端口号.png"></p><p>&emsp;&emsp;如上图所示，是不是很简单？</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;用yml怎么修改呢？也不难：</p><p><img src="/uploads/article/2019-08-23/yml修改端口号.png" alt="yml修改端口号.png"></p><p>&emsp;&emsp;如上图所示：也不难</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 808</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;<strong>看到了上面两个图片，应该也已经发现了，两个配置文件存放位置都在resource目录下面。或者在类路径的”/config”路径下</strong></p><p>&emsp;&emsp;这两种写法要怎么写呢？</p><p><strong>properties：</strong> 等号连接，右边是值</p><p><strong>yml：key:</strong></p><ul><li>value 表示一对键值对（冒号后面必须要有空格）</li><li>使用空格缩进表示层级关系</li><li>左侧缩进的空格数目不重要，只要同一层级的元素左侧对齐即可</li><li>key 与 value 大小写敏感</li></ul><p>PS: yml不管是存map，还是list，都要记得<strong>key后面的冒号一定要跟空格，再写值</strong></p><p>&emsp;&emsp;举个栗子，我们定义一个bean类，在配置文件里面赋值，在项目里面取出来用。比方说：我们项目里面定义一个Userbean类。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.PropertySource;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;user&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String nickname;</span><br><span class="line">    private String password;</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;这里有几点需要注意：</p><ol><li>这里的bean类，必须要有写set/get方法，不然赋不了值，我这里没写是因为我用的@Data这个注解，它默认帮我们创建了set/get方法</li><li>@ConfigurationProperties注解就是 告诉SpringBoot将配置文件中对应属性的值，映射到这个组件类中,进行一 一绑定，prefix = “user”的作用就是配置文件中的前缀名，哪个前缀与下面的所有属性进行一一映射</li><li>@Component 注解就是将当前组件也就是这个bean类作为SpringBoot中的一个组件，才能使用容器提供的</li></ol><p>然后就是在配置文件中赋值，properties或者是yml，都可以：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">properties中：</span><br><span class="line"></span><br><span class="line"> server.port=8081</span><br><span class="line">user.username=s19734682s</span><br><span class="line">user.age=20</span><br><span class="line">user.password=123456</span><br><span class="line">user.nickname=林汐痕</span><br><span class="line"></span><br><span class="line">yml中：</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8088</span><br><span class="line">  </span><br><span class="line">//这个user就是上面说的配置文件中的前缀名</span><br><span class="line">user:</span><br><span class="line">  nickname: 海晨忆</span><br><span class="line">  username: pk19734682</span><br><span class="line">  password: 123456</span><br><span class="line">  age: 18</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;怎么使用呢？直接在controller中用这个user就可以了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboot.pojo.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class SayController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/say&quot;)</span><br><span class="line">    public String say() &#123;</span><br><span class="line">        return &quot;hello &quot; +user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就这样，请求这个接口就能打印值。</p><p>&emsp;&emsp;还有通过@Value指定值的方式</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class SayController &#123;</span><br><span class="line">    @Value(&quot;$&#123;user.nickname&#125;&quot;)</span><br><span class="line">    private String nickname;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/say&quot;)</span><br><span class="line">    public String say() &#123;</span><br><span class="line">        return &quot;hello &quot; + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="PropertySource-加载局部配置文件"><a href="#PropertySource-加载局部配置文件" class="headerlink" title="@PropertySource 加载局部配置文件"></a>@PropertySource 加载局部配置文件</h3><p>&emsp;&emsp;什么叫加载局部配置文件呢？就是加载指定的配置文件，并不是从properties或者是yml中加载。怎么加载呢？如下图：</p><p><img src="/uploads/article/2019-08-23/局部配置文件.png" alt="局部配置文件.png"></p><p><strong>第一步，</strong> 在resources目录下创建xxx.properties/xxx.yml，这个xxx你自己命名。我这里创建的是user.properties/user.yml。记得语法不要写错了</p><p><strong>第二步，</strong> 在你的组件的地方加上@PropertySource注解。图上有，可以导入多个局部配置，用逗号隔开，每个局部配置的写法就是 <strong>“classpath:文件名”</strong> 之前导入全局的配置的时候加的注解也需要，不能删除。</p><p><strong>第三步，</strong> 之前是怎么使用的，现在还是怎么使用。</p><h3 id="ImportResource加载xml配置文件"><a href="#ImportResource加载xml配置文件" class="headerlink" title="@ImportResource加载xml配置文件"></a>@ImportResource加载xml配置文件</h3><p>&emsp;&emsp;Spring Boot框架并不推荐用xml加载配置文件，这个是Spring加载文件的方式。项目中如果必须要用到xml加载文件，要怎么办呢？</p><p>举个栗子：我要加载一个Service类到项目中。Spring Boot有注解可以直接使用，这里，我们通过xml加载。</p><p><strong>第一步，</strong> 创建一个service。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.service;</span><br><span class="line"></span><br><span class="line">public class UserService &#123;</span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;xml...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>第二步，</strong> 在resources目录下，创建spring config的xml配置文件</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;userService&quot; class=&quot;com.haichenyi.springboot.service.UserService&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;如上，添加了一个bean类，两个属性，id和class。class指向刚才创建的类，id用于获取这个类。</p><p><strong>第三步，</strong> 在我们的引导类中加上 <strong>@ImportResource</strong> 注解</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line">@ImportResource(locations = &quot;classpath:springboot01.xml&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootInitApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootInitApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>第四步，</strong> 通过ApplicationContext的getBean方法获取，传的参数就是在xml中定义的id。如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboot.pojo.User;</span><br><span class="line">import com.haichenyi.springboot.service.UserService;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringBootInitApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void textXml() &#123;</span><br><span class="line">        UserService userService = (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="自定义配置类向容器中注入组件-SpringBoot推荐"><a href="#自定义配置类向容器中注入组件-SpringBoot推荐" class="headerlink" title="自定义配置类向容器中注入组件(SpringBoot推荐)"></a>自定义配置类向容器中注入组件(SpringBoot推荐)</h3><p>举个栗子：跟上面xml的例子一样。</p><p><strong>第一步，</strong> 跟上面一样，创建一个service</p><p><strong>第二步，</strong> 创建配置类：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.custom;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboot.service.UserService;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userService2() &#123;</span><br><span class="line">        return new UserService();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>需要注意的地方：</strong></p><ul><li>@Configuration 用于标识当前类是一个配置类，用来表示对应spring配置文件</li><li>@Bean 标识的方法用于向容器注入组件</li><li>方法的返回值就是注入容器中的组件对象</li><li>方法名是这个组件对象的 id值</li></ul><p><strong>第三步，</strong> 就是使用了，跟上面第四步一样。不需要上面的第三步。</p><h3 id="Profile多环境支持"><a href="#Profile多环境支持" class="headerlink" title="Profile多环境支持"></a>Profile多环境支持</h3><p>&emsp;&emsp;profile是Sping用来针对不同的环境要求，提供不同的配置支持。什么不同的环境呢？比方说：开发环境，生产环境。</p><p>&emsp;&emsp;全局 Profile 配置使用的文件名可以是<br>application-{profile}.properties / application-{profile}.yml 。如：application-dev.properties / application-prod.properties</p><p><strong>举个栗子：</strong></p><p>&emsp;&emsp;我们的项目环境分为 开发 （dev）和 生产（prod）环境 ，开发环境下端口号为 8081，<br>生产环境下端口号为8082。</p><h4 id="通过properties文件指定"><a href="#通过properties文件指定" class="headerlink" title="通过properties文件指定"></a>通过properties文件指定</h4><p><img src="/uploads/article/2019-08-23/profile-properties.png" alt="profile-properties.png"></p><p>&emsp;&emsp;如上图，创建了两个文件：application-dev.properties，application-prod.properties，里面内容很简单，就是指定端口号。server.port=8081</p><p>&emsp;&emsp;然后，我们在application.properties文件中指定激活哪一个文件即可。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//激活application-dev.properties配置</span><br><span class="line">spring.profiles.active=dev</span><br><span class="line"></span><br><span class="line">//激活application-prod.properties配置</span><br><span class="line">spring.profiles.active=prod</span><br></pre></td></tr></table></figure></div><h4 id="通过yml文件指定"><a href="#通过yml文件指定" class="headerlink" title="通过yml文件指定"></a>通过yml文件指定</h4><p>&emsp;&emsp;不用新建文件，直接在application.yml写就可以了。</p><p><strong>PS:需要用三个减号隔开，表示不同的文档块。</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod #激活哪个profile , 当前激活的是 prod 开发环境</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: dev #指定属于哪个环境, dev 环境时使用</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: prod #指定属于哪个环境, prod 环境时使用</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;用IDEA可以直接创建SpringBoot项目，创建Moudle的时候，在选Maven的地方，选择Sping Initializr即可，很简单。前面讲过了IDEA生成Maven项目，并且嵌入SpringBoot，直接创建Spring Boot项目就是IDEA直接帮我们依赖，并且生成Application和properties文件。其它，也没啥大的区别，就不多说了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—@SpringBootApplication源码解析（三）</title>
    <link href="http://haichenyi.com/2019/08/22/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94-SpringBootApplication%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/22/SpringBoot系列—-SpringBootApplication源码解析（三）/</id>
    <published>2019-08-22T08:20:22.000Z</published>
    <updated>2019-09-18T09:10:23.418Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇，内容很少，说了一下SpringBoot的底层是怎么依赖的。这一篇讲一下SpringBoot底层源码是怎么实现的。</p><a id="more"></a><p>&emsp;&emsp;从SpringBoot的入口开始。第一篇的时候说过了，最好把入口文件放在最外层的包下面，至于原因就不多阐述了。</p><p>&emsp;&emsp;说说这个 <strong>@SpringBootApplication</strong>注解的原理,点进去看一下：</p><p>如下图：</p><p><img src="/uploads/article/2019-08-22/springbootapplication注解.png" alt="springbootapplication注解.png"></p><p>主要就是这三个注解：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>&emsp;&emsp;SpringBootConfiguration这个注解是由Configuration注解实现的。</p><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>&emsp;&emsp;从名字上就可以判断出，这个注解是跟SpringBoot配置相关的，<strong>@Configuration</strong>，这个注解是Spring底层的一个注解，之前都是配置xml，SpringBoot推荐我们用配置类来描述配置，配置类是什么呢？就用@Configuration标记的类。</p><p>&emsp;&emsp;Configuration这个注解是由Component注解实现。</p><h5 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h5><p>&emsp;&emsp;这个注解的意义就是，把当前的配置类添加到spring容器中，表示是一个组件。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>&emsp;&emsp;EnableAutoConfiguration这个注解是由<strong>AutoConfigurationPackage</strong>和<strong>@Import({AutoConfigurationImportSelector.class})</strong>注解实现</p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>&emsp;&emsp;这个注解从名字上面看出来是自动配置包，这是什么意思呢？在第一篇我们就说过了入口要放在最外层的包，至于原因，已经讲过了，因为SpringBoot会自动将引导类 <strong>@SpringBootApplication标注的类</strong>所在的包以及下面所有子包里面所有的组件扫描到Spring容器中统一管理。就是这个注解实现的。那么，这个注解是怎么实现的呢？就是通过它的这个 <strong>@Import({Registrar.class})</strong>，下面就是Registrar类的源码了</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;</span><br><span class="line">        Registrar() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">            AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">            return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;就是通过下面这个代码注册进去的。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());</span><br></pre></td></tr></table></figure></div><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p>&emsp;&emsp;这个注解是干什么用的呢？</p><ol><li>它会把项目里面所有需要导入的组件以全类名的方式返回，将这些组件添加到容器中。</li><li>会给容器中注入非常多的自动配置类，就是导入并配置好当前项目中<br>所需要的组件,省去我们手动编写配置去注入组件。</li></ol><p>&emsp;&emsp;怎么实现的呢？打开AutoConfigurationImportSelector类，找到如下代码：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br></pre></td></tr></table></figure></div><p>找到getCandidateConfigurations方法，如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">        return configurations;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>找到loadFactoryNames方法，如下：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">        String factoryClassName = factoryClass.getName();</span><br><span class="line">        return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>找到loadSpringFactories方法，里面有</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);</span><br></pre></td></tr></table></figure></div><p>这里就是我们的配置，我们这个配置具体是在哪呢？如下图</p><p><img src="/uploads/article/2019-08-22/autoConfigure.png" alt="autoConfigure.png"></p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>&emsp;&emsp;这个注解的主要作用就是，被该注解标识的类会被Spring容器纳入管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇，内容很少，说了一下SpringBoot的底层是怎么依赖的。这一篇讲一下SpringBoot底层源码是怎么实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—底层依赖（二）</title>
    <link href="http://haichenyi.com/2019/08/22/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E5%B1%82%E4%BE%9D%E8%B5%96%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/22/SpringBoot系列—底层依赖（二）/</id>
    <published>2019-08-22T07:01:05.000Z</published>
    <updated>2019-09-18T09:10:16.941Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前面，我们创建了一个Spring Boot的hello world，我们仅仅添加了一个<strong>spring-boot-starter-parent</strong>，它是怎么帮我们实现这个依赖的呢？我们可以点进去看一下<strong>Ctrl+鼠标左键</strong>，如下图：</p><a id="more"></a><p><img src="/uploads/article/2019-08-22/parent的pom文件1.png" alt="parent的pom文件1.png"></p><p><img src="/uploads/article/2019-08-22/parent的pom文件2.png" alt="parent的pom文件2.png"></p><p>&emsp;&emsp;我们发现它，还有一个父级依赖<strong>spring-boot-dependencies</strong>，我们继续点进去看，如下图：</p><p><img src="/uploads/article/2019-08-22/dependencies的pom文件.png" alt="dependencies的pom文件.png"></p><p>&emsp;&emsp;在这个pom文件里面，我们发现了，它定义很多个框架的版本号，这里就是，我们在自己项目里面引入框架不需要加版本号的原因。因为，它帮我们定义好了，它会自动依赖这里定义的版本。spring测试通过的，不会有冲突。</p><p>&emsp;&emsp;我们后面还依赖了一个<strong>spring-boot-starter-web</strong>这个框架，这里分两部分：</p><ul><li>spring-boot-starter：spring boot的场景启动器</li><li>web：web相关的如：Tomcat、springMVC等等</li></ul><p>&emsp;&emsp;我们可以看一下，我们这里的web启动器的内容是什么。如下图：</p><p><img src="/uploads/article/2019-08-22/web场景启动器.png" alt="web场景启动器.png"></p><p>&emsp;&emsp;我们可以看到，它帮我们依赖了很多框架，这就是为什么，我们只添加了一个依赖，我们的项目就依赖的很多个框架的原因，这些都是spring boot帮我们依赖好的。所以，没什么特殊的，一切都是从最简单的开始的。</p><p>&emsp;&emsp;spring boot有很多的<a href="https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/html/using-boot-build-systems.html#using-boot-starter" target="_blank" rel="noopener">场景启动器</a>，如下图：</p><p><img src="/uploads/article/2019-08-22/场景启动器.png" alt="场景启动器.png"></p><p>&emsp;&emsp;你需要用到什么样的功能，依赖响应的场景启动器即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前面，我们创建了一个Spring Boot的hello world，我们仅仅添加了一个&lt;strong&gt;spring-boot-starter-parent&lt;/strong&gt;，它是怎么帮我们实现这个依赖的呢？我们可以点进去看一下&lt;strong&gt;Ctrl+鼠标左键&lt;/strong&gt;，如下图：&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Hello World（一）</title>
    <link href="http://haichenyi.com/2019/08/22/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Hello-World%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/22/SpringBoot系列—Hello-World（一）/</id>
    <published>2019-08-22T06:00:44.000Z</published>
    <updated>2019-09-18T09:10:26.609Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;终于要正式开始了java后台之路，虽然，之前断断续续的看过过黑马的java web视频，但是，都是好几年前的视频，很老了，感觉用处比较大的就是MySQL数据库操作，之前也写过几篇关于<a href="https://blog.csdn.net/qq_27634797/article/category/8050256" target="_blank" rel="noopener">MySQL数据库操作的博客</a>。目前，java后台最火的框架就属<a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener">Spring Boot</a>了。它是<a href="https://spring.io/" target="_blank" rel="noopener">spring</a>家族的衍生框架，并不是加强某个功能，它是为了简化配置，提高开发效率。</p><a id="more"></a><h3 id="Spring-Boot概要"><a href="#Spring-Boot概要" class="headerlink" title="Spring Boot概要"></a>Spring Boot概要</h3><h4 id="Spring-Boot-介绍"><a href="#Spring-Boot-介绍" class="headerlink" title="Spring Boot 介绍"></a>Spring Boot 介绍</h4><p>&emsp;&emsp;随着动态语言的流行(Ruby,Node.js等等)，java作为静态语言，他的开发显得格外的笨重；繁多的配置、低效的开发效率、复杂的部署流程以及第三方技术整合难度大。</p><p>&emsp;&emsp;在上述环境下，Spring Boot由此诞生，它的设计是为了尽快的启动和运行。它使用”习惯优于配置”(就是Spring Boot初始化了大量的配置，让你可以无需配置就能直接运行，当然，你也可以更改)的理念让你的项目快速的运行起来。并且，使用Spring Boot可以让你很容易创建一个独立运行(运行jar，内嵌servlet容器即Tomcat)、准生产力强的基于spring的项目。</p><h4 id="Spring-Boot-优点"><a href="#Spring-Boot-优点" class="headerlink" title="Spring Boot 优点"></a>Spring Boot 优点</h4><ol><li>快速构建spring项目</li><li>无需依赖外部servlet容器即Tomcat，应用无需打成WAR包；项目可以打成Jar包直接运行</li><li>提供一系列的 start pom来简化maven的依赖加载</li><li>无需配置XML，开箱即用，简化开发，同时也可以修改默认值来满足特定需求</li><li>Spring Boot并不是对Spring功能上的加强，而是提供了一种快速使用Spring的方式</li><li>极大的提高了开发和部署效率</li></ol><h3 id="Spring-Boot-入门开发"><a href="#Spring-Boot-入门开发" class="headerlink" title="Spring Boot 入门开发"></a>Spring Boot 入门开发</h3><h4 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h4><p>&emsp;&emsp;每一个版本的Spring Boot，对系统的环境要求都不一样。我这里用的<a href="https://spring.io/projects/spring-boot#learn" target="_blank" rel="noopener">Spring Boot 2.1.7版本</a>，它需要的</p><ul><li>jdk8，兼容12</li><li>Maven 3.3+</li></ul><h4 id="修改Maven配置文件"><a href="#修改Maven配置文件" class="headerlink" title="修改Maven配置文件"></a>修改Maven配置文件</h4><p>&emsp;&emsp;首先，你需要先下载<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven</a>，然后安装。找到安装目录下的config文件夹，点进去找到setting.xml配置文件，进行如下修改</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--开始处更改下载依赖的存放路径， 以下目录需要已经创建--&gt;</span><br><span class="line">&lt;localRepository&gt;D:\apache-maven-3.6.1\repository&lt;/localRepository&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--在 mirrors 标签下 添加阿里云maven私服库--&gt;</span><br><span class="line">  &lt;mirrors&gt;</span><br><span class="line">&lt;id&gt;nexus-aliyun&lt;/id&gt;    </span><br><span class="line">&lt;name&gt;nexus-aliyun&lt;/name&gt;  </span><br><span class="line">&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;    </span><br><span class="line">&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  </span><br><span class="line">  &lt;/mirrors&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--在 profiles 标签下指定jdk版本--&gt;</span><br><span class="line">&lt;profiles&gt;  </span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">&lt;id&gt;jdk-1.8&lt;/id&gt;</span><br><span class="line"></span><br><span class="line">&lt;activation&gt;</span><br><span class="line">&lt;activeByDefault&gt;true&lt;/activeByDefault&gt; </span><br><span class="line">&lt;jdk&gt;1.8&lt;/jdk&gt;</span><br><span class="line">&lt;/activation&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></div><h4 id="修改IDEA配置"><a href="#修改IDEA配置" class="headerlink" title="修改IDEA配置"></a>修改IDEA配置</h4><p><img src="/uploads/article/2019-08-22/IDEA配置.png" alt="IDEA配置.png"></p><p>&emsp;&emsp;如上图，我们打开IDEA的setting界面，找到MAVEN，在Maven Home Directory这一栏选择，我们刚才Maven安装的路径，当这一栏选好之后，第三栏的本地仓库路径会自动修改，然后，我们修改第二栏，选择我们上面修改的setting.xml文件。这样修改完成之后，我们maven项目在线依赖的库都存放在我们自己定义的存放文件夹下面。</p><h4 id="创建SpringBoot项目"><a href="#创建SpringBoot项目" class="headerlink" title="创建SpringBoot项目"></a>创建SpringBoot项目</h4><p>&emsp;&emsp;这里创建的是Maven项目，然后嵌入SpringBoot框架，这样你就不会因为直接创建SpringBoot项目生成的文件不知道是干什么用的造成的困惑。创建Maven项目之后的项目结构，如下图：</p><p><img src="/uploads/article/2019-08-22/Maven项目结构图.png" alt="Maven项目结构图.png"></p><p>&emsp;&emsp;如上图，有三个文件夹和一个pom.xml文件。</p><ul><li>java文件夹：存放java代码</li><li>resources文件夹：存放资源文件</li><li>test文件夹：单元测试</li><li>pom.xml：依赖库</li></ul><p>&emsp;&emsp;Maven项目会自动帮我们<a href="https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/html/getting-started-first-application.html#getting-started-first-application-pom" target="_blank" rel="noopener">创建pom.xml文件</a>，不用我们手动创建，我们先在pom.xml文件下添加如下依赖：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;关于这个我想说的就是，spring-boot-starter-parent是一个父级依赖，它是一个特殊的starter，这个依赖提供了常用的SpringBoot依赖库，使用它之后，我们SpringBoot常用库就不需要指定Version，这样，我们就避免了冲突，不兼容等问题。之前Android项目总是碰到依赖包冲突，这一点SpringBoot很nice。</p><p>&emsp;&emsp;添加完成这两个之后，我们就可以创建controller，也就是接口了。<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.POST)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello world!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><p>&emsp;&emsp;我这里类用@RestController注解标明，你也可以用@Controller，当你用@Controller的时候，你的方法上面还要加另外一个注解@ResponseBody。</p><p>&emsp;&emsp;再就是方法名称，在你的方法上面加@RequestMapping，里面的value值就是你的接口名称，后面的method就是你需要访问接口的方式。</p><p>&emsp;&emsp;再就是最后一步，创建一个引导类，它的主要作用就是启动我们的SpringBoot项目。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class HelloApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;到这里，我们就完成了，我们最后看一下项目结构图：</p><p><img src="/uploads/article/2019-08-22/项目结构图.png" alt="项目结构图.png"></p><p>PS:在这里，我们需要注意的是我们这个启动类最好放在最外层的包下面，因为这个启动类在启动的时候，会加载它这个包下面及其所有子包下面所有组件到spring容器中统一管理，你如果把这个启动类写在其它包下面，有可能就加载不到有的组件。</p><p>&emsp;&emsp;启动项目，不用我们手动部署到Tomcat，我们直接点击这个启动类的main方法，左边的启动按钮，run application就可以了。</p><p>&emsp;&emsp;最后，请求接口，因为，我这里定义的方式是post请求，所以，不能直接浏览器访问，你也可以把这个方式去掉，就可以了。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//http协议+ip+port+接口名</span><br><span class="line">http://localhost:8080/hello</span><br></pre></td></tr></table></figure></div><h4 id="项目打jar包"><a href="#项目打jar包" class="headerlink" title="项目打jar包"></a>项目打jar包</h4><p>添加依赖</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></div><p>&emsp;&emsp;选择项目右边的Maven—moudle名称—Lifecycle—package—run maven build即可。如下图：</p><p><img src="/uploads/article/2019-08-22/打jar包.png" alt="打jar包.png"></p><p><img src="/uploads/article/2019-08-22/jar包路径.png" alt="jar包路径.png"></p><p>&emsp;&emsp;然后，在控制台找到这个jar的路径，在我们的DOS命令界面用如下命令运行，即可：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar 刚才打好的jar包全名称包括后缀名</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;终于要正式开始了java后台之路，虽然，之前断断续续的看过过黑马的java web视频，但是，都是好几年前的视频，很老了，感觉用处比较大的就是MySQL数据库操作，之前也写过几篇关于&lt;a href=&quot;https://blog.csdn.net/qq_27634797/article/category/8050256&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL数据库操作的博客&lt;/a&gt;。目前，java后台最火的框架就属&lt;a href=&quot;https://spring.io/projects/spring-boot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot&lt;/a&gt;了。它是&lt;a href=&quot;https://spring.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring&lt;/a&gt;家族的衍生框架，并不是加强某个功能，它是为了简化配置，提高开发效率。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>dagger2整个流程解析（一）</title>
    <link href="http://haichenyi.com/2019/07/31/dagger2%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/07/31/dagger2整个流程解析（一）/</id>
    <published>2019-07-31T12:17:33.000Z</published>
    <updated>2019-09-18T09:02:34.288Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;众所周知，dagger的入门是比较难的，在嵌入之前，我先说一下这个dagger必要的东西，也是比较常见的东西，几个注解 <strong>@Component</strong>，<strong>@Singleton</strong>，<strong>@Module</strong>，<strong>@Provides</strong>，<strong>@Inject</strong></p><a id="more"></a><p>&emsp;&emsp;<strong>大致的整个流程如下：</strong></p><ol><li>编译的时候，先找构造方法由@Inject标记的类，生成对应的Factory.class类，这个类里面通过new生成对应的对象</li><li>然后，moudle里面，每一个由@Provider标记的方法，都会生成一个对应的Factory.class文件，这里返回的对象，就是刚才由new生成的对象</li><li>最后，我们通过component获取对象的时候，就找moudle去取。moudle取的对象就是之前new生成的</li></ol><p>&emsp;&emsp;<strong>也可以这样理解：</strong></p><ol><li>@Component直到桥梁的作用，告诉application,activity我能给你提供哪些对象</li><li>当Component中返回对象时，它会到@Module中去找这个对象创建没</li><li>@Module中的方法很多，它不可以每个方法的识别一次，它只找@Provider标记的方法</li></ol><p>&emsp;&emsp;<strong>后文的说明都是依赖于<a href="https://github.com/haichenyi/KotlinMvp" target="_blank" rel="noopener">kotlin框架</a></strong></p><p>&emsp;&emsp;这里我拿如下方法来说明整个流程：</p><p><img src="/uploads/article/2019-07-31/图一.png" alt="图一.png"></p><p>如上图：在AppComponent里面的getSpHelper()方法，返回对象就是SpHelper，前面我们说了，component里面需要的对象要在moudle里面找，moudle里面需要的对象要在@Inject的地方生成，所以，moudle里面也要有对应的方法：如下图：</p><p><img src="/uploads/article/2019-07-31/图五.png" alt="图五.png"></p><p>这里的，整个SpHelper是个什么东西呢？参数SpReal又是个什么东西呢？他就是一个sharePreference的接口。SpReal是SpHelper的实现类，如下图：</p><p><img src="/uploads/article/2019-07-31/图二.png" alt="图二.png"></p><p>这个就是一个普通的接口，与dagger2搭不上边。我们看他的实现类：</p><p><img src="/uploads/article/2019-07-31/图三.png" alt="图三.png"></p><p>如上图：类SpReal实现SpHelper接口，并且，它的构造方法用@Inject标记了。这里就跟我们的dagger2搭上关系了，我们就需要找SpReal对应的Factory.clss文件。如下图：</p><p><img src="/uploads/article/2019-07-31/图四.png" alt="图四.png"></p><p>如上图，SpReal_Factory类有三个方法，两个get()方法返回SpReal对象，静态的newInstance()方法也是返回SpReal对象，静态的create()方法，返回的是当前类的对象。那么，这里的调用顺序是什么呢？</p><p>我们在转过头来看看moudle里面方法对应的Factory：如下图</p><p><img src="/uploads/article/2019-07-31/图六.png" alt="图六.png"></p><p>如上图，左边我们看到AppMoudle生成了三个对应的Factory文件，为什么会生成三个？因为，我们的AppMoudle里面有三个方法是用注解@Provides标记的，可以回过头去看一下AppMoudle的内容。</p><p>我们仔细看一下，我们需要的这个类的内容AppModule_ProvideSpHelperFactory，一共有四个方法：一个构造方法，一个get方法，一个create方法，一个provideSpHelper方法。</p><p>是不是很眼熟这个providerSpHelper方法，并且他的返回值也是SpHelper，没错，这个方法就是我们AppMoudle里面定义的方法，在这里生成的对应的方法，它只是参数多了一个AppModule，为什么会多了这个参数呢？带着这个问题，我们看这个方法的实现：</p><p><img src="/uploads/article/2019-07-31/图七.png" alt="图七.png"></p><p>可以点击跳转这个方法，你会发现，它跳转回我们的AppMoudle方法里面对应的provideSpHelper()方法。回过头来想，我们的AppMoudle就是一个类，里面的provideSpHelper()就是一个普通的方法，怎么调用这个方法呢？就只有用 <strong>对象.方法名()</strong> 调用，所以，这里参数就多加了一个AppMoudle。</p><p>上面解释了为什么多了一个参数，我们再来看一下这个方法的实现。如下图：</p><p><img src="/uploads/article/2019-07-31/图八.png" alt="图八.png"></p><p>如上图，就是一个非空判断，如果为空就抛出空指针异常，如果不为空，就返回第一个参数。第一个参数是什么呢？第一个参数，不就是，我们上面说的对象调用方法名么？我们来看一下它这里是怎么实现的。如下图</p><p><img src="/uploads/article/2019-07-31/图九.png" alt="图九.png"></p><p>咦，怎么又返回来了？回到AppMoudle类了，它没有给我们实现啊？我们再想想，首先这个方法，返回的是第一个参数的值，第一个参数又是一个调用我们AppMoudle里面的方法，我们AppMoudle这个方法的返回值，就是这里这个方法的返回值。我们看一下，我们方法的返回值是什么？</p><p><img src="/uploads/article/2019-07-31/图九.png" alt="图十.png"></p><p>我们方法的返回值，不就是传进来的参数么？那我们再看看这里方法传进来的参数是什么？</p><p><img src="/uploads/article/2019-07-31/图十一.png" alt="图十一.png"></p><p>它这里的传的参数，就是这个方法的第二个参数。到这里，我们又断了，依然不知道，这个参数从哪来的。</p><p>冷静下来想一想，调用方法，参数从哪里来？我们从方法里面实现怎么看的到，我们肯定是要在调用方法的地方看。所以，我们就要找到在哪调用这个方法的。既然是写在AppComponent里面，那我们就找他的编译后生成的文件，也就是DaggerAppComponent，如下图：</p><p><img src="/uploads/article/2019-07-31/图十二.png" alt="图十二.png"></p><p>一眼看过去，这么多东西，怎么看？我又想到，这个DaggerAppComponent类是由AppComponent生成的类，通过上面的判断，这个类里面也应该有我在AppComponent定义的方法的实现才对，搜一下getSpHelper方法，果不其然。如下图：</p><p><img src="/uploads/article/2019-07-31/图十三.png" alt="图十三.png"></p><p>如上图，我们可以看到这个方法的实现，类点方法名，说明整个方法是静态的，我们点过去一看。如下图：</p><p><img src="/uploads/article/2019-07-31/图十四.png" alt="图十四.png"></p><p>不就是，我们前面说的那个静态方法吗？这样就跟我们前面分析的都串起来了。我们前面的问题是什么？不就是不知道这个方法的第二个参数从哪来的吗？现在，我们看到了，就是在这里new出来的。</p><p>至于第一个参数AppMoudle从哪来的？我们可以接着分析一下。如下图</p><p><img src="/uploads/article/2019-07-31/图十五.png" alt="图十五.png"></p><p>我们可以看到这个appMoudle定义的是一个全局的变量，我们就要找，在哪里初始化的？如下图：</p><p><img src="/uploads/article/2019-07-31/图十六.png" alt="图十六.png"></p><p>我们发现它是在构造方法里面初始化的，我们就要找在哪里调用的这个构造方法。如下图</p><p><img src="/uploads/article/2019-07-31/图十七.png" alt="图十七.png"></p><p>我们发现，在这个Builder类里面的build()方法调用的这个构造方法，我们就找在哪里调用的这个build()方法。如下图：</p><p><img src="/uploads/article/2019-07-31/图十八.png" alt="图十八.png"></p><p>我们发现，是AndroidInjector这个接口里面的抽象Builder类，这个抽象Builder类实现的是AndroidInjector.Factory，我们要找的就是这个create()方法。</p><p><img src="/uploads/article/2019-07-31/图十九.png" alt="图十九.png"></p><p>所以，这里在我们的Application里面初始化的，也就是我这里的MyApp里面初始化的。这个参数怎么传递的？如下图：</p><p><img src="/uploads/article/2019-07-31/图二十.png" alt="图二十.png"></p><p>在create方法里面调用build()之前还调用了seedInstance()方法，这里是抽象类的方法，要想知道这个方法是怎么实现的，那就得看他的实现类。这个Builder<t>的实现类是谁？想一想上面是怎么跳转过来的？不想这个，我们也可以点这个类进行跳转。如下图</t></p><p><img src="/uploads/article/2019-07-31/图二十一.png" alt="图二十一.png"></p><p>如上图，我们可以看到有两个地方调用，一个是ActComponent，一个是AppComponent，前面一个是activity相关的，我们还没有说到，我们现在一直说的都是Application相关的。所以，这里跳转的地方，肯定是Application。如下图</p><p><img src="/uploads/article/2019-07-31/图二十二.png" alt="图二十二.png"></p><p>这个方法还过时了，正好，我们这个Builder<t>抽象类还用@Deprecated标记了。诶？那这里还是没有实现啊，这也是一个抽象类。这个是抽象类，AppComponent又是一个接口，所以，我们要找这个AppComponent接口的实现类。如下图：</t></p><p><img src="/uploads/article/2019-07-31/图二十三.png" alt="图二十三.png"></p><p>如上图，AppComponent的实现类，就是DaggerAppComponent类。我们在这个类里面找Builder<t>的实现类就可以了。找找找，如下图</t></p><p><img src="/uploads/article/2019-07-31/图二十四.png" alt="图二十四.png"></p><p>如上图，这里有seedInstance方法和build两个方法，而且都是@Override的，从父类继承过来的，我们在看看AndroidInjector类。如下图：</p><p><img src="/uploads/article/2019-07-31/图二十五.png" alt="图二十五.png"></p><p>正好，它有这两个方法，并且还都是抽象方法。所以，这个类就是它的实现类。所以，调用的seedInstance方法，就是这里的这个方法。如下图：</p><p><img src="/uploads/article/2019-07-31/图二十六.png" alt="图二十六.png"></p><p>这个方法就是做了一个赋值操作，赋值之前做了一个非空检验。所以，在执行build()的时候这个seedInstance对象已经赋值了，不是空。所以这里就走通了。如下图</p><p><img src="/uploads/article/2019-07-31/图二十七.png" alt="图二十七.png"></p><p>如上的构造方法就走通了，那么appMoudle就有值了，那么我们前面的问题。如下图：</p><p><img src="/uploads/article/2019-07-31/图二十八.png" alt="图二十八.png"></p><p>我们之前就是在这里，不知道这个appMoudle是怎么赋值的，这里已经走通了。这就是通过AppComponent过去getSpHelper()的整个流程了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;众所周知，dagger的入门是比较难的，在嵌入之前，我先说一下这个dagger必要的东西，也是比较常见的东西，几个注解 &lt;strong&gt;@Component&lt;/strong&gt;，&lt;strong&gt;@Singleton&lt;/strong&gt;，&lt;strong&gt;@Module&lt;/strong&gt;，&lt;strong&gt;@Provides&lt;/strong&gt;，&lt;strong&gt;@Inject&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="http://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
</feed>
