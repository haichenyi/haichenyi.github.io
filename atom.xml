<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haichenyi.com/"/>
  <updated>2018-10-11T15:03:08.367Z</updated>
  <id>http://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDBC的简单使用——MySQL</title>
    <link href="http://haichenyi.com/2018/10/11/JDBC%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94MySQL/"/>
    <id>http://haichenyi.com/2018/10/11/JDBC的简单使用——MySQL/</id>
    <published>2018-10-11T14:51:00.000Z</published>
    <updated>2018-10-11T15:03:08.367Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前面几篇学了基本的SQL语句和用工具操作数据库，今天讲一下用代码操作数据库。</p><h4 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h4><p>&emsp;&emsp;<strong><em>首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java</em></strong></p><p>&emsp;&emsp;<strong><em>首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java</em></strong></p><p>&emsp;&emsp;<strong><em>首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java</em></strong></p><a id="more"></a><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1、获取驱动类,路动类路径：com.mysql.jdbc.Driver</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//获取url：jdbc:mysql://ip:端口号/数据库名称</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">//用户名</span><br><span class="line">String username = &quot;root&quot;;</span><br><span class="line">//密码</span><br><span class="line">String password = &quot;123&quot;;</span><br><span class="line">//获取Connection对象</span><br><span class="line">Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">System.out.print(connection);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总的来说，先要获取驱动类，然后就是获取Connection对象，就是一行代码<code>DriverManager.getConnection(url, username, password);</code>能走通，就说明连接上了。</p><h4 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test1() throws ClassNotFoundException, SQLException &#123;</span><br><span class="line">        //获取驱动类</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        //获取url</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">        //用户名</span><br><span class="line">        String username = &quot;root&quot;;</span><br><span class="line">        //密码</span><br><span class="line">        String password = &quot;123&quot;;</span><br><span class="line">        //获取Connection对象</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">        System.out.print(connection);</span><br><span class="line">        //获取Statement对象</span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        //String sql=&quot;INSERT INTO employee (eid,ename,edid) VALUES(null,&apos;小红&apos;,2)&quot;;</span><br><span class="line">        String sql = &quot;UPDATE employee SET edid=1 WHERE ename=&apos;小红&apos;&quot;;</span><br><span class="line">        statement.executeUpdate(sql);</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就是在连接数据库之后，通过Connection对象获取Statement对象，通过Statement对象的execute方法执行对应的SQL语句，最后记得关闭</p><h4 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        Connection con = null;</span><br><span class="line">        Statement state = null;</span><br><span class="line">        ResultSet resultSet = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String driverClassName = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">            String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">            String username = &quot;root&quot;;</span><br><span class="line">            String password = &quot;123&quot;;</span><br><span class="line">            Class.forName(driverClassName);</span><br><span class="line">            con = DriverManager.getConnection(url, username, password);</span><br><span class="line">            state = con.createStatement();</span><br><span class="line">            String querySQL = &quot;SELECT * FROM employee&quot;;</span><br><span class="line">            resultSet = state.executeQuery(querySQL);</span><br><span class="line">            List&lt;Map&lt;String, String&gt;&gt; mapList = new ArrayList&lt;&gt;();</span><br><span class="line">            while (resultSet.next()) &#123;</span><br><span class="line">                Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">                map.put(&quot;ename&quot;, resultSet.getString(&quot;ename&quot;));</span><br><span class="line">                map.put(&quot;edid&quot;, String.valueOf(resultSet.getInt(&quot;edid&quot;)));</span><br><span class="line">                mapList.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(mapList.size());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (resultSet != null) &#123;</span><br><span class="line">                    resultSet.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (state != null) &#123;</span><br><span class="line">                    state.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (con != null) &#123;</span><br><span class="line">                    con.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;查询数据库需要注意的地方就是：</p><ol><li><p>执行SQL语句的方法是<code>executeQuery()</code>，只能执行查询语句。</p></li><li><p>他有一个返回值ResultSet，然后循环这个Set对象，获取数据，他提供了一个移动光标的方法<code>next()</code>，当他为null的时候，返回false，结束循环。</p></li><li><p>还提供了一系列的get方法，传表每一栏的下标index，或者每一栏的名称，获取对应的值。值的类型要与get的类型相同。值为int，就用getInt，值为String就用getString</p></li><li><p>最后记得关闭连接，倒着关闭。</p></li></ol><h4 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h4><p>&emsp;&emsp;上面用自己拼接sql语句的方式查询数据库，会容易被sql攻击。所以，我们需要用<code>PreparedStatement</code>来防止被sql攻击，具体方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean login(String username, String password) throws Exception &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement pstat = null;</span><br><span class="line">        ResultSet rs = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">            String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">            String user = &quot;root&quot;;</span><br><span class="line">            String psw = &quot;123&quot;;</span><br><span class="line">            connection = DriverManager.getConnection(url, user, psw);</span><br><span class="line">            String sql = &quot;select * from t_user where username=? and psw=?&quot;;</span><br><span class="line">            pstat = connection.prepareStatement(sql);</span><br><span class="line">            pstat.setString(1, username);</span><br><span class="line">            pstat.setString(2, password);</span><br><span class="line">            rs = pstat.executeQuery();</span><br><span class="line">            return rs.next();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (rs != null) rs.close();</span><br><span class="line">            if (pstat != null) pstat.close();</span><br><span class="line">            if (connection != null) connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，是一个登录接口，传用户名，密码给后台，后台查询数据库，我们在获取了connection之后，通过connection调用prepareStatement方法，需要传一个sql模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;select * from t_user where username=? and psw=?&quot;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;什么是sql模板呢？就是吧需要动态传的参数用问好代替。我们上面这个查询语句，需要动态变化的就是username和psw。然后，我们调用PreparedStatement的setXxx方法，去设置值，第一个参数表示给第几个值赋值，第二个参数就是需要赋值的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//给第一个参数赋值为username</span><br><span class="line">pstat.setString(1, username);</span><br><span class="line">//给第二个参数赋值为password</span><br><span class="line">pstat.setString(2, password);</span><br></pre></td></tr></table></figure><h4 id="大数据存储"><a href="#大数据存储" class="headerlink" title="大数据存储"></a>大数据存储</h4><p>&emsp;&emsp;这里以存mp3为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_binary(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(50),</span><br><span class="line">DATA MEDIUMBLOB</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，首先创建一张表去存数据，数据类型不要错了，BLOB类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test1() throws SQLException, IOException &#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql=&quot;INSERT INTO t_binary VALUE(?,?,?)&quot;;</span><br><span class="line">        PreparedStatement pstat = connection.prepareStatement(sql);</span><br><span class="line">        pstat.setInt(1,1);</span><br><span class="line">        pstat.setString(2,&quot;KenT - 唱给谁听.mp3&quot;);</span><br><span class="line">        byte[] bytes= IOUtils.toByteArray(new FileInputStream(&quot;D:/CloudMusic/KenT - 唱给谁听.mp3&quot;));</span><br><span class="line">        Blob blob=new SerialBlob(bytes);</span><br><span class="line">        pstat.setBlob(3,blob);</span><br><span class="line">        pstat.executeLargeUpdate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面test1就是存的方法，步骤：</p><ol><li><p>先连接数据库，获取Connection对象</p></li><li><p>然后，获取PreparedStatement对象，设置参数，其中blob参数，Blob是一个接口，先获取他的实现类SerialBlob，这个实现类的构造方法需要传一个byte[]数组，所以，我们只用把需要存储的文件转成byte[]数组就可以了</p></li><li><p>最后，执行sql语句就可以了</p></li></ol><p>这里需要注意的是，要在my.ini服务器配置文件中设置最大存储<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个大小大于你的存储文件即可</span><br><span class="line">max_allowed_packet=20M</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;[mysqld]下边的是服务器配置，[mysql]下边的是客户端配置</p><p>&emsp;&emsp;接下来就是怎么取文件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test2() throws SQLException, IOException &#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql=&quot;SELECT * FROM t_binary WHERE name=?&quot;;</span><br><span class="line">        PreparedStatement pstat = connection.prepareStatement(sql);</span><br><span class="line">        pstat.setString(1,&quot;KenT - 唱给谁听.mp3&quot;);</span><br><span class="line">        ResultSet rs = pstat.executeQuery();</span><br><span class="line">        if (rs.next())&#123;</span><br><span class="line">            Blob blob = rs.getBlob(&quot;data&quot;);</span><br><span class="line">            InputStream in = blob.getBinaryStream();</span><br><span class="line">            FileOutputStream out = new FileOutputStream(&quot;D:/cgst.mp3&quot;);</span><br><span class="line">            IOUtils.copy(in,out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要说的就是获取到ResultSet之后，获取到Blob，通过他的getBinaryStream()方法，转成输入流，拿到输入流之后，转成File即可</p><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test6() throws SQLException &#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql = &quot;INSERT INTO t_user VALUE(?,?,?)&quot;;</span><br><span class="line">        PreparedStatement pstat = connection.prepareStatement(sql);</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            pstat.setInt(1, i + 1);</span><br><span class="line">            pstat.setString(2, &quot;user&quot; + i);</span><br><span class="line">            pstat.setString(3, i % 2 == 0 ? &quot;男&quot; : &quot;女&quot;);</span><br><span class="line">            pstat.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        pstat.executeBatch();</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.print(end - start);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意点：</p><ol><li>每添加一条数据，调用一遍pstat.addBatch();</li><li>当数据添加完以后，调用pstat.executeBatch();执行sql语句</li><li>mysql要开启批处理功能，不然慢到你无法想象。在获取Connection传的url后面，添加<code>rewriteBatchedStatements=true</code>。完整url<code>jdbc:mysql://localhost:3306/test4?rewriteBatchedStatements=true</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前面几篇学了基本的SQL语句和用工具操作数据库，今天讲一下用代码操作数据库。&lt;/p&gt;
&lt;h4 id=&quot;连接MySQL&quot;&gt;&lt;a href=&quot;#连接MySQL&quot; class=&quot;headerlink&quot; title=&quot;连接MySQL&quot;&gt;&lt;/a&gt;连接MySQL&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -JDBC" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（五）——多表查询</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（五）——多表查询/</id>
    <published>2018-10-11T14:50:45.000Z</published>
    <updated>2018-10-11T15:03:11.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并结果集-union-all-包含相同行-、union-去除相同行"><a href="#合并结果集-union-all-包含相同行-、union-去除相同行" class="headerlink" title="合并结果集 union all(包含相同行)、union(去除相同行)"></a>合并结果集 <code>union all(包含相同行)、union(去除相同行)</code></h3><p>&emsp;&emsp;把查询的结果合并到一起。<strong>要求：</strong> <code>查询的结果列数相同，列类型相同</code></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">    eid int,</span><br><span class="line">    ename varchar(50),</span><br><span class="line">    eage int</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table stu(</span><br><span class="line">    sid int,</span><br><span class="line">    sname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//合并结果集（加上all，包含相同的行）</span><br><span class="line">select eid,ename from emp</span><br><span class="line">union all</span><br><span class="line">select * from stu;</span><br><span class="line"></span><br><span class="line">//合并结果集（去掉all，去除相同行）</span><br><span class="line">select eid,ename from emp</span><br><span class="line">union</span><br><span class="line">select * from stu;</span><br></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p><strong>方言：</strong> <code>select * from 表1,表2 where 条件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表a有三条数据：q，w，e</span><br><span class="line">表b有两条数据：h，j</span><br><span class="line">select * from a,b;</span><br><span class="line">得出的结果是表a与表b的笛卡尔集，也就是会得到6条数据，</span><br><span class="line">分别：qh,qj,wh,wj,eh,ej</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">去除无用的笛卡尔集，加上where后面的条件</span><br><span class="line">连表查询会有附表的外键=主表的主键这个条件</span><br><span class="line"></span><br><span class="line">select * from student,teacher where student.tid=teacher.tid;</span><br><span class="line"></span><br><span class="line">查询学生的全部信息，需要查询学生表和老师表，</span><br><span class="line">条件是学生表里面的老师id等于老师表里面的老师id，</span><br><span class="line">这样查出来的结果就是我们想要的结果</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例子：要求打印员工姓名，工资以及部分名称</span><br><span class="line">     员工姓名，工资在emp表，部门名称在dept表</span><br><span class="line">select emp.ename,emp.sal,dept.dname</span><br><span class="line">from emp,dept</span><br><span class="line">where emp.did=dept.did;</span><br><span class="line"></span><br><span class="line">如果嫌弃表名字太长了可以这样：</span><br><span class="line">select e.ename,e.sal,d.dname</span><br><span class="line">from emp e,dept d</span><br><span class="line">where e.did=d.did;</span><br></pre></td></tr></table></figure><p><strong>标准：</strong> <code>select * from 表1 别名1 inner join 表2 别名2 on 条件</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">别名都是可选的，条件跟上面写的一样。两者的区别就只有二个：</span><br><span class="line">1、方言连接两个表是用逗号，标准连接两个表是用 inner join</span><br><span class="line">2、条件：方言用where，标准用on</span><br><span class="line"></span><br><span class="line">select e.ename,e.sal,d.dname</span><br><span class="line">from emp e inner join dept d</span><br><span class="line">where e.did=d.did;</span><br></pre></td></tr></table></figure></p><h4 id="外连接-一主一次"><a href="#外连接-一主一次" class="headerlink" title="外连接 一主一次"></a>外连接 <code>一主一次</code></h4><p><strong>左外连接</strong> <code>left outer join ,左表为主表，右表为次表,左表中不论满足不满足条件都查询出来，右表中对应的位置用null补位</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询所有员工名称，工资以及部门名称，部门名称为null的填无部分</span><br><span class="line">select e.ename as 姓名,e.sal as 工资,d.ifnull(dname,&apos;无部门&apos;) as 部门名称</span><br><span class="line">from emp e left outer join dept d</span><br><span class="line">where e.did=d.did;</span><br></pre></td></tr></table></figure></p><p><strong>右外连接</strong> <code>right outer join 与左外对应</code></p><h3 id="子查询-一条sql语句中有多个select关键字-ALL-ANY-IN"><a href="#子查询-一条sql语句中有多个select关键字-ALL-ANY-IN" class="headerlink" title="子查询 一条sql语句中有多个select关键字,ALL,ANY,IN"></a>子查询 <code>一条sql语句中有多个select关键字,ALL,ANY,IN</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查询员工中最高工资员工的详细信息</span><br><span class="line">select * from emp where sal=MAX(sal);</span><br><span class="line">//上面这个写法是错误的，条件中是不能出现集合函数</span><br><span class="line">//上面这个写法是错误的，条件中是不能出现集合函数</span><br><span class="line">//上面这个写法是错误的，条件中是不能出现集合函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1、先查最高工资</span><br><span class="line">select MAX(sal) from emp;</span><br><span class="line">//2、最高工资的员工信息</span><br><span class="line">select * from emp where sal=(select MAX(sal) from emp);</span><br><span class="line">//上面这个写法才是正确的</span><br><span class="line">//上面这个写法才是正确的</span><br><span class="line">//上面这个写法才是正确的</span><br></pre></td></tr></table></figure><p><strong>出现的位置：</strong> <code>1、from后作为表 2、where后作为条件</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上面那条sql语句就是作为条件</span><br><span class="line">//查询部门等于30的员工的姓名和年龄</span><br><span class="line">select e.name,e.age from (select * from emp where did=30) e;</span><br><span class="line">//上面这条就是from后面作为表</span><br></pre></td></tr></table></figure></p><p><strong>1、打印高于平均工资的所有人的信息(单行单列作为条件)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where (sal&gt;select AVG(sal) from emp);</span><br></pre></td></tr></table></figure></p><p><strong>2、打印大于30部门的所有员工工资的员工信息(多行单列作为条件)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where sal &gt; ALL (select sal from emp where did=30);</span><br></pre></td></tr></table></figure></p><p><strong>3、打印大于30部门任意一人员工工资的员工信息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where sal&gt; ANY (select sal from emp where did = 30);</span><br></pre></td></tr></table></figure></p><p><strong>4、打印工作和部门与张三相同的员工信息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where (job,did) IN (select job,did from emp where ename=&apos;张三&apos;);</span><br></pre></td></tr></table></figure></p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p><strong><em>前提条件已知四张表</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">员工表emp(eid,ename,job,emid,etime,sal,edid)</span><br><span class="line">部门表dept(did,dname,dloc)</span><br><span class="line">薪资等级表salgrade(grade,losal,hisal)</span><br><span class="line">领导表mgr(mid,mname,mtime)</span><br></pre></td></tr></table></figure></p><p><strong>1、查询至少有一个员工的部门，显示部门编号，部门名称，部门位置，部门人数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：d.did，d.dname，d.dloc，部门人数</span><br><span class="line">2、表：dept d，emp e</span><br><span class="line">条件：e.did=d.did</span><br><span class="line"></span><br><span class="line">//查询部门编号，部门名称，部门位置</span><br><span class="line">select * from dept;</span><br><span class="line"></span><br><span class="line">//查询部门人数</span><br><span class="line">select e.did,count(*) from emp group by e.did;</span><br><span class="line"></span><br><span class="line">//把上面查询的两张表内连接</span><br><span class="line">select * from dept inner join select e.did,count(*) from emp group by e.did;</span><br><span class="line"></span><br><span class="line">//加上条件，给出别名</span><br><span class="line">select d.*,z1.cnt from dept d inner join (select did,count(*) cnt from emp group by e.did) z1 where d.did=z1.did;</span><br></pre></td></tr></table></figure></p><p><strong>2、查询所有员工名称及其直接上级领导名称</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：e.ename，m.mname</span><br><span class="line">2、表：emp e，mgr m</span><br><span class="line">条件：e.emid=m.mid</span><br><span class="line">//查询员工名称</span><br><span class="line">select ename from emp;</span><br><span class="line">//查询领导名称</span><br><span class="line">select mname from mgr;</span><br><span class="line"></span><br><span class="line">select ename from emp e left outer join (select mname from mgr ) m on e.emid = m.mid;</span><br></pre></td></tr></table></figure></p><p><strong>3、列出受雇佣日期早于直接上级的所有员工编号，姓名，以及部门名称</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：e.eid,e.ename,d.dname</span><br><span class="line">2、表：emp，mgr，dept</span><br><span class="line">//查询受雇佣日期早于直接上级领导的员工信息</span><br><span class="line">select etime from emp;</span><br><span class="line">select mtime from mgr;</span><br><span class="line"></span><br><span class="line">select * from emp e</span><br><span class="line">inner join </span><br><span class="line">select mtime from mgr m</span><br><span class="line">on e.emid=m.mid and e.etime&lt;m.mtime</span><br><span class="line"></span><br><span class="line">//再把部门名称加上</span><br><span class="line">(select eid,ename,edid from emp e</span><br><span class="line">inner join </span><br><span class="line">select mtime from mgr m</span><br><span class="line">on e.emid=m.mid and e.etime&lt;m.mtime) z1 </span><br><span class="line">left outer join </span><br><span class="line">select dname from dept d </span><br><span class="line">on z1.edid = d.did;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">select e.eid,e.ename,d.dname</span><br><span class="line">from emp e,mgr m,dept d</span><br><span class="line">where e.emid=m.mid and e.etime&lt;m.mtime and e.edid=d.did;</span><br></pre></td></tr></table></figure></p><p><strong>4、列出部门名称和这些部门的员工信息，同事列出没有员工的部门</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：员工信息，和部门名称，没有员工的部门也要列出来</span><br><span class="line">2、表：emp,dept</span><br><span class="line"></span><br><span class="line">select e.*,d.dname from emp e </span><br><span class="line">right outer join </span><br><span class="line">dept d</span><br><span class="line">on e.edid=d.did;</span><br></pre></td></tr></table></figure></p><p><strong>5、列出最低薪资大于15000的各种工作以及从事此工作的人数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：工作类型，人数</span><br><span class="line">2、表：emp</span><br><span class="line">条件：min(sal)&gt;15000</span><br><span class="line"></span><br><span class="line">select job,count(*)</span><br><span class="line">from emp</span><br><span class="line">group by job</span><br><span class="line">having min(sal)&gt;15000</span><br></pre></td></tr></table></figure></p><p><strong>6、列出在销售部工作的员工姓名，假定不知道销售部的部门编号</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：员工姓名</span><br><span class="line">2、表：emp,dept</span><br><span class="line">条件：e.edid=d.did</span><br><span class="line"></span><br><span class="line">select ename</span><br><span class="line">from emp e</span><br><span class="line">where e.edid=(select did from dept where dname=&apos;销售部&apos;);</span><br></pre></td></tr></table></figure></p><p><strong>7、列出薪资高于公司平均工资的所有员工信息，所在部门名称，上级领导，工资等级</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：员工信息，部门名称，上级领导名称，工资等级</span><br><span class="line">2、表：emp,dept,mgr</span><br><span class="line">条件：sal&gt;avg(sal),e.edid=d.did,e.emid=m.mid</span><br><span class="line">//先查询高出平均工资的员工信息</span><br><span class="line">select * from emp where sal&gt;(select avg(sal) from emp);</span><br><span class="line"></span><br><span class="line">//把后面的表一个一个的加上去</span><br><span class="line">//加部门名称</span><br><span class="line">select e.*,d.dname</span><br><span class="line">from </span><br><span class="line">    emp e left outer join dept d on e.edid=d.did</span><br><span class="line">where e.sal&gt;(select avg(sal) from emp)</span><br><span class="line"></span><br><span class="line">//加上级领导名称</span><br><span class="line">select e.*,d.dname,m.mname</span><br><span class="line">from </span><br><span class="line">    emp e left outer join dept d on e.edid=d.did</span><br><span class="line">    left outer join mgr m on e.emid = m.mid</span><br><span class="line">where e.sal&gt;(select avg(sal) from emp)</span><br><span class="line"></span><br><span class="line">//最后加工资等级</span><br><span class="line">select e.*,d.dname,m.mname,s.grade</span><br><span class="line">from </span><br><span class="line">    emp e left outer join dept d on e.edid=d.did</span><br><span class="line">    left outer join mgr m on e.emid = m.mid</span><br><span class="line">    left outer join salgrade s on e.sal between s.losal and hisal</span><br><span class="line">where e.sal&gt;(select avg(sal) from emp)</span><br></pre></td></tr></table></figure></p><p><strong>8、列出与张三从事相同工作的所有员工以及部门名称</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：所有员工，部门名称</span><br><span class="line">2、表：emp，dept</span><br><span class="line">条件：张三的工作相同，e.edid=d.did</span><br><span class="line"></span><br><span class="line">select e.*,d.dname from emp e </span><br><span class="line">left outer join dept d</span><br><span class="line">on e.edid=d.did</span><br><span class="line">where e.job=(select job from emp where ename=&apos;张三&apos;);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">select e.*,d.dname from emp e,dept d where e.edid=did and e.job=(select job from emp where ename=&apos;张三&apos;);</span><br></pre></td></tr></table></figure></p><p><strong>9、列出薪资高于30部门的所有员工薪资的员工的姓名和薪资，部门名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select e.ename,e.sal,d.dname from emp e left outer join dept d</span><br><span class="line">where e.sal &gt; all (select sal from emp where edid=30) and e.edid = d.did;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;合并结果集-union-all-包含相同行-、union-去除相同行&quot;&gt;&lt;a href=&quot;#合并结果集-union-all-包含相同行-、union-去除相同行&quot; class=&quot;headerlink&quot; title=&quot;合并结果集 union all(包含相同行)、union(去除相同行)&quot;&gt;&lt;/a&gt;合并结果集 &lt;code&gt;union all(包含相同行)、union(去除相同行)&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;把查询的结果合并到一起。&lt;strong&gt;要求：&lt;/strong&gt; &lt;code&gt;查询的结果列数相同，列类型相同&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（四）——多表之间的关系</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（四）——多表之间的关系/</id>
    <published>2018-10-11T14:50:29.000Z</published>
    <updated>2018-10-11T15:03:14.674Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主键与外键"><a href="#主键与外键" class="headerlink" title="主键与外键"></a>主键与外键</h3><p><code>1、一张表可以有多个外键</code></p><p><code>2、外键是表的主键，可以是别的表，也可以是本身（少见）</code></p><p><code>3、外键可以为null，可以重复，但是不能不存在，必须要查的到</code></p><p><strong>创建语法</strong> <code>foreign key(本表的列名) references 关联的表名(关联表的主键)</code></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//创建一个部门表</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">did INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">dname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//插入几条数据</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;销售部&apos;);</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;技术部&apos;);</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;人力部&apos;);</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;保洁部&apos;);</span><br><span class="line"></span><br><span class="line">//创建一个员工表，这里的的edid是一个外键，对应部门表的主键did</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">eid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">ename VARCHAR(50),</span><br><span class="line">edid INT,</span><br><span class="line">CONSTRAINT fk_empl_dept FOREIGN KEY(edid) REFERENCES dept(did)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">eid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">ename VARCHAR(50),</span><br><span class="line">edid INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alter table employee add CONSTRAINT fk_empl_dept FOREIGN KEY(edid) REFERENCES dept(did);</span><br><span class="line"></span><br><span class="line">//上面这样也可以设置外键</span><br></pre></td></tr></table></figure><h3 id="一对一关系-把从表的主键设置成外键与主表的主键关联"><a href="#一对一关系-把从表的主键设置成外键与主表的主键关联" class="headerlink" title="一对一关系 把从表的主键设置成外键与主表的主键关联"></a>一对一关系 <code>把从表的主键设置成外键与主表的主键关联</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">    eid int primary key auto_increment,</span><br><span class="line">    ename varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table hmp(</span><br><span class="line">    hid int primary key auto_increment,</span><br><span class="line">    hname varchar(50),</span><br><span class="line">    constraint fk_hmp_emp foreign key(hid) references emp(eid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//如上，这样创建的两张表emp与hmp就是一对一的关系</span><br><span class="line"></span><br><span class="line">//插入数据</span><br><span class="line">insert into emp values(1,&apos;张三&apos;);</span><br><span class="line">insert into hmp values(1,&apos;李四&apos;);</span><br><span class="line">//这样张三跟李四就对应上了</span><br></pre></td></tr></table></figure><h3 id="多对多关系-两个主表-一个关联表"><a href="#多对多关系-两个主表-一个关联表" class="headerlink" title="多对多关系 两个主表+一个关联表"></a>多对多关系 <code>两个主表+一个关联表</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">create table teacher(</span><br><span class="line">    tid int primary key auto_increment,</span><br><span class="line">    tname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table student(</span><br><span class="line">    sid int primary key auto_increment,</span><br><span class="line">    sname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table stu_tea(</span><br><span class="line">    tid int,</span><br><span class="line">    sid int,</span><br><span class="line">    constraint fk_student foreign key(sid) references student(sid),</span><br><span class="line">    constraint fk_teacher foreign key(tid) references teacher(tid)</span><br><span class="line">);</span><br><span class="line">//这里的stu_tea就是关联表。多对多并不是说多张表对应多张表</span><br><span class="line"></span><br><span class="line">//插入数据</span><br><span class="line">insert into teacher values(1,&apos;黄老师&apos;);</span><br><span class="line">insert into teacher values(2,&apos;李老师&apos;);</span><br><span class="line">insert into teacher values(3,&apos;赵老师&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into student values(1,&apos;张三&apos;);</span><br><span class="line">insert into student values(2,&apos;李四&apos;);</span><br><span class="line">insert into student values(3,&apos;王五&apos;);</span><br><span class="line">insert into student values(4,&apos;赵六&apos;);</span><br><span class="line"></span><br><span class="line">//这里黄老师教过张三，李四</span><br><span class="line">insert into stu_tea values(1,1);</span><br><span class="line">insert into stu_tea values(1,2);</span><br><span class="line">//李老师教过王五，赵六</span><br><span class="line">insert into stu_tea values(2,3);</span><br><span class="line">insert into stu_tea values(2,4);</span><br><span class="line">//赵老师教过张三，李四，王五，赵六</span><br><span class="line">insert into stu_tea values(3,1);</span><br><span class="line">insert into stu_tea values(3,2);</span><br><span class="line">insert into stu_tea values(3,3);</span><br><span class="line">insert into stu_tea values(3,4);</span><br><span class="line"></span><br><span class="line">//上面这样，一个学生对应多个老师，一个老师也对应多个学生，叫做多对多的关系</span><br></pre></td></tr></table></figure><h3 id="一对多关系-一方不变，另一方在变化"><a href="#一对多关系-一方不变，另一方在变化" class="headerlink" title="一对多关系 一方不变，另一方在变化"></a>一对多关系 <code>一方不变，另一方在变化</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//我们一开始创建的员工表与部门表就是一对多</span><br><span class="line">create table dept(</span><br><span class="line">    did int primary key auto_increment,</span><br><span class="line">    dname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">    eid int primary key auto_increment,</span><br><span class="line">    ename varchar(50)</span><br><span class="line">    edid int,</span><br><span class="line">    constraint fk_emp_dept foreign key(edid) references dept(did)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//这里的一就是部门表（主表），多就是员工表（附表）</span><br><span class="line">//插入数据</span><br><span class="line">insert into dept values(10,&apos;技术部&apos;);</span><br><span class="line">insert into dept values(20,&apos;人事部&apos;);</span><br><span class="line"></span><br><span class="line">//张三，李四属于技术部，王五属于人事部</span><br><span class="line">insert into emp values(null,&apos;张三&apos;,10);</span><br><span class="line">insert into emp values(null,&apos;李四&apos;,10);</span><br><span class="line">insert into emp values(null,&apos;王五&apos;,20);</span><br><span class="line"></span><br><span class="line">//一个部门对应多个员工，一对多</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主键与外键&quot;&gt;&lt;a href=&quot;#主键与外键&quot; class=&quot;headerlink&quot; title=&quot;主键与外键&quot;&gt;&lt;/a&gt;主键与外键&lt;/h3&gt;&lt;p&gt;&lt;code&gt;1、一张表可以有多个外键&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2、外键是表的主键，可以是别的表，也可以是本身（少见）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3、外键可以为null，可以重复，但是不能不存在，必须要查的到&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建语法&lt;/strong&gt; &lt;code&gt;foreign key(本表的列名) references 关联的表名(关联表的主键)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（三）——数据库的备份与恢复</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（三）——数据库的备份与恢复/</id>
    <published>2018-10-11T14:50:13.000Z</published>
    <updated>2018-10-11T15:03:20.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库的备份与恢复"><a href="#数据库的备份与恢复" class="headerlink" title="数据库的备份与恢复"></a>数据库的备份与恢复</h3><p><strong>备份</strong>：<code>mysqldump -u用户名 -p密码 数据库名&gt;生成的脚本路径</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//末尾没有分号，也不要登录</span><br><span class="line">mysqldunp -uroot -p123 school&gt;C:a.sql</span><br></pre></td></tr></table></figure><p><strong>恢复</strong>：<code>mysqldump -u用户名 -p密码 数据库名&lt;生成的脚本路径</code></p><p><code>或者：登录之后，切换到需要恢复的数据库，输入：source 生成的脚本路径</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//要先删除school数据库，再重新创建数据库，这两步需要登录</span><br><span class="line">//执行下面sql语句，不要登录，末尾没有分号</span><br><span class="line">mysqldunp -uroot -p123 school&lt;C:a.sql</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><p>找到你的mysql的安装目录，找到my.ini文件，更bin目录同级，修改如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">character-set-server=utf8 </span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"></span><br><span class="line">default-character-set=utf8 </span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"></span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure></p><p><strong>修改完之后，不仅是要重新连接数据库，必须要重启数据库</strong></p><p><strong>修改完之后，不仅是要重新连接数据库，必须要重启数据库</strong></p><p><strong>修改完之后，不仅是要重新连接数据库，必须要重启数据库</strong></p><p><code>net stop mysql</code> <code>net start mysql</code></p><h3 id="主键-primary-key"><a href="#主键-primary-key" class="headerlink" title="主键 primary key"></a>主键 primary key</h3><p><strong>创建表的时候直接设置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid CHAR(12) PRIMARY KEY,</span><br><span class="line">ename VARCHAR(20),</span><br><span class="line">esal INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">esid CHAR(12),</span><br><span class="line">ename VARCHAR(20),</span><br><span class="line">esal INT,</span><br><span class="line">PRIMARY KEY(esid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>修改主键</strong> <code>alter table 表名 add primary key(键名)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp add primary key(esid);</span><br></pre></td></tr></table></figure></p><p><strong>删除主键</strong> <code>alter table 表名 drop primary key</code></p><p><strong>主键自增长</strong> <code>auto_increment</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid int PRIMARY KEY auto_increment,</span><br><span class="line">ename VARCHAR(20),</span><br><span class="line">esal INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>非空约束</strong> <code>not null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid int PRIMARY KEY auto_increment,</span><br><span class="line">ename VARCHAR(20) not null,</span><br><span class="line">esal INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>唯一约束</strong> <code>not null unique</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid int PRIMARY KEY auto_increment,</span><br><span class="line">ename VARCHAR(20) not null unique,</span><br><span class="line">esal INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据库的备份与恢复&quot;&gt;&lt;a href=&quot;#数据库的备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;数据库的备份与恢复&quot;&gt;&lt;/a&gt;数据库的备份与恢复&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;备份&lt;/strong&gt;：&lt;code&gt;mysqldump -u用户名 -p密码 数据库名&amp;gt;生成的脚本路径&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//末尾没有分号，也不要登录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysqldunp -uroot -p123 school&amp;gt;C:a.sql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;恢复&lt;/strong&gt;：&lt;code&gt;mysqldump -u用户名 -p密码 数据库名&amp;lt;生成的脚本路径&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;或者：登录之后，切换到需要恢复的数据库，输入：source 生成的脚本路径&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//要先删除school数据库，再重新创建数据库，这两步需要登录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//执行下面sql语句，不要登录，末尾没有分号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysqldunp -uroot -p123 school&amp;lt;C:a.sql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（二）——DQL</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94DQL/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（二）——DQL/</id>
    <published>2018-10-11T14:49:56.000Z</published>
    <updated>2018-10-11T15:08:39.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>关键字：<figure class="highlight plain"><figcaption><span>by、having、roder by```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">#### 基本查询</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;**查询所有：**``select * from 表名;``</span><br></pre></td></tr></table></figure></p><p>select * from t_stu;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;**查询部分列**``select 列名,...列名 from 表名;``</span><br></pre></td></tr></table></figure></p><p>select stu_num,stu_name from t_stu;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;**查询去除完全重复的列**``select distinct * from 表名;``</span><br></pre></td></tr></table></figure></p><p>select distinct * from t_stu;<br>select distinct stu_age from t_stu;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;**也可以查询同时做加、减、乘、除运算操作**：</span><br></pre></td></tr></table></figure></p><p>//把查询出来的年龄都乘以2倍。<br>select stu_age*2 from t_stu;<br>//如果查出来的年龄为null，就设置为29<br>select ifnull(stu_age,29) from t_stu;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;**做连接字符串操作：CONCAT**</span><br></pre></td></tr></table></figure></p><p>//把名字和年龄拼接起来<br>select CONCAT(stu_name,stu_age) from t_stu;</p><p>select CONCAT(‘我的名字是：’,stu_name,’，我今年’,stu_age,’岁’) from t_stu;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;**给列起别名：as**</span><br></pre></td></tr></table></figure></p><p>select stu_age as 年龄 from t_stu;<br>select stu_age as 年龄,stu_name as 姓名 from t_stu;<br>select CONCAT(stu_name,stu_age) as 描述 from t_stu;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 条件查询</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;跟前面一篇讲的更新，删除里面设置条件的方法是一样的。``where``后面跟条件</span><br></pre></td></tr></table></figure></p><p>//查询年龄大于等于20的学生<br>select <em> from t_stu where stu_age&gt;=20;<br>//查询年龄在15到25岁之间的学生<br>select </em> from t_stu where stu_age between 15 and 25;<br>//查询名字叫zhangsan,lisi,wangwu.zhaoliu的学生<br>select * from t_stu where stu_name in(‘zhangsan’,’lisi’,’wangwu’,’zhangliu’);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;**模糊查询**``like``</span><br></pre></td></tr></table></figure></p><p>//一个字加一个下划线，两个字就是两个下划线<br>//查询名字中张开头，并且是两个字的学生.<br>select <em> from t_stu where stu<em>name like ‘张</em>‘;<br>//查询名字是三个字的学生<br>select </em> from t_stu where stu<em>name like ‘__</em>‘;</p><p>//百分号%匹配0~N个字符<br>//查询名字中以雷结尾的学生<br>select <em> from t_stu where stu_name like ‘%雷’;<br>//查询名字中包含晓的学生<br>select </em> from t_stu where stu_name like ‘%晓%’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 排序 ``order by``</span><br></pre></td></tr></table></figure></p><p>// desc:降序，asc：升序<br>//按学生年龄升序排列<br>select <em> from t_stu ORDER BY stu_age ASC;<br>//按学生年龄降序排列<br>select </em> from t_stu ORDER BY stu_age DESC;<br>//年龄相同的时候，按名字降序排列。可以无限添加排序条件<br>select * from t_stu ORDER BY stu_age ASC,stu_name DESC;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 聚合函数(纵向查询)</span><br><span class="line"></span><br><span class="line">``计数count``</span><br></pre></td></tr></table></figure></p><p>//只要不为null，就+1<br>select count(*) from t_stu;<br>select count(stu_age) from t_stu;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">``计算和sum``</span><br></pre></td></tr></table></figure></p><p>//计算学生年龄加起来的总数<br>select sum(stu_age) from t_stu;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">``最大值max,最小值min``</span><br></pre></td></tr></table></figure></p><p>//查询年龄中最大的<br>select max(stu_age) from t_stu;<br>//查询年龄中最小的<br>select min(stu_age) from t_stu;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">``平均值avg``</span><br></pre></td></tr></table></figure></p><p>select avg(stu_age) from t_stu;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####  分组查询``group by``</span><br><span class="line"></span><br><span class="line">写法：``select 条件,聚合函数,...,聚合函数 from 表名 group by 条件;``</span><br><span class="line"></span><br><span class="line">分组查询必须都是聚合函数，并且，上面两个位置的条件必须相同</span><br></pre></td></tr></table></figure></p><p>//按老师分组查询，每组老师名下的学生个数<br>select stu_teacher,count(*) from t_stu group by stu_teacher;</p><p>//分组前条件，不满足条件的没有参加分组<br>//按老师分组查询，查询每组老师名下年龄大于20岁的学生的个数<br>select stu_teacher,count(*) from t_stu where stu_age&gt;20 group by stu_teacher;</p><p>//having 分组后条件<br>//按老师分组查询，查询老师名下年龄大于20岁的学生，并且剔除学生个数小于5个的老师<br>select stu_teacher,count(<em>) from t_stu where stu_age&gt;20 group by stu_teacher having count(</em>)&lt;5;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### limit(MySQL特有的)</span><br></pre></td></tr></table></figure></p><p>//从下标0开始，往后查询5条数据<br>select * from t_stu limit 0,5;</p><p>//分页查询，比方说如果你要查第N页的数据，每页数据M条<br>//(当前页-1)<em>每页的数据数<br>select </em> from t_stu limit (N-1)*M,M;<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;DQL&quot;&gt;&lt;a href=&quot;#DQL&quot; class=&quot;headerlink&quot; title=&quot;DQL&quot;&gt;&lt;/a&gt;DQL&lt;/h3&gt;&lt;p&gt;关键字：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;by、having、ro
      
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（一）——DDL、DML、DCL</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94DDL%E3%80%81DML%E3%80%81DCL/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（一）——DDL、DML、DCL/</id>
    <published>2018-10-11T14:49:35.000Z</published>
    <updated>2018-10-11T15:03:23.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL:"></a>MySQL:</h3><p>&emsp;&emsp;<strong>启动：</strong><code>net start mysql</code></p><p>&emsp;&emsp;<strong>停止：</strong><code>net stop mysql</code></p><p>&emsp;&emsp;<strong>登录：</strong><code>mysql -u root -p</code> 例如：mysql -uroot -p123 -hlocalhost</p><p>&emsp;&emsp;<strong>退出：</strong><code>exit或者quit</code></p><a id="more"></a><h3 id="DDL操作："><a href="#DDL操作：" class="headerlink" title="DDL操作："></a>DDL操作：</h3><p>&emsp;&emsp;加上if exists或者if not exists：都是如果存在，或者如果不存在，就不做相关操作</p><p>&emsp;&emsp;<strong>查询当前有哪些数据库：</strong><code>show databases;</code></p><p>&emsp;&emsp;<strong>创建数据库：</strong><code>CREATE DATABASE if not exists 数据库的名字 CHARSET=utf8;</code>例如：CREATE DATABASE if not exists employee CHARSET=utf8;创建一个编码为utf-8的employee数据库。不存在就创建，存在就不管。</p><p>&emsp;&emsp;<strong>删除数据库：</strong><code>DRAP DATABASE if exists 数据库名称;</code>例如：DRAP DATABASE if exists employee;删除employee数据库，如果存在就删除，不存在就不管。</p><p>&emsp;&emsp;<strong>修改数据库编码方式：</strong><code>ALTER DATABASE 数据库名称 CHARACTER SET utf8;</code></p><p>&emsp;&emsp;<strong>切换数据库：</strong><code>use 数据库名称;</code></p><p>&emsp;&emsp;<strong>创建表：</strong><code>CREATE TABLE if not exists 表名(列名 列类型,...,列名 列类型);</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE if noe exists t_stu(</span><br><span class="line"></span><br><span class="line">        stu_num char(11),</span><br><span class="line"></span><br><span class="line">        stu_name varchar(50),</span><br><span class="line"></span><br><span class="line">        stu_age int,</span><br><span class="line"></span><br><span class="line">        stu_sex varchar(10)</span><br><span class="line"></span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>显示当前数据库包含的表：</strong><code>show tables;</code></p><p>&emsp;&emsp;<strong>显示当前表结构：</strong><code>desc 表名称;</code></p><p>&emsp;&emsp;<strong>删除表：</strong><code>drop table 表名称;</code></p><p>&emsp;&emsp;<strong>新增列：</strong><code>alter table 表名 add(列名 列类型,...,列名 列类型);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu add(</span><br><span class="line"></span><br><span class="line">        stu_address varchar(100),</span><br><span class="line"></span><br><span class="line">        stu_phone char(11)</span><br><span class="line"></span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改列类型：</strong><code>alter table 表名 modify 列名 列新类型;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu modify stu_address varchar(50);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改列名：</strong><code>alter table 表名 change 原始列名 新列名 列类型;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu change stu_address stu_addr varchar(100);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>删除列：</strong><code>alter table 表名 drop 列名;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu drop stu_address;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>修改表名：</strong><code>alter table 原始表名 rename to 新表名;</code></p><h3 id="DML操作："><a href="#DML操作：" class="headerlink" title="DML操作："></a>DML操作：</h3><p>为了好操作，先用一下查询的命令，查询表的所有记录： select * from 表名;</p><p>&emsp;&emsp;<strong>插入一行记录：</strong><code>INSERT INTO 表名 (列名,...,列名)VALUES(列值,...,列值);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t_stu(</span><br><span class="line"></span><br><span class="line">        stu_num,stu_name,stu_age,stu_sex,stu_phone</span><br><span class="line">        </span><br><span class="line">        )VALUES(</span><br><span class="line">        </span><br><span class="line">        &apos;test_num_001&apos;,&apos;张三&apos;,18,&apos;man&apos;,&apos;13888888888&apos;</span><br><span class="line">        </span><br><span class="line">        );</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>修改所有数据：</strong><code>update 表名 set 列名=列值,...,列名=列值;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t_stu set name=&apos;wangwu&apos;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改数据(单个条件)：</strong><code>update 表名 set 列名=列值,...,列名=列值 where 列名=列值;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t_stu set stu_name=&apos;zhangsan&apos; where stu_num=&apos;testNum_00001&apos;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改数据(多个条件)：</strong><code>update 表名 set 列名=列值,...,列名=列值 where 列名=列值 or 列名=列值;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//or,或者</span><br><span class="line">update t_stu set stu_age=28 where stu_num=&apos;testNum_0001&apos; or stu_name=&apos;zhangliu&apos;;</span><br><span class="line">//and，并且</span><br><span class="line">update t_stu set stu_age=28 where stu_age&gt;=25 and stu_age&lt;=30;</span><br><span class="line">//between...and...在什么区间内</span><br><span class="line">update t_stu set stu_age=28 where stu_age between 25 and 30;</span><br><span class="line">//in(...)</span><br><span class="line">update t_stu set stu_age=28 where stu_name  in (&apos;zhangsan&apos;,&apos;lisi&apos;);</span><br><span class="line">//is null，是null。不能是stu_name=null</span><br><span class="line">update t_stu set stu_age=28 where stu_name  is null;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>删除记录：</strong><code>DELETE FROM 表名 where ...;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这里where后面的条件跟前面的update是一样的写法</span><br><span class="line">DELETE FROM t_stu where stu_age = 28;</span><br></pre></td></tr></table></figure></p><h3 id="DCL操作："><a href="#DCL操作：" class="headerlink" title="DCL操作："></a>DCL操作：</h3><p>&emsp;&emsp;<strong>创建用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//只要是写用户名的位置都可以设置固定ip，或者不固定ip</span><br><span class="line">CREATE USER 用户名@IP地址 IDENTIFIED BY &apos;密码&apos;;//固定ip登录</span><br><span class="line">CREATE USER 用户名@&apos;%&apos; IDENTIFIED BY &apos;密码&apos;;//任意ip登录</span><br><span class="line">CREATE USER zhangSan@&apos;%&apos; IDENTIFIED BY &apos;123&apos;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>给用户授权：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限1,权限2,...,权限n ON 数据库名称.* TO 用户名@ip地址;</span><br><span class="line">GRANT 权限1,权限2,...,权限n ON 数据库名称.* TO 用户名@&apos;%&apos;;</span><br><span class="line"></span><br><span class="line">GRANT CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT ON school.* TO zhangSan@&apos;%&apos;;</span><br><span class="line">//给所有权限</span><br><span class="line">GRANT ALL ON school.* TO zhangSan@&apos;%&apos;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>撤销权限：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE  权限1,权限2,...,权限n ON 数据库名称.* FROM 用户名@&apos;%&apos;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>查看用户权限：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR 用户名@ip地址;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>删除用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER 用户名@ip地址;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL:&quot;&gt;&lt;/a&gt;MySQL:&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;启动：&lt;/strong&gt;&lt;code&gt;net start mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;停止：&lt;/strong&gt;&lt;code&gt;net stop mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;登录：&lt;/strong&gt;&lt;code&gt;mysql -u root -p&lt;/code&gt; 例如：mysql -uroot -p123 -hlocalhost&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;退出：&lt;/strong&gt;&lt;code&gt;exit或者quit&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Android——MQTT推送</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E2%80%94%E2%80%94MQTT%E6%8E%A8%E9%80%81/"/>
    <id>http://haichenyi.com/2018/05/13/Android——MQTT推送/</id>
    <published>2018-05-13T14:28:22.000Z</published>
    <updated>2018-05-13T14:36:43.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h3><p>&emsp;&emsp;最近公司用到的推送MQTT。不想过多的介绍背景什么的，我就直接讲怎么实现这个功能。</p><p>&emsp;&emsp;他这个原理长连接，这个不用多讲，用法类似于EventBus，需要先订阅，然后通过topic再发送消息。topic是什么呢？我先来讲讲整体流程：</p> <a id="more"></a><ol><li><p>先连接服务器，要先建立长连接</p></li><li><p>然后需要订阅topic，连接之后才能订阅topic</p></li><li><p>最后就是通过topic推送消息，接收消息</p></li></ol><p>一步一步讲：</p><h3 id="第一步，与服务器建立连接"><a href="#第一步，与服务器建立连接" class="headerlink" title="第一步，与服务器建立连接"></a>第一步，与服务器建立连接</h3><p>&emsp;&emsp;先丢代码，然后看注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void initPush() &#123;</span><br><span class="line">        // 服务器地址（协议+地址+端口号）</span><br><span class="line">        String uri = host;</span><br><span class="line">        client = new MqttAndroidClient(this, uri, clientId);</span><br><span class="line">        // 设置MQTT监听并且接受消息</span><br><span class="line">        client.setCallback(mqttCallback);</span><br><span class="line">        //Mqtt的一些设置</span><br><span class="line">        conOpt = new MqttConnectOptions();</span><br><span class="line">        conOpt.setAutomaticReconnect(true);</span><br><span class="line">        // 清除缓存</span><br><span class="line">        conOpt.setCleanSession(true);</span><br><span class="line">        // 设置超时时间，单位：秒</span><br><span class="line">        conOpt.setConnectionTimeout(10);</span><br><span class="line">        // 心跳包发送间隔，单位：秒</span><br><span class="line">        conOpt.setKeepAliveInterval(20);</span><br><span class="line">        myTopic = String.format(TOPIC_SUB, mDeviceId);</span><br><span class="line">        Log.e(TAG,&quot;myTopic_________&quot;+myTopic);</span><br><span class="line">        doClientConnection();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><ol><li>第一个问题，与服务器建立连接，你得先有一个服务器吧？我根据网上的步骤，创建了一个apache-apollo服务器，并且启动了，也启动成功了，我建立连接的时候，总是失败。然后，找啊找，找啊找。问题没有解决，但是，我找到了一个可以用的服务器，也就是这里的uri，不要设置MqttConnectOptions的用户名和密码，设置了他会拒绝</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private String host = &quot;tcp://test.mosquitto.org:1883&quot;;</span><br></pre></td></tr></table></figure><ol><li>第二个问题，我连接成功之后，不一会，他就会自动断开连接，或者，推送完消息之后，他就会断开连接。然后，网上搜原因，找啊找，诶，我找到了。MqttAndroidClient的构造方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructor - create an MqttAndroidClient that can be used to communicate with an MQTT server on android</span><br><span class="line"> * </span><br><span class="line"> * @param context </span><br><span class="line"> *            object used to pass context to the callback. </span><br><span class="line"> * @param serverURI</span><br><span class="line"> *            specifies the protocol, host name and port to be used to</span><br><span class="line"> *            connect to an MQTT server</span><br><span class="line"> * @param clientId</span><br><span class="line"> *            specifies the name by which this connection should be</span><br><span class="line"> *            identified to the server</span><br><span class="line"> */</span><br><span class="line">public MqttAndroidClient(Context context, String serverURI,</span><br><span class="line">String clientId) &#123;</span><br><span class="line">this(context, serverURI, clientId, null, Ack.AUTO_ACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看第三个参数，clientId，指定一个名字，用来连接服务器的身份标识。就是说，你设置的这个值，是你在服务器的唯一标识，不能跟其他用户的相同。我把这个clientId直接用uuid生成，就没问题了。</p><h3 id="第二步，订阅topic"><a href="#第二步，订阅topic" class="headerlink" title="第二步，订阅topic"></a>第二步，订阅topic</h3><p>&emsp;&emsp;回到上面，接着往下面走，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 连接MQTT服务器</span><br><span class="line">     */</span><br><span class="line">    private void doClientConnection() &#123;</span><br><span class="line">        if (!client.isConnected() &amp;&amp; isConnectIsNormal()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                client.connect(conOpt, null, iMqttActionListener);</span><br><span class="line">            &#125; catch (MqttException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 判断网络是否连接</span><br><span class="line">     */</span><br><span class="line">    private boolean isConnectIsNormal() &#123;</span><br><span class="line">        ConnectivityManager connectivityManager = (ConnectivityManager) this.getApplicationContext()</span><br><span class="line">                .getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        if (connectivityManager != null) &#123;</span><br><span class="line">            NetworkInfo info = connectivityManager.getActiveNetworkInfo();</span><br><span class="line">            if (info != null &amp;&amp; info.isAvailable()) &#123;</span><br><span class="line">                String name = info.getTypeName();</span><br><span class="line">                Log.e(TAG, &quot;MQTT当前网络名称：&quot; + name);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.e(TAG, &quot;MQTT 没有可用网络&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法就是用来连接服务器的，首先判断是否正在连接，后面那个是判断当前有没有网络。再就是这个iMqttActionListener监听了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// MQTT是否连接成功</span><br><span class="line">    private IMqttActionListener iMqttActionListener = new IMqttActionListener() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onSuccess(IMqttToken arg0) &#123;</span><br><span class="line">            Log.e(TAG, &quot;连接成功 &quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 订阅myTopic话题</span><br><span class="line">                client.subscribe(myTopic, 0);</span><br><span class="line">            &#125; catch (MqttException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onFailure(IMqttToken arg0, Throwable arg1) &#123;</span><br><span class="line">            Log.e(TAG, &quot;连接失败&quot;);</span><br><span class="line">            arg1.printStackTrace();</span><br><span class="line">            // 连接失败，重连</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讷，就是这里，你如果服务器有问题，他一直走onFailure方法。服务器连接成功之后，就是订阅topic。我来说说这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.subscribe(myTopic, 0);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先，这个主题，是你自己跟服务器商量好的，随便什么都可以。为什么要订阅主题呢？我提前给你瞅瞅推送消息是怎么推送的</p><p>&emsp;&emsp;第二个参数，消息的类型qos，有三种：0、1、2</p><ol><li>0代表“至多一次”，消息发布完全依赖底层 TCP/IP 协议。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送</li><li>1代表“至少一次”，确保消息到达，但消息重复可能会发生</li><li>2代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。</li></ol><p>&emsp;&emsp;简单说明下，如果发送的是临时的消息，例如给某topic所有在线的设备发送一条消息，丢失的话也无所谓，0就可以了。如果需要客户端保证能接收消息，需要指定QoS为1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.publish(topic, new MqttMessage(msg.getBytes()));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讷，推送消息，是根据topic推送的，第二个参数，就是你要推送的具体消息。我个人认为，你可以理解成就类似于键值对的形式，</p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p>&emsp;&emsp;这个就是跟其他长连接不同的地方，底层，其实都一样，虽然我没有看底层的代码。想也想的到，服务器肯定是根据这个主题，去找对应的用户，然后推送消息。而其他的长连接就是直接指定用户。跑题了，跑题了。</p><h3 id="第三步，推送、接收消息"><a href="#第三步，推送、接收消息" class="headerlink" title="第三步，推送、接收消息"></a>第三步，推送、接收消息</h3><p>&emsp;&emsp;当你连接服务器成功之后，就要推送消息了，我用的EventBus发的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void publishData(String msg) &#123;</span><br><span class="line">        String topic = myTopic;</span><br><span class="line">        try &#123;</span><br><span class="line">            Log.e(TAG,&quot;给__&quot;+topic+&quot;__topic发送的消息为：&quot;+msg);</span><br><span class="line">            client.publish(topic, new MqttMessage(msg.getBytes()));</span><br><span class="line">        &#125; catch (MqttException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // MQTT监听并且接受消息</span><br><span class="line">    private MqttCallback mqttCallback = new MqttCallback() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void messageArrived(String topic, MqttMessage message) throws Exception &#123;</span><br><span class="line">            Log.e(TAG,&quot;接受到__&quot;+topic+&quot;__topic的消息为：&quot;+new String(message.getPayload()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void deliveryComplete(IMqttDeliveryToken arg0) &#123;</span><br><span class="line">            Log.e(TAG,&quot;deliveryComplete&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void connectionLost(Throwable arg0) &#123;</span><br><span class="line">            // 失去连接，重连</span><br><span class="line">            Log.e(TAG,&quot;失去连接&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当你的clientId重复的时候，他就会一直走connectionLost方法。到这里，基本上就讲完了，要注意的是，退出的时候，记得要释放资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (client != null &amp;&amp; client.isConnected()) &#123;</span><br><span class="line">                client.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (MqttException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        EventBus.getDefault().unregister(this);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>网上很多都是直接讲整体流程，重来不讲中间碰到的问题。难受</p><p><a href="https://download.csdn.net/download/qq_27634797/10408420" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;整体介绍&quot;&gt;&lt;a href=&quot;#整体介绍&quot; class=&quot;headerlink&quot; title=&quot;整体介绍&quot;&gt;&lt;/a&gt;整体介绍&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近公司用到的推送MQTT。不想过多的介绍背景什么的，我就直接讲怎么实现这个功能。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;他这个原理长连接，这个不用多讲，用法类似于EventBus，需要先订阅，然后通过topic再发送消息。topic是什么呢？我先来讲讲整体流程：&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android—React Native编程</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E2%80%94React-Native%E7%BC%96%E7%A8%8B/"/>
    <id>http://haichenyi.com/2018/05/13/Android—React-Native编程/</id>
    <published>2018-05-13T14:28:07.000Z</published>
    <updated>2018-05-13T14:32:04.667Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人博客：haichenyi.com。感谢关注</strong></p><h2 id="新公司，新的开始，新的技术"><a href="#新公司，新的开始，新的技术" class="headerlink" title="新公司，新的开始，新的技术"></a>新公司，新的开始，新的技术</h2><p>&emsp;&emsp;新公司的项目，用到的RN编程，之前完全没有碰到过，遇到新技术，之前完全没有碰到过怎么办？google、百度咯。通过不屑的努力，找到了<a href="https://www.jianshu.com/u/6e613846e1ea" target="_blank" rel="noopener">恋猫月亮 </a>的三篇关于RN的文章。我感觉还是很不错的。</p> <a id="more"></a><p><a href="https://www.jianshu.com/p/97692b1c451d" target="_blank" rel="noopener">从Android到React Native开发（一、入门）</a></p><p><a href="https://www.jianshu.com/p/bec040926db8" target="_blank" rel="noopener">从Android到React Native开发（二、通信与模块实现）</a></p><p><a href="https://www.jianshu.com/p/a488674d55b3" target="_blank" rel="noopener">从Android到React Native开发（三、自定义原生控件支持）</a></p><p>&emsp;&emsp;可以先浏览上面的第一篇入门，再过来看我这篇文章，我这篇文章就是讲怎么运行一个RN，我只是针对我的项目，把RN的部分提取了出来，上面大佬讲的比较全面。</p><h2 id="React-Native环境配置"><a href="#React-Native环境配置" class="headerlink" title="React Native环境配置"></a>React Native环境配置</h2><p><strong>开发工具</strong>：android studio。我不知道为什么要换开发工具。AS不好吗？环境还是跟你之前开发的一样配置，不用变</p><p><strong>python安装</strong>：python官网，下载安装。记得配置环境变量。不用非要按照他那个上面说的去安装。安装完成之后cmd里面敲python然后回车，看到如下界面:</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-a4af2b0fc841a608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="python.png"></p><p><strong>node.js安装</strong>：node也是一样，百度安装,配置完环境变量。cmd里面敲 npm -v然后回车，看到如下界面</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-62ea02b1913843e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="node.png"></p><p>最后，跑如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。</span><br><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br><span class="line">//React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</span><br><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，RN的配置就完成了。记得配置NDK环境，然后就是上你们公司的svn，或者git去down项目下来,应该还会有一个错误，那就是找不到<strong>react.gradle</strong>的路径，找到你添加依赖的那个gradle，在最上面添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: &quot;../../node_modules/react-native/react.gradle&quot;</span><br></pre></td></tr></table></figure><p>这个配置应该是添加greenDao那个是一样的，这样就能找到了<strong>react.gradle</strong></p><p>项目结构如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-86b8e4e093e337da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="project.png"></p><p>&emsp;&emsp;我用箭头标记了，你down下来的项目，应该是没有node_modules文件夹的，这个文件夹是怎么产生的呢？你在cmd进入你down的项目，就是图片上面的文件目录，跑如下命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>当命令运行完，就可以跑项目了。</p><h2 id="React-Native项目搭建"><a href="#React-Native项目搭建" class="headerlink" title="React Native项目搭建"></a>React Native项目搭建</h2><p>&emsp;&emsp;同鞋，你有freeStyle吗？有没有用过WebView？WebView就是在你的xml里面新增了一个WebView控件，RN也一样，他的这个控件就是ReactRootView。所以，这个控件哪里来？当然是添加依赖了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//版本号你自己找</span><br><span class="line">compile &apos;com.facebook.react:react-native:0.50.3&apos;</span><br></pre></td></tr></table></figure><p>最终的作用代码就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mReactRootView.startReactApplication(mReactInstanceManager, &quot;XXX&quot;, null);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个ReacRootView对象，你可以new出来，也可以写在xml里面findViewById。只要你能获取到这个对象就可以了，然后就是这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName, @Nullable Bundle initialProperties)</span><br></pre></td></tr></table></figure><p>三个参数</p><ol><li>ReactInstanceManager reactInstanceManager</li><li>String moduleName</li><li>@Nullable Bundle initialProperties</li></ol><h3 id="第一个参数：ReactInstanceManager"><a href="#第一个参数：ReactInstanceManager" class="headerlink" title="第一个参数：ReactInstanceManager"></a>第一个参数：<strong>ReactInstanceManager</strong></h3><p>就像配置WebView的参数，那些什么配置client允许js弹窗啊，新的页面直接覆盖原来的页面，并不是新建一个页面之类的参数，对应的这里，就是配置<strong>ReactInstanceManager</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReactInstanceManagerBuilder builder = ReactInstanceManager.builder();</span><br><span class="line">        builder = builder</span><br><span class="line">                .setApplication(getApplication())</span><br><span class="line">                .setBundleAssetName(&quot;index.android.bundle&quot;)</span><br><span class="line">                .setJSMainModulePath(&quot;index.android&quot;);</span><br><span class="line"></span><br><span class="line">        mReactInstanceManager = builder</span><br><span class="line">                .addPackage(new MainReactPackage())</span><br><span class="line">                .addPackage(new YzgHDReactPackage())</span><br><span class="line">//                .setUseDeveloperSupport(!Global.ISPRD)</span><br><span class="line">                .setUseDeveloperSupport(true)</span><br><span class="line">              .setInitialLifecycleState(LifecycleState.RESUMED)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;前面的builder的初始化是必须要写的，setApplication，如果你没有自己写application，那就直接getApplication，如果，你有自己实现application那就传你的application对象。</p><p>&emsp;&emsp;setBundleAssetName和setJSMainModulePath都是写死的，后面的名字也是写死的。</p><p>&emsp;&emsp;然后就是添加package，在package里面添加module。这里就是JS和Android相互调用的地方。package里面要实现ReactPackage，在createNativeModules里面去添加moudle</p><h3 id="第二个参数：String-moduleName"><a href="#第二个参数：String-moduleName" class="headerlink" title="第二个参数：String moduleName"></a>第二个参数：<strong>String moduleName</strong></h3><p>这个moudleName是怎么来的？就是我们前面设置的MoudlePath那个JS里面的。这里的路径应该是<strong>index.android.js</strong>，是一个js文件，打开之后，最下面有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppRegistry.registerComponent(&apos;zzz&apos;, () =&gt; XXX);</span><br></pre></td></tr></table></figure><p>这里的zzz就是我们这里需要传的名字</p><h3 id="第三个参数：Bundle-initialProperties"><a href="#第三个参数：Bundle-initialProperties" class="headerlink" title="第三个参数：Bundle initialProperties"></a>第三个参数：<strong>Bundle initialProperties</strong></h3><p>这里应该是传一个bundle，传输的数据，传个null就可以了</p><h2 id="React-Native流程"><a href="#React-Native流程" class="headerlink" title="React Native流程"></a>React Native流程</h2><p>&emsp;&emsp;前面的整个配置都配置完成之后，Android这边只用新建方法，给RN调用就可以了。新建的方法要用@ReactMethod标记。辣么，这个方法新建在哪呢？————Module，就是对应我们前面package里面添加的module。都说RN每个模块是独立的，怎么独立呢？就是这样独立的。每个模块功能对应一个module，每个都有该功能对应的方法。我就拿我这里的UserModule来举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class UserModule extends IModule implements NoticeListener&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static final String MODULE_NAME = &quot;User_Module&quot;;</span><br><span class="line"></span><br><span class="line">    private ReactApplicationContext mContext;</span><br><span class="line"></span><br><span class="line">    public UserModule(ReactApplicationContext reactContext) &#123;</span><br><span class="line">        super(reactContext);</span><br><span class="line">        this.mContext = reactContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return MODULE_NAME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户登录接口</span><br><span class="line">     * @param params</span><br><span class="line">     * @param callback</span><br><span class="line">     */</span><br><span class="line">    @ReactMethod</span><br><span class="line">    public void doLogin(String params, final Callback callback)&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,String&gt; map = GsonTool.gson2Map(params);</span><br><span class="line"></span><br><span class="line">        if(map == null || map.size() &lt;= 0)&#123;</span><br><span class="line">            callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;参数异常&quot;)));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final String userName = map.get(&quot;userName&quot;);</span><br><span class="line">        final String password = map.get(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">        if(TextUtils.isEmpty(userName) || TextUtils.isEmpty(password))&#123;</span><br><span class="line">            callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;用户名或密码不能为空&quot;)));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //登录</span><br><span class="line">        new Handler().post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                String result = new UserBridge().doLogin(userName,password, Global.DEVICE_ID,Global.APP_VERSION_NAME);</span><br><span class="line">                callback.invoke(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我就粘贴出来了部分代码，module要继承IModule，这个是一个抽象类，他继承ReactContextBaseJavaModule，最主要就是继承它，继承之后，我像说的就是这两个方法，getName()和注解的方法doLogin()。</p><p>&emsp;&emsp;我们可以看到，这个getName最终返回的是一个User_Module，这个字符串是怎么确定的呢？这个登录的方法名称是怎么确定的呢？</p><p>&emsp;&emsp;这些东西都是在js里面定义好的，这里是一个登录方法，我们打开登录的js。</p><p><strong>PS:</strong> 这里应该是通过js去确定我们这边的方法名，并不是通过这里的名称去确定js的。</p><p>&emsp;&emsp;我就不把JS代码，贴出来了，只贴出伪代码，打开js之后，搜索NativeModules。你应该会搜到类似的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; User_Module, Shop_Module &#125; = NativeModules;</span><br></pre></td></tr></table></figure><p>这里有两个Module，没错，就是两个。我们这里现在只关注User_Module，然后，我们搜索 User_Module，你会看到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">_onLogIn = () =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        const &#123; username, password &#125; = this.userInfo;</span><br><span class="line">        if (username.length &lt;= 0) return this._modal.Alert(&apos;请输入用户名&apos;);</span><br><span class="line">        if (password.length &lt;= 0) return this._modal.Alert(&apos;请输入密码&apos;);</span><br><span class="line">        this._button.setButton(false, &apos;正在登录...&apos;);</span><br><span class="line">        const params = &#123; userName: username, password &#125;;</span><br><span class="line">        // 登录</span><br><span class="line">        const _dologin = () =&gt; &#123;</span><br><span class="line">            return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123;</span><br><span class="line">                    const data = Other.callHandle(values) || &#123;&#125;;</span><br><span class="line">                    if (data.status) &#123;</span><br><span class="line">                        resolve(&apos;登录成功&apos;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        reject(data.message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>其他的一切，我们都不用管，我们在意的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123;</span><br><span class="line">                    const data = Other.callHandle(values) || &#123;&#125;;</span><br><span class="line">                    if (data.status) &#123;</span><br><span class="line">                        resolve(&apos;登录成功&apos;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        reject(data.message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个是我的项目里面的js，你们搜到的肯定跟我的不一样，我这里要说的是，怎么确定name的返回值，和注解方法。我们看到了，name就是这里的User_Module，方法就是这里的doLogin，android里面写用@ReactMethod标记，然后就是参数了，这里两个参数，一个是String，json格式的。用ArrayMap存储好key—value之后，转成字符串即可。第二个参数就是callback。android与JS通信，发送数据，就是一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback.invoke(&quot;data&quot;)</span><br></pre></td></tr></table></figure><p>他需要什么，你就发送什么。上面是RN主动调用Android方法，辣么，Android怎么主动调用RN方法呢？其实也很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//发送给RN</span><br><span class="line">        if (mReactInstanceManager.getCurrentReactContext() != null) &#123;</span><br><span class="line">            mReactInstanceManager.getCurrentReactContext()</span><br><span class="line">                    .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)</span><br><span class="line">                    .emit(PUSH_DATA_RN, mqttBean.info);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>就是获取ReactContext对象，通过调用getJSModule方法，参数传DeviceEventManagerModule.RCTDeviceEventEmitter.class这个类就可以了，然后通过调用emit方法，第一个参数，就是RN规定的方法名称，第二个参数就是需要传给RN的数据。为什么这样写呢？我们再来看看RN那边是怎么写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DeviceEventEmitter.addListener(&quot;push_data_rn&quot;,(data)=&gt;&#123;</span><br><span class="line">            alert(data)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>他就是通过这DeviceEventEmitter类添加addListener方法，传两个参数，第一个参数就是我们规定的名称，第二个参数就是一个回调，有一个参数，就是用来接收我们的数据，最后做的处理就是简单的弹窗，当然，这是我自己测试用的，最后RN要怎么坐，就是我要担心的问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;个人博客：haichenyi.com。感谢关注&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;新公司，新的开始，新的技术&quot;&gt;&lt;a href=&quot;#新公司，新的开始，新的技术&quot; class=&quot;headerlink&quot; title=&quot;新公司，新的开始，新的技术&quot;&gt;&lt;/a&gt;新公司，新的开始，新的技术&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;新公司的项目，用到的RN编程，之前完全没有碰到过，遇到新技术，之前完全没有碰到过怎么办？google、百度咯。通过不屑的努力，找到了&lt;a href=&quot;https://www.jianshu.com/u/6e613846e1ea&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;恋猫月亮 &lt;/a&gt;的三篇关于RN的文章。我感觉还是很不错的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android转场动画——共享元素</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0/"/>
    <id>http://haichenyi.com/2018/05/13/Android转场动画——共享元素/</id>
    <published>2018-05-13T14:27:52.000Z</published>
    <updated>2018-05-13T14:33:04.328Z</updated>
    
    <content type="html"><![CDATA[<p>这个东西其实很简单，我这里只是做一个简单的记录。</p> <a id="more"></a><p>XML代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--第一个Activity的xml布局，需要共享的元素，加上transitionName属性。至于名字，你随便定义，要保持相同--&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:gravity=&quot;bottom&quot;</span><br><span class="line">    tools:context=&quot;com.haichenyi.activitytransitionanimation.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/img&quot;</span><br><span class="line">        android:layout_width=&quot;300dp&quot;</span><br><span class="line">        android:layout_height=&quot;200dp&quot;</span><br><span class="line">        android:transitionName=&quot;wang&quot;</span><br><span class="line">        android:src=&quot;@mipmap/bg&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/btn&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;跳转&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--第二个activity的xml布局--&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/img&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;300dp&quot;</span><br><span class="line">        android:src=&quot;@mipmap/bg&quot;</span><br><span class="line">        android:transitionName=&quot;wang&quot;/&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/btn&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;back&quot;/&gt;</span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><p>java代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/3/29</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onClick(View v) &#123;</span><br><span class="line">      //共享元素转场动画，只支持android 5.0，所以加一个判断</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">          startActivity(new Intent(MainActivity.this, Step1Activity.class),</span><br><span class="line">              ActivityOptions.makeSceneTransitionAnimation(MainActivity.this,</span><br><span class="line">                  findViewById(R.id.img), &quot;wang&quot;).toBundle());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          startActivity(new Intent(MainActivity.this, Step1Activity.class));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，就是一个Button点击跳转。这个共享元素的核型代码，就是一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions.makeSceneTransitionAnimation(Activity activity,</span><br><span class="line">            View sharedElement, String sharedElementName)</span><br></pre></td></tr></table></figure><p>三个参数：</p><ol><li>Activity activity：activity对象，这个不用多说了</li><li>View sharedElement：共享元素的那个控件</li><li>String sharedElementName：共享元素控件的那个transitionName属性的值。前面xml里面的注释讲过要相同，有三个位置用到这个：跳转activity的xml里面，跳转的目标activity的xml里面，再就是这里，跳转的代码这里需要设置。</li></ol><p>就这么简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个东西其实很简单，我这里只是做一个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android——PorterDuffXfermode</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E2%80%94%E2%80%94PorterDuffXfermode/"/>
    <id>http://haichenyi.com/2018/05/13/Android——PorterDuffXfermode/</id>
    <published>2018-05-13T14:27:36.000Z</published>
    <updated>2018-05-13T14:35:37.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;PorterDuffXfermode是什么鬼？个人理解，简单的来讲就是做两个Bitmap操作的，什么操作呢？有裁剪，合并等等，有16种图形混合模式。先举一个简单的例子，我们在慢慢讲：</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/28</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MyCustomView extends View &#123;</span><br><span class="line">  private int width = 300;</span><br><span class="line">  private int height = 300;</span><br><span class="line">  private Bitmap dstBmp;</span><br><span class="line">  private Bitmap srcBmp;</span><br><span class="line">  private Paint mPaint;</span><br><span class="line"></span><br><span class="line">  public MyCustomView(Context context) &#123;</span><br><span class="line">    this(context, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">    super(context, attrs, defStyleAttr);</span><br><span class="line">    initView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void initView() &#123;</span><br><span class="line">    setLayerType(View.LAYER_TYPE_SOFTWARE, null);</span><br><span class="line">    srcBmp = makeSrc(width, height);</span><br><span class="line">    dstBmp = makeDst(width, height);</span><br><span class="line">    mPaint = new Paint();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2);</span><br><span class="line">    canvas.drawColor(Color.BLUE);</span><br><span class="line">    int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG);</span><br><span class="line">    canvas.drawBitmap(dstBmp, 0, 0, mPaint);</span><br><span class="line">    @SuppressLint(&quot;DrawAllocation&quot;) PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);</span><br><span class="line">    mPaint.setXfermode(xfermode);</span><br><span class="line">    canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint);</span><br><span class="line">    mPaint.setXfermode(null);</span><br><span class="line">    canvas.restoreToCount(layerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Bitmap makeDst(int w, int h) &#123;</span><br><span class="line">    Bitmap dst = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas mCanvas = new Canvas(dst);</span><br><span class="line">    Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(Color.RED);</span><br><span class="line">    mCanvas.drawOval(new RectF(0, 0, w, h), mPaint);</span><br><span class="line">    return dst;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Bitmap makeSrc(int w, int h) &#123;</span><br><span class="line">    Bitmap src = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas mCanvas = new Canvas(src);</span><br><span class="line">    Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(Color.YELLOW);</span><br><span class="line">    mCanvas.drawRect(0, 0, w, h, mPaint);</span><br><span class="line">    return src;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/7041675-a473668793539882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="简介demo图.png"></p><p>&emsp;&emsp;上面画了一个圆形bitmap，画了一个矩形bitmap，设置了一个模式 <strong><em>PorterDuff.Mode.SRC_IN</em></strong> 就变成了上面的形状，这是怎么做到的呢？带着我们的问题，进入我们的主题。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong><em>注意点</em></strong></h2><p>&emsp;&emsp;为什么我要拿一个大标题来写这个呢？因为，我当时卡在这里很久，然后踩着巨人的肩膀，我才踏过去的。</p><ol><li><p>首先，两个图形必须都是Bitmap，直接用Canvas画形状，做操作，是达不到效果的。重要的事情说三遍：<strong><em>两个图形必须都是Bitmap。两个图形必须都是Bitmap。两个图形必须都是Bitmap</em></strong></p></li><li><p>其次，避免不必要的麻烦，请先关闭硬件加速。重要的事情说三遍：<strong><em>请先关闭硬件加速。请先关闭硬件加速。请先关闭硬件加速</em></strong></p></li><li><p>然后，两个bitmap的大小最好一样。</p></li><li><p>最后，我要强调的是：<strong><em>先绘制的是目标图，后绘制的是源图。</em></strong></p></li></ol><p>&emsp;&emsp;这里一直说bitmap，辣么，怎么生成这个bitmap，生成这个bitmap之后怎么画图形呢？如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//第一步，我们先创建一个bitmap对象</span><br><span class="line">Bitmap dst = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line">//第二步，我们通过这个bitmap对象创建一个画布，</span><br><span class="line">//说白了，就是new 一个画布，把bitmap放到画布的构造方法里面</span><br><span class="line">    Canvas mCanvas = new Canvas(dst);</span><br><span class="line">    Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(Color.RED);</span><br><span class="line">//最后，在这个画布上面的所有操作，最后都是呈现在bitmap上面。</span><br><span class="line">//就像这里的，在这个画布上面画了一个椭圆，其实，最后我们的bitmap就是一个椭圆</span><br><span class="line">    mCanvas.drawOval(new RectF(0, 0, w, h), mPaint);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以，bitmap会创建了，再就是我们前面说的两个bitmap，<strong><em>先绘制的是目标图，后绘制的是源图</em></strong>，一个是dst（目标图片，下层，先画），一个是src（源图片，上层，后画）。就是我们上面的自定view里面的onDraw()方法里面，用onDraw的canvas画的东西。</p><p>&emsp;&emsp;我们如果不用这个xfermode模式，我们的代码应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2);</span><br><span class="line">    canvas.drawColor(Color.BLUE);</span><br><span class="line">    canvas.drawBitmap(dstBmp, 0, 0, mPaint);</span><br><span class="line">    canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很简单的几行代码，把画布移到正中间，给画布加一个背景蓝色，先画dst，后画src，跑出来的效果图应该是下面这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-eae7b8c745ec218e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意点1.png"></p><p>&emsp;&emsp;我们如果加上这个xfermode模式里面的 <strong><em>PorterDuff.Mode.SRC_IN</em></strong>模式，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2);</span><br><span class="line">    canvas.drawColor(Color.BLUE);</span><br><span class="line">    int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG);</span><br><span class="line">    canvas.drawBitmap(dstBmp, 0, 0, mPaint);</span><br><span class="line">    @SuppressLint(&quot;DrawAllocation&quot;) PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);</span><br><span class="line">    mPaint.setXfermode(xfermode);</span><br><span class="line">    canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint);</span><br><span class="line">    mPaint.setXfermode(null);</span><br><span class="line">    canvas.restoreToCount(layerID);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比上面的代码，就多加了一个xfermode模式，他们要是同一个画笔，用完之后，记得要把这个模式置null这个saveLayer等会讲，先不说。跑出来的效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-f1b34b7fb8df357e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意点2.png"></p><p>&emsp;&emsp;前面，我们一直都在强调dst先画，src后画，如果调换一下，会是什么样的结果呢？代码我就不贴出来了，就把那两个drawBitmap调换一个位置，跑出来的效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-e8ad2cf4229095fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意点3.png"></p><p>&emsp;&emsp;很明显，跟我们的预期结果不一样。这是为什么呢？带着我们的问题进入下一节。</p><h2 id="十六种模式和saveLayer"><a href="#十六种模式和saveLayer" class="headerlink" title="十六种模式和saveLayer()"></a>十六种模式和saveLayer()</h2><h3 id="十六种模式"><a href="#十六种模式" class="headerlink" title="十六种模式"></a>十六种模式</h3><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">含义</th><th style="text-align:center">名字</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">CLEAR</td><td style="text-align:center">清除模式［0，0］，即最终所有点的像素的alpha 和color 都为 0，所以画出来的效果只有白色背景</td><td style="text-align:center">SRC</td><td style="text-align:center">显示上层绘制图片</td></tr><tr><td style="text-align:center">DST</td><td style="text-align:center">显示下层绘制图片</td><td style="text-align:center">SRC_OVER</td><td style="text-align:center">正常绘制显示，上下层绘制叠盖</td></tr><tr><td style="text-align:center">DST_OVER</td><td style="text-align:center">上下层都显示，下层居上显示</td><td style="text-align:center">SRC_IN</td><td style="text-align:center">取两层绘制交集。显示上层</td></tr><tr><td style="text-align:center">DST_IN</td><td style="text-align:center">取两层绘制交集，显示下层</td><td style="text-align:center">SRC_OUT</td><td style="text-align:center">取上层绘制非交集部分</td></tr><tr><td style="text-align:center">DST_OUT</td><td style="text-align:center">取下层绘制非交集部分</td><td style="text-align:center">SRC_ATOP</td><td style="text-align:center">取下层非交集部分与上层交集部分</td></tr><tr><td style="text-align:center">DST_ATOP</td><td style="text-align:center">取上层非交集部分与下层交集部分</td><td style="text-align:center">XOR</td><td style="text-align:center">异或：去除两图层交集部分</td></tr><tr><td style="text-align:center">DARKEN</td><td style="text-align:center">取两图层全部区域，交集部分颜色加深</td><td style="text-align:center">LIGHTEN</td><td style="text-align:center">取两图层全部，点亮交集部分颜色</td></tr><tr><td style="text-align:center">MULTIPLY</td><td style="text-align:center">取两图层交集部分叠加后颜色</td><td style="text-align:center">SCREEN</td><td style="text-align:center">取两图层全部区域，交集部分变为透明色</td></tr></tbody></table><p>PS：名称前面都应该有：<strong><em>PorterDuff.Mode</em></strong> ，例如：PorterDuff.Mode.CLEAR</p><p>&emsp;&emsp;什么？有的看不懂什么意思？没关系，我也没指望你一次就看懂，我们先来说一说saveLayer()，且听我娓娓道来。</p><h3 id="saveLayer"><a href="#saveLayer" class="headerlink" title="saveLayer()"></a>saveLayer()</h3><p>&emsp;&emsp;这个方法是干嘛用的？保存指定区域内画布的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public int saveLayer(RectF bounds, Paint paint, int saveFlags)  </span><br><span class="line">public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;后面的saveFlags，有6个值，我们这里用到的 <strong><em>Canvas.ALL_SAVE_FLAG</em></strong>，很明显，表示保存所有内容。我们这里如果把这个方法去掉，会是什么样的结果呢？代码就不贴出来了，就直接注释掉saveLayer的两行代码。还是先画dst，后画src，跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-85a4080bc042c63c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="去掉saveLayer().png"></p><p>我们先规定两点：</p><ol><li>先画dst，也就是目标图像，是一个圆形。</li><li>后画src，也就是源图像，是一个矩形。</li></ol><table><thead><tr><th style="text-align:center">代码名称1</th><th style="text-align:center">顺序</th><th style="text-align:center">中文名称</th><th style="text-align:center">形状</th></tr></thead><tbody><tr><td style="text-align:center">dst</td><td style="text-align:center">先画</td><td style="text-align:center">目标图像</td><td style="text-align:center">红色圆形</td></tr><tr><td style="text-align:center">src</td><td style="text-align:center">后画</td><td style="text-align:center">源图像</td><td style="text-align:center">黄色矩形</td></tr></tbody></table><p>&emsp;&emsp;规定好之后，我们再来说一说这个 <strong><em>SRC_IN</em></strong>，我们前面说了：取两层绘制交集。显示上层。首先IN是取交集部分，OUT是取非交集部分。这个就是说最后显示的图形，他们的交集部分，显示src，也就是矩形的颜色，也就是黄色。先画的dst，他自然在src的上层。所以，显示dst的形状，两者交集部分显示src的颜色。可以看下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-0b1c817304fec954.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="saveLayer.png"></p><p>&emsp;&emsp;我们再来说说saveLayer的绘制流程：如上图所示，它会创建一个全新图名的bitmap，大小跟你前面指定的保存区域相同，然后，绘制的图形会保存在这个全新透明的bitmap上面，最后把这个透明的bitmap画在画布上面。</p><p>&emsp;&emsp;辣么，没有savelayer()方法的绘制流程呢？如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-38b1242793a0807b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="no_saveLayer.png"></p><p>他是直接作用在画布上面的。</p><h2 id="常用的PorterDuffXfermode模式介绍"><a href="#常用的PorterDuffXfermode模式介绍" class="headerlink" title="常用的PorterDuffXfermode模式介绍"></a>常用的PorterDuffXfermode模式介绍</h2><h3 id="SRC模式"><a href="#SRC模式" class="headerlink" title="SRC模式"></a>SRC模式</h3><p>&emsp;&emsp;只保留源图像的 alpha 和 color ，所以绘制出来只有源图，有时候会感觉分不清先绘制的是源图还是后绘制的是源图，这个时候可以这么记，先绘制的是目标图，不管任何时候，一定要做一个有目标的人，目标在前！（未达到我们的预期效果，感觉有问题）</p><h3 id="DST模式"><a href="#DST模式" class="headerlink" title="DST模式"></a>DST模式</h3><p>&emsp;&emsp;只显示目标图片，也就是只显示红色的圆形。</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-5a78edd1ea287820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST.png"></p><h3 id="SRC-OVER模式"><a href="#SRC-OVER模式" class="headerlink" title="SRC_OVER模式"></a>SRC_OVER模式</h3><p>&emsp;&emsp;在目标图片顶部绘制源图像,从命名上也可以看出来就是把源图像绘制在上方，也就是把黄色长方形，画在红色圆形的上面。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-efa828311c86ebcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SRC_OVER.png"></p><h3 id="DST-OVER模式"><a href="#DST-OVER模式" class="headerlink" title="DST_OVER模式"></a>DST_OVER模式</h3><p>&emsp;&emsp;把目标图像绘制在上方。与前一个相反，把红色圆形画在长方形上面。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d715a0025e2c1baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST_OVER.png"></p><h3 id="SRC-IN模式"><a href="#SRC-IN模式" class="headerlink" title="SRC_IN模式"></a>SRC_IN模式</h3><p>&emsp;&emsp;在两者相交的地方绘制源图像，并且绘制的效果会受到目标图像对应地方透明度的影响。</p><p>&emsp;&emsp;有点绕，我分成几段讲出来：</p><p>&emsp;&emsp;也就是说，两者相交的位置，显示源图像，也就是黄色的矩形，目标图像的透明度为0，然后，&emsp;源图像的其他位置的透明度&emsp;&emsp;会跟源图像与目标图像相交的地方&emsp;&emsp;的目标图像的透明度一样。</p><p>&emsp;&emsp;有点绕。其实，就是说源图像的其他地方隐藏，就显示相交的位置。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-7e2826c64c63d907.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SRC_IN.png"></p><h3 id="DST-IN模式"><a href="#DST-IN模式" class="headerlink" title="DST_IN模式"></a>DST_IN模式</h3><p>&emsp;&emsp;跟前面刚好对应，在两者相交的地方绘制目标图像，并且，绘制效果会受到源图像对应地方透明度的影响。我们最是绘制目标图像。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-4bea3004d59f8260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST_IN.png"></p><h3 id="SRC-OUT模式"><a href="#SRC-OUT模式" class="headerlink" title="SRC_OUT模式"></a>SRC_OUT模式</h3><p>&emsp;&emsp;在不相交的地方绘制源图像，相交处根据目标alpha进行过滤，目标色完全不透明时则完全过滤，完全透明则不过滤；</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-306477eebd6a23d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SRC_OUT.png"></p><h3 id="DST-OUT模式"><a href="#DST-OUT模式" class="headerlink" title="DST_OUT模式"></a>DST_OUT模式</h3><p>&emsp;&emsp;同样，可以类比SRC_OUT , 在不相交的地方绘制目标图像，相交处根据源图像alpha进行过滤，完全不透明处则完全过滤，完全透明则不过滤；</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-05650d7d10021591.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST_OUT.png"></p><p>太多了，后面就不写了，用的也比较少。</p><p>用途，加上上一篇的贝赛尔曲线的水波纹。很明显，我就想做如下效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-dcdb3859d8e4fbf8.gif?imageMogr2/auto-orient/strip" alt="圆形水波纹.gif"></p><p>这个圆只是一种，这只是一个demo，这个圆，你可以换成任意的形状。你知道水波纹用贝赛尔曲线怎么做，知道了，PorterDuffXfermode这个模式，两张图片是怎么切割。像这样的，还不就是一个道理。随手拈来。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-946eca2d7f94cdcf.gif?imageMogr2/auto-orient/strip" alt="自定义背景.gif"></p><p>这个水波纹的，已经全部封装好了。任意改变背景图片。<a href="https://download.csdn.net/download/qq_27634797/10314335" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;PorterDuffXfermode是什么鬼？个人理解，简单的来讲就是做两个Bitmap操作的，什么操作呢？有裁剪，合并等等，有16种图形混合模式。先举一个简单的例子，我们在慢慢讲：&lt;/p&gt;
    
    </summary>
    
      <category term="Android -自定义view" scheme="http://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>Android自定义View——贝赛尔曲线</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E8%87%AA%E5%AE%9A%E4%B9%89View%E2%80%94%E2%80%94%E8%B4%9D%E8%B5%9B%E5%B0%94%E6%9B%B2%E7%BA%BF/"/>
    <id>http://haichenyi.com/2018/05/13/Android自定义View——贝赛尔曲线/</id>
    <published>2018-05-13T14:27:18.000Z</published>
    <updated>2018-05-13T14:35:32.961Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文针对有一定自定义View的童鞋，最好对贝赛尔曲线有辣么一丢丢了解，不了解也没关系。花5分钟看一下 <strong><em>GcsSloop</em></strong>的 <a href="http://www.gcssloop.com/customview/Path_Bezier" target="_blank" rel="noopener">安卓自定义View进阶-Path之贝塞尔曲线</a>。</p><p>本文的最终效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-bb761f08bb5704c5.gif?imageMogr2/auto-orient/strip" alt="最终效果图.gif"></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>首先他是一个只有上半部分的正弦形状的水波纹，很规则。</li><li>其次，他这个正弦图左右在移动。</li><li>然后，就是它这个自定义View，上下也在移动，是慢慢增加的</li><li>最后，优化点：一开始刚出来的时候，它那个水波纹的角度，更达到一定角度后，最后面，快要完成的时候的角度是不一样的。</li></ol><h2 id="第一步：画正弦形状的水波纹"><a href="#第一步：画正弦形状的水波纹" class="headerlink" title="第一步：画正弦形状的水波纹"></a>第一步：画正弦形状的水波纹</h2><p>&emsp;&emsp;有一定自定义View基础的童鞋都知道，一阶贝赛尔画直线，这里的正弦图形是用二阶贝赛尔曲线。至于三阶，四阶，五阶用的都比较少。</p><p>&emsp;&emsp;我们这里知道了，这是用的二阶贝赛尔曲线，辣么，方法呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)</span><br><span class="line">mPath.rQuadTo(dx1, dy1, dx2, dy2);</span><br><span class="line">//mPath.quadTo(dx1, dy1, dx2, dy2);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Path调用该方法，这里就是传的两个点，也就是四个值，参数的含义：第一个点是控制点，第二个点是终点。前面还有一个起点，通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPath.moveTo(x,y);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法是确定起点。不懂的童鞋，看一下文章开头推荐的文章。我们效果的是一排波浪线，我们上面这个方法只是一个。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//构造方法里面初始化</span><br><span class="line">private void initView() &#123;</span><br><span class="line">    path = new Path();</span><br><span class="line">    paint = new Paint();</span><br><span class="line">    paint1 = new Paint();</span><br><span class="line">    paint.setColor(Color.GREEN);</span><br><span class="line">    paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    paint.setStrokeWidth(10);</span><br><span class="line">    paint1.set(paint);</span><br><span class="line">    paint1.setColor(Color.RED);</span><br><span class="line">  &#125;</span><br><span class="line">//onDraw里面去画出来</span><br><span class="line">    @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.moveTo(0,300);</span><br><span class="line">    path.quadTo(150, 150, 300, 300);</span><br><span class="line">    path.quadTo(450, 450, 600, 300);</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line"></span><br><span class="line">    canvas.drawCircle(0,300,5,paint1);</span><br><span class="line">    canvas.drawCircle(150,150,5,paint1);</span><br><span class="line">    canvas.drawCircle(300,300,5,paint1);</span><br><span class="line">    canvas.drawCircle(450,450,5,paint1);</span><br><span class="line">    canvas.drawCircle(600,300,5,paint1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面就是简单的初始化paint，和path，然后画出path，另外，我还画出了5个点，帮助理解。跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-9343cb6e4066e3ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个水波纹效果图.png"></p><p>&emsp;&emsp;转换成对应的坐标系，手画的，有点丑，知道是这个意思就行了。如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8215466464df72f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个水波纹放入坐标系中.png"></p><p><strong>画一个正弦图的思路：</strong></p><ol><li><p>首先，把path移动到起点，对应的也就是moveTo(0,300)</p></li><li><p>然后，确定终点，也就是我们前面说的quadTo()方法的第二个点(300,300)</p></li><li><p>最后，我们确定控制点，也就是我们前面说的quadTo()方法的第一个点。 <strong><em>辣么，这个控制点是怎么确定的呢？问题就在这里。敲黑板</em></strong> 因为我们画的是一个规则的正弦图，所以，控制点的x坐标肯定是终点x坐标300的一半，也就是150。再就是他的y坐标，其实y坐标是随便定义的。y坐标只是约束这个正弦图形的坡度，对坡度。你把y坐标定义的离终点的y坐标远一点，他的坡度就大一点。离他近一点，坡度就小一点。你如果定义控制点是（150,100），他相对于控制点是(150,150)的坡度就会大一点。因为100距300相差200，150距300相差150。200大于150。对，就是这样。辣么，怎么控制是上半部分的正弦图还是下半部分的正弦图呢？ <strong><em>|y控|&gt;|y终|，上半部分；相反，则是下半部分。</em></strong></p></li></ol><p>&emsp;&emsp;对了，这里我需要说明的是，上面我们调用了两次quadTo()方法，第二次调用的起点，就是第一次的终点。</p><p>&emsp;&emsp;上面效果是调用quadTo()方法，我们再来说一说rQuadTo()方法。上面的注释里面，我们也标明了两者的区别。 <strong><em>辣么，什么叫相对于原点的坐标系？什么叫相对于当前点的坐标系呢？</em></strong> 我们知道android的坐标系原点是左上角，你可以这样理解，第一种，不带r的方法quadTo()，他的坐标原点(0,0)点始终在左上角，第二种带r的方法rQuadTo()，我们第一次移动到起点(0,300)的时候，这个时候的原点就是(0,300)，所以说此时的终点应该是(300,0),然后确定我们的控制点(150,-150)。辣么，我们调用第二次的时候，此时的终点就是(300,0)，这个时候的终点就是(300,0)，在确定此时的控制点(150,150)。两次的终点都是(300,0)，但是，意义是不一样的。有点绕，但是你理解了相对于原点坐标系，和相对于当前点的坐标系，就很简单了。理解一下，思考5分钟。辣么，上面用带r的怎么写呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">path.moveTo(0,300);</span><br><span class="line">//    path.quadTo(150, 150, 300, 300);</span><br><span class="line">//    path.quadTo(450, 450, 600, 300);</span><br><span class="line">    path.rQuadTo(150,-150,300,0);</span><br><span class="line">    path.rQuadTo(150,150,300,0);</span><br><span class="line">    canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，怎么换一个正弦图，以及，两个方法的区别，已经讲完了，我觉得已经讲的非常清楚了。感觉，没有谁比我讲的还要清楚了。手把手教学。我们这个效果，画一个，肯定不行。要画满一个屏幕。怎么画呢？</p><p>&emsp;&emsp;找规律，一个正弦图，我们上面都是围绕这三个点，起点，控制点，终点。要想规则，控制点的x坐标是终点x坐标的一半。再就是，要画满一个屏幕，要在屏幕内部，所以，终点x坐标要小于屏幕宽度。综上所述。</p><ol><li><p>三个点：起点，终点，控制点</p></li><li><p>控制点的x坐标是终点x坐标的一半</p></li><li><p>终点x坐标要小于屏幕宽度</p></li></ol><p>我们就开始写代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  private int startY = 300;//定义起始点的y坐标</span><br><span class="line"></span><br><span class="line">  private int endX = 300;//定义终点的x坐标</span><br><span class="line"></span><br><span class="line">  private int controlY = 150;//定义控制点的y坐标</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.moveTo(0, 300);</span><br><span class="line">    path.moveTo(0, startY);</span><br><span class="line">//    path.quadTo(150, 150, 300, 300);</span><br><span class="line">//    path.quadTo(450, 450, 600, 300);</span><br><span class="line">//这里的for循环为什么每次要加2倍的终点x坐标呢？</span><br><span class="line">    //你想一想，我们一次for循环，画的图的终点x坐标在哪？</span><br><span class="line">    for (int i = 0; i &lt; getWidth(); i += 2*endX) &#123;</span><br><span class="line">//      path.rQuadTo(150, -150, 300, 0);</span><br><span class="line">//      path.rQuadTo(150, 150, 300, 0);</span><br><span class="line">      path.rQuadTo(endX/2, -controlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX/2, controlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d302f33c39805efe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整个屏幕的水波纹效果图.png"></p><p>&emsp;&emsp;好，到这里，第一步完成了，满屏的水波纹出来了。</p><h2 id="第二步，正弦图左右在移动"><a href="#第二步，正弦图左右在移动" class="headerlink" title="第二步，正弦图左右在移动"></a>第二步，正弦图左右在移动</h2><p>&emsp;&emsp;想一想，这个动画，想一想，想一想，像不像水平位移动画？像不像？越想越像。辣么，我们就去验证一下。写一个动画，这种，明显就是属性动画。既然是左右移动，辣么就肯定是改变x轴的坐标值，改变谁的呢？肯定是起点的啊，只有改变起点的x左边的值，水波纹才会有动的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void startAnimation()&#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofFloat(0, 1);</span><br><span class="line">    animator.setDuration(1000);</span><br><span class="line">    animator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">        Float animatedValue = (Float) animation.getAnimatedValue();</span><br><span class="line">        currentStartX = (int) (endX * animatedValue);</span><br><span class="line">        postInvalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();//不加会有重影，不是我们想要的</span><br><span class="line">//    path.moveTo(0, 300);</span><br><span class="line">//    path.moveTo(0, startY);</span><br><span class="line">    path.moveTo(currentStartX, startY);</span><br><span class="line">      ...//其他的不变</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d38f9817410a015c.gif?imageMogr2/auto-orient/strip" alt="移动有空白.gif"></p><p>&emsp;&emsp;尼玛，什么鬼？动是动起来了，为啥左边还有一段空白？不要急，想一想为什么？我们之前是从Y轴开始画的，我们这个动画是从左向又移动一个endx的值，所以，我们设置起点的时候，也向左偏移一个endx的值不就好了么？我们再试一试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();</span><br><span class="line">//    path.moveTo(0, 300);</span><br><span class="line">//    path.moveTo(0, startY);</span><br><span class="line">    path.moveTo(-endX + currentStartX, startY);</span><br><span class="line">//    path.quadTo(150, 150, 300, 300);</span><br><span class="line">//    path.quadTo(450, 450, 600, 300);</span><br><span class="line">    //这里的for循环为什么每次要加2倍的终点x坐标呢？</span><br><span class="line">    //你想一想，我们一次for循环，画的图的终点x坐标在哪？</span><br><span class="line">    for (int i = -endX; i &lt; getWidth() + endX; i += 2 * endX) &#123;</span><br><span class="line">//      path.rQuadTo(150, -150, 300, 0);</span><br><span class="line">//      path.rQuadTo(150, 150, 300, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, -controlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, controlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-f84524374a6c4273.gif?imageMogr2/auto-orient/strip" alt="移动会闪一下.gif"></p><p>&emsp;&emsp;咦，满脸的嫌弃，这是什么东西啊，空白虽然没了，为什么会卡一下，并且这个也不是我们想要的效果。我们再想一想，我们这个无线循环的动画的原理是什么？ <strong><em>敲黑板，其实，我们就是多画了一个正弦波形，我们移动之后，跟移动之前一样，也就是位移了两个正弦图，结束后的图形，跟结束前的图形重合，然后一直重复动画，从而让用户感觉是无线循环的动画。</em></strong> 辣么，哪里出问题呢？想一想，为什么达不到我们的效果，肯定是我们水平移动距离的有问题啊。找啊找啊找，找到了，我们这里的endx坐标，是一个完整正弦图形的一半。所以，我们动画移动的距离要乘以2。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">currentStartX = (int) (2 * endX * animatedValue);//动画里面的</span><br><span class="line">//动画还要加上插值器，从而达到平滑的效果</span><br><span class="line">animator.setInterpolator(new LinearInterpolator());</span><br><span class="line"></span><br><span class="line">辣么，这里距离变了，我们起始点的距离，循环的距离也要变。要不然会有空白</span><br><span class="line">path.moveTo(-endX*2 + currentStartX, startY);</span><br><span class="line"></span><br><span class="line">for (int i = -endX*2; i &lt; getWidth() + endX*2; i += 2 * endX) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;综上所述，去除无关代码之后的完整代码，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/27</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class WaveView1 extends View &#123;</span><br><span class="line">  private Path path;</span><br><span class="line">  private Paint paint;</span><br><span class="line">  private Paint paint1;</span><br><span class="line"></span><br><span class="line">  private int startY = 300;</span><br><span class="line"></span><br><span class="line">  private int endX = 300;</span><br><span class="line"></span><br><span class="line">  private int controlY = 150;</span><br><span class="line"></span><br><span class="line">  private int currentStartX;</span><br><span class="line"></span><br><span class="line">  public WaveView1(Context context) &#123;</span><br><span class="line">    this(context, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public WaveView1(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public WaveView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">    super(context, attrs, defStyleAttr);</span><br><span class="line">    initView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void initView() &#123;</span><br><span class="line">    path = new Path();</span><br><span class="line">    paint = new Paint();</span><br><span class="line">    paint1 = new Paint();</span><br><span class="line">    paint.setColor(Color.GREEN);</span><br><span class="line">    paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    paint.setStrokeWidth(10);</span><br><span class="line">    paint1.set(paint);</span><br><span class="line">    paint1.setColor(Color.RED);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();</span><br><span class="line">    path.moveTo(-endX*2 + currentStartX, startY);</span><br><span class="line">    for (int i = -endX*2; i &lt; getWidth() + endX*2; i += 2 * endX) &#123;</span><br><span class="line">      path.rQuadTo(endX / 2, -controlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, controlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void startAnimation() &#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofFloat(0, 1);</span><br><span class="line">    animator.setDuration(1000);</span><br><span class="line">    animator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">    animator.setInterpolator(new LinearInterpolator());</span><br><span class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">        Float animatedValue = (Float) animation.getAnimatedValue();</span><br><span class="line">        currentStartX = (int) (2 * endX * animatedValue);</span><br><span class="line">        postInvalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-aefa92a1ca8a1026.gif?imageMogr2/auto-orient/strip" alt="移动水波纹.gif"></p><p>完美达到了我们的预期效果。</p><h2 id="第三步：自定义View上下移动"><a href="#第三步：自定义View上下移动" class="headerlink" title="第三步：自定义View上下移动"></a>第三步：自定义View上下移动</h2><p>&emsp;&emsp;经过上面的左右动画，现在这个上下移动的动画就很简单了，很明显是改变起始点y坐标的值，当然，肯定是属性动画。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void startAnimation() &#123;</span><br><span class="line">    </span><br><span class="line">    ...//这是我们的左移动画，没写上来</span><br><span class="line">    </span><br><span class="line">    //这就是我们的竖着移动的动画</span><br><span class="line">    ValueAnimator animator1 = ValueAnimator.ofFloat(0, 1);</span><br><span class="line">    animator1.setDuration(5000);</span><br><span class="line">    animator1.setInterpolator(new LinearInterpolator());</span><br><span class="line">    animator1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">        Float animatedValue = (Float) animation.getAnimatedValue();</span><br><span class="line">        currentStartY = (int) (getHeight() * animatedValue);</span><br><span class="line">        postInvalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator1.start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //改变我们的初始点的y坐标。不要只写个currentStartY，</span><br><span class="line">  //光写这个是从下往上移动，你要的是从上往下移动</span><br><span class="line">  path.moveTo(-endX*2 + currentStartX, getHeight()-currentStartY);</span><br><span class="line">  </span><br><span class="line">  //再就是修改画笔为填充</span><br><span class="line">  paint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">  </span><br><span class="line">  //并且把path连接成一个闭合图形</span><br><span class="line">  ...//这里是onDraw里面的for循环画正弦图形</span><br><span class="line">  path.lineTo(getWidth(),getHeight());</span><br><span class="line">    path.lineTo(0,getHeight());</span><br><span class="line">    path.close();</span><br><span class="line">    canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure><p>跑出来的效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-54f3ea96e5dc33a5.gif?imageMogr2/auto-orient/strip" alt="上下移动有bug.gif"></p><p>&emsp;&emsp;到这个位置，基本上已经完成了百分之九十了。我们可以看到开始会有一个问题，结束的时候也有一个问题，这个问题是怎么产生的呢？</p><h2 id="第四步：优化开始和结束的动画"><a href="#第四步：优化开始和结束的动画" class="headerlink" title="第四步：优化开始和结束的动画"></a>第四步：优化开始和结束的动画</h2><p>&emsp;&emsp;其实，我们可以想一想，一开始，我们这个控制点的Y值，不应该一出来就是写死的，显得太突兀了，一开始，我们应该是慢慢涨，涨到我们规定的值，然后快结束的时候，我们应该是慢慢减，减到0为止。应该是这样才对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();</span><br><span class="line">    int currentControlY = 0;</span><br><span class="line">    if (currentStartY &lt; controlY) &#123;</span><br><span class="line">      currentControlY = currentStartY;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      currentControlY = controlY;</span><br><span class="line">    &#125;</span><br><span class="line">    if (getHeight() - currentStartY &lt; controlY) &#123;</span><br><span class="line">      currentControlY = getHeight() - currentStartY;</span><br><span class="line">    &#125;</span><br><span class="line">    path.moveTo(-endX * 2 + currentStartX, getHeight() - currentStartY);</span><br><span class="line">    for (int i = -endX * 2; i &lt; getWidth() + endX * 2; i += 2 * endX) &#123;</span><br><span class="line">      path.rQuadTo(endX / 2, -currentControlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, currentControlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    path.lineTo(getWidth(), getHeight());</span><br><span class="line">    path.lineTo(0, getHeight());</span><br><span class="line">    path.close();</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-bb761f08bb5704c5.gif?imageMogr2/auto-orient/strip" alt="最终效果图.gif"></p><p>经过上面的操作，就完美的达到了我们的预期效果。(PS：把画笔的宽度去掉)</p><p>把这个自定义View优化一下，把方法封装好了。<a href="https://download.csdn.net/download/qq_27634797/10312090" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本文针对有一定自定义View的童鞋，最好对贝赛尔曲线有辣么一丢丢了解，不了解也没关系。花5分钟看一下 &lt;strong&gt;&lt;em&gt;GcsSloop&lt;/em&gt;&lt;/strong&gt;的 &lt;a href=&quot;http://www.gcssloop.com/customview/Path_Bezier&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安卓自定义View进阶-Path之贝塞尔曲线&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文的最终效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7041675-bb761f08bb5704c5.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;最终效果图.gif&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -自定义view" scheme="http://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>Android自定义刷新布局——Ultra-Pull-To-Refresh-With-Load-More（二））</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%B7%E6%96%B0%E5%B8%83%E5%B1%80%E2%80%94%E2%80%94Ultra-Pull-To-Refresh-With-Load-More%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/05/13/Android自定义刷新布局——Ultra-Pull-To-Refresh-With-Load-More（二））/</id>
    <published>2018-05-13T14:26:56.000Z</published>
    <updated>2018-05-13T14:37:02.365Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人博客：haichenyi.com。感谢关注</strong></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>上一篇，我们讲到了Ultra-Pull-To-Refresh的基本用法。分成四步：</p><ol><li><p>xml里面定义控件PtrFrameLayout</p></li><li><p>设置相关属性</p></li><li><p>添加Header，Footer，并监听</p></li><li><p>监听刷新过程</p><a id="more"></a></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&emsp;&emsp;<strong>目的：</strong> 做一个我们自己的自定义刷新的动画（我们先不管动画是什么，不同的需求，动画都不一样）</p><p>&emsp;&emsp;我们前面讲到的主要类无非就是两个： <strong><em>PtrFrameLayout</em></strong>，<strong><em>Header（Footer）</em></strong>，前者是刷新控件，监听刷新过程，后者是头布局（脚布局），以添加头布局为例：我们这里首先就会想到重写这个布局。辣么？怎么重写这个头布局呢？我们先来看看怎么添加这个头布局的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setHeaderView(View header) &#123;</span><br><span class="line">        if (mHeaderView != null &amp;&amp; header != null &amp;&amp; mHeaderView != header) &#123;</span><br><span class="line">            removeView(mHeaderView);</span><br><span class="line">        &#125;</span><br><span class="line">        ViewGroup.LayoutParams lp = header.getLayoutParams();</span><br><span class="line">        if (lp == null) &#123;</span><br><span class="line">            lp = new LayoutParams(-1, -2);</span><br><span class="line">            header.setLayoutParams(lp);</span><br><span class="line">        &#125;</span><br><span class="line">        mHeaderView = header;</span><br><span class="line">        addView(header);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它这里实际上就是添加了一个View，所以，我们随便写一个自定义View，继承View就可以传进来</p><p>&emsp;&emsp;我们，再来看看另一个方法，就是监听的方法，这里好像也是传的View对象，因为，我们前面写的时候就是传的header：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void addPtrUIHandler(PtrUIHandler ptrUIHandler) &#123;</span><br><span class="line">        PtrUIHandlerHolder.addHandler(mPtrUIHandlerHolder, ptrUIHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;咦，不对啊，这里不是应该传的View对象么？怎么是PtrUIHandler类型的。其实，你看名字就应该看的出来，他这里传的是一个PtrUIHandler对象，点进去看，他就是一个接口。里面是下拉刷新的回调。讲到这里，我们就应该明了了，就是一个自定义View，继承View，实现PtrUIHandler接口。辣么，就开始撸了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MyCustomHeader extends FrameLayout implements PtrUIHandler &#123;</span><br><span class="line">  public MyCustomHeader(@NonNull Context context) &#123;</span><br><span class="line">    this(context, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomHeader(@NonNull Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomHeader(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">    super(context, attrs, defStyleAttr);</span><br><span class="line">    initView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void initView() &#123;</span><br><span class="line">    LayoutInflater.from(getContext()).inflate(R.layout.header_layout, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIReset(PtrFrameLayout frame) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshPrepare(PtrFrameLayout frame) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshBegin(PtrFrameLayout frame) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshComplete(PtrFrameLayout frame, boolean isHeader) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIPositionChange(PtrFrameLayout frame, boolean isUnderTouch, byte status,</span><br><span class="line">                                 PtrIndicator ptrIndicator) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，我这里面什么都没有，就是继承了FrameLayout布局，实现了PtrUIHandler接口，然后在构造方法里面加载了一个布局，添加进来，布局也很简单，里面就只有一个ImageView。布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;200dp&quot;</span><br><span class="line">        android:src=&quot;@drawable/psb17&quot;/&gt;</span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再就是调用了，跟上一篇的调用方式一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final PtrFrameLayout ptrFrameLayout = findViewById(R.id.ptr_frame_layout);</span><br><span class="line">    MyCustomHeader myCustomHeader = new MyCustomHeader(this);</span><br><span class="line">    ptrFrameLayout.setHeaderView(myCustomHeader);</span><br><span class="line">    ptrFrameLayout.addPtrUIHandler(myCustomHeader);</span><br><span class="line">    ptrFrameLayout.setPtrHandler(new PtrDefaultHandler2() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onRefreshBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">        frame.postDelayed(ptrFrameLayout::refreshComplete, 2000);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onLoadMoreBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">        frame.postDelayed(ptrFrameLayout::refreshComplete, 2000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后运行，你就会看到，刷新的header就是你的自定义view。到此，自定义刷新布局就完成了，脚布局方式类似。</p><p>&emsp;&emsp;什么鬼？这就没了？刷新布局就一个ImageView就没了？这么敷衍。好歹你也加个动画啊。可以可以，那就加个动画。</p><p>&emsp;&emsp;如你所愿，我加了一个帧动画。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/refresh1&quot; android:duration=&quot;100&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/refresh2&quot; android:duration=&quot;100&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/refresh3&quot; android:duration=&quot;100&quot;/&gt;</span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure><p>header里面的改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void initView() &#123;</span><br><span class="line">    LayoutInflater.from(getContext()).inflate(R.layout.header_layout, this);</span><br><span class="line">    imageView = findViewById(R.id.img);</span><br><span class="line">    animationDrawable = (AnimationDrawable) imageView.getDrawable();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   @Override</span><br><span class="line">  public void onUIRefreshBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">    imageView.setImageDrawable(animationDrawable);</span><br><span class="line">    animationDrawable.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshComplete(PtrFrameLayout frame, boolean isHeader) &#123;</span><br><span class="line">    animationDrawable.stop();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在初始化的时候，把动画获取到，然后在刷新的时候开始动画，在刷新完成的时候停止动画。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;个人博客：haichenyi.com。感谢关注&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;上一篇，我们讲到了Ultra-Pull-To-Refresh的基本用法。分成四步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;xml里面定义控件PtrFrameLayout&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置相关属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加Header，Footer，并监听&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监听刷新过程&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android下拉刷新，上拉加载——Ultra-Pull-To-Refresh-With-Load-More（一）</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E2%80%94%E2%80%94Ultra-Pull-To-Refresh-With-Load-More%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/05/13/Android下拉刷新，上拉加载——Ultra-Pull-To-Refresh-With-Load-More（一）/</id>
    <published>2018-05-13T14:26:34.000Z</published>
    <updated>2018-05-13T14:37:49.782Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人博客：haichenyi.com。感谢关注</strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Android里面刷新和分页加载是常见的，刷新有Google的SwipeRefreshLayout，但是UI不同意，非要跟IOS一样，那就没办法了。</p> <a id="more"></a><p>开源框架链接：<a href="https://github.com/captainbupt/android-Ultra-Pull-To-Refresh-With-Load-More" target="_blank" rel="noopener">Ultra-Pull-To-Refresh-With-Load-More</a>。这个开源框架是基于<a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh" target="_blank" rel="noopener">Ultra-Pull-To-Refresh</a>拓展了一个上拉加载功能。</p><p>作者：<a href="https://github.com/liaohuqiu" target="_blank" rel="noopener">廖祜秋</a></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">implementation &apos;in.srain.cube:ptr-load-more:1.0.6&apos;</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>整个项目就只有一个核心类：PtrFrameLayout，继承ViewGroup。步骤：</p><ol><li><p>xml里面定义控件PtrFrameLayout</p></li><li><p>设置相关属性</p></li><li><p>添加Header，Footer，并监听</p></li><li><p>监听刷新过程</p></li></ol><h3 id="第一步：xml里面定义控件PtrFrameLayout"><a href="#第一步：xml里面定义控件PtrFrameLayout" class="headerlink" title="第一步：xml里面定义控件PtrFrameLayout"></a>第一步：xml里面定义控件PtrFrameLayout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;in.srain.cube.views.ptr.PtrFrameLayout</span><br><span class="line">    android:id=&quot;@+id/ptr_frame_layout&quot;</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    xmlns:cube_ptr=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line"></span><br><span class="line">    cube_ptr:ptr_resistance_header=&quot;1.7&quot;</span><br><span class="line">    cube_ptr:ptr_ratio_of_header_height_to_refresh=&quot;1.2&quot;</span><br><span class="line">    cube_ptr:ptr_duration_to_back_header=&quot;300&quot;</span><br><span class="line">    cube_ptr:ptr_duration_to_close_header=&quot;2000&quot;</span><br><span class="line">    cube_ptr:ptr_keep_header_when_refresh=&quot;true&quot;</span><br><span class="line">    cube_ptr:ptr_pull_to_fresh=&quot;false&quot;</span><br><span class="line"></span><br><span class="line">    cube_ptr:ptr_resistance_footer=&quot;1.3&quot;</span><br><span class="line">    cube_ptr:ptr_duration_to_back_footer=&quot;300&quot;</span><br><span class="line">    cube_ptr:ptr_duration_to_close_footer=&quot;2000&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:background=&quot;@color/colorAccent&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;</span><br><span class="line">            android:text=&quot;textView&quot;/&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/in.srain.cube.views.ptr.PtrFrameLayout&gt;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的布局，根布局是 <strong><em>PtrFrameLayout</em></strong> ，他的子View可以是任意view。</p><h3 id="第二步：设置相关属性"><a href="#第二步：设置相关属性" class="headerlink" title="第二步：设置相关属性"></a>第二步：设置相关属性</h3><p>我们也看到了，他的布局里面有一些自定义属性，可以在布局里面设置，也可以在java代码里面设置，相关属性含义如下：</p><ol><li><p>Resistence：阻尼系数，可以分别设置header和footer。默认: 1.7f，越大，感觉下拉刷新时越吃力。上拉加载也是一样的</p></li><li><p>Ratio of the Height of the Header to Refresh：触发刷新时移动的位置比例。<br>默认，1.2f，移动达到头部高度1.2倍时可触发刷新操作。下拉刷新，上拉加载都一样。</p></li><li><p>Duration to Close back：回弹延时。默认 200ms，回弹到刷新或者高度所用时间，可以跟上面一样分开设置，也可以设置一个</p></li><li><p>Duration to Close Header：刷新完成之后隐藏头部的时间。默认1000ms<strong><em>cube_ptr:ptr_duration_to_close_either=”2000”</em></strong></p></li><li><p>Keep Header while Refreshing：刷新是保持头部，也就是显示头部。默认值 true。false：隐藏头部</p></li><li><p>Pull to Refresh / Release to Refresh：下拉刷新 / 释放刷新。<br>默认为释放的时候刷新</p></li></ol><p>在java代码中设置方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final PtrFrameLayout ptrFrameLayout = findViewById(R.id.ptr_frame_layout);</span><br><span class="line">//配置头部参数,可以在xml中设置</span><br><span class="line">// the following are default settings</span><br><span class="line">    ptrFrameLayout.setResistance(1.7f);</span><br><span class="line">    ptrFrameLayout.setRatioOfHeaderHeightToRefresh(1.2f);</span><br><span class="line">    ptrFrameLayout.setDurationToClose(200);</span><br><span class="line">    ptrFrameLayout.setDurationToCloseHeader(1000);</span><br><span class="line">// default is false</span><br><span class="line">    ptrFrameLayout.setPullToRefresh(false);</span><br><span class="line">// default is true</span><br><span class="line">    ptrFrameLayout.setKeepHeaderWhenRefresh(true);</span><br></pre></td></tr></table></figure><h2 id="第三步：添加Header，Footer，并监听"><a href="#第三步：添加Header，Footer，并监听" class="headerlink" title="第三步：添加Header，Footer，并监听"></a>第三步：添加Header，Footer，并监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//第一种头部,StoreHouse风格的头部实现</span><br><span class="line">    /*StoreHouseHeader storeHouseHeader = new StoreHouseHeader(this);</span><br><span class="line">    storeHouseHeader.setPadding(0,100,0,0);</span><br><span class="line">    storeHouseHeader.setBackgroundColor(Color.BLACK);</span><br><span class="line">    storeHouseHeader.setTextColor(Color.WHITE);</span><br><span class="line">    storeHouseHeader.initWithString(&quot;haichenyi&quot;);//只可英文，中文不可运行(添加时间)</span><br><span class="line">    ptrFrameLayout.setHeaderView(storeHouseHeader);</span><br><span class="line">    ptrFrameLayout.addPtrUIHandler(storeHouseHeader);*/</span><br><span class="line"></span><br><span class="line">    //第二种头部,Material Design风格的头部实现,类似SwipeRefreshLayout</span><br><span class="line">    /*MaterialHeader materialHeader = new MaterialHeader(this);</span><br><span class="line">    materialHeader.setColorSchemeColors(new int[]&#123;Color.RED, Color.GREEN, Color.BLUE&#125;);</span><br><span class="line">    ptrFrameLayout.setHeaderView(materialHeader);</span><br><span class="line">    ptrFrameLayout.addPtrUIHandler(materialHeader);*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //第三种头部,经典 风格的头部实现，下拉箭头+时间</span><br><span class="line">    PtrClassicDefaultHeader ptrClassicDefaultHeader = new PtrClassicDefaultHeader(this);</span><br><span class="line">    ptrFrameLayout.setHeaderView(ptrClassicDefaultHeader);</span><br><span class="line"></span><br><span class="line">    PtrClassicDefaultFooter ptrClassicDefaultFooter = new PtrClassicDefaultFooter(this);</span><br><span class="line">    ptrFrameLayout.setFooterView(ptrClassicDefaultFooter);</span><br><span class="line"></span><br><span class="line">    ptrFrameLayout.addPtrUIHandler(ptrClassicDefaultHeader);</span><br><span class="line">    ptrFrameLayout.addPtrUIHandler(ptrClassicDefaultFooter);</span><br></pre></td></tr></table></figure><p>如上面代码所示，Header，Footer的种类是一样的，Header有三种，Footer也有三种，定义好之后，通过 <strong>setHeaderView()</strong>, <strong>setFooterView()</strong> 添加到 <strong>ptrFrameLayout</strong> 中，然后通过调用 <strong>addPtrUIHandler</strong> 监听两者的状态即可。不监听会显示空白，看不到具体内容</p><h2 id="第四步：监听刷新过程"><a href="#第四步：监听刷新过程" class="headerlink" title="第四步：监听刷新过程"></a>第四步：监听刷新过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ptrFrameLayout.setPtrHandler(new PtrDefaultHandler2() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onLoadMoreBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">        frame.postDelayed(ptrFrameLayout::refreshComplete, 2000);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onRefreshBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">        frame.postDelayed(ptrFrameLayout::refreshComplete, 2000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ptrFrameLayout.setMode(PtrFrameLayout.Mode.LOAD_MORE);</span><br></pre></td></tr></table></figure><p>通过设置 <strong>setPtrHandler()</strong> 方法监听刷新过程。默认的是 <strong>PtrDefaultHandler2()</strong>,它是后来加的，包括刷新和加载。<strong>PtrDefaultHandler()</strong> 只包含刷新功能。通过setMode()方法设置：只要下拉刷新，或者只要上拉加载，或者两者都要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;个人博客：haichenyi.com。感谢关注&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Android里面刷新和分页加载是常见的，刷新有Google的SwipeRefreshLayout，但是UI不同意，非要跟IOS一样，那就没办法了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>**个人博客：haichenyi.com。感谢关注**</title>
    <link href="http://haichenyi.com/2018/05/13/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9Ahaichenyi-com%E3%80%82%E6%84%9F%E8%B0%A2%E5%85%B3%E6%B3%A8/"/>
    <id>http://haichenyi.com/2018/05/13/个人博客：haichenyi-com。感谢关注/</id>
    <published>2018-05-13T14:26:00.000Z</published>
    <updated>2018-05-13T14:26:00.843Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 加密算法（二）</title>
    <link href="http://haichenyi.com/2018/05/13/Java-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/05/13/Java-加密算法（二）/</id>
    <published>2018-05-13T14:22:11.000Z</published>
    <updated>2018-05-13T14:24:05.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="补充知识点："><a href="#补充知识点：" class="headerlink" title="补充知识点："></a>补充知识点：</h2><p><strong><em>密钥：</em></strong> 加密方用公钥，解密方用私钥</p><p><strong>重要的事情强调六遍：</strong></p><p><strong><em>不用自己写加密算法</em></strong></p><p><strong><em>不用自己写加密算法</em></strong></p><p><strong><em>不用自己写加密算法</em></strong></p><p><strong><em>不用自己写加密算法</em></strong></p><p><strong><em>不用自己写加密算法</em></strong></p><p><strong><em>不用自己写加密算法</em></strong></p><a id="more"></a><h3 id="Cipher类"><a href="#Cipher类" class="headerlink" title="Cipher类"></a>Cipher类</h3><p>&emsp;&emsp;Android有专门用来加密的工具类Cipher类，他里面封装了几种常用的加密算法，本篇介绍两种AES，RSA。</p><p><strong><em>用法</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">分三步：以AES举例说明</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 加密方式：AES</span><br><span class="line">   * 工作模式：ECB,CBC,CTR,OFB,CFB</span><br><span class="line">   * 填充模式：PKCS5Padding，PKCS7Padding，ZEROPadding等等</span><br><span class="line">   */</span><br><span class="line">String CBC_PKCS5_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;//AES是加密方式 CBC是工作模式 PKCS5Padding是填充模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第一步：获取对象</span><br><span class="line">Cipher cipher = Cipher.getInstance(String transformation);//传 CBC_PKCS5_PADDING</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二步：设置初始化参数</span><br><span class="line">    /**</span><br><span class="line">     * 第一个参数：传类型，是加密Cipher.ENCRYPT_MODE，还是解密Cipher.DECRYPT_MODE</span><br><span class="line">     * 第二个参数：传密钥key，我们这里传的是SecretKeySpec，它实现SecretKey，SecretKey实现Key接口。</span><br><span class="line">     *             SecretKeySpec keySpec = new SecretKeySpec(raw, AES);//第一个参数传密钥byte数组，第二个参数传加密类型也就是&quot;AES&quot;字符串即可</span><br><span class="line">     * 第三个参数：传偏移量AlgorithmParameterSpec，我们这里传的IvParameterSpec，他实现AlgorithmParameterSpec接口，iv偏移量传默认的16个0的字节数组</span><br><span class="line">     *              new IvParameterSpec(new byte[cipher.getBlockSize()])，这里是传的默认的16个0的byte数组，也是常用的方式</span><br><span class="line">     */</span><br><span class="line">cipher.init(int opmode, Key key, AlgorithmParameterSpec params)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三步：加密。传需要加密的字符串的byte数组</span><br><span class="line">cipher.doFinal(byte[] input)</span><br><span class="line"></span><br><span class="line">经过以上三步：AES加密就算完成了，加密之后就需要解密，辣么，怎么解密呢？</span><br><span class="line"></span><br><span class="line">    草鸡简单，第二步初始化的时候，第一个参数传解密即可，其他都是一样的。</span><br></pre></td></tr></table></figure><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>出自百度百科</p><p>&emsp;&emsp;需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。</p><p>&emsp;&emsp;所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。</p><p>&emsp;&emsp;因此，加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。</p><p>&emsp;&emsp;说了这么多废话，要我说，就一句话公钥，私钥 <strong><em>相同</em></strong> 的加密方式称之为对称加密</p><h2 id="用法——AES"><a href="#用法——AES" class="headerlink" title="用法——AES"></a>用法——AES</h2><p>&emsp;&emsp;申明：我这里并不是说对称加密就只有AES这一种方式，相反，对称加密有很多种，我这里只讲我用到的对称加密中的一种方式——AES</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  private static final String CBC_PKCS5_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;//AES是加密方式 CBC是工作模式 PKCS5Padding是填充模式</span><br><span class="line">  private static final String AES = &quot;AES&quot;;//AES 加密</span><br><span class="line">  private static final String SHA1PRNG = &quot;SHA1PRNG&quot;;// SHA1PRNG 强随机种子算法, 要区别4.2以上版本的调用方法</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * 随机生成密钥，传同一个字符串，每次都生成的不一样</span><br><span class="line">   * @param seed 一般传用户的密码</span><br><span class="line">   * @return 返回密钥的byte数组</span><br><span class="line">   * @throws Exception 异常</span><br><span class="line">   */</span><br><span class="line">  private static byte[] getRawKey(String seed) throws Exception &#123;</span><br><span class="line">    SecureRandom sr = null;</span><br><span class="line">    // 在4.2以上版本中，SecureRandom获取方式发生了改变</span><br><span class="line">    if (android.os.Build.VERSION.SDK_INT &gt;= 17) &#123;</span><br><span class="line">      sr = SecureRandom.getInstance(SHA1PRNG, &quot;Crypto&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      sr = SecureRandom.getInstance(&quot;SHA1PRNG&quot;); // 获得一个随机数，传入的参数为默认方式。</span><br><span class="line">    &#125;</span><br><span class="line">    sr.setSeed(seed.getBytes());  // 设置一个种子，这个种子一般是用户设定的密码。也可以是其它某个固定的字符串</span><br><span class="line">    KeyGenerator keyGen = KeyGenerator.getInstance(&quot;AES&quot;);  // 获得一个key生成器（AES加密模式）</span><br><span class="line">    //AES中128位密钥版本有10个加密循环，192比特密钥版本有12个加密循环，256比特密钥版本则有14个加密循环。</span><br><span class="line">    keyGen.init(128, sr);      // 设置密匙长度128位</span><br><span class="line">    SecretKey key = keyGen.generateKey();  // 获得密匙</span><br><span class="line">    return key.getEncoded();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 加密过程</span><br><span class="line">   * @param raw 密钥的数组</span><br><span class="line">   * @param clear 需要加密的byte数组</span><br><span class="line">   * @return 加密后的byte数组</span><br><span class="line">   * @throws Exception 异常</span><br><span class="line">   */</span><br><span class="line">  private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception &#123;</span><br><span class="line">    SecretKeySpec keySpec = new SecretKeySpec(raw, AES);</span><br><span class="line">    Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING);</span><br><span class="line">    //iv偏移量传默认的16个0的字节数组</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(new byte[cipher.getBlockSize()]));</span><br><span class="line">    return cipher.doFinal(clear);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">   * 解密</span><br><span class="line">   */</span><br><span class="line">  private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception &#123;</span><br><span class="line">    SecretKeySpec keySpec = new SecretKeySpec(raw, AES);</span><br><span class="line">    Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING);</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(new byte[cipher.getBlockSize()]));</span><br><span class="line">    return cipher.doFinal(encrypted);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面给的三个方法，一个获取密钥，一个加密，一个解密，注释写的很清楚，我就不用再讲了，转16进制的方法，我前一篇讲加密的时候就给出来了，不知道的可以去前一篇看一下，我下面给出调用方式和结果截图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">       byte[] rawKey = getRawKey(key);</span><br><span class="line">       Log.v(&quot;wz&quot;, rawKey.length + &quot;&quot;);</span><br><span class="line">       String s = bytesToHexFun1(rawKey);</span><br><span class="line">       Log.v(&quot;wz&quot;,&quot;密钥16进制--&gt;&quot;+s);</span><br><span class="line">       byte[] encrypt = encrypt(rawKey, data.getBytes());</span><br><span class="line">       String after = Base64.encodeToString(encrypt, Base64.NO_WRAP);</span><br><span class="line">       Log.v(&quot;wz&quot;,&quot;加密后--&gt;&quot;+after);</span><br><span class="line">       byte[] decode = Base64.decode(after, Base64.NO_WRAP);</span><br><span class="line">       byte[] before = decrypt(rawKey, decode);</span><br><span class="line">       Log.v(&quot;wz&quot;,&quot;解密后--&gt;&quot;+new String(before));</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>出自百度百科</p><p>&emsp;&emsp;1976年，美国学者Dime和Henman为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。</p><p>&emsp;&emsp;与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p><p>&emsp;&emsp;说了这么多废话，要我说，就一句话公钥，私钥 <strong><em>不相同</em></strong> 的加密方式称之为对称加密</p><h2 id="用法——RSA"><a href="#用法——RSA" class="headerlink" title="用法——RSA"></a>用法——RSA</h2><p>&emsp;&emsp;申明：我这里并不是说非对称加密就只有RSA这一种方式，相反，对非称加密有很多种，我这里只讲我用到的非对称加密中的一种方式——RSA</p><p>&emsp;&emsp;辣么，成对公钥，私钥怎么来呢？难道我们自己去写吗？你要是会写，那你很棒棒哦，反正我不会(爱咋咋)，我是<a href="http://web.chacuo.net/netrsakeypair" target="_blank" rel="noopener">在线生成公钥，私钥对</a>。用法跟上面讲的AES是类似的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 我们之前拿到的是公钥，我们还要把公钥转成Key</span><br><span class="line">   * 因为cipher.init()初始化的时候，第二个参数需要传Key类型的，并不是String</span><br><span class="line">   * 获取Key，我这里返回的是PublicKey，它实现的Key接口</span><br><span class="line">   * @param pubKey 生成的公钥</span><br><span class="line">   * @return 最后需要的key</span><br><span class="line">   * @throws Exception 异常</span><br><span class="line">   */</span><br><span class="line">  public static PublicKey loadPublicKey(String pubKey) throws Exception &#123;</span><br><span class="line">    byte[] buffer = Base64.decode(pubKey, Base64.DEFAULT);</span><br><span class="line">    KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer);</span><br><span class="line">    return keyFactory.generatePublic(keySpec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 加密</span><br><span class="line">   * @param data 需要加密的数据</span><br><span class="line">   * @param publicKey key</span><br><span class="line">   * @return 返回加密后的byte，需要转成字符串</span><br><span class="line">   * @throws Exception 异常</span><br><span class="line">   */</span><br><span class="line">  private static byte[] encryptRSA(String data,PublicKey publicKey) throws Exception &#123;</span><br><span class="line">    Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE,publicKey);</span><br><span class="line">    return cipher.doFinal(data.getBytes());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 解密（我们需要注意的是，我们解密的是私钥加密的数据，不能解密公钥加密的数据）</span><br><span class="line">   * @param data 需要解密的数据</span><br><span class="line">   * @param publicKey key</span><br><span class="line">   * @return 返回解密后的数组</span><br><span class="line">   * @throws Exception 异常</span><br><span class="line">   */</span><br><span class="line">  private static byte[] decryptRSA(String data,PublicKey publicKey) throws Exception &#123;</span><br><span class="line">    Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE,publicKey);</span><br><span class="line">    return cipher.doFinal(data.getBytes());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里，注释说的很清楚，看懂了前面的AES，辣么，这个RSA应该不是问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;补充知识点：&quot;&gt;&lt;a href=&quot;#补充知识点：&quot; class=&quot;headerlink&quot; title=&quot;补充知识点：&quot;&gt;&lt;/a&gt;补充知识点：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;密钥：&lt;/em&gt;&lt;/strong&gt; 加密方用公钥，解密方用私钥&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要的事情强调六遍：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不用自己写加密算法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -加密算法" scheme="http://haichenyi.com/categories/Android-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 加密算法（一）</title>
    <link href="http://haichenyi.com/2018/03/08/Java-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/03/08/Java-加密算法（一）/</id>
    <published>2018-03-08T12:06:32.000Z</published>
    <updated>2018-03-08T12:08:30.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="补充知识点："><a href="#补充知识点：" class="headerlink" title="补充知识点："></a>补充知识点：</h2><p><strong><em>字节</em></strong>：也就是 <strong>byte</strong> 是一种统计单位，表示数量的多少</p><p><strong><em>字符</em></strong>：是指计算机中使用的文字和符号，比如：1、2、3、A、S、D、$、%等等符号</p> <a id="more"></a><p><strong><em>字节与字符的对应关系</em></strong>：它们完全不是一个概念，所以，没有什么有没有区别这个说法。不同的编码，两者的对应关系是不相同的，我这里就说常用的两种编码：</p><ol><li>ASCII码中，一个英文字母（不区分大小写）占一个字节，一个中文汉字占两个字节</li><li>UTF-8中，一个英文字母占一个字节，一个中文汉字占三个字节</li></ol><p>&emsp;&emsp;我们加密最终常常操作的是bit，而我们加密首先得到的是byte数组的，byte的取值范围-128~127，中间包括0，刚好256个。也就是2^8=256。并且，<strong><em>1  byte = 8 bit</em></strong>（1kb = 1024 byte = 8^1024 bit等等）</p><p>&emsp;&emsp;我们获得了byte之后，要把byte数组转成String字符串，String其实就是char数组，我们java有一个<strong><em>new String(char[] chars)</em></strong>，应该都用过。我们转成字符串的前提是转成char数组，由于，<strong><em>1 char = 2 byte</em></strong>，所以，我们byte转成char长度扩大了1倍。</p><h2 id="四种分类"><a href="#四种分类" class="headerlink" title="四种分类"></a>四种分类</h2><ol><li>MD5加密</li><li>Base64加密</li><li>对称加密</li><li>非对称加密</li></ol><h2 id="MD5加密——不可逆"><a href="#MD5加密——不可逆" class="headerlink" title="MD5加密——不可逆"></a>MD5加密——不可逆</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>&emsp;&emsp;MD5加密是我们常见的加密算法，是不可逆的，也就是说加密完成之后，无法解密转成原来的内容。MD5加密算法其实是一种散列函数，使用的是hash算法。MD5的原文是无线多个，但是MD5的值是有限的。所以一个MD5的值可能对应多个原文。SHA算法跟MD5是差不多的，只是MD5是128位，SHA是160位，多32位</p><p>&emsp;&emsp;为什么MD5的值是有限多个呢？主流的MD5使用的是将任意长度的字节串映射为一个128bit的大整数。也就是一共有2^128种可能，所以说这个数字是有限的，而，我们的原文则是无限多个。发现两段原文对应同一个MD5的值概率非常小，也就忽略不记了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String name1 = &quot;haichenyi&quot;;</span><br><span class="line">   String name2 = &quot;海晨忆&quot;;</span><br><span class="line">    try &#123;</span><br><span class="line">      MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">      byte[] digest1 = md5.digest(name1.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">      Log.v(&quot;WZ&quot;,&quot;length1:&quot;+digest1.length);</span><br><span class="line"></span><br><span class="line">      byte[] digest2 = md5.digest(name2.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">      Log.v(&quot;WZ&quot;,&quot;length1:&quot;+digest2.length);</span><br><span class="line">    &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们通过MD5，得到的是一个byte数组（这个byte数组的长度跟我们的1byte=8bit没有直接关系），我们需要做的就是对这个byte数组进行操作，我们习惯上就是把这个btye转成16进制数存进数据库，当然，你也可以转成其他的类型存到数据库。这里给出几个byte数组转16进制字符串的方法，亲测可用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">private static final char[] HEX_CHAR = &#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;,</span><br><span class="line">      &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 方法一：</span><br><span class="line">   * byte[] to hex string</span><br><span class="line">   *</span><br><span class="line">   * @param bytes</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public String bytesToHexFun1(byte[] bytes) &#123;</span><br><span class="line">    // 一个byte为8位，可用两个十六进制位标识</span><br><span class="line">    char[] buf = new char[bytes.length * 2];</span><br><span class="line">    int a = 0;</span><br><span class="line">    int index = 0;</span><br><span class="line">    for (byte b : bytes) &#123; // 使用除与取余进行转换</span><br><span class="line">      if (b &lt; 0) &#123;</span><br><span class="line">        a = 256 + b;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        a = b;</span><br><span class="line">      &#125;</span><br><span class="line">      buf[index++] = HEX_CHAR[a / 16];</span><br><span class="line">      buf[index++] = HEX_CHAR[a % 16];</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 方法二：</span><br><span class="line">   * byte[] to hex string</span><br><span class="line">   *</span><br><span class="line">   * @param bytes</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public String bytesToHexFun2(byte[] bytes) &#123;</span><br><span class="line">    char[] buf = new char[bytes.length * 2];</span><br><span class="line">    int index = 0;</span><br><span class="line">    for(byte b : bytes) &#123; // 利用位运算进行转换，可以看作方法一的变种</span><br><span class="line">      buf[index++] = HEX_CHAR[b &gt;&gt;&gt; 4 &amp; 0xf];</span><br><span class="line">      buf[index++] = HEX_CHAR[b &amp; 0xf];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new String(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 方法三：</span><br><span class="line">   * byte[] to hex string</span><br><span class="line">   *</span><br><span class="line">   * @param bytes</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public String bytesToHexFun3(byte[] bytes) &#123;</span><br><span class="line">    StringBuilder buf = new StringBuilder(bytes.length * 2);</span><br><span class="line">    for(byte b : bytes) &#123; // 使用String的format方法进行转换</span><br><span class="line">      buf.append(String.format(&quot;%02x&quot;, new Integer(b &amp; 0xff)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return buf.toString();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 将16进制字符串转换为byte[]</span><br><span class="line">   *</span><br><span class="line">   * @param str</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public byte[] toBytes(String str) &#123;</span><br><span class="line">    if(str == null || str.trim().equals(&quot;&quot;)) &#123;</span><br><span class="line">      return new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    byte[] bytes = new byte[str.length() / 2];</span><br><span class="line">    for(int i = 0; i &lt; str.length() / 2; i++) &#123;</span><br><span class="line">      String subStr = str.substring(i * 2, i * 2 + 2);</span><br><span class="line">      bytes[i] = (byte) Integer.parseInt(subStr, 16);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bytes;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Base64加密——可逆"><a href="#Base64加密——可逆" class="headerlink" title="Base64加密——可逆"></a>Base64加密——可逆</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>要知道的是有一个64个数的表，也称Base64编码表。可以字节定义，不过都是用的一样的。</li><li>Base64是按照字符长度，以3个字符为一组</li><li>接着增对每组的每个字符，取<a href="http://ascii.911cha.com/" target="_blank" rel="noopener">ASCII编码</a></li><li>然后将获得的编码转换成8bit的二进制，就会得到3*8=24bit的字节</li><li>然后将这24bit的字节以6个bit为一组，分成4组</li><li>接着在每组前面填两个高位0，凑成每组8bit</li><li>最后将这每组8bit的二进制转成十进制，对应下面的Base64编码表</li></ol><p><strong><em>Base64 编码表</em></strong></p><table><thead><tr><th style="text-align:center">value</th><th style="text-align:center">char</th><th style="text-align:center">value</th><th style="text-align:center">char</th><th style="text-align:center">value</th><th style="text-align:center">char</th><th style="text-align:center">value</th><th style="text-align:center">char</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">A</td><td style="text-align:center">16</td><td style="text-align:center">Q</td><td style="text-align:center">32</td><td style="text-align:center">g</td><td style="text-align:center">48</td><td style="text-align:center">w</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">B</td><td style="text-align:center">17</td><td style="text-align:center">R</td><td style="text-align:center">33</td><td style="text-align:center">h</td><td style="text-align:center">49</td><td style="text-align:center">x</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">C</td><td style="text-align:center">18</td><td style="text-align:center">S</td><td style="text-align:center">34</td><td style="text-align:center">i</td><td style="text-align:center">50</td><td style="text-align:center">y</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D</td><td style="text-align:center">19</td><td style="text-align:center">T</td><td style="text-align:center">35</td><td style="text-align:center">j</td><td style="text-align:center">51</td><td style="text-align:center">z</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">E</td><td style="text-align:center">20</td><td style="text-align:center">U</td><td style="text-align:center">36</td><td style="text-align:center">k</td><td style="text-align:center">52</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">F</td><td style="text-align:center">21</td><td style="text-align:center">V</td><td style="text-align:center">37</td><td style="text-align:center">l</td><td style="text-align:center">53</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">G</td><td style="text-align:center">22</td><td style="text-align:center">U</td><td style="text-align:center">38</td><td style="text-align:center">m</td><td style="text-align:center">54</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">H</td><td style="text-align:center">23</td><td style="text-align:center">X</td><td style="text-align:center">39</td><td style="text-align:center">n</td><td style="text-align:center">55</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">I</td><td style="text-align:center">24</td><td style="text-align:center">Y</td><td style="text-align:center">40</td><td style="text-align:center">o</td><td style="text-align:center">56</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">J</td><td style="text-align:center">25</td><td style="text-align:center">Z</td><td style="text-align:center">41</td><td style="text-align:center">p</td><td style="text-align:center">57</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">K</td><td style="text-align:center">26</td><td style="text-align:center">a</td><td style="text-align:center">42</td><td style="text-align:center">q</td><td style="text-align:center">58</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">L</td><td style="text-align:center">27</td><td style="text-align:center">b</td><td style="text-align:center">43</td><td style="text-align:center">r</td><td style="text-align:center">59</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">M</td><td style="text-align:center">28</td><td style="text-align:center">c</td><td style="text-align:center">44</td><td style="text-align:center">s</td><td style="text-align:center">60</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">N</td><td style="text-align:center">29</td><td style="text-align:center">d</td><td style="text-align:center">45</td><td style="text-align:center">t</td><td style="text-align:center">61</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">O</td><td style="text-align:center">30</td><td style="text-align:center">e</td><td style="text-align:center">46</td><td style="text-align:center">u</td><td style="text-align:center">62</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">P</td><td style="text-align:center">31</td><td style="text-align:center">f</td><td style="text-align:center">47</td><td style="text-align:center">v</td><td style="text-align:center">63</td><td style="text-align:center">/</td></tr></tbody></table><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;hai&quot;;</span><br><span class="line">    byte[] encode = Base64.encode(str.getBytes(), Base64.NO_WRAP);</span><br><span class="line">    try &#123;</span><br><span class="line">      String a = new String(encode,&quot;UTF-8&quot;);</span><br><span class="line">      String a1 = new String(encode,&quot;US-ASCII&quot;);</span><br><span class="line">      Log.v(&quot;wz&quot;,a);</span><br><span class="line">    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    String after = Base64.encodeToString(str.getBytes(), Base64.NO_WRAP);</span><br><span class="line">    Log.v(&quot;wz&quot;,&quot;after--&gt;&quot;+after);</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>&emsp;&emsp;这里，我要使用Base64加密”hai”这个字符串，根据上面的流程：</p><table><thead><tr><th style="text-align:center">待加密字符串</th><th style="text-align:center">h</th><th style="text-align:center">a</th><th style="text-align:center">i</th></tr></thead><tbody><tr><td style="text-align:center">ASCII编码</td><td style="text-align:center">104</td><td style="text-align:center">97</td><td style="text-align:center">105</td></tr><tr><td style="text-align:center">二进制</td><td style="text-align:center">01101000</td><td style="text-align:center">01100001</td><td style="text-align:center">01101001</td></tr></tbody></table><p>下面，上面的表不好表示，我再换一个表，下一步，该6位分一组了</p><p>现在的字符串：01101000 01100001 01101001</p><table><thead><tr><th style="text-align:center">六位分一组</th><th style="text-align:center">011010</th><th style="text-align:center">000110</th><th style="text-align:center">000101</th><th style="text-align:center">101001</th></tr></thead><tbody><tr><td style="text-align:center">每组前面补0</td><td style="text-align:center">00011010</td><td style="text-align:center">00000110</td><td style="text-align:center">00000101</td><td style="text-align:center">00101001</td></tr><tr><td style="text-align:center">转成10进制</td><td style="text-align:center">26</td><td style="text-align:center">6</td><td style="text-align:center">5</td><td style="text-align:center">41</td></tr><tr><td style="text-align:center">Base64编码</td><td style="text-align:center">a</td><td style="text-align:center">G</td><td style="text-align:center">F</td><td style="text-align:center">p</td></tr></tbody></table><p><strong>结果图：</strong></p><p><strong><em>PS：</em></strong></p><ol><li>Base64.encodeToString()方法直接转成加密后的字符串</li><li>Base64.encode()方法返回的byte数组是16进制的，不用手动在去转一遍16进制</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;补充知识点：&quot;&gt;&lt;a href=&quot;#补充知识点：&quot; class=&quot;headerlink&quot; title=&quot;补充知识点：&quot;&gt;&lt;/a&gt;补充知识点：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;字节&lt;/em&gt;&lt;/strong&gt;：也就是 &lt;strong&gt;byte&lt;/strong&gt; 是一种统计单位，表示数量的多少&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;字符&lt;/em&gt;&lt;/strong&gt;：是指计算机中使用的文字和符号，比如：1、2、3、A、S、D、$、%等等符号&lt;/p&gt;
    
    </summary>
    
      <category term="Android -加密算法" scheme="http://haichenyi.com/categories/Android-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>EventBus源码解析(二)——注册</title>
    <link href="http://haichenyi.com/2018/03/07/EventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C/"/>
    <id>http://haichenyi.com/2018/03/07/EventBus源码解析-二-——注册/</id>
    <published>2018-03-07T12:24:37.000Z</published>
    <updated>2018-03-07T12:29:18.134Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;之前我们讲过<a href="http://haichenyi.com/2018/03/06/EventBus源码解析-一-——获取EventBus对象/">获取EventBus对象的源码</a>，这一篇，我们来讲讲注册的源码。推荐<a href="https://www.jianshu.com/p/bda4ed3017ba" target="_blank" rel="noopener">EventBus 3.0进阶：源码及其设计模式 完全解析</a></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they</span><br><span class="line">     * are no longer interested in receiving events.</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;.</span><br><span class="line">     * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link</span><br><span class="line">     * ThreadMode&#125; and priority.</span><br><span class="line">     */</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; <strong>翻译：</strong> 注册给订阅方去接收事件，订阅者一旦对接收事件不感兴趣了，就要unregister，订阅者必须要有用Subscribe注解的方法，注解也可以设置线程和优先级</p><p>&emsp;&emsp; <strong>白话文：</strong> 订阅者要是想接收消息，必须要先注册。当页面退出，或者不想接收消息的时候必须要反注册，不然他会一直处于接收消息的状态，页面退出会内存泄漏。订阅者的接收方法必须要用Subscribe注解，这个注解的后面可以设置接收这个消息的线程和优先级。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode = ThreadMode.MAIN,priority = 100,sticky = true)</span><br><span class="line">  public void handleMsg(DataBean dataBean)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就像上面这样写，我一个一个来讲。我们先来说说这个<strong><em>ThreadMode</em></strong>类，点进去，我们可以看到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 每个订阅的方法都有一个线程，决定那个线程的方法被叫做EventBus</span><br><span class="line">   * EventBus的线程可以跟Post事件的那个线程不相同</span><br><span class="line">   */</span><br><span class="line">public enum ThreadMode &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   *订阅者将在跟Post事件的那个线程的同一个线程中被调用，这是默认值，</span><br><span class="line">   * 因为，他没有线程切换，所以开销最少，所以也是推荐模式。需要注意的是</span><br><span class="line">   * post事件的线程可能是UI线程，也可能是其他线程，所以，这里的操作要做判断，</span><br><span class="line">   * 如果是UI操作，你必须要在UI线程中完成，如果是耗时操作，你必须要新开线程</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    POSTING,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 在Android上面，订阅者将会在UI线程中调用，如果post事件的线程是UI线程，</span><br><span class="line">   * 辣么，这个订阅方法将直接被调用，如果不是UI线程，辣么，它将要排队交付，</span><br><span class="line">   * 所以，这里可能阻塞线程，订阅者使用这个模式必须要快速返回，避免阻塞UI线程，</span><br><span class="line">   * 就是不要在这里做耗时操作。谢谢。</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    MAIN,</span><br><span class="line">    </span><br><span class="line">  /**</span><br><span class="line">   *这一个，跟上面的刚好对应，就是不管怎么样，都要排队交付，</span><br><span class="line">   * 不论post事件是不是处于UI线程发送的</span><br><span class="line">   */</span><br><span class="line">    </span><br><span class="line">    MAIN_ORDERED,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 在android上面，订阅方法将在子线程中调用。如果post事件处于子线程，</span><br><span class="line">   * 辣么，订阅方法将直接被调用。如果post事件处于UI线程，辣么，eventBus</span><br><span class="line">   * 就会新开线程，按照顺序处理事件，当然，也要注意，避免阻塞子线程</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    BACKGROUND,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 订阅方法将会在独立的线程中调用，这个线程总是独立语post事件</span><br><span class="line">   * 所处的线程和主线程。如果post事件是耗时操作：例如网络请求，</span><br><span class="line">   * 订阅方法调用的时候，不会等待。我们不用考虑线程数量的问题，</span><br><span class="line">   * EventBus已经限制了并发线程，并使用线程池高效的重用线程</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">    ASYNC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他就是一个枚举类，几个值的意义，我说的很清楚了。</p><p>&emsp;&emsp;我们再来讲讲另外两个： <strong><em>sticky</em></strong>，默认值是false，如果设置成true，辣么，这个事件将会是粘性事件。发送事件的方式从<strong>post</strong>变成了<strong>postSticky</strong>，其他都没变。</p><p>&emsp;&emsp;再来讲讲 <strong><em>priority</em></strong> ，默认值是0，在同一个线程中值越大，优先级越高。优先级高的比优先级低的先收到消息。</p><p>好，终于准备工作做完了，我们来看看 <strong><em>register()</em></strong> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注册方法。首先，他通过反射的方式获得当前类名，然后通过当前类名，找到订阅方法，存到list里面。我们来看看 <strong><em>findSubscriberMethods()</em></strong>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">//首先从缓存中读取当前类的订阅方法，如果不等于null，就直接返回从缓存中读取到的list</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">        if (subscriberMethods != null) &#123;</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">//ignoreGeneratedIndex的值，从Builder可知，一般为false。</span><br><span class="line">        if (ignoreGeneratedIndex) &#123;</span><br><span class="line">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                    + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //将获取的subscriberMeyhods放入缓存中</span><br><span class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">            return subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的注释写的很清楚，ignoreGeneratedIndex为false，辣么就会走<strong><em>findUsingInfo()</em></strong> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">//首先新建了一个FindState，FindState是一个静态内部类，保存订阅者的信息</span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line">        //初始化FindState</span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line">        while (findState.clazz != null) &#123;</span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            //初始化的findState获得的订阅者信息，一般都是null</span><br><span class="line">            if (findState.subscriberInfo != null) &#123;</span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            //就会跳到这里</span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            //移动到父类继续查找</span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        return getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面，我们提到了<strong><em>FindState</em></strong>类，我们来看看这个类的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static class FindState &#123;</span><br><span class="line">//订阅方法的列表</span><br><span class="line">        final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;();</span><br><span class="line">//以class的名称为key，以方法为value</span><br><span class="line">        final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;();</span><br><span class="line">//以方法名称为key，订阅者类为value</span><br><span class="line">        final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;();</span><br><span class="line">        final StringBuilder methodKeyBuilder = new StringBuilder(128);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; subscriberClass;</span><br><span class="line">        Class&lt;?&gt; clazz;</span><br><span class="line">        boolean skipSuperClasses;</span><br><span class="line">        SubscriberInfo subscriberInfo;</span><br><span class="line">//初始化</span><br><span class="line">        void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">            this.subscriberClass = clazz = subscriberClass;</span><br><span class="line">            skipSuperClasses = false;</span><br><span class="line">            subscriberInfo = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不难看出，这里的几个map包括了，类名找方法，方法名找类，我们后面都用的到，然后就是初始化方法，前面我们注释里面写了，初始化之后一般信息都是null，这里我们也可以看到。所以，它会走 <strong><em>findUsingReflectionInSingleClass</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">        Method[] methods;</span><br><span class="line">        try &#123;</span><br><span class="line">            // This is faster than getMethods, especially when subscribers are fat classes like Activities</span><br><span class="line">            methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; catch (Throwable th) &#123;</span><br><span class="line">            // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses = true;</span><br><span class="line">        &#125;</span><br><span class="line">        /*------------------------------上面就是获取方法，重要的是在下面------------------------------------*/</span><br><span class="line">        //这里我强调的是我们前面的用法里面有说过注意点</span><br><span class="line">        //1.必须是public修饰</span><br><span class="line">        //2.必须是void类型</span><br><span class="line">        //3.必须是一个参数</span><br><span class="line">        //4.必须用Subscribe注解</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">        //获取方法的修饰符</span><br><span class="line">            int modifiers = method.getModifiers();</span><br><span class="line">            if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123;</span><br><span class="line">            //获取方法参数类型</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                //如果参数个数等于1</span><br><span class="line">                if (parameterTypes.length == 1) &#123;</span><br><span class="line">                //获取方法注解名称</span><br><span class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                    if (subscribeAnnotation != null) &#123;</span><br><span class="line">                    //参数类型 即为事件类型</span><br><span class="line">                        Class&lt;?&gt; eventType = parameterTypes[0];</span><br><span class="line">                        //调用checkAdd方法判断是否添加过</span><br><span class="line">                        if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        //从注解里面获取线程模式</span><br><span class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                            //新建一个SubscriberMethod对象，并添加到findState的subscriberMethods这个集合内</span><br><span class="line">                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                   //如果开启了严格验证，同时当前方法又有@Subscribe注解，对不符合要求的方法会抛出异常</span><br><span class="line">                &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                    String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                    throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</span><br><span class="line">                            &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                throw new EventBusException(methodName +</span><br><span class="line">                        &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法非常重要！！！在这个方法内部，利用反射的方式，对订阅者类进行扫描判断，是否满足条件从而找出订阅方法，并用上面的容器进行保存。辣么，上面提到的 <strong><em>checkAdd()</em></strong> 方法是怎么检查的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">            // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.</span><br><span class="line">            // Usually a subscriber doesn&apos;t have methods listening to the same event type.</span><br><span class="line">            Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">            if (existing == null) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (existing instanceof Method) &#123;</span><br><span class="line">                    if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</span><br><span class="line">                        // Paranoia check</span><br><span class="line">                        throw new IllegalStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Put any non-Method object to &quot;consume&quot; the existing Method</span><br><span class="line">                    anyMethodByEventType.put(eventType, this);</span><br><span class="line">                &#125;</span><br><span class="line">                return checkAddWithMethodSignature(method, eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个注释写的很清楚，两层检验，第一层是检测事件类型，第二次检验则是检验判断方法的完整，首先以eventType为键，方法为值，存到map中（这个map是在FindState类初始化的），put方法会有一个返回值，返回value，这个value是这个key对应的上一个值，所以说，如果是第一次存放，那么就会返回null。否则，之前存放过，辣么就会进入下一个判断 <strong><em>checkAddWithMethodSignature</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">            methodKeyBuilder.setLength(0);</span><br><span class="line">            methodKeyBuilder.append(method.getName());</span><br><span class="line">            methodKeyBuilder.append(&apos;&gt;&apos;).append(eventType.getName());</span><br><span class="line"></span><br><span class="line">            String methodKey = methodKeyBuilder.toString();</span><br><span class="line">            Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">            Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">            if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">                // Only add if not already found in a sub class</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Revert the put, old class is further down the class hierarchy</span><br><span class="line">                subscriberClassByMethodKey.put(methodKey, methodClassOld);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法就是用来判断方法签名是否相同的，方法签名是什么呢？就是修饰符+返回类型+方法名+参数list是否相同。如果方法签名相同，辣么，就把旧值赋值给methodClassOld，判断这个值不是为null，第一次调用，没有旧值，就肯定为null，所以，if前面的一个条件是满足的，后面一个条件<strong>methodClassOld.isAssignableFrom(methodClass)</strong> 的意思是判断旧值是否是methodClass或者同一个类，如果两个条件都不满足，辣么当前方法就不会添加为订阅方法。</p><p>&emsp;&emsp;那么，说了一大堆关于checkAdd和checkAddWithMethodSignature方法的源码，那么这两个方法到底有什么作用呢？从这两个方法的逻辑来看，第一层判断根据eventType来判断是否有多个方法订阅该事件，而第二层判断根据完整的方法签名(包括方法名字以及参数名字)来判断。下面是笔者的理解：</p><p>&emsp;&emsp;第一种情况：比如一个类有多个订阅方法，方法名不同，但它们的参数类型都是相同的(虽然一般不这样写，但不排除这样的可能)，那么遍历这些方法的时候，会多次调用到checkAdd方法，由于existing不为null，那么会进而调用checkAddWithMethodSignature方法，但是由于每个方法的名字都不同，因此methodClassOld会一直为null，因此都会返回true。也就是说，<strong>允许一个类有多个参数相同的订阅方法。</strong></p><p>&emsp;&emsp;第二种情况：类B继承自类A，而每个类都是有相同订阅方法，换句话说，类B的订阅方法继承并重写自类A，它们都有着一样的方法签名。方法的遍历会从子类开始，即B类，在checkAddWithMethodSignature方法中，methodClassOld为null，那么B类的订阅方法会被添加到列表中。接着，向上找到类A的订阅方法，由于methodClassOld不为null而且显然类B不是类A的父类，methodClassOld.isAssignableFrom(methodClass)也会返回false，那么会返回false。也就是说，<strong>子类继承并重写了父类的订阅方法，那么只会把子类的订阅方法添加到订阅者列表，父类的方法会忽略。</strong></p><p>&emsp;&emsp;让我们回到findUsingReflectionInSingleClass方法，当遍历完当前类的所有方法后，会回到findUsingInfo方法，接着会执行最后一行代码，即return getMethodsAndRelease(findState);那么我们继续 <strong><em>getMethodsAndRelease</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123;</span><br><span class="line">        //从findState获取subscriberMethods，放进新的ArrayList</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">        //把findState回收</span><br><span class="line">        findState.recycle();</span><br><span class="line">        synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">            for (int i = 0; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">                if (FIND_STATE_POOL[i] == null) &#123;</span><br><span class="line">                    FIND_STATE_POOL[i] = findState;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过该方法，把subscriberMethods不断逐层返回，直到返回EventBus#register()方法，最后开始遍历每一个订阅方法，并调用subscribe(subscriber, subscriberMethod)方法，那么，我们继续来看<strong><em>subscribe</em></strong>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// Must be called in synchronized block</span><br><span class="line">    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">        //将subscriber和subscriberMethod封装成 Subscription</span><br><span class="line">        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</span><br><span class="line">        //根据事件类型获取特定的 Subscription</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">        //如果为null，说明该subscriber尚未注册该事件</span><br><span class="line">        if (subscriptions == null) &#123;</span><br><span class="line">            subscriptions = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">            subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //如果不为null，并且包含了这个subscription 那么说明该subscriber已经注册了该事件，抛出异常</span><br><span class="line">            if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                        + eventType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //根据优先级来设置放进subscriptions的位置，优先级高的会先被通知</span><br><span class="line">        int size = subscriptions.size();</span><br><span class="line">        for (int i = 0; i &lt;= size; i++) &#123;</span><br><span class="line">            if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">                subscriptions.add(i, newSubscription);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //根据subscriber(订阅者)来获取它的所有订阅事件</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">        if (subscribedEvents == null) &#123;</span><br><span class="line">            subscribedEvents = new ArrayList&lt;&gt;();</span><br><span class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">        &#125;</span><br><span class="line">        subscribedEvents.add(eventType);</span><br><span class="line">        </span><br><span class="line">//下面是对粘性事件的处理</span><br><span class="line">        if (subscriberMethod.sticky) &#123;</span><br><span class="line">        //从EventBusBuilder可知，eventInheritance默认为true</span><br><span class="line">            if (eventInheritance) &#123;</span><br><span class="line">                // Existing sticky events of all subclasses of eventType have to be considered.</span><br><span class="line">                // Note: Iterating over all events may be inefficient with lots of sticky events,</span><br><span class="line">                // thus data structure should be changed to allow a more efficient lookup</span><br><span class="line">                // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        Object stickyEvent = entry.getValue();</span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">             //根据eventType，从stickyEvents列表中获取特定的事件</span><br><span class="line">                Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                //分发事件</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到目前为止，注册流程基本分析完毕，丢一张流程图</p><p><img src="http://upload-images.jianshu.io/upload_images/7041675-2b90513e16f84c03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注册流程图.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;之前我们讲过&lt;a href=&quot;http://haichenyi.com/2018/03/06/EventBus源码解析-一-——获取EventBus对象/&quot;&gt;获取EventBus对象的源码&lt;/a&gt;，这一篇，我们来讲讲注册的源码。推荐&lt;a href=&quot;https://www.jianshu.com/p/bda4ed3017ba&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EventBus 3.0进阶：源码及其设计模式 完全解析&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="http://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 设计模式（Design Patterns）（三）</title>
    <link href="http://haichenyi.com/2018/03/07/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/03/07/Java-设计模式（Design-Patterns）（三）/</id>
    <published>2018-03-07T12:24:11.000Z</published>
    <updated>2018-03-07T12:26:37.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="十三、策略模式"><a href="#十三、策略模式" class="headerlink" title="十三、策略模式"></a>十三、策略模式</h2><p>顾名思义:不同的策略，对应我们项目中用到的地方就是，同一个功能，不同的实现方法。就比方说登录功能：我们有帐号密码登录，QQ第三方登录，微信第三方登录等等。其实我个人认为最典型的就是：同一个接口方法，不同的实现方式。</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface LoginInterface&#123;</span><br><span class="line">    void login();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PhoneLogin implements LoginInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void login()&#123;</span><br><span class="line">    //具体的逻辑</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;帐号密码登录&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class QqLogin implements LoginInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void login()&#123;</span><br><span class="line">    //具体的逻辑</span><br><span class="line">        Log.v(&quot;wz&quot;,&quot;QQ第三方登录&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像上面这样，同一个登录功能，不同的实现。</p><h2 id="十四、责任链模式"><a href="#十四、责任链模式" class="headerlink" title="十四、责任链模式"></a>十四、责任链模式</h2><p>责任链模式，我项目里面用的比较少，但是我知道一个android里面绝对常用的东西用的是责任连模式，那就是——<a href="http://haichenyi.com/2018/02/22/Android事件分发机制原理/">andoid事件分发</a></p><h2 id="十五、状态模式"><a href="#十五、状态模式" class="headerlink" title="十五、状态模式"></a>十五、状态模式</h2><p>状态模式，我项目里面用的比较少，但是我知道的是游戏里面用的很多。就是那种存档功能，遇到自己感觉过不去的地方，把当前进度存起来，过不去了之后，死了，游戏结束了，再读当前的存档。</p><p>PS：其他的设计模式等用到了再补充</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;十三、策略模式&quot;&gt;&lt;a href=&quot;#十三、策略模式&quot; class=&quot;headerlink&quot; title=&quot;十三、策略模式&quot;&gt;&lt;/a&gt;十三、策略模式&lt;/h2&gt;&lt;p&gt;顾名思义:不同的策略，对应我们项目中用到的地方就是，同一个功能，不同的实现方法。就比方说登录功能：我们有帐号密码登录，QQ第三方登录，微信第三方登录等等。其实我个人认为最典型的就是：同一个接口方法，不同的实现方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -设计模式" scheme="http://haichenyi.com/categories/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 设计模式（Design Patterns）（二）</title>
    <link href="http://haichenyi.com/2018/03/07/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/03/07/Java-设计模式（Design-Patterns）（二）/</id>
    <published>2018-03-07T12:23:53.000Z</published>
    <updated>2018-03-07T12:26:04.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六、适配器模式"><a href="#六、适配器模式" class="headerlink" title="六、适配器模式"></a>六、适配器模式</h2><p>分类有三种：类的适配器模式，对象的适配器模式，接口的适配器模式，我印象最深刻的是<strong><em>接口适配器模式</em></strong></p> <a id="more"></a><p><strong>接口适配器模式</strong></p><p>&emsp;&emsp;有的时候，我们写的一个接口，会有很多种方法。而，我们的实现类只需要实现某一种，或者某几种，所以，我们这里会借助一个抽象类，去实现接口的所有方法。我们的具体实现类跟这个抽象类去打交道，而不是跟原始的接口去打交道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public abstract class MySubscriber&lt;T&gt; extends ResourceSubscriber&lt;T&gt; &#123;</span><br><span class="line">  private BaseView baseView;</span><br><span class="line">  private boolean showLoading;</span><br><span class="line"></span><br><span class="line">  public MySubscriber(BaseView baseView) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MySubscriber(BaseView baseView, boolean showLoading) &#123;</span><br><span class="line">    this.baseView = baseView;</span><br><span class="line">    this.showLoading = showLoading;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onStart() &#123;</span><br><span class="line">    super.onStart();</span><br><span class="line">    if (null != baseView &amp;&amp; showLoading) &#123;</span><br><span class="line">      baseView.showLoading();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onError(Throwable t) &#123;</span><br><span class="line">    if (null == baseView) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    baseView.hideLoading();</span><br><span class="line">    if (t instanceof ApiException) &#123;</span><br><span class="line">      ApiException apiException = (ApiException) t;</span><br><span class="line">      switch (apiException.getCode()) &#123;</span><br><span class="line">        case HttpCode.NO_PARAMETER:</span><br><span class="line">          baseView.showTipMsg(&quot;参数为空&quot;);</span><br><span class="line">          break;</span><br><span class="line">        case HttpCode.SERVER_ERR:</span><br><span class="line">          baseView.showTipMsg(&quot;服务器错误&quot;);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onComplete() &#123;</span><br><span class="line">    if (null != baseView) &#123;</span><br><span class="line">      baseView.hideLoading();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addSubscribe(helper.selectBrandList()</span><br><span class="line">        .compose(RxUtil.handleHttp())</span><br><span class="line">        .subscribeWith(new MySubscriber&lt;List&lt;String&gt;&gt;(baseView, true) &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onNext(List&lt;String&gt; dataList) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;,&quot;111&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个代码，就是我之前写的<a href="http://haichenyi.com/categories/Android-框架/">从零开始搭建一个主流项目框架</a>系列里面的网络请求，处理返回结果的回调方法，我的返回结果，不可能每个去实现onStart，onError，onNext，onCompleted方法。我的实现类只用去继承这个类，实现某一个，或者某几个方法。更直接的就是，我之前写的框架，BaseActivity，实现BaseView接口，然后，我其他的Activity去继承BaseActivity，选择实现BaseView的方法。</p><p>如果上面这样，你还无法认同，那我们看看下面这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//success动画结束监听</span><br><span class="line">    successAnim.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">        super.onAnimationEnd(animation);</span><br><span class="line">        if (null != myAnimotionInterface) &#123;</span><br><span class="line">          myAnimotionInterface.AnimationEnd();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>动画监听，我这里只想监听动画结束，在动画结束的时候，我做我的逻辑处理，但是，他的接口有开始，结束，暂停，重复等等监听，我不要这么，你们可以点 <strong>AnimatorListenerAdapter()</strong> 这个类，去看一下他是什么，他就是一个抽象类，实现了动画监听的那个接口，这个是官方封装好的一个类。</p><h2 id="七、装饰器模式"><a href="#七、装饰器模式" class="headerlink" title="七、装饰器模式"></a>七、装饰器模式</h2><p>这个模式就是我之前写<a href="http://haichenyi.com/categories/Android-框架/">从零开始搭建一个主流项目框架</a>系列里面网络请求，SP的操作，Socket的操作，关于他们的封装都是用的装饰者模式。说的官方一点：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。项目中的应用就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public interface HttpHelper &#123;</span><br><span class="line">  Flowable&lt;WeatherBean&gt; getWeather(String city);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 登录时获取验证码.</span><br><span class="line">   *</span><br><span class="line">   * @param phone 手机号</span><br><span class="line">   * @return &#123;&quot;code&quot;:0&#125;</span><br><span class="line">   */</span><br><span class="line">  Flowable&lt;HttpNoResult&gt; loginCode(String phone);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个就是装饰对象和被装饰对象实现的同一个接口，他们一开始就只有一个功能，那就是获取天气，后来他们又新加了一个功能，必须登录之后才能获取天气，那就多了一个登录功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class DataHelper implements HttpHelper, PreferencesHelper, SqlHelper &#123;</span><br><span class="line">  private SqlHelper sqlHelper;</span><br><span class="line">  private HttpHelper httpHelper;</span><br><span class="line">  private PreferencesHelper preferencesHelper;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 初始化数据帮助类.</span><br><span class="line">   *</span><br><span class="line">   * @param sqlHelper         &#123;@link SqlHelper&#125;</span><br><span class="line">   * @param httpHelper        &#123;@link HttpHelper&#125;</span><br><span class="line">   * @param preferencesHelper &#123;@link PreferencesHelper&#125;</span><br><span class="line">   */</span><br><span class="line">  public DataHelper(SqlHelper sqlHelper, HttpHelper httpHelper,</span><br><span class="line">                    PreferencesHelper preferencesHelper) &#123;</span><br><span class="line">    this.sqlHelper = sqlHelper;</span><br><span class="line">    this.httpHelper = httpHelper;</span><br><span class="line">    this.preferencesHelper = preferencesHelper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123;</span><br><span class="line">    return httpHelper.getWeather(city);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123;</span><br><span class="line">    return httpHelper.loginCode(phone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个就是装饰类，负责调用接口的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class RetrofitHttp implements HttpHelper &#123;</span><br><span class="line">  private WardrobeApi wardrobeApi;</span><br><span class="line">  private WeatherApi weatherApi;</span><br><span class="line"></span><br><span class="line">  @Inject</span><br><span class="line">  RetrofitHttp(WardrobeApi wardrobeApi, WeatherApi weatherApi) &#123;</span><br><span class="line">    this.wardrobeApi = wardrobeApi;</span><br><span class="line">    this.weatherApi = weatherApi;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;WeatherBean&gt; getWeather(String city) &#123;</span><br><span class="line">    return weatherApi.getWeather(city, &quot;c41d9ca568d449e2802244d8eeb3d3c6&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Flowable&lt;HttpNoResult&gt; loginCode(String phone) &#123;</span><br><span class="line">    return wardrobeApi.loginCode(phone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个就是被装饰类，负责具体的实现，这里是retrofit网络请求。以上都是伪代码。具体就是为了说明这个装饰者模式的中心思想，以及我在项目中的运用，不保证一定完全正确，都是按照自己的理解写的。</p><p>PS：其他的设计模式等用到了再补充</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;六、适配器模式&quot;&gt;&lt;a href=&quot;#六、适配器模式&quot; class=&quot;headerlink&quot; title=&quot;六、适配器模式&quot;&gt;&lt;/a&gt;六、适配器模式&lt;/h2&gt;&lt;p&gt;分类有三种：类的适配器模式，对象的适配器模式，接口的适配器模式，我印象最深刻的是&lt;strong&gt;&lt;em&gt;接口适配器模式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -设计模式" scheme="http://haichenyi.com/categories/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 设计模式（Design Patterns）（一）</title>
    <link href="http://haichenyi.com/2018/03/06/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Design-Patterns%EF%BC%89%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/03/06/Java-设计模式（Design-Patterns）（一）/</id>
    <published>2018-03-06T13:02:20.000Z</published>
    <updated>2018-03-06T13:06:53.893Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>设计模式的分类</em></strong></p><ol><li>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><a id="more"></a><p><strong>我只讲我用的多的，用的多的印象深刻，知道怎么讲，用的少的，不知道怎么讲。只讲我熟练的。</strong></p></li></ol><h2 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h2><p>单例模式，我想应该做过开发的人都用过。</p><h3 id="懒汉式（用的时候初始化，延迟加载）"><a href="#懒汉式（用的时候初始化，延迟加载）" class="headerlink" title="懒汉式（用的时候初始化，延迟加载）"></a>懒汉式（用的时候初始化，延迟加载）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MySocket&#123;</span><br><span class="line">    private static MySocket instance;</span><br><span class="line">    private MySocket()&#123;&#125;</span><br><span class="line">    public static synchronized MySocket getInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">            instance = new MySocket();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里在懒汉式的单例模式中加上了同步锁synchronized，所以，这是线程安全的，但是，也是因为锁，所以造成的效率低，可以根据不同实际情况判断是否需要加同步锁。</p><h3 id="饿汉式（加载类的时候直接初始化）"><a href="#饿汉式（加载类的时候直接初始化）" class="headerlink" title="饿汉式（加载类的时候直接初始化）"></a>饿汉式（加载类的时候直接初始化）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MySocket&#123;</span><br><span class="line">    private static MySocket instance = new MySocket();</span><br><span class="line">    private MySocket()&#123;&#125;</span><br><span class="line">    public static MySocket getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MySocket&#123;</span><br><span class="line">    private static MySocket instance;</span><br><span class="line">    private MySocket()&#123;&#125;</span><br><span class="line">    public static MySocket getInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">            synchronized(MySocket.class)&#123;</span><br><span class="line">                if(null == instance)&#123;</span><br><span class="line">                    instance = new MySocket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的双重校验锁，其实就是我这里的线程安全懒汉式的升级版本，双重校验锁很多开源框架都是用的这种单例，比方说：EventBus。关于单例模式的其他变种我就不说了。单例模式的最终目的，就是全局单例，一个项目不论哪里调用这个类都是引用的同一个对象。</p><h2 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2017/12/21</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class FragmentFactory &#123;</span><br><span class="line">  public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz) &#123;</span><br><span class="line">    return createFragment(clz, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static BaseFragment createFragment(Class&lt;? extends BaseFragment&gt; clz, Bundle bundle) &#123;</span><br><span class="line">    if (HomeFragment.class == clz) &#123;</span><br><span class="line">      return new HomeFragment();</span><br><span class="line">    &#125; else if (MyClothesFragment.class == clz) &#123;</span><br><span class="line">      return new MyClothesFragment();</span><br><span class="line">    &#125; else if (WardrobeStructureFragment.class == clz) &#123;</span><br><span class="line">      return new WardrobeStructureFragment();</span><br><span class="line">    &#125; else if (WifiFragment.class == clz) &#123;</span><br><span class="line">      return new WifiFragment();</span><br><span class="line">    &#125; else if (WardrobeConfigFragment.class == clz) &#123;</span><br><span class="line">      return new WardrobeConfigFragment();</span><br><span class="line">    &#125; else if (ShowFragment.class == clz) &#123;</span><br><span class="line">      return new ShowFragment();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new NullPointerException(&quot;not found fragment&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz) &#123;</span><br><span class="line">    return createDialogFragment(clz, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  private static &lt;T extends DialogFragment&gt; T createDialogFragment(Class&lt;T&gt; clz, Bundle bundle) &#123;</span><br><span class="line">    if (clz == IconDialogFragment.class) &#123;</span><br><span class="line">      return (T) new IconDialogFragment();</span><br><span class="line">    &#125; else if (clz == PasswordDialogFragment.class) &#123;</span><br><span class="line">      return (T) PasswordDialogFragment.newInstance();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw new NullPointerException(&quot;not found fragment&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个fragment工厂类，就是我项目里面用到的。常用的工厂模式就是静态工厂，利用static方法，我这里的工厂就是静态工厂。我们常说的工厂方法对应的这里是什么呢？其实，工厂方法也是一个普通的方法，对应的这里就是<strong><em>createFragment(Class&lt;? extends BaseFragment&gt; clz)</em></strong>。工厂模式什么时候用呢？在需要大量类似的数据的时候（个人观点），Android里面，工厂方法用的最多的就是创建Fragment。</p><h2 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface IFragmentFactory&#123;</span><br><span class="line">    BaseFragment createFragment();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HomeFactory implements IFragmentFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public BaseFragment createFragment()&#123;</span><br><span class="line">        return new HomeFragment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WifiFragment implements IFragmentFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public BaseFragment createFragment()&#123;</span><br><span class="line">        return new WifiFragment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我把上面的静态工厂类，改成了抽象工厂类，就是上面的代码。就是有一个工厂接口或者抽象的工厂类，然后创建不同的工厂类去实现这个接口，实现对应的类，返回你需要的东西</p><h2 id="四、建造者模式"><a href="#四、建造者模式" class="headerlink" title="四、建造者模式"></a>四、建造者模式</h2><p>我之前写Luban源码解析的时候就讲过建造者模式，可以去看一下，就在源码解析的一开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.mytakephoto;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/6</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class DataBean &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  private int age;</span><br><span class="line">  private String sex;</span><br><span class="line"></span><br><span class="line">  public DataBean(Builder builder) &#123;</span><br><span class="line">    this.name = builder.name;</span><br><span class="line">    this.age = builder.age;</span><br><span class="line">    this.sex = builder.sex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age = 20;</span><br><span class="line">    private String sex = &quot;男&quot;;</span><br><span class="line"></span><br><span class="line">    public Builder setName(String name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setAge(int age) &#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder setSex(String sex) &#123;</span><br><span class="line">      this.sex = sex;</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DataBean build() &#123;</span><br><span class="line">      return new DataBean(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码就是一个DataBean类，用建造者模式创建。要是还是不懂，你可以理解成，我们常常在写bean类的时候，往往要写set方法，你可以理解成，把set方法写在Builder里面，在Builder里面赋好值之后，在我们bean类的构造方法里面传递过来就可以了。</p><h2 id="五、原型模式"><a href="#五、原型模式" class="headerlink" title="五、原型模式"></a>五、原型模式</h2><p>这个模式，我没用到过，网上搜的是，类似于拷贝功能。可以自行搜索。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;设计模式的分类&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。&lt;/li&gt;
&lt;li&gt;结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -设计模式" scheme="http://haichenyi.com/categories/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
