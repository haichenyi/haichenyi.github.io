<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haichenyi.com/"/>
  <updated>2019-07-31T12:18:30.985Z</updated>
  <id>http://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>dagger2整个流程解析（一）</title>
    <link href="http://haichenyi.com/2019/07/31/dagger2%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/07/31/dagger2整个流程解析（一）/</id>
    <published>2019-07-31T12:17:33.000Z</published>
    <updated>2019-07-31T12:18:30.985Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;众所周知，dagger的入门是比较难的，在嵌入之前，我先说一下这个dagger必要的东西，也是比较常见的东西，几个注解 <strong>@Component</strong>，<strong>@Singleton</strong>，<strong>@Module</strong>，<strong>@Provides</strong>，<strong>@Inject</strong></p><a id="more"></a><p>&emsp;&emsp;<strong>大致的整个流程如下：</strong></p><ol><li>编译的时候，先找构造方法由@Inject标记的类，生成对应的Factory.class类，这个类里面通过new生成对应的对象</li><li>然后，moudle里面，每一个由@Provider标记的方法，都会生成一个对应的Factory.class文件，这里返回的对象，就是刚才由new生成的对象</li><li>最后，我们通过component获取对象的时候，就找moudle去取。moudle取的对象就是之前new生成的</li></ol><p>&emsp;&emsp;<strong>也可以这样理解：</strong></p><ol><li>@Component直到桥梁的作用，告诉application,activity我能给你提供哪些对象</li><li>当Component中返回对象时，它会到@Module中去找这个对象创建没</li><li>@Module中的方法很多，它不可以每个方法的识别一次，它只找@Provider标记的方法</li></ol><p>&emsp;&emsp;<strong>后文的说明都是依赖于<a href="https://github.com/haichenyi/KotlinMvp" target="_blank" rel="noopener">kotlin框架</a></strong></p><p>&emsp;&emsp;这里我拿如下方法来说明整个流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-5848942509707b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图一.png"></p><p>如上图：在AppComponent里面的getSpHelper()方法，返回对象就是SpHelper，前面我们说了，component里面需要的对象要在moudle里面找，moudle里面需要的对象要在@Inject的地方生成，所以，moudle里面也要有对应的方法：如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-ee65722ac7acc82f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图五.png"></p><p>这里的，整个SpHelper是个什么东西呢？参数SpReal又是个什么东西呢？他就是一个sharePreference的接口。SpReal是SpHelper的实现类，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-f93a02df4c98209a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二.png"></p><p>这个就是一个普通的接口，与dagger2搭不上边。我们看他的实现类：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-19f754529d696ff4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图三.png"></p><p>如上图：类SpReal实现SpHelper接口，并且，它的构造方法用@Inject标记了。这里就跟我们的dagger2搭上关系了，我们就需要找SpReal对应的Factory.clss文件。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8557df97bc0e57f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图四.png"></p><p>如上图，SpReal_Factory类有三个方法，两个get()方法返回SpReal对象，静态的newInstance()方法也是返回SpReal对象，静态的create()方法，返回的是当前类的对象。那么，这里的调用顺序是什么呢？</p><p>我们在转过头来看看moudle里面方法对应的Factory：如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-b11fe1ea3fcb642b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图六.png"></p><p>如上图，左边我们看到AppMoudle生成了三个对应的Factory文件，为什么会生成三个？因为，我们的AppMoudle里面有三个方法是用注解@Provides标记的，可以回过头去看一下AppMoudle的内容。</p><p>我们仔细看一下，我们需要的这个类的内容AppModule_ProvideSpHelperFactory，一共有四个方法：一个构造方法，一个get方法，一个create方法，一个provideSpHelper方法。</p><p>是不是很眼熟这个providerSpHelper方法，并且他的返回值也是SpHelper，没错，这个方法就是我们AppMoudle里面定义的方法，在这里生成的对应的方法，它只是参数多了一个AppModule，为什么会多了这个参数呢？带着这个问题，我们看这个方法的实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-197b292b4a70e56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图七.png"></p><p>可以点击跳转这个方法，你会发现，它跳转回我们的AppMoudle方法里面对应的provideSpHelper()方法。回过头来想，我们的AppMoudle就是一个类，里面的provideSpHelper()就是一个普通的方法，怎么调用这个方法呢？就只有用 <strong>对象.方法名()</strong> 调用，所以，这里参数就多加了一个AppMoudle。</p><p>上面解释了为什么多了一个参数，我们再来看一下这个方法的实现。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-ba6cdeaaa4a2c6d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图八.png"></p><p>如上图，就是一个非空判断，如果为空就抛出空指针异常，如果不为空，就返回第一个参数。第一个参数是什么呢？第一个参数，不就是，我们上面说的对象调用方法名么？我们来看一下它这里是怎么实现的。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-9e69d44dfd05c27b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图九.png"></p><p>咦，怎么又返回来了？回到AppMoudle类了，它没有给我们实现啊？我们再想想，首先这个方法，返回的是第一个参数的值，第一个参数又是一个调用我们AppMoudle里面的方法，我们AppMoudle这个方法的返回值，就是这里这个方法的返回值。我们看一下，我们方法的返回值是什么？</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-9e69d44dfd05c27b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十.png"></p><p>我们方法的返回值，不就是传进来的参数么？那我们再看看这里方法传进来的参数是什么？</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-eb0d6d0c5c648f77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十一.png"></p><p>它这里的传的参数，就是这个方法的第二个参数。到这里，我们又断了，依然不知道，这个参数从哪来的。</p><p>冷静下来想一想，调用方法，参数从哪里来？我们从方法里面实现怎么看的到，我们肯定是要在调用方法的地方看。所以，我们就要找到在哪调用这个方法的。既然是写在AppComponent里面，那我们就找他的编译后生成的文件，也就是DaggerAppComponent，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-c3afc3041e959418.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十二.png"></p><p>一眼看过去，这么多东西，怎么看？我又想到，这个DaggerAppComponent类是由AppComponent生成的类，通过上面的判断，这个类里面也应该有我在AppComponent定义的方法的实现才对，搜一下getSpHelper方法，果不其然。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d570e9598aba5e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十三.png"></p><p>如上图，我们可以看到这个方法的实现，类点方法名，说明整个方法是静态的，我们点过去一看。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-9825f1f6dba4e603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十四.png"></p><p>不就是，我们前面说的那个静态方法吗？这样就跟我们前面分析的都串起来了。我们前面的问题是什么？不就是不知道这个方法的第二个参数从哪来的吗？现在，我们看到了，就是在这里new出来的。</p><p>至于第一个参数AppMoudle从哪来的？我们可以接着分析一下。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-c731742fe5d1aa48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十五.png"></p><p>我们可以看到这个appMoudle定义的是一个全局的变量，我们就要找，在哪里初始化的？如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-a156ff943b621cfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十六.png"></p><p>我们发现它是在构造方法里面初始化的，我们就要找在哪里调用的这个构造方法。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-1d5cc745a0c96bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十七.png"></p><p>我们发现，在这个Builder类里面的build()方法调用的这个构造方法，我们就找在哪里调用的这个build()方法。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-1f317b639c2c6082.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十八.png"></p><p>我们发现，是AndroidInjector这个接口里面的抽象Builder类，这个抽象Builder类实现的是AndroidInjector.Factory，我们要找的就是这个create()方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8d816d6035b16ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十九.png"></p><p>所以，这里在我们的Application里面初始化的，也就是我这里的MyApp里面初始化的。这个参数怎么传递的？如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-89398696cffd1c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十.png"></p><p>在create方法里面调用build()之前还调用了seedInstance()方法，这里是抽象类的方法，要想知道这个方法是怎么实现的，那就得看他的实现类。这个Builder<t>的实现类是谁？想一想上面是怎么跳转过来的？不想这个，我们也可以点这个类进行跳转。如下图</t></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8ef9ff91c7c700c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十一.png"></p><p>如上图，我们可以看到有两个地方调用，一个是ActComponent，一个是AppComponent，前面一个是activity相关的，我们还没有说到，我们现在一直说的都是Application相关的。所以，这里跳转的地方，肯定是Application。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-785da091381f46bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十二.png"></p><p>这个方法还过时了，正好，我们这个Builder<t>抽象类还用@Deprecated标记了。诶？那这里还是没有实现啊，这也是一个抽象类。这个是抽象类，AppComponent又是一个接口，所以，我们要找这个AppComponent接口的实现类。如下图：</t></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-f791b0ac17b7937a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十三.png"></p><p>如上图，AppComponent的实现类，就是DaggerAppComponent类。我们在这个类里面找Builder<t>的实现类就可以了。找找找，如下图</t></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d6f726948fd5d5dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十四.png"></p><p>如上图，这里有seedInstance方法和build两个方法，而且都是@Override的，从父类继承过来的，我们在看看AndroidInjector类。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-fcbdcca6f62275f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十五.png"></p><p>正好，它有这两个方法，并且还都是抽象方法。所以，这个类就是它的实现类。所以，调用的seedInstance方法，就是这里的这个方法。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-37db29d8250698ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十六.png"></p><p>这个方法就是做了一个赋值操作，赋值之前做了一个非空检验。所以，在执行build()的时候这个seedInstance对象已经赋值了，不是空。所以这里就走通了。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-a638e6ef80bfdf05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十七.png"></p><p>如上的构造方法就走通了，那么appMoudle就有值了，那么我们前面的问题。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-96c53c9b44324478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十八.png"></p><p>我们之前就是在这里，不知道这个appMoudle是怎么赋值的，这里已经走通了。这就是通过AppComponent过去getSpHelper()的整个流程了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;众所周知，dagger的入门是比较难的，在嵌入之前，我先说一下这个dagger必要的东西，也是比较常见的东西，几个注解 &lt;strong&gt;@Component&lt;/strong&gt;，&lt;strong&gt;@Singleton&lt;/strong&gt;，&lt;strong&gt;@Module&lt;/strong&gt;，&lt;strong&gt;@Provides&lt;/strong&gt;，&lt;strong&gt;@Inject&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="http://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>一场由dagger2引发的一些思考</title>
    <link href="http://haichenyi.com/2019/07/31/%E4%B8%80%E5%9C%BA%E7%94%B1dagger2%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://haichenyi.com/2019/07/31/一场由dagger2引发的一些思考/</id>
    <published>2019-07-31T09:40:23.000Z</published>
    <updated>2019-07-31T09:42:37.760Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;用了好几年的dagger2，从dagger2.android。就只有当时刚开始用dagger的时候深入的了解过，后来就再也没有深入的时候研究过。这几天又研究了一下，做个总结。</p><p>&emsp;&emsp;就拿之前写的<a href="https://github.com/haichenyi/KotlinMvp" target="_blank" rel="noopener">kotlin的框架</a>来说，它用的是dagger2.android。从dagger2.android。最明显的就是，需要我们自己写的东西越来越少了，框架帮我们做的事情越来越多了，以至于，我们对这个过程越来越看不懂了。也就有了我这篇博客。</p> <a id="more"></a><p>先说这嵌入过程吧。</p><h3 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a>1.依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//dagger2_start</span><br><span class="line">def dagger = &quot;2.23.2&quot;</span><br><span class="line">implementation &quot;com.google.dagger:dagger-android:$dagger&quot;</span><br><span class="line">implementation &quot;com.google.dagger:dagger-android-support:$dagger&quot; // if you use the support libraries</span><br><span class="line">kapt &quot;com.google.dagger:dagger-android-processor:$dagger&quot;</span><br><span class="line">implementation &quot;com.google.dagger:dagger:$dagger&quot;</span><br><span class="line">kapt &quot;com.google.dagger:dagger-compiler:$dagger&quot;</span><br><span class="line">//dagger2_end</span><br></pre></td></tr></table></figure><h3 id="2-DaggerApplication"><a href="#2-DaggerApplication" class="headerlink" title="2.DaggerApplication"></a>2.DaggerApplication</h3><p>&emsp;&emsp;新建类AppMoudle，并用注解@Moudle标记，暂时先不添加任何内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">class AppModule &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;新建接口AppComponent，并实现AndroidInjector<t>接口，泛型先空着，添加如下代码：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Singleton</span><br><span class="line">@Component(modules = [AndroidSupportInjectionModule::classAppModule::class])</span><br><span class="line">interface AppComponent : AndroidInjector&lt;MyApp&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Component.Builder</span><br><span class="line">    abstract class Builder : AndroidInjector.Builder&lt;MyApp&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的MyAPP是我们下面新建的Application</p><p>&emsp;&emsp;新建MyApp，继承DaggerApplication并实现它的抽象方法，添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyApp : DaggerApplication() &#123;</span><br><span class="line"></span><br><span class="line">    override fun applicationInjector(): AndroidInjector&lt;out DaggerApplication&gt; =</span><br><span class="line">        DaggerAppComponent.builder().create(this)</span><br><span class="line"></span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个时候，你的项目应该报错，因为你没有DaggerAppComponent这个类，你现在编译一遍，应该就是能生成</p><h3 id="DaggerAppCompatActivity"><a href="#DaggerAppCompatActivity" class="headerlink" title="DaggerAppCompatActivity"></a>DaggerAppCompatActivity</h3><p>&emsp;&emsp;让你的BaseActivity类，继承这个DaggerAppCompatActivity</p><p>&emsp;&emsp;新建ActComponent接口，并且实现AndroidInjector<t>接口，泛型传你的BaseActivity，如下：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Subcomponent(modules = [AndroidSupportInjectionModule::class])</span><br><span class="line">interface ActComponent : AndroidInjector&lt;BaseActivity&lt;BasePresenter&lt;BaseView&gt;&gt;&gt; &#123;</span><br><span class="line">    @Subcomponent.Builder</span><br><span class="line">    abstract class Builder : AndroidInjector.Builder&lt;BaseActivity&lt;BasePresenter&lt;BaseView&gt;&gt;&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;新建AllActivityModule类，添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Module(subcomponents = [ActComponent::class])</span><br><span class="line">abstract class AllActivitiesModule &#123;</span><br><span class="line">    @ContributesAndroidInjector</span><br><span class="line">    internal abstract fun contributeMainActivityInjector(): MainActivity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个MainActivity是你的主页面，并且继承你的BaseActivity。</p><p>&emsp;&emsp;至此，配置就完成了，你就可以像之前一样，用@Inject标记构造方法，然后，定义变量的地方用@Inject就可以直接用了。</p><p><strong>PS:</strong> 我这里用的kotlin，kotlin参数默认是private，dagger2需要参数是public，这里需要加上JvmField注解。并且，要var类型，不能val，因为，val不能二次赋值。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@JvmField</span><br><span class="line">@Inject</span><br><span class="line">var presenter: P? = null</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们之前用dagger2，没有用dagger2.android的时候，application和activity并不是实现的DaggerApplication，DaggerAppCompatActivity这两个，我们做了很多额外的操作，现在，我们都没有做了，为什么一样可以能运行？因为，我们之前做的额外的操作，现在都是这两个继承的类帮我们做了，可以点进去看一下源码。</p><h3 id="引发的思考"><a href="#引发的思考" class="headerlink" title="引发的思考"></a>引发的思考</h3><p>&emsp;&emsp;如标题，引发的思考是什么呢？它这个注解到底是怎么做到的呢？</p><h4 id="问，这里为什么会分AppComponent，ActivityComponent，FragmentComponent，写一个component不好吗？"><a href="#问，这里为什么会分AppComponent，ActivityComponent，FragmentComponent，写一个component不好吗？" class="headerlink" title="问，这里为什么会分AppComponent，ActivityComponent，FragmentComponent，写一个component不好吗？"></a>问，这里为什么会分AppComponent，ActivityComponent，FragmentComponent，写一个component不好吗？</h4><p>&emsp;&emsp;<strong><em>答：</em></strong> 我不知道对不对，我的理解是：与整个APP生命周期同步即放在AppComponent中，与Activity生命周期同步即放在ActComponent中，<br>与Fragment生命周期同步即放在FragComponent中。</p><p>&emsp;&emsp;从这里引申出什么问题呢？那就是生命周期，我的<a href="https://github.com/haichenyi/KotlinMvp" target="_blank" rel="noopener">kotlin框架</a>整个生命周期都有处理，框架的README也有说明。说到生命周期同步，就要说到不同步，不同步造成的结果就是内存泄漏，至于常见的什么情况下回造成内存泄漏我就不说了，想到内存泄漏，就联想到了内存，想到内存，我就想到了内存分配。这就是我想说的，内存分配。</p><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>&emsp;&emsp;说到内存分配，我们就先说三个名词：<strong>栈，堆，方法区</strong></p><ol><li>栈：存放变量的引用</li><li>堆：存放new的对象，堆是最占内存的</li><li>方法区：存储字节码信息(类，方法等等字节码)，常量，静态变量等等。常量池在方法区中</li></ol><p>举个栗子：<strong>String b = new String(“a”)</strong> 和 <strong>String c = “a”</strong>，他们内存是怎么分配的？如图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-73a4d29d6483e6c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存分配1.png"></p><ol><li>等于号左边 <strong>String b，String c</strong>这里的b，c都是引用，所以放在栈中。栈存放引用</li><li>等于号右边，new的过程，就是在堆中创建内存的过程，这里的0x123456789就是我们常说的内存地址</li><li>常量池里面才是放字符串a</li></ol><p>&emsp;&emsp;很多面试题都会出这个问题，<strong>b==c和b.equal(a)</strong> ，他们两个的结果结果都知道，前面是false，后面是true。<strong>==</strong> 比较的是整个对象，而<strong>equals</strong>比较的是值。这里b指向的是堆内存中的地址，这个地址才是指向常量池中的字符串a，而c是直接指向常量池中的字符串a</p><p>&emsp;&emsp;想多说一句就是 <strong>==</strong> 是怎么比较物理地址的呢？通过比较hashCode的值，在java中是获取不到地址的，不过Object中有个identityHashCodeNative方法，它虽然不是地址，但你可以理解为一个地址对应一个值，这个值就能过identityHashCodeNative来获取，具体怎么算了，这是个native方法我们不知道。不过没关系，只要知道一个地址对应一个值就行了，地址相同这个值就相同。而hashCode默认就是返回这个值，那么如果我们重写了hashCode,按我们的规则来写，可以达到不同的地址，hashCode的值相同，从而得到两个不同的地址用==比较是相同的。</p><p>&emsp;&emsp; <strong>PS:</strong> 我们平时说的 <strong><em>把某某对象置为空，释放内存。这种说法是错误的。</em></strong> 比方说这里，b=null，首先，我们只是把某个对象的引用置为空，并不是把某个对象置为空。释放内存，是java的GC回收机制，释放内存，并不是我们释放内存。当GC扫描到，某个对象没有引用指向它了，它就会释放这个对象占用的内存。说到这里，就又想到GC回收机制与强软弱虚四大引用</p><h4 id="GC回收和强软弱虚四大引用"><a href="#GC回收和强软弱虚四大引用" class="headerlink" title="GC回收和强软弱虚四大引用"></a>GC回收和强软弱虚四大引用</h4><p><strong>强软弱虚四大引用</strong></p><p>&emsp;&emsp; 其实我也不知道说啥，就是上面理解了内存分配，这里再看这几句话，应该印象更加深刻一些。</p><ol><li>强引用：不论什么情况下，GC回收机制扫描到强引用，都不会管，如果内存不足，则抛出OOM异常</li><li>软引用(SoftReference)：GC回收机制扫描到软引用时，当内存足够的时候，不会管，当内存不足的时候，则会回收对应内存</li><li>弱引用(WeakReference)：不论什么情况下，只要GC回收机制扫描到弱引用，都会回收对应的内存。</li><li>虚引用(PhantomReference)：顾名思义，形同虚设，前面三种都是与生命周期相关，而虚引用不会决定对象的生命周期，如果，一个对象仅持有虚引用，那这个对象就跟没有引用是一样的，不管什么时候，GC回收机制扫描到了这个对象，都有可能会回收对应的内存。为什么说是有可能呢？虚引用必须和引用队列连用，当GC回收机制扫描到一个对象，并准备回收它的时候，发现它还存在虚引用，那么，GC会把这个虚引用先加入到与它关联的引用队列中。所以，当GC发现一个对象有虚引用，并且，这个虚引用已经存在与之关联的引用队列当中了，就会回收这个对象。</li></ol><p>&emsp;&emsp; GC回收机制判断是否回收内存，都是先判断对象的引用是否存在，引用存放在栈中。</p><p><strong>GC回收机制</strong></p><p>&emsp;&emsp; 说到GC回收机制，就先聊聊JVM堆的相关知识，一说要JAVA虚拟机，那就要聊聊java是跨平台语言了，它是怎么实现跨平台的呢？</p><p>&emsp;&emsp; java程序是跨平台的语言，它是怎么实现跨平台的？</p><p>&emsp;&emsp;java程序依赖于JVM（java虚拟机），java程序必须运行在JVM上，JVM是用C、C++开发的，不同的平台是不同的JVM，但是，不管是什么类型的JVM都能运行java程序，这就是所谓的java跨平台。但是，不同JVM编译java程序生成的字节码是一样的，但是编译生成的机器码是不一样的，所以跨平台的是java程序，而不是编译生成的机器码。</p><p>&emsp;&emsp;JVM堆，也就是我们上面那个图的堆，JVM堆分为三部分</p><ol><li>新域：也就是年轻代，分为三部分，一部分：Eden，另两个部分是辅助空间分别是：From Space，To Space</li><li>旧域：也就是老年代</li><li>永久域：从配置角度看，永久域是独立于JVM的，大小为4M</li></ol><p>&emsp;&emsp;程序员无法手动释放内存，只能释放引用，内存释放只能由GC释放，程序员可以手动触发GC：<strong><em>System.gc()，</em></strong> 或者是当内存不够用的时候，GC会自动启动，或者是APP空闲的时候，也会启动回收机制。</p><p>&emsp;&emsp;GC执行的过程：</p><ol><li>新建的对象都首先存放在Eden中，如果对象太大，可能直接进入老年代，也就是旧域中。</li><li>GC开始执行，都是从Eden或者是From Space把对象copy到To Space中，至于中间的算法，有好几种，标记算法，标记幸存次数，还有复制算法，具体怎么实现的，我不知道。当把对象移动到To Spce之后，此时的To Space变成了From Space，之前的From Space变成了To Space。然后，继续循环</li><li>循环一次次数之后，对象达到了移动到旧域的条件，就把对象移动到旧域。</li><li>最后，GC就会释放旧域的对象所占用的内存</li></ol><p>PS：以上都是个人观点，不保证完全正确，没有漏洞。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;用了好几年的dagger2，从dagger2.android。就只有当时刚开始用dagger的时候深入的了解过，后来就再也没有深入的时候研究过。这几天又研究了一下，做个总结。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;就拿之前写的&lt;a href=&quot;https://github.com/haichenyi/KotlinMvp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kotlin的框架&lt;/a&gt;来说，它用的是dagger2.android。从dagger2.android。最明显的就是，需要我们自己写的东西越来越少了，框架帮我们做的事情越来越多了，以至于，我们对这个过程越来越看不懂了。也就有了我这篇博客。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Tomcat安装与启动</title>
    <link href="http://haichenyi.com/2019/07/25/Tomcat%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
    <id>http://haichenyi.com/2019/07/25/Tomcat安装与启动/</id>
    <published>2019-07-25T12:22:47.000Z</published>
    <updated>2019-07-25T12:51:18.998Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;搭建android框架的时候总是会遇到测试网络请求没有接口的问题，今天就自己搭建一个服务器Tomcat。不用写web项目就能直接获取到数据</p><a id="more"></a><p>&emsp;&emsp;一.Tomcat主页跳转<a href="https://tomcat.apache.org/" target="_blank" rel="noopener">下载</a></p><p>&emsp;&emsp;二.Download——版本(点击)——Binary Distributions——Core——zip(点击)，该版本是解压版，解压就可以用，无需安装。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-00a048db46aed79e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="步骤1.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-2843477983ad2d7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="步骤2.png"></p><p>&emsp;&emsp;三.下载完成之后，我把zip放在Dpan根目录，解压到当前文件夹即可。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-91cbbc3a3c2ef45d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解压.png"></p><p>&emsp;&emsp;四.配置环境变量。两个地方要注意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建环境变量：CATALINA_HOME=D:\apache-tomcat-9.0.22</span><br><span class="line">如下图：</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8258261aaa0caa19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建环境变量.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">修改Path变量：</span><br><span class="line"></span><br><span class="line">%CATALINA_HOME%\lib</span><br><span class="line"></span><br><span class="line">%CATALINA_HOME%\lib\servlet-api.jar</span><br><span class="line"></span><br><span class="line">%CATALINA_HOME%\lib\jsp-api.jar</span><br><span class="line"></span><br><span class="line">把上面三个放在Path后面</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8b6e28c8c5323a3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改path.png"></p><p>&emsp;&emsp;五.添加用户，进入config目录，我这里是D:\apache-tomcat-9.0.22\conf，找到tomcat-users.xml，新增如下用户，我这里把它的注释都去掉了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;tomcat-users xmlns=&quot;http://tomcat.apache.org/xml&quot;</span><br><span class="line">              xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">              xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;</span><br><span class="line">              version=&quot;1.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;role rolename=&quot;manager-wz&quot;/&gt; </span><br><span class="line"></span><br><span class="line">&lt;role rolename=&quot;admin-wz&quot;/&gt;  </span><br><span class="line"></span><br><span class="line">&lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;admin-wz&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;admin&quot; roles=&quot;manager-wz&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/tomcat-users&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;六.进入D:\apache-tomcat-9.0.22\bin目录下，双击<strong>startup.bat</strong>文件，即可启动Tomcat</p><p>&emsp;&emsp;七.浏览器输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080</span><br><span class="line"></span><br><span class="line">http://127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>即可访问主页</p><p>PS:启动的时候控制台中文乱码：找到confi目录下的<strong>logging.properties</strong>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.util.logging.ConsoleHandler.encoding = utf-8</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"></span><br><span class="line">java.util.logging.ConsoleHandler.encoding = GBK</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;八.新建json文件。进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\apache-tomcat-9.0.22\webapps\examples</span><br></pre></td></tr></table></figure><p>新建txt文件，修改内容为json格式的字符串，我这里是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;code&quot;:&quot;200&quot;,&quot;msg&quot;:&quot;请求成功&quot;,&quot;data&quot;:&quot;asdf&quot;&#125;</span><br></pre></td></tr></table></figure><p>修改名字，并且把.txt改成.json</p><p>&emsp;&emsp;九.重启Tomcat，浏览器输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/examples/xxx.json</span><br></pre></td></tr></table></figure><p>即可访问到文件</p><p>&emsp;&emsp;十.手机访问电脑Tomcat</p><ol><li>电脑，手机都连接到同一局域网内</li><li>需要关闭防火墙。需要关闭防火墙。需要关闭防火墙。控制面板–&gt;系统和安全–&gt;Windows防火墙–&gt;启用或关闭Windows防火墙–&gt;关闭</li><li>手机浏览器输入地址：<a href="http://电脑IP地址:8080/，" target="_blank" rel="noopener">http://电脑IP地址:8080/，</a> 即可访问tomcat主页</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;搭建android框架的时候总是会遇到测试网络请求没有接口的问题，今天就自己搭建一个服务器Tomcat。不用写web项目就能直接获取到数据&lt;/p&gt;
    
    </summary>
    
      <category term="Tomcat" scheme="http://haichenyi.com/categories/Tomcat/"/>
    
    
  </entry>
  
  <entry>
    <title>Android开发中的小技巧（持续更新...）</title>
    <link href="http://haichenyi.com/2019/07/25/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/07/25/Android开发中的小技巧（持续更新-）/</id>
    <published>2019-07-25T12:22:29.000Z</published>
    <updated>2019-07-25T12:54:32.183Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;android开发中那些不为人知的小技巧</p><a id="more"></a><h3 id="1-不需要读写权限就可以操作的目录"><a href="#1-不需要读写权限就可以操作的目录" class="headerlink" title="1. 不需要读写权限就可以操作的目录"></a>1. 不需要读写权限就可以操作的目录</h3><p>&emsp;&emsp;一谈起要做文件的读写操作，应在脑海中的就是先申请读写权限，没有读写权限就不让对应的操作。那为什么SP也是把数据存本地，缺不需要读写权限呢？</p><p>&emsp;&emsp;只要是存储在你的APP目录下面，就不需要读写权限。而，手机上面APP目录有两种：一种是手机内部，一种是SD卡目录。怎么获取呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//手机内部：APP目录下默认有两个文件夹，一个是cache，一个是files</span><br><span class="line">//cache目录</span><br><span class="line">cacheDir.absolutePath</span><br><span class="line">//files目录</span><br><span class="line">filesDir.absolutePath</span><br><span class="line">//手机内部的APP目录怎么获取呢？</span><br><span class="line">cacheDir.parent</span><br><span class="line">filesDir.parent</span><br><span class="line"></span><br><span class="line">//手机外部APP目录</span><br><span class="line">//cache目录</span><br><span class="line">externalCacheDir.absolutePath</span><br><span class="line">//APP目录</span><br><span class="line">externalCacheDir.parent</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上这些目录不需要存储权限就可以做操作。但是，在APP卸载的时候，这些数据都会被删除。其他的目录都是需要存储权限的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Environment.getDataDirectory():     /data</span><br><span class="line">Environment.getRootDirectory():    /system</span><br><span class="line">Environment.getDownloadCacheDirectory():     /cache</span><br><span class="line">Environment.getExternalStorageDirectory():   /storage/emulated/0</span><br><span class="line">--------------------- </span><br><span class="line">作者：海晨忆 </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https://blog.csdn.net/qq_27634797/article/details/49495611 </span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上这些目录都需要存储权限。我们可以这样理解：</p><ol><li>只要是通过Context.get能获取到的目录，都不需要存储权限。</li><li>只要是通过Environment.get能获取到的目录，都需要存储权限。</li></ol><h3 id="2-dp转px不需要context也能转"><a href="#2-dp转px不需要context也能转" class="headerlink" title="2. dp转px不需要context也能转"></a>2. dp转px不需要context也能转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回你需要的值：如：这里你传20，单位你传dp，返回值就是你这个手机对应的20dp</span><br><span class="line"> *</span><br><span class="line"> * @param value 数据</span><br><span class="line"> * @param unit  单位：dp为&#123;@link TypedValue#COMPLEX_UNIT_DIP&#125;,</span><br><span class="line"> *              sp为&#123;@link TypedValue#COMPLEX_UNIT_SP&#125;,</span><br><span class="line"> *              px为&#123;@link TypedValue#COMPLEX_UNIT_PX&#125;,</span><br><span class="line"> *              其它请看&#123;@link TypedValue#applyDimension(int, float, DisplayMetrics)&#125;</span><br><span class="line"> * @return 具体长度数值</span><br><span class="line"> */</span><br><span class="line">public static float digitValue(final float value, final int unit) &#123;</span><br><span class="line">    return TypedValue.applyDimension(unit, value, Resources.getSystem().getDisplayMetrics());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>持续更新…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;android开发中那些不为人知的小技巧&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之协程一简单使用</title>
    <link href="http://haichenyi.com/2019/07/16/kotlin%E4%B9%8B%E5%8D%8F%E7%A8%8B%E4%B8%80%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://haichenyi.com/2019/07/16/kotlin之协程一简单使用/</id>
    <published>2019-07-16T10:17:14.000Z</published>
    <updated>2019-07-18T06:41:59.052Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;kotlin协程用于线程切换，kotlin里面不需要new Thread，并且，协程的开销小于new Thread。有三种写法：<strong><em>runBlocking，launch，async</em></strong></p><a id="more"></a><p>既然协程的出现可以取代Thread，我们这里想要验证的是：</p><ol><li>会不会阻塞主线程？</li><li>协程里面的代码是怎么执行的？按顺序执行还是并行?</li><li>协程里面能不能更新页面？</li></ol><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>&emsp;&emsp;协程需要额外依赖一个库协程用于android的库，它会自动依赖官方提供的那个协程的代码库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.0-M2&apos;</span><br></pre></td></tr></table></figure></p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_start&quot;)</span><br><span class="line">            for (i in 0..5) &#123;</span><br><span class="line">                Log.e(&quot;wz&quot;, i.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_end&quot;)</span><br><span class="line">            tvName.text =  &quot;for_end&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, &quot;runBocking外&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="https://upload-images.jianshu.io/upload_images/7041675-e04c10bdd88c256f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="runBlocking.png"></p><p>&emsp;&emsp;从打印顺序上看，runBlocking的执行顺序是从上往下执行的，并且能更新页面。回答上面的三个问题：</p><ol><li>会阻塞线程</li><li>从上往下按顺序执行的</li><li>可以更新页面</li></ol><p>&emsp;&emsp;java里面有Thread，所以线程休眠用Thread.sleep()。kotlin里面既然协程可以取代Thread，所以，kotlin也有自己的休眠方法，也就是上面的delay()，注意，这里delay只能用在协程里面，不能用在外面。</p><h3 id="GlobalScope-launch"><a href="#GlobalScope-launch" class="headerlink" title="GlobalScope.launch"></a>GlobalScope.launch</h3><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_start&quot;)</span><br><span class="line">            for (i in 0..5) &#123;</span><br><span class="line">                Log.e(&quot;wz&quot;, i.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_end&quot;)</span><br><span class="line">            tvName.text =  &quot;for_end&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, &quot;协程外&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-4a79c1067a2b3c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="launch.png"></p><p>&emsp;&emsp;从打印顺序上面看，launch是先执行外面的代码，然后执行协程里面的代码，并且更新了页面。回答上面的三个问题:</p><ol><li>不会阻塞线程</li><li>既然不会阻塞线程，那就是并行的</li><li>能更新页面</li></ol><h3 id="GlobalScope-async"><a href="#GlobalScope-async" class="headerlink" title="GlobalScope.async"></a>GlobalScope.async</h3><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        GlobalScope.async &#123;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_start&quot;)</span><br><span class="line">            for (i in 0..5) &#123;</span><br><span class="line">                Log.e(&quot;wz&quot;, i.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_end&quot;)</span><br><span class="line">            tvName.text =  &quot;for_end&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, &quot;协程外&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-4a79c1067a2b3c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="async.png"></p><p>&emsp;&emsp;从打印顺序上看，跟launch是一样的，并且也更新了页面。所以结论更launch是一样的。</p><p>&emsp;&emsp;都一样的话，那么launch和async有什么区别呢？他们俩的返回值不一样。launch的返回值：Job，而async的返回值：Deferred<t>。async与await()联用。</t></p><p>&emsp;&emsp;Job是一个接口，有join，cancel，cancelAndJoin等等方法，Deferred实现了Job接口。</p><p>&emsp;&emsp;launch和async的区别：launch返回值是job，而async的返回值是：把async的最后一行封装成Deferred返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val job = GlobalScope.launch &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, job.toString())</span><br><span class="line"></span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            val b = GlobalScope.async &#123;</span><br><span class="line">                1111</span><br><span class="line">            &#125;.await()</span><br><span class="line">            Log.e(&quot;wz&quot;, b.toString())</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="async并发"><a href="#async并发" class="headerlink" title="async并发"></a>async并发</h3><p>&emsp;&emsp;我们项目里面有时候会碰到，我们做某个功能的时候，需要拿到两个数据A,B。我们要先算出A，接着算出B，最后，拿到这两个数据再做处理。那么，time(总) = time(A)+time(B)。</p><p>&emsp;&emsp;用async，我们可以怎么处理呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">            measureTimeMillis &#123;</span><br><span class="line">                val n1 = GlobalScope.async &#123; doA() &#125;</span><br><span class="line">                val n2 = GlobalScope.async &#123; doB() &#125;</span><br><span class="line">                val time = n1.await() + n2.await()</span><br><span class="line">                Log.e(&quot;wz&quot;, time.toString())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">suspend fun doA(): Int &#123;</span><br><span class="line">        //做其他操作花费2秒钟</span><br><span class="line">        return 3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">suspend fun doB(): Int &#123;</span><br><span class="line">        //做其他操作花费4秒钟</span><br><span class="line">        return 4</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面，我们得到结论async是不阻塞线程的，所以，doA和doB是同时进行的。当同时获取到A,B的结果所花费的时间，是doA和doB中花费时间长的那一个，所以，这里花费的总时间是4秒钟，而不是6秒</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;kotlin协程用于线程切换，kotlin里面不需要new Thread，并且，协程的开销小于new Thread。有三种写法：&lt;strong&gt;&lt;em&gt;runBlocking，launch，async&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之内部类，匿名内部类与伴生对象</title>
    <link href="http://haichenyi.com/2019/06/14/kotlin%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/"/>
    <id>http://haichenyi.com/2019/06/14/kotlin之内部类，匿名内部类与伴生对象/</id>
    <published>2019-06-14T12:57:56.000Z</published>
    <updated>2019-06-14T12:59:55.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>&emsp;&emsp;kotlin的内部类与java的内部类有点不同<strong><em>java的内部类可以直接访问外部类的成员，kotlin的内部类不能直接访问外部类的成员，必须用inner标记之后才能访问外部类的成员</em></strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AAA&#123;</span><br><span class="line">    var a = 0</span><br><span class="line">    class BBB&#123;</span><br><span class="line">        //此时，BBB类的内部是不能直接用a变量的</span><br><span class="line">        var b = a //编译无法通过</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AAA&#123;</span><br><span class="line">    var a = 0</span><br><span class="line">    inner class BBB&#123;</span><br><span class="line">        //此时，BBB类的内部是可以直接用a变量的</span><br><span class="line">        var b = a //编译可以通过</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>&emsp;&emsp;匿名内部类主要是针对那些获取抽象类或者接口对象而来的。最常见的匿名内部类点击事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//java,匿名内部类的写法</span><br><span class="line">btn.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个是java匿名内部类的写法，kotlin没有new关键字，那么kotlin的匿名内部类该怎么写呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn1.setOnClickListener(object : View.OnClickListener&#123;</span><br><span class="line">            override fun onClick(v: View?) &#123;</span><br><span class="line">                print(&quot;1111&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;方法的参数是一个匿名内部类，先写object:，然后写你的参数类型View.OnClickListener{}，然后编译器会出提示，让你补齐即可。</p><p>&emsp;&emsp;kotlin还有一个写法<strong>lambda 表达式</strong>，非常之方便，这个是java，jdk1.8里面包含的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn1.setOnClickListener &#123; print(&quot;1111&quot;) &#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式-object"><a href="#单例模式-object" class="headerlink" title="单例模式(object)"></a>单例模式(object)</h3><p>&emsp;&emsp;说道这个object就让我想到了kotlin里面的单例模式，kotlin里面用object标记的类，默认在初始化时候自己生成单例，这也是为什么我们再混合开发的时候，java里面调用会有INSTANCE这个东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object AAA&#123;</span><br><span class="line">    var a = 10</span><br><span class="line">    fun getName() : String&#123;</span><br><span class="line">        return &quot;海晨忆&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个类AAA，默认就有单例，所以可以直接AAA.getName()，这样调用方法。AAA.a这样直接使用变量，混合模式的时候，我们的调用方式是”AAA.INSTANCE.getName()”</p><p>&emsp;&emsp;我们java里面写的工具类都是用static表示，kotlin里面就不需要，直接把你的工具类的class表示换成object，然后在这个工具类里面正常写方法，就可以直接用<strong>类.方法</strong>调用，常量也是一样的</p><h3 id="伴生对象-companion-object"><a href="#伴生对象-companion-object" class="headerlink" title="伴生对象(companion object)"></a>伴生对象(companion object)</h3><p>&emsp;&emsp;伴生对象对应的java里面的就是一个类中的静态变量，静态方法。但是，这里编译之后对应的java文件，并不是静态的，而是通过单例调用的。伴生对象的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class SecondActivity : AppCompatActivity() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        var c: Int = 10</span><br><span class="line"></span><br><span class="line">        fun getName(): String &#123;</span><br><span class="line">            return c.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        class CCC &#123;</span><br><span class="line">            var d: Int = 11</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//在其他位置的调用方式：</span><br><span class="line">SecondActivity.c</span><br><span class="line">SecondActivity.getName()</span><br><span class="line">SecondActivity.Companion.CCC().d</span><br></pre></td></tr></table></figure><h3 id="object，companion-object，扩展方法的区别"><a href="#object，companion-object，扩展方法的区别" class="headerlink" title="object，companion object，扩展方法的区别"></a>object，companion object，扩展方法的区别</h3><p>&emsp;&emsp;昨天写的<strong>扩展方法</strong>，我们说到，它编译之后对应的java文件生成的方法都加上了<strong>final static</strong>，所以，我们说它是静态的。</p><p>&emsp;&emsp;今天的这两个<strong>object和伴生对象</strong>，通过查看它编译之后的java文件，他的属性，方法都是加了<strong>final</strong>，并没有static，但是，<strong><em>object标识的类在初始化的时候生成了final static类型的INSTANCE变量 ，伴生对象在初始化的时候生成了final static类型的Companion变量</em></strong></p><p><strong>PS:最好写个demo看一下对应的java文件，印象深刻，查看方式：Tools –&gt; Kotlin –&gt; Show Kotlin ByteCodes</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;kotlin的内部类与java的内部类有点不同&lt;strong&gt;&lt;em&gt;java的内部类可以直接访问外部类的成员，kotlin的内部类不能直接访问外部类的成员，必须用inner标记之后才能访问外部类的成员&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之扩展方法</title>
    <link href="http://haichenyi.com/2019/06/14/kotlin%E4%B9%8B%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/"/>
    <id>http://haichenyi.com/2019/06/14/kotlin之扩展方法/</id>
    <published>2019-06-14T12:57:34.000Z</published>
    <updated>2019-06-14T12:59:06.644Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;kotlin的扩展方法类似于java工具类，但是又优于java的工具类。</p><a id="more"></a><h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>&emsp;&emsp;扩展方法的写法，<strong><em>新建一个File类型的kt文件，不是Class类型，不是Interface类型，不是枚举类型，不是Object类型，就是File类型</em></strong></p><p>&emsp;&emsp;然后直接定义方法，跟kotlin定义方法相同，需要什么方法就定义什么方法，唯一的区别就是在方法名的前面可以加上”类型.”，格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//类型可以省略，即任意类型</span><br><span class="line">fun 类型.方法名(参数...):返回值&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//两个数相加，任意类型都可以调用</span><br><span class="line">fun add(a: Int, b: Int): Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//加载图片，只有ImageView类型可以调用</span><br><span class="line">fun ImageView.loadUrl(imgUrl: String) &#123;</span><br><span class="line">    Glide.with(this.context).load(imgUrl).into(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.aloe.mykotlin</span><br><span class="line"></span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.support.v7.app.AppCompatActivity</span><br><span class="line">import kotlinx.android.synthetic.main.activity_second.*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SecondActivity : AppCompatActivity()&#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_second)</span><br><span class="line">        val a = 1</span><br><span class="line">        val b = 2</span><br><span class="line">        //调用两个数相加</span><br><span class="line">        add(a, b)</span><br><span class="line">        //调用加载图片</span><br><span class="line">        img.loadUrl(&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是：</p><ol><li>如果方法没有加类型，就是随便什么类型都能调用，就是只要是项目在内的其他任意地方都可以调用这个方法</li><li>第二个是ImageView类型才能调用，要记得是变量调用，而不是类型调用，变量调用方法。就像我这里的img变量，就是ImageView类型的</li><li>写法我们都知道用Glide加载图片，最后into方法传递的是一个ImageView类型的view，我上面写的this，这里的this就是指的是当前方法前面类型的变量，也就是这里的ImageView类型的变量，也就是我们调用的时候的img变量</li><li>扩展方法，其实最后生成java文件的时候，就是在方法的前面加上了static final ，没什么神奇的，最后跟我们java里面工具类的原理是一样的。</li></ol><h3 id="Activity间的跳转"><a href="#Activity间的跳转" class="headerlink" title="Activity间的跳转"></a>Activity间的跳转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(Intent(this@MainActivity,SecondActivity::class.java))</span><br></pre></td></tr></table></figure><h3 id="密封类sealed"><a href="#密封类sealed" class="headerlink" title="密封类sealed"></a>密封类sealed</h3><p>&emsp;&emsp;java中没有密封类的概念，这个是kotlin独有的，他能使我们的代码更加安全。</p><p>&emsp;&emsp;kotlin的类默认是final，不能被继承，sealed修饰的类可以被继承，因为它修饰的是open，这里只是把open隐藏了。</p><p>&emsp;&emsp;为什么说它能使我们的代码更加安全呐？举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lateinit var obj : Any</span><br><span class="line">var b = when(obj)&#123;</span><br><span class="line">    1 -&gt; 2</span><br><span class="line">    is String -&gt; 3</span><br><span class="line">    3,4 -&gt; &quot;obj等于3或者等于4&quot;</span><br><span class="line">    in 10..20 -&gt; &quot;obj在10到20之间&quot;</span><br><span class="line">    else -&gt; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个是我们之前说过的when的表达式，我们之前讲过when表达式最后必须要加else，不然编译通过不了。或者你能保证else前面的条件语句包括else条件的情况，那就不用加。一般情况下，我们都加else。我们看一下下面这个写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sealed class AAA &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BBB : AAA() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CCC : AAA() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun QQQ(aaa: AAA): Int =</span><br><span class="line">        when (aaa) &#123;</span><br><span class="line">            is BBB -&gt; 10</span><br><span class="line"></span><br><span class="line">            is CCC -&gt; 11</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们这里类AAA是用sealed标识的，类BBB,CCC都继承AAA。我们方法QQQ需要传递一个AAA对象，里面用when做判断，这里就不需要加else，因为这里的条件只有两种，一种是类BBB,一种是类CCC，没有第三种。如果AAA，没有用sealed标识，这里还可以加其他条件，编译都可以通过，因为判断不出来，所以，代码就不安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;kotlin的扩展方法类似于java工具类，但是又优于java的工具类。&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之构造函数(constructor)</title>
    <link href="http://haichenyi.com/2019/06/12/kotlin%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-constructor/"/>
    <id>http://haichenyi.com/2019/06/12/kotlin之构造函数-constructor/</id>
    <published>2019-06-12T14:27:43.000Z</published>
    <updated>2019-06-12T14:29:05.172Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;java中的构造函数是与类名相同即可，kotlin里面的构造函数是用constructor关键字表示。</p><a id="more"></a><p>&emsp;&emsp;kotlin里面的构造函数分为主构造函数和次构造函数。<strong>主构造函数只能有一个，次构造函数个数不限制，可以有一个或者多个</strong></p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>&emsp;&emsp;啥是主构造方法？啥是次构造方法呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//主构造方法如下，跟在类名后面</span><br><span class="line">class Person constructor(name:String)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person constructor()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//当主构造方法没有任何注解或者可见性修饰符时，可以省略，写成下面这样</span><br><span class="line">class Person &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这种就是有注解标记的主构造方法，不能省略</span><br><span class="line">class Person @Inject internal constructor()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//次构造方法，一个无参的次构造方法，一个有一个参数的次构造方法</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    constructor(name:String)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到主构造方法是没有方法体的，那么，我们需要初始化的数据应该放到哪呢？kotlin提供了init方法，给我们初始化数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor()&#123;</span><br><span class="line">    init&#123;</span><br><span class="line">        print(&quot;111&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        println()</span><br><span class="line">        print(&quot;222&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person()</span><br><span class="line">//这里我们会看到打印台打印:111，换行打印222</span><br><span class="line">//这里构造方法是按顺序执行的</span><br><span class="line">//我都是自己写代码跑的结果，不想贴图了，自己写了跑一边，印象会更加深刻</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么，问题来了，次构造方法有方法体，会执行这个init模块吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        println()</span><br><span class="line">        print(&quot;111&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        print(&quot;222&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里我们会看到打印台打印:222，换行打印111</span><br></pre></td></tr></table></figure><p>结论：<strong><em>不管是什么构造方法，先执行init模块逻辑，后执行构造方法的逻辑</em></strong></p><h3 id="this，super"><a href="#this，super" class="headerlink" title="this，super"></a>this，super</h3><p>&emsp;&emsp;简单的说一下继承,this和super两个关键字，跟java差不多；</p><p>&emsp;&emsp;this是调用自己的，super是调用父类的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">open class AAA &#123;</span><br><span class="line">        constructor(name: String) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;$name A&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        constructor(name: String, age: Int) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;我是AAA的两个参数的构造方法&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        init &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;222&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class BBB : AAA &#123;</span><br><span class="line">        constructor(name: String) : this(name, 0) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;我是BBB的一个参数的构造方法&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        constructor(name: String, age: Int) : super(name, age) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;我是BBB的两个参数的构造方法&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var b = BBB(&quot;小王&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;类BBB继承类AAA，其中BBB分别有一个参数的构造方法和两个参数的构造方法；一个参数的构造方法用的this关键字调用自己的两个参数的构造；而两个参数的构造方法用的super关键字调用的父类两个参数的构造方法；这里控制台打印的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">222</span><br><span class="line">我是AAA的两个参数的构造方法</span><br><span class="line">我是BBB的两个参数的构造方法</span><br><span class="line">我是BBB的一个参数的构造方法</span><br></pre></td></tr></table></figure><h3 id="重写set-get方法"><a href="#重写set-get方法" class="headerlink" title="重写set/get方法"></a>重写set/get方法</h3><p>说到了这个类，讲一下怎么重写属性的set/get方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">open class Person &#123;</span><br><span class="line">        var name: String = &quot;&quot;</span><br><span class="line">            set(value) &#123;</span><br><span class="line">                field = value + &quot;www&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            get() &#123;</span><br><span class="line">                return field + &quot;zzz&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        var age: Int = 0</span><br><span class="line">            set(value) &#123;</span><br><span class="line">                field = if (value &gt;= 20) 20 else value</span><br><span class="line">            &#125;</span><br><span class="line">            get() &#123;</span><br><span class="line">                return field * 2</span><br><span class="line">            &#125;</span><br><span class="line">        var address: String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里一个person类，里面有三个属性：name，age，address；在name和age下面分别写了set，get方法，address没写。</p><p><strong>重点：</strong></p><ol><li>你想重写哪个属性的set，get方法，就在哪个属性下方写set，get方法，不用成对出现，可以只重写set方法，也可以只重写get方法</li><li>用field表示你想要的值</li></ol><p>&emsp;&emsp;这里，我就只重写了name和age的set，get方法，没有重写address的set，get方法</p><p>&emsp;&emsp;这里，我再存名字的时候在名字的后面加上了www，在获取的时候又加上了zzz，也就是说，如果你这里name传的是”小王”，那么你用get方法取到的name的值应该是”小王wwwzzz”</p><p>&emsp;&emsp;存age的时候，自己分析一下吧，很简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;java中的构造函数是与类名相同即可，kotlin里面的构造函数是用constructor关键字表示。&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之扩展函数let，run，also，apply</title>
    <link href="http://haichenyi.com/2019/06/11/kotlin%E4%B9%8B%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0let%EF%BC%8Crun%EF%BC%8Calso%EF%BC%8Capply/"/>
    <id>http://haichenyi.com/2019/06/11/kotlin之扩展函数let，run，also，apply/</id>
    <published>2019-06-11T14:33:50.000Z</published>
    <updated>2019-06-11T14:46:13.881Z</updated>
    
    <content type="html"><![CDATA[<p>举个例子</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">open class Person &#123;</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">    var age: Int = 0</span><br><span class="line">    var address: String = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    override fun toString(): String &#123;</span><br><span class="line">        return &quot;Person($name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;新建一个Person类，有三个属性，重写了toString方法。</p><p>&emsp;&emsp;这里有个关键字open，只有用open标识的类才能被继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var person1 = Person().let &#123;</span><br><span class="line">    it.name = &quot;张三let&quot;</span><br><span class="line">    it.age = 24</span><br><span class="line">    it.address = &quot;浦东新区&quot;</span><br><span class="line">    10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log.v(&quot;wz&quot;, person1.toString())//10</span><br><span class="line">var person2 = Person().run &#123;</span><br><span class="line">    this.name = &quot;张思run&quot;</span><br><span class="line">    this.age = 25</span><br><span class="line">    this.address = &quot;青浦区&quot;</span><br><span class="line">    20</span><br><span class="line">&#125;</span><br><span class="line">Log.v(&quot;wz&quot;, person2.toString())//20</span><br><span class="line"></span><br><span class="line">var person3 = Person().also &#123;</span><br><span class="line">    it.name = &quot;张武also&quot;</span><br><span class="line">    it.age = 26</span><br><span class="line">    it.address = &quot;黄浦区&quot;</span><br><span class="line">    30</span><br><span class="line">&#125;</span><br><span class="line">Log.v(&quot;wz&quot;,person3.toString())//Person(张武also)</span><br><span class="line"></span><br><span class="line">var person4 = Person().apply &#123;</span><br><span class="line">    this.name = &quot;张柳apply&quot;</span><br><span class="line">    this.age = 27</span><br><span class="line">    this.address = &quot;崇明区&quot;</span><br><span class="line">    40</span><br><span class="line">&#125;</span><br><span class="line">Log.v(&quot;wz&quot;,person4.toString())//Person(张柳apply)</span><br></pre></td></tr></table></figure><p>上面打印的结果：</p><pre><code>person1——let——10person2——run——20person3——also——Person(张武also)person4——apply——Person(张柳apply)</code></pre><p>总结：</p><ol><li>let,run以最后一行的结果为返回值；also,apply返回对象本身。</li><li>在他们的方法体中，let,also用it代指本身；run,apply用this代指本身。</li></ol><p>PS:充分了解他们的用法，以及返回值的区别，可以实现链式调用实现功能模块，使代码清晰，一目了然。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;举个例子&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之基础</title>
    <link href="http://haichenyi.com/2019/06/11/kotlin%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://haichenyi.com/2019/06/11/kotlin之基础/</id>
    <published>2019-06-11T14:33:36.000Z</published>
    <updated>2019-06-11T14:43:21.986Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;自从18年上一家公司用kotlin做了项目之后，新公司就没有用过kotlin了，都快要忘完了，最近又想起来了，再捡了一下吧。</p><a id="more"></a><h3 id="定义变量的方式"><a href="#定义变量的方式" class="headerlink" title="定义变量的方式"></a>定义变量的方式</h3><p>&emsp;&emsp;java：类型+变量名+值+逗号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;kotlin：var/val+变量名+(:类型)+值(ps:类型可省略)</p><p>&emsp;&emsp;var：可变变量（可以重新分配值）</p><p>&emsp;&emsp;val：只读变量（初始化的时候必须赋值，不能修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var c:int</span><br><span class="line">    c = 5</span><br><span class="line">var c = 5    </span><br><span class="line">val b = 5</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>&emsp;&emsp;java：public/private/protected+返回类型+方法名+括号参数+大括号方法体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void add(int a ,int b)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public int add1(int a,int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;kotlin：fun+方法名+括号参数+(:返回类型)+大括号方法体</p><p>&emsp;&emsp;返回类型Unit类型，对应java的void，即无返回值，可省略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun add(a:int,b:int):Unit&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun add(a:int,b:int)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun add1(a:int,b:int):int&#123;</span><br><span class="line">  return a+b  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if表达式-java中三目运算符"><a href="#if表达式-java中三目运算符" class="headerlink" title="if表达式(java中三目运算符)"></a>if表达式(java中三目运算符)</h3><p>&emsp;&emsp;把a和b两个数中值大的赋值给c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java：三目运算符</span><br><span class="line">int c = a &gt; b ? a : b</span><br><span class="line">kotlin：if表达式</span><br><span class="line">val c = if( a &gt; b) a else b</span><br></pre></td></tr></table></figure></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//java</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">list.add(&quot;b&quot;);</span><br><span class="line">list.add(&quot;c&quot;);</span><br><span class="line">list.add(&quot;d&quot;);</span><br><span class="line">for (int j = 0; j &lt;= list.size(); j++) &#123;</span><br><span class="line">    Log.v(&quot;wz&quot;, list.get(j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//kotlin</span><br><span class="line">val list = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)</span><br><span class="line">for(item in list)&#123;</span><br><span class="line">    Log.v(&quot;wz&quot;,item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上面这个for循环等同于forEach</span><br><span class="line"></span><br><span class="line">list.forEach&#123;</span><br><span class="line">    Log.v(&quot;wz&quot;,it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上面两种循环拿不到下标</span><br><span class="line"></span><br><span class="line">for(index in list.indices)&#123;</span><br><span class="line">    //美元符号的用法见后面</span><br><span class="line">    Log.v(&quot;wz&quot;,&quot;第$index 个item的值是$&#123;list[index]&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//上面这种就可以拿到for循环的下标</span><br><span class="line">//kotlin中String类型的变量也可以for循环遍历每一个char的值</span><br></pre></td></tr></table></figure><h3 id="美元符号"><a href="#美元符号" class="headerlink" title="美元符号($)"></a>美元符号($)</h3><p>&emsp;&emsp;把$符号放在变量前面，输出的就是变量的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val i = 3</span><br><span class="line">Log.v(&quot;wz&quot;,&quot;i的值是：$i&quot;)</span><br><span class="line">//输出的是：i的值是：3</span><br><span class="line"></span><br><span class="line">Log.v(&quot;wz&quot;,&quot;i的值是：$3&quot;)</span><br><span class="line">//输出的是：i的值是：$3</span><br></pre></td></tr></table></figure></p><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="== 和 ===的区别"></a>== 和 ===的区别</h3><p>&emsp;&emsp;类似于java中的==和equals的区别</p><p>&emsp;&emsp;java：==判断值是否相等，equals判断物理地址是否相等</p><p>&emsp;&emsp;kotlin：==判断物理地址是否相等，===判断值是否相等</p><h3 id="数据类型的转换-toInt-toBoolean-等等"><a href="#数据类型的转换-toInt-toBoolean-等等" class="headerlink" title="数据类型的转换:toInt(),toBoolean()等等"></a>数据类型的转换:toInt(),toBoolean()等等</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//java中不同数据类型的相互转换是强转</span><br><span class="line">String s = &quot;1&quot;;</span><br><span class="line">int a = (int)s;</span><br><span class="line"></span><br><span class="line">//kotlin中没有强转提供了转换的方法</span><br><span class="line">var s = &quot;1&quot;</span><br><span class="line">var a = s.toInt()</span><br><span class="line">var a1 = s.toBoolean()</span><br></pre></td></tr></table></figure><h3 id="is运算符"><a href="#is运算符" class="headerlink" title="is运算符"></a>is运算符</h3><p>&emsp;&emsp;个人觉得is运算符类似于java中的instanceof关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//java：判断某个变量是否是某个类型的</span><br><span class="line">String s = &quot;1&quot;;</span><br><span class="line">if(s instanceof String)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//kotlin：判断某个变量是否是某个类型</span><br><span class="line">var s = &quot;1&quot;</span><br><span class="line">if(s is String)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//既然上面说了is是个运算符，运算符当然可以加非</span><br><span class="line">if(s !is String)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="空指针和lateinit"><a href="#空指针和lateinit" class="headerlink" title="空指针和lateinit"></a>空指针和lateinit</h3><p>&emsp;&emsp;要明确一点：java中才会有空指针异常，kotlin中不存在空指针异常，因为它有非空判断机制</p><p>&emsp;&emsp;比方说，我们如果要在kotlin定义一个Bitmap变量，我们知道Bitmap是非常占内存的，用完之后我们要手动置空</p><p>&emsp;&emsp;在类型的后面加上问号，用的时候也要加问号才能用，表示不为空的时候才会往下走，如果为空就不会往下走了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var bitmap:Bitmap? = null</span><br><span class="line">var w = bitmap?.width</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么，我们如果要定义一个不可能为空的对象怎么定义呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lateinit var bitmap:Bitmap</span><br><span class="line">bitmap.width</span><br></pre></td></tr></table></figure><h3 id="黑科技：when表达式和Any-任意类型"><a href="#黑科技：when表达式和Any-任意类型" class="headerlink" title="黑科技：when表达式和Any(任意类型)"></a>黑科技：when表达式和Any(任意类型)</h3><p>&emsp;&emsp;when表达式取代java中的switch，when的返回值依据每一个条件的返回值来定，可以返回任意类型，从上往下按顺序执行，else不能少</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lateinit var obj : Any</span><br><span class="line">var b = when(obj)&#123;</span><br><span class="line">    1 -&gt; 2</span><br><span class="line">    is String -&gt; 3</span><br><span class="line">    3,4 -&gt; &quot;obj等于3或者等于4&quot;</span><br><span class="line">    in 10..20 -&gt; &quot;obj在10到20之间&quot;</span><br><span class="line">    else -&gt; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比方说这里，先定义个可以是任意类型变量的的obj，如果传进来的是Int类型的1，则返回int类型的2。如果传进来的是String类型的变量，则返回int类型的3。其他，则返回boolean类型的true</p><p>&emsp;&emsp;when可以取代 if-else if链。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val x = 10</span><br><span class="line">when &#123;</span><br><span class="line">    x &lt; 10 -&gt; &quot;x小于10&quot;</span><br><span class="line">    x in 10..20 -&gt; &quot;x在10到20之间&quot;</span><br><span class="line">    x in 21..40 -&gt; &quot;x在21到40之间&quot;</span><br><span class="line">    else -&gt; &quot;x大于40&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><p>&emsp;&emsp;顾名思义：在某个范围内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//等同于 x &gt;= 1 &amp;&amp; x &lt;= 4(包括1，包括4)，从1到4</span><br><span class="line">x in 1..4 //1，2，3，4</span><br><span class="line"></span><br><span class="line">//等同于 x &gt;= 1 &amp;&amp; x &lt; 4(包括1，不包括4)，从1到4</span><br><span class="line">x in 1 until 4 //1，2，3</span><br><span class="line"></span><br><span class="line">//包括1，包括4 ，从4到1</span><br><span class="line">x in 4 downTo 1 //4，3，2，1</span><br><span class="line"></span><br><span class="line">//从1到8，每隔两个循环一次，也就是1，3，5，7</span><br><span class="line">i in 1..8 step 2</span><br><span class="line"></span><br><span class="line">//从8到1，每隔两个循环一次，也就是8，6，4，2</span><br><span class="line">i in 8 downTo 1 step 2</span><br><span class="line"></span><br><span class="line">//从8到1，每隔两个，并且要满足能整除3的，这里就是6</span><br><span class="line">i in (8 downTo 1 step 2).filter &#123; it % 3 == 0 &#125;</span><br><span class="line">//上面的关键字filter，还有map等，用过RxJava的应该很眼熟</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;自从18年上一家公司用kotlin做了项目之后，新公司就没有用过kotlin了，都快要忘完了，最近又想起来了，再捡了一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>Android——Tensorflow-Lite简单使用</title>
    <link href="http://haichenyi.com/2019/06/11/Android%E2%80%94%E2%80%94Tensorflow-Lite%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://haichenyi.com/2019/06/11/Android——Tensorflow-Lite简单使用/</id>
    <published>2019-06-11T14:33:16.000Z</published>
    <updated>2019-06-11T14:40:00.369Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;项目里面用到了tflite，用于做简单的图片处理，不是判断图片是什么类型，就是传进去图片，生成新图片，类似于前面一篇讲的GPUImage的滤镜功能，但是比滤镜功能更加强大。</p><a id="more"></a><p>&emsp;&emsp;我这里要做的就是集成，拿人家训练好的模型直接来用，我不用去训练模型。</p><h3 id="第一步-依赖"><a href="#第一步-依赖" class="headerlink" title="第一步 依赖"></a>第一步 依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//依赖库</span><br><span class="line">implementation &apos;org.tensorflow:tensorflow-lite:0.0.0-nightly&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ···</span><br><span class="line">    //set no compress models</span><br><span class="line">    aaptOptions &#123;</span><br><span class="line">        noCompress &quot;tflite&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步-加载训练模型"><a href="#第二步-加载训练模型" class="headerlink" title="第二步 加载训练模型"></a>第二步 加载训练模型</h3><p>&emsp;&emsp;网上很多介绍资料都是把训练模型直接copy到项目main目录下的assets目录（不存在就创建）与java目录平级，自然，这样的加载方式就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// load infer model</span><br><span class="line">    private void loadModel(String model) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            tflite = new Interpreter(loadModelFile(model));</span><br><span class="line">            Log.d(TAG, model + &quot; model load success&quot;);</span><br><span class="line">            tflite.setNumThreads(4);</span><br><span class="line">            load_result = true;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            Log.d(TAG, model + &quot; model load fail&quot;);</span><br><span class="line">            load_result = false;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Memory-map the model file in Assets.</span><br><span class="line">     */</span><br><span class="line">    private MappedByteBuffer loadModelFile(String model) throws IOException &#123;</span><br><span class="line">        AssetFileDescriptor fileDescriptor = getApplicationContext().getAssets().openFd(model + &quot;.tflite&quot;);</span><br><span class="line">        FileInputStream inputStream = new FileInputStream(fileDescriptor.getFileDescriptor());</span><br><span class="line">        FileChannel fileChannel = inputStream.getChannel();</span><br><span class="line">        long startOffset = fileDescriptor.getStartOffset();</span><br><span class="line">        long declaredLength = fileDescriptor.getDeclaredLength();</span><br><span class="line">        return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个tflite文件就好几M，甚至十几M，全部copy到项目里面不显示，所以，我们一般项目里面用都是先下载，然后再使用，那，这样的方式，我们要怎么加载训练模型呢？</p><p>&emsp;&emsp;我们先分析一下再assets目录下面怎么加载的？说白了就是新建一个Interpreter对象，就是加载模型。上面的方法都过时了，我们可以找到Interpreter类，里面你会看到如下的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数传tflite文件，第二个参数传一个Interpreter静态内部类对象</span><br><span class="line">public Interpreter(@NonNull File modelFile, Interpreter.Options options) &#123;</span><br><span class="line">        this.wrapper = new NativeInterpreterWrapper(modelFile.getAbsolutePath(), options);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">//所以，我们自己项目里面加载模型，用如下方式即可</span><br><span class="line">Interpreter.Options options = new Interpreter.Options();</span><br><span class="line">options.setNumThreads(4);</span><br><span class="line">tflite = new Interpreter(new File(&quot;&quot;), options);</span><br></pre></td></tr></table></figure><h3 id="第三步-执行run方法"><a href="#第三步-执行run方法" class="headerlink" title="第三步 执行run方法"></a>第三步 执行run方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tflite.run(in, out);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过执行这个run方法，获取我们需要的东西，第一个参数，输入对象，第二个参数，输出参数。</p><p><strong><em>重点，敲黑板</em></strong></p><p><strong><em>重点，敲黑板</em></strong></p><p><strong><em>重点，敲黑板</em></strong></p><p>&emsp;&emsp;重点就在这里，这里的输入和输出参数要怎么传？我这里训练模型是用Python做的，它需要传入一个四维数组，所以，输出我们自然也要用一个四维数组接收。</p><p>&emsp;&emsp;这里的四维数组怎么传递呐？就要说到Android里面的bitmap知识了，它的每个像素点都是一个ARGB数组。即透明度，红色，绿色，蓝色。我们前面的灰色滤镜之类的东西，实际上就是改变RGB三原色的值，让颜色变成灰色，然后改变亮度之类的就是改变每个管道的透明度。网上有很多这样的知识。</p><p>&emsp;&emsp;再来说说这个四维数组，我项目里面用到的这个四维数组：<strong><em>1 X 256 X 256 X 3</em></strong>，这几个值怎么理解呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：表示一张图片</span><br><span class="line"></span><br><span class="line">256X256：表示图片的宽高</span><br><span class="line"></span><br><span class="line">3：表示RGB色值</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那我们怎么把bitmap对象，转换成我们需要的四维数组呐？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//定义了一个一维数组，里面就是我们需要的参数，便于修改</span><br><span class="line">private int[] ddims = &#123;1, 256, 256, 3&#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取图片的四维数组</span><br><span class="line">     * @param bitmap bitmap对象</span><br><span class="line">     * @param ddims 参数数组</span><br><span class="line">     * @return 图片四维数组</span><br><span class="line">     */</span><br><span class="line">public float[][][][] getScaledMatrix(Bitmap bitmap, int[] ddims) &#123;</span><br><span class="line">        //新建一个1*256*256*3的四维数组</span><br><span class="line">        float[][][][] inFloat = new float[ddims[0]][ddims[1]][ddims[2]][ddims[3]];</span><br><span class="line">        //新建一个一维数组，长度是图片像素点的数量</span><br><span class="line">        int[] pixels = new int[ddims[1] * ddims[2]];</span><br><span class="line">        //把原图缩放成我们需要的图片大小</span><br><span class="line">        Bitmap bm = Bitmap.createScaledBitmap(bitmap, ddims[1], ddims[2], false);</span><br><span class="line">        //把图片的每个像素点的值放到我们前面新建的一维数组中</span><br><span class="line">        bm.getPixels(pixels, 0, bm.getWidth(), 0, 0, ddims[1], ddims[2]);</span><br><span class="line">        int pixel = 0;</span><br><span class="line">        //for循环，把每个像素点的值转换成RBG的值，存放到我们的目标数组中</span><br><span class="line">        for (int i = 0; i &lt; ddims[1]; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; ddims[2]; ++j) &#123;</span><br><span class="line">                final int val = pixels[pixel++];</span><br><span class="line">                float red = ((val &gt;&gt; 16) &amp; 0xFF);</span><br><span class="line">                float green = ((val &gt;&gt; 8) &amp; 0xFF);</span><br><span class="line">                float blue = (val &amp; 0xFF);</span><br><span class="line">                float[] arr = &#123;red, green, blue&#125;;</span><br><span class="line">                inFloat[0][i][j] = arr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bm.isRecycled()) &#123;</span><br><span class="line">            bm.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        return inFloat;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面代码注释写的很清楚了吧？每一行都有注释，for循环的作用也标的很清楚，通过这个方法，我们得到的就是我们想要的四维数组了，这里的四维数组的格式，图片的大小，都是tflite文件建模型的时候设置好的，看你们训练模型的工程师是怎么定义的，你就怎么传。</p><p>&emsp;&emsp;然后，新建一个一模一样格式的数组去接收输出值，也是一个四维数组，那么，我们怎么把这个四维数组转换成我们需要的bitmap呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//创建bitmap的方法，</span><br><span class="line">Bitmap.createBitmap(@NonNull @ColorInt int[] colors,</span><br><span class="line">            int width, int height, Config config);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就是这个方法，传一个一维颜色数组，图片的宽高，还有一个图片的格式，那我们这里就是要把这个四维数组转成一个一维的颜色数组了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 四维数组转成bitmap对象</span><br><span class="line"> * @param outArr 数组</span><br><span class="line"> * @param ddims 格式</span><br><span class="line"> * @return bitmap</span><br><span class="line"> */</span><br><span class="line">public Bitmap getBitmap(float[][][][] outArr, int[] ddims) &#123;</span><br><span class="line">    //获取图片的三维数组</span><br><span class="line">    float[][][] temp = outArr[0];</span><br><span class="line">    int n = 0;</span><br><span class="line">    //新建一个接收的颜色数组，长度就是图片的宽高之积，类似于上面的像素那个数组</span><br><span class="line">    int[] colorArr = new int[ddims[1] * ddims[2]];</span><br><span class="line">    //for循环遍历把图片的ARGB色值转成一个颜色值，放入颜色数组中</span><br><span class="line">    for (int i = 0; i &lt; ddims[1]; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; ddims[2]; j++) &#123;</span><br><span class="line">            float[] arr = temp[i][j];</span><br><span class="line">            int alpha = 255;</span><br><span class="line">            int red = (int) arr[0];</span><br><span class="line">            int green = (int) arr[1];</span><br><span class="line">            int blue = (int) arr[2];</span><br><span class="line">            int tempARGB = (alpha &lt;&lt; 24) | (red &lt;&lt; 16) | (green &lt;&lt; 8) | blue;</span><br><span class="line">            colorArr[n++] = tempARGB;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建bitmap对象</span><br><span class="line">    return Bitmap.createBitmap(colorArr, ddims[1], ddims[2], Bitmap.Config.ARGB_8888);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，我们就拿到了，我们需要的bitmap对象了，然后再做后续的逻辑即可。</p><p><a href="https://download.csdn.net/download/qq_27634797/11199751" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;项目里面用到了tflite，用于做简单的图片处理，不是判断图片是什么类型，就是传进去图片，生成新图片，类似于前面一篇讲的GPUImage的滤镜功能，但是比滤镜功能更加强大。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>图片滤镜——GPUImage</title>
    <link href="http://haichenyi.com/2019/06/11/%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E2%80%94%E2%80%94GPUImage/"/>
    <id>http://haichenyi.com/2019/06/11/图片滤镜——GPUImage/</id>
    <published>2019-06-11T14:32:53.000Z</published>
    <updated>2019-06-11T14:38:34.991Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<a href="https://github.com/cats-oss/android-gpuimage" target="_blank" rel="noopener">GPUImage</a>图片滤镜处理的第三方开源库，对照IOS版的GPUImage写的,部分功能尚未完善，目前也有很多种滤镜，常用的滤镜基本上都有，请先浏览一遍github上面的用法。</p><a id="more"></a><h2 id="依赖的库"><a href="#依赖的库" class="headerlink" title="依赖的库"></a>依赖的库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">//这个版本号2.x.x，具体的数字看，github官方说明</span><br><span class="line">//README.md下方Download后面的版本号</span><br><span class="line">    implementation &apos;jp.co.cyberagent.android:gpuimage:2.x.x&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="一、图片变形"><a href="#一、图片变形" class="headerlink" title="一、图片变形"></a>一、图片变形</h3><p>&emsp;&emsp;Android版目前没有IOS那么多类，那么多用法，我们用的最多的就是GPUImageView这个自定义view，继承的FrameLayout，并不是继承的ImageView，所以，它这里显示图片的时候，会有<strong>图片变形的问题</strong>。我的<strong><em>处理方法：</em></strong></p><ol><li>先用Glide获取图片的宽高</li><li>然后获取GPUImageView的LayoutParams，动态设置控件的宽高</li></ol><h3 id="二、内存溢出"><a href="#二、内存溢出" class="headerlink" title="二、内存溢出"></a>二、内存溢出</h3><ol><li>图片过大造成的内存溢出，压缩图片，推荐使用鲁班压缩</li><li>频繁使用GPUImage获取Bitmap的getBitmapWithFilterApplied()方法，造成Bitmap过多的内存泄漏，推荐用WeakReference(弱引用)标记Bitmap，GC自动回收</li><li>显示大图和缩略图，一般都是一个大图和多种添加滤镜后的效果图(这个是缩略图)，这里缩略图再通过getBitmapWithFilterApplied获取之前，最好吧原图按照规则缩小之后再获取显示，这样也能尽可能的减少内存的占用，点击缩略图显示大的效果图的时候，并不是改变bitmap，是给gpuIamgeView对象设置你点击目标图使用滤镜即可，这样也可以避免内存过多的消耗</li></ol><h3 id="三、滤镜添加"><a href="#三、滤镜添加" class="headerlink" title="三、滤镜添加"></a>三、滤镜添加</h3><ol><li>单一滤镜的添加</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这里以添加黑白滤镜为例</span><br><span class="line">GPUImageView gpuImageView = findViewById(R.id.img);</span><br><span class="line">gpuImageView.setImage(bitmap);</span><br><span class="line">gpuImageView.setFilter(new GPUImageGrayscaleFilter());</span><br></pre></td></tr></table></figure><ol><li>组合滤镜的添加GPUImageFilterGroup</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GPUImageView gpuImageView = findViewById(R.id.img);</span><br><span class="line">gpuImageView.setImage(bitmap);</span><br><span class="line">GPUImageFilterGroup filterGroup = new GPUImageFilterGroup();</span><br><span class="line">//把你需要添加的滤镜放到GPUImageFilterGroup容器里面，</span><br><span class="line">//这里我添加了灰色滤镜，曝光度滤镜和饱和度滤镜理论上可以添加无数个</span><br><span class="line">filterGroup.add(new GPUImageGrayscaleFilter());</span><br><span class="line">filterGroup.add(new GPUImageExposureFilter());</span><br><span class="line">filterGroup.add(new GPUImageSaturationFilter());</span><br><span class="line">//把这个容器添加到GPUImageView</span><br><span class="line">gpuImageView.setFilter(filterGroup);</span><br></pre></td></tr></table></figure><ol><li>多张图片的滤镜</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//这里以GPUImageTwoInputFilter为例（可以加到组合滤镜里面）,它有多个子类</span><br><span class="line">//我们这里用GPUImageChromaKeyBlendFilter为例</span><br><span class="line">//实现的效果是一个过渡效果，从原图过渡到目标图</span><br><span class="line">GPUImageView gpuImageView = findViewById(R.id.img);</span><br><span class="line">//设置原图</span><br><span class="line">gpuImageView.setImage(bitmap);</span><br><span class="line">//新建滤镜对象，并且把目标图设置给滤镜</span><br><span class="line">GPUImageChromaKeyBlendFilter keyBlendFilter = new GPUImageChromaKeyBlendFilter();</span><br><span class="line">//设置目标图</span><br><span class="line">keyBlendFilter.setBitmap(bitmap1);</span><br><span class="line">//平滑的过渡方法，改变参数的值即可</span><br><span class="line">keyBlendFilter.setSmoothing(progressFloat);</span><br><span class="line">//把滤镜设置给GPUImageView</span><br><span class="line">gpuImageView.setFilter(keyBlendFilter);</span><br></pre></td></tr></table></figure><h3 id="四、微调（敏感度问题）"><a href="#四、微调（敏感度问题）" class="headerlink" title="四、微调（敏感度问题）"></a>四、微调（敏感度问题）</h3><p>&emsp;&emsp;只要构造方法，方法带参数的，都可以微调，这里微调的取值范围，Filter源码的类注释上面都有。如果，我们把seekBar的取值范围设置成类注释上面的范围，你滑动很小距离的seekBar，图片变化就会很大，所以，我们一般都是缩小范围再使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数seekBar是最大值，第二个参数是最小值，第三个参数是默认值，第四个参数是seekbar分几段</span><br><span class="line">//mapSeekBarBean.put(TYPE_SATURATION, new SeekBarBean(2, 0, 0.5f, 10));</span><br><span class="line">mapSeekBarBean.put(TYPE_SATURATION, new SeekBarBean(100, 0, 50f, 2));</span><br><span class="line">//mapSeekBarBean.put(TYPE_BRIGHTNESS, new SeekBarBean(1, -1, 0.5f, 10));</span><br><span class="line">mapSeekBarBean.put(TYPE_BRIGHTNESS, new SeekBarBean(100, 0, 50f, 2));</span><br><span class="line">//mapSeekBarBean.put(TYPE_EXPOSURE, new SeekBarBean(10, -10, 0.5f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_EXPOSURE, new SeekBarBean(100, 0, 50f, 2));</span><br><span class="line">//mapSeekBarBean.put(TYPE_CONTRAST, new SeekBarBean(4, 0, 0.25f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_CONTRAST, new SeekBarBean(100, 0, 25f, 2));</span><br><span class="line">mapSeekBarBean.put(TYPE_POSTERIZE, new SeekBarBean(256, 0, 100f, 3));</span><br><span class="line">//mapSeekBarBean.put(TYPE_HIGH_LIGHT_SHADOW, new SeekBarBean(1, 0, 0f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_HIGH_LIGHT_SHADOW, new SeekBarBean(100, 0, 0f, 2));</span><br><span class="line">mapSeekBarBean.put(TYPE_SHARPEN, new SeekBarBean(100, 0, 50f, 3));</span><br><span class="line">//mapSeekBarBean.put(TYPE_GAMMA, new SeekBarBean(3, 0, 0.33f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_GAMMA, new SeekBarBean(100, 0, 33f, 3));</span><br><span class="line">//mapSeekBarBean.put(TYPE_OPACITY, new SeekBarBean(1, 0, 1f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_OPACITY, new SeekBarBean(100, 0, 100f, 2));</span><br><span class="line">//mapSeekBarBean.put(TYPE_VIBRANCE, new SeekBarBean(1, 0, 0f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_VIBRANCE, new SeekBarBean(100, 0, 0f, 2));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//这里是最终设置的值</span><br><span class="line">switch (entrySet.getKey()) &#123;</span><br><span class="line">                case TYPE_SATURATION:</span><br><span class="line">                    //最后面*2是范围（0,2）</span><br><span class="line">                    float f1 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 2;</span><br><span class="line">                    filters.add(new GPUImageSaturationFilter(f1));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_BRIGHTNESS:</span><br><span class="line">                    float f2 = entrySet.getValue().getProgress();</span><br><span class="line">                    if (f2 == 50) &#123;</span><br><span class="line">                        f2 = 0f;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //后面的*0.7是范围（-1,1），以中间0为准，分成两部分（-1,0），（0,1）</span><br><span class="line">                        //负数为变暗，正数为变亮,本应该*1</span><br><span class="line">                        f2 = (float) (((f2 - 50) / 50) * 0.4);</span><br><span class="line">                    &#125;</span><br><span class="line">                    filters.add(new GPUImageBrightnessFilter(f2));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_EXPOSURE:</span><br><span class="line">                    float f3 = entrySet.getValue().getProgress();</span><br><span class="line">                    if (f3 == 50) &#123;</span><br><span class="line">                        f3 = 0f;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //后面的*1是范围（-10,10），以中间0为准，分成两部分（-10,0），（0,10）</span><br><span class="line">                        //负数为变暗，正数为变亮，本应该*10</span><br><span class="line">                        f3 = ((f3 - 50) / 50) * 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    filters.add(new GPUImageExposureFilter(f3));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_CONTRAST:</span><br><span class="line">                    //最后面*4是范围（0,4）</span><br><span class="line">                    float f4 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 4;</span><br><span class="line">                    filters.add(new GPUImageContrastFilter(f4));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_POSTERIZE:</span><br><span class="line">                    filters.add(new GPUImagePosterizeFilter((int) entrySet.getValue().getProgress()));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_HIGH_LIGHT_SHADOW:</span><br><span class="line">                    GPUImageHighlightShadowFilter highlightShadowFilter = new GPUImageHighlightShadowFilter();</span><br><span class="line">                    float f9 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1;</span><br><span class="line">                    highlightShadowFilter.setHighlights(1 - f9);</span><br><span class="line">                    highlightShadowFilter.setShadows(f9);</span><br><span class="line">                    filters.add(highlightShadowFilter);</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_SHARPEN:</span><br><span class="line">                    float f5 = entrySet.getValue().getProgress();</span><br><span class="line">                    if (f5 == 50) &#123;</span><br><span class="line">                        f5 = 0f;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //后面的*4是范围（-4,4），以中间0为准，分成两部分（-4,0），（0,4）</span><br><span class="line">                        //负数为变暗，正数为变亮，本应该*4</span><br><span class="line">                        f5 = ((f5 - 50) / 50) * 4;</span><br><span class="line">                    &#125;</span><br><span class="line">                    filters.add(new GPUImageSharpenFilter(f5));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_GAMMA:</span><br><span class="line">                    //最后面*3是范围（0,3）</span><br><span class="line">                    float f6 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 3;</span><br><span class="line">                    filters.add(new GPUImageGammaFilter(f6));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_OPACITY:</span><br><span class="line">                    float f7 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1;</span><br><span class="line">                    filters.add(new GPUImageOpacityFilter(f7));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_VIBRANCE:</span><br><span class="line">                    float f8 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1;</span><br><span class="line">                    filters.add(new GPUImageVibranceFilter(f8));</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>&emsp;&emsp;上面的注意事项里面已经说了简单的用法了，怎么获取滤镜后的图片呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//这个方法是获取bitmap对象，至于怎么保存，那就是你自己做了</span><br><span class="line">gpuImageView.getGPUImage().getBitmapWithFilterApplied();</span><br><span class="line"></span><br><span class="line">//当然，库也提供了保存图片的方法：保存的文件夹名称，文件名字，回调方法</span><br><span class="line">gpuImageView.saveToPictures(folderName,fileName,OnPictureSavedListener)</span><br><span class="line">//其中回调方法里面返回的uri，不能直接传给File，会找不到路径，需要转换一下</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 根据Uri获取文件的路径</span><br><span class="line">     *</span><br><span class="line">     * @param context    context</span><br><span class="line">     * @param contentURI uri</span><br><span class="line">     * @return 文件路径</span><br><span class="line">     */</span><br><span class="line">    public static String getRealPathFromURI(Context context, Uri contentURI) &#123;</span><br><span class="line">        String result;</span><br><span class="line">        Cursor cursor = context.getContentResolver().query(contentURI,</span><br><span class="line">                new String[]&#123;MediaStore.Images.ImageColumns.DATA&#125;,</span><br><span class="line">                null, null, null);</span><br><span class="line">        if (cursor == null) &#123;</span><br><span class="line">            result = contentURI.getPath();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cursor.moveToFirst();</span><br><span class="line">            int index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);</span><br><span class="line">            result = cursor.getString(index);</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>项目就不贴出来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;https://github.com/cats-oss/android-gpuimage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GPUImage&lt;/a&gt;图片滤镜处理的第三方开源库，对照IOS版的GPUImage写的,部分功能尚未完善，目前也有很多种滤镜，常用的滤镜基本上都有，请先浏览一遍github上面的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>JDBC的简单使用——MySQL</title>
    <link href="http://haichenyi.com/2018/10/11/JDBC%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94MySQL/"/>
    <id>http://haichenyi.com/2018/10/11/JDBC的简单使用——MySQL/</id>
    <published>2018-10-11T14:51:00.000Z</published>
    <updated>2018-10-11T15:03:08.367Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前面几篇学了基本的SQL语句和用工具操作数据库，今天讲一下用代码操作数据库。</p><h4 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h4><p>&emsp;&emsp;<strong><em>首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java</em></strong></p><p>&emsp;&emsp;<strong><em>首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java</em></strong></p><p>&emsp;&emsp;<strong><em>首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java</em></strong></p><a id="more"></a><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1、获取驱动类,路动类路径：com.mysql.jdbc.Driver</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//获取url：jdbc:mysql://ip:端口号/数据库名称</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">//用户名</span><br><span class="line">String username = &quot;root&quot;;</span><br><span class="line">//密码</span><br><span class="line">String password = &quot;123&quot;;</span><br><span class="line">//获取Connection对象</span><br><span class="line">Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">System.out.print(connection);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总的来说，先要获取驱动类，然后就是获取Connection对象，就是一行代码<code>DriverManager.getConnection(url, username, password);</code>能走通，就说明连接上了。</p><h4 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test1() throws ClassNotFoundException, SQLException &#123;</span><br><span class="line">        //获取驱动类</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        //获取url</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">        //用户名</span><br><span class="line">        String username = &quot;root&quot;;</span><br><span class="line">        //密码</span><br><span class="line">        String password = &quot;123&quot;;</span><br><span class="line">        //获取Connection对象</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">        System.out.print(connection);</span><br><span class="line">        //获取Statement对象</span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        //String sql=&quot;INSERT INTO employee (eid,ename,edid) VALUES(null,&apos;小红&apos;,2)&quot;;</span><br><span class="line">        String sql = &quot;UPDATE employee SET edid=1 WHERE ename=&apos;小红&apos;&quot;;</span><br><span class="line">        statement.executeUpdate(sql);</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就是在连接数据库之后，通过Connection对象获取Statement对象，通过Statement对象的execute方法执行对应的SQL语句，最后记得关闭</p><h4 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        Connection con = null;</span><br><span class="line">        Statement state = null;</span><br><span class="line">        ResultSet resultSet = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String driverClassName = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">            String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">            String username = &quot;root&quot;;</span><br><span class="line">            String password = &quot;123&quot;;</span><br><span class="line">            Class.forName(driverClassName);</span><br><span class="line">            con = DriverManager.getConnection(url, username, password);</span><br><span class="line">            state = con.createStatement();</span><br><span class="line">            String querySQL = &quot;SELECT * FROM employee&quot;;</span><br><span class="line">            resultSet = state.executeQuery(querySQL);</span><br><span class="line">            List&lt;Map&lt;String, String&gt;&gt; mapList = new ArrayList&lt;&gt;();</span><br><span class="line">            while (resultSet.next()) &#123;</span><br><span class="line">                Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">                map.put(&quot;ename&quot;, resultSet.getString(&quot;ename&quot;));</span><br><span class="line">                map.put(&quot;edid&quot;, String.valueOf(resultSet.getInt(&quot;edid&quot;)));</span><br><span class="line">                mapList.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(mapList.size());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (resultSet != null) &#123;</span><br><span class="line">                    resultSet.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (state != null) &#123;</span><br><span class="line">                    state.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (con != null) &#123;</span><br><span class="line">                    con.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;查询数据库需要注意的地方就是：</p><ol><li><p>执行SQL语句的方法是<code>executeQuery()</code>，只能执行查询语句。</p></li><li><p>他有一个返回值ResultSet，然后循环这个Set对象，获取数据，他提供了一个移动光标的方法<code>next()</code>，当他为null的时候，返回false，结束循环。</p></li><li><p>还提供了一系列的get方法，传表每一栏的下标index，或者每一栏的名称，获取对应的值。值的类型要与get的类型相同。值为int，就用getInt，值为String就用getString</p></li><li><p>最后记得关闭连接，倒着关闭。</p></li></ol><h4 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h4><p>&emsp;&emsp;上面用自己拼接sql语句的方式查询数据库，会容易被sql攻击。所以，我们需要用<code>PreparedStatement</code>来防止被sql攻击，具体方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean login(String username, String password) throws Exception &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement pstat = null;</span><br><span class="line">        ResultSet rs = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">            String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">            String user = &quot;root&quot;;</span><br><span class="line">            String psw = &quot;123&quot;;</span><br><span class="line">            connection = DriverManager.getConnection(url, user, psw);</span><br><span class="line">            String sql = &quot;select * from t_user where username=? and psw=?&quot;;</span><br><span class="line">            pstat = connection.prepareStatement(sql);</span><br><span class="line">            pstat.setString(1, username);</span><br><span class="line">            pstat.setString(2, password);</span><br><span class="line">            rs = pstat.executeQuery();</span><br><span class="line">            return rs.next();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (rs != null) rs.close();</span><br><span class="line">            if (pstat != null) pstat.close();</span><br><span class="line">            if (connection != null) connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，是一个登录接口，传用户名，密码给后台，后台查询数据库，我们在获取了connection之后，通过connection调用prepareStatement方法，需要传一个sql模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;select * from t_user where username=? and psw=?&quot;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;什么是sql模板呢？就是吧需要动态传的参数用问好代替。我们上面这个查询语句，需要动态变化的就是username和psw。然后，我们调用PreparedStatement的setXxx方法，去设置值，第一个参数表示给第几个值赋值，第二个参数就是需要赋值的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//给第一个参数赋值为username</span><br><span class="line">pstat.setString(1, username);</span><br><span class="line">//给第二个参数赋值为password</span><br><span class="line">pstat.setString(2, password);</span><br></pre></td></tr></table></figure><h4 id="大数据存储"><a href="#大数据存储" class="headerlink" title="大数据存储"></a>大数据存储</h4><p>&emsp;&emsp;这里以存mp3为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_binary(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(50),</span><br><span class="line">DATA MEDIUMBLOB</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，首先创建一张表去存数据，数据类型不要错了，BLOB类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test1() throws SQLException, IOException &#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql=&quot;INSERT INTO t_binary VALUE(?,?,?)&quot;;</span><br><span class="line">        PreparedStatement pstat = connection.prepareStatement(sql);</span><br><span class="line">        pstat.setInt(1,1);</span><br><span class="line">        pstat.setString(2,&quot;KenT - 唱给谁听.mp3&quot;);</span><br><span class="line">        byte[] bytes= IOUtils.toByteArray(new FileInputStream(&quot;D:/CloudMusic/KenT - 唱给谁听.mp3&quot;));</span><br><span class="line">        Blob blob=new SerialBlob(bytes);</span><br><span class="line">        pstat.setBlob(3,blob);</span><br><span class="line">        pstat.executeLargeUpdate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面test1就是存的方法，步骤：</p><ol><li><p>先连接数据库，获取Connection对象</p></li><li><p>然后，获取PreparedStatement对象，设置参数，其中blob参数，Blob是一个接口，先获取他的实现类SerialBlob，这个实现类的构造方法需要传一个byte[]数组，所以，我们只用把需要存储的文件转成byte[]数组就可以了</p></li><li><p>最后，执行sql语句就可以了</p></li></ol><p>这里需要注意的是，要在my.ini服务器配置文件中设置最大存储<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个大小大于你的存储文件即可</span><br><span class="line">max_allowed_packet=20M</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;[mysqld]下边的是服务器配置，[mysql]下边的是客户端配置</p><p>&emsp;&emsp;接下来就是怎么取文件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test2() throws SQLException, IOException &#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql=&quot;SELECT * FROM t_binary WHERE name=?&quot;;</span><br><span class="line">        PreparedStatement pstat = connection.prepareStatement(sql);</span><br><span class="line">        pstat.setString(1,&quot;KenT - 唱给谁听.mp3&quot;);</span><br><span class="line">        ResultSet rs = pstat.executeQuery();</span><br><span class="line">        if (rs.next())&#123;</span><br><span class="line">            Blob blob = rs.getBlob(&quot;data&quot;);</span><br><span class="line">            InputStream in = blob.getBinaryStream();</span><br><span class="line">            FileOutputStream out = new FileOutputStream(&quot;D:/cgst.mp3&quot;);</span><br><span class="line">            IOUtils.copy(in,out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要说的就是获取到ResultSet之后，获取到Blob，通过他的getBinaryStream()方法，转成输入流，拿到输入流之后，转成File即可</p><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test6() throws SQLException &#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql = &quot;INSERT INTO t_user VALUE(?,?,?)&quot;;</span><br><span class="line">        PreparedStatement pstat = connection.prepareStatement(sql);</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            pstat.setInt(1, i + 1);</span><br><span class="line">            pstat.setString(2, &quot;user&quot; + i);</span><br><span class="line">            pstat.setString(3, i % 2 == 0 ? &quot;男&quot; : &quot;女&quot;);</span><br><span class="line">            pstat.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        pstat.executeBatch();</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.print(end - start);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意点：</p><ol><li>每添加一条数据，调用一遍pstat.addBatch();</li><li>当数据添加完以后，调用pstat.executeBatch();执行sql语句</li><li>mysql要开启批处理功能，不然慢到你无法想象。在获取Connection传的url后面，添加<code>rewriteBatchedStatements=true</code>。完整url<code>jdbc:mysql://localhost:3306/test4?rewriteBatchedStatements=true</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前面几篇学了基本的SQL语句和用工具操作数据库，今天讲一下用代码操作数据库。&lt;/p&gt;
&lt;h4 id=&quot;连接MySQL&quot;&gt;&lt;a href=&quot;#连接MySQL&quot; class=&quot;headerlink&quot; title=&quot;连接MySQL&quot;&gt;&lt;/a&gt;连接MySQL&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -JDBC" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（五）——多表查询</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（五）——多表查询/</id>
    <published>2018-10-11T14:50:45.000Z</published>
    <updated>2018-10-11T15:03:11.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并结果集-union-all-包含相同行-、union-去除相同行"><a href="#合并结果集-union-all-包含相同行-、union-去除相同行" class="headerlink" title="合并结果集 union all(包含相同行)、union(去除相同行)"></a>合并结果集 <code>union all(包含相同行)、union(去除相同行)</code></h3><p>&emsp;&emsp;把查询的结果合并到一起。<strong>要求：</strong> <code>查询的结果列数相同，列类型相同</code></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">    eid int,</span><br><span class="line">    ename varchar(50),</span><br><span class="line">    eage int</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table stu(</span><br><span class="line">    sid int,</span><br><span class="line">    sname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//合并结果集（加上all，包含相同的行）</span><br><span class="line">select eid,ename from emp</span><br><span class="line">union all</span><br><span class="line">select * from stu;</span><br><span class="line"></span><br><span class="line">//合并结果集（去掉all，去除相同行）</span><br><span class="line">select eid,ename from emp</span><br><span class="line">union</span><br><span class="line">select * from stu;</span><br></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p><strong>方言：</strong> <code>select * from 表1,表2 where 条件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表a有三条数据：q，w，e</span><br><span class="line">表b有两条数据：h，j</span><br><span class="line">select * from a,b;</span><br><span class="line">得出的结果是表a与表b的笛卡尔集，也就是会得到6条数据，</span><br><span class="line">分别：qh,qj,wh,wj,eh,ej</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">去除无用的笛卡尔集，加上where后面的条件</span><br><span class="line">连表查询会有附表的外键=主表的主键这个条件</span><br><span class="line"></span><br><span class="line">select * from student,teacher where student.tid=teacher.tid;</span><br><span class="line"></span><br><span class="line">查询学生的全部信息，需要查询学生表和老师表，</span><br><span class="line">条件是学生表里面的老师id等于老师表里面的老师id，</span><br><span class="line">这样查出来的结果就是我们想要的结果</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例子：要求打印员工姓名，工资以及部分名称</span><br><span class="line">     员工姓名，工资在emp表，部门名称在dept表</span><br><span class="line">select emp.ename,emp.sal,dept.dname</span><br><span class="line">from emp,dept</span><br><span class="line">where emp.did=dept.did;</span><br><span class="line"></span><br><span class="line">如果嫌弃表名字太长了可以这样：</span><br><span class="line">select e.ename,e.sal,d.dname</span><br><span class="line">from emp e,dept d</span><br><span class="line">where e.did=d.did;</span><br></pre></td></tr></table></figure><p><strong>标准：</strong> <code>select * from 表1 别名1 inner join 表2 别名2 on 条件</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">别名都是可选的，条件跟上面写的一样。两者的区别就只有二个：</span><br><span class="line">1、方言连接两个表是用逗号，标准连接两个表是用 inner join</span><br><span class="line">2、条件：方言用where，标准用on</span><br><span class="line"></span><br><span class="line">select e.ename,e.sal,d.dname</span><br><span class="line">from emp e inner join dept d</span><br><span class="line">where e.did=d.did;</span><br></pre></td></tr></table></figure></p><h4 id="外连接-一主一次"><a href="#外连接-一主一次" class="headerlink" title="外连接 一主一次"></a>外连接 <code>一主一次</code></h4><p><strong>左外连接</strong> <code>left outer join ,左表为主表，右表为次表,左表中不论满足不满足条件都查询出来，右表中对应的位置用null补位</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询所有员工名称，工资以及部门名称，部门名称为null的填无部分</span><br><span class="line">select e.ename as 姓名,e.sal as 工资,d.ifnull(dname,&apos;无部门&apos;) as 部门名称</span><br><span class="line">from emp e left outer join dept d</span><br><span class="line">where e.did=d.did;</span><br></pre></td></tr></table></figure></p><p><strong>右外连接</strong> <code>right outer join 与左外对应</code></p><h3 id="子查询-一条sql语句中有多个select关键字-ALL-ANY-IN"><a href="#子查询-一条sql语句中有多个select关键字-ALL-ANY-IN" class="headerlink" title="子查询 一条sql语句中有多个select关键字,ALL,ANY,IN"></a>子查询 <code>一条sql语句中有多个select关键字,ALL,ANY,IN</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查询员工中最高工资员工的详细信息</span><br><span class="line">select * from emp where sal=MAX(sal);</span><br><span class="line">//上面这个写法是错误的，条件中是不能出现集合函数</span><br><span class="line">//上面这个写法是错误的，条件中是不能出现集合函数</span><br><span class="line">//上面这个写法是错误的，条件中是不能出现集合函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1、先查最高工资</span><br><span class="line">select MAX(sal) from emp;</span><br><span class="line">//2、最高工资的员工信息</span><br><span class="line">select * from emp where sal=(select MAX(sal) from emp);</span><br><span class="line">//上面这个写法才是正确的</span><br><span class="line">//上面这个写法才是正确的</span><br><span class="line">//上面这个写法才是正确的</span><br></pre></td></tr></table></figure><p><strong>出现的位置：</strong> <code>1、from后作为表 2、where后作为条件</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上面那条sql语句就是作为条件</span><br><span class="line">//查询部门等于30的员工的姓名和年龄</span><br><span class="line">select e.name,e.age from (select * from emp where did=30) e;</span><br><span class="line">//上面这条就是from后面作为表</span><br></pre></td></tr></table></figure></p><p><strong>1、打印高于平均工资的所有人的信息(单行单列作为条件)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where (sal&gt;select AVG(sal) from emp);</span><br></pre></td></tr></table></figure></p><p><strong>2、打印大于30部门的所有员工工资的员工信息(多行单列作为条件)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where sal &gt; ALL (select sal from emp where did=30);</span><br></pre></td></tr></table></figure></p><p><strong>3、打印大于30部门任意一人员工工资的员工信息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where sal&gt; ANY (select sal from emp where did = 30);</span><br></pre></td></tr></table></figure></p><p><strong>4、打印工作和部门与张三相同的员工信息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where (job,did) IN (select job,did from emp where ename=&apos;张三&apos;);</span><br></pre></td></tr></table></figure></p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p><strong><em>前提条件已知四张表</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">员工表emp(eid,ename,job,emid,etime,sal,edid)</span><br><span class="line">部门表dept(did,dname,dloc)</span><br><span class="line">薪资等级表salgrade(grade,losal,hisal)</span><br><span class="line">领导表mgr(mid,mname,mtime)</span><br></pre></td></tr></table></figure></p><p><strong>1、查询至少有一个员工的部门，显示部门编号，部门名称，部门位置，部门人数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：d.did，d.dname，d.dloc，部门人数</span><br><span class="line">2、表：dept d，emp e</span><br><span class="line">条件：e.did=d.did</span><br><span class="line"></span><br><span class="line">//查询部门编号，部门名称，部门位置</span><br><span class="line">select * from dept;</span><br><span class="line"></span><br><span class="line">//查询部门人数</span><br><span class="line">select e.did,count(*) from emp group by e.did;</span><br><span class="line"></span><br><span class="line">//把上面查询的两张表内连接</span><br><span class="line">select * from dept inner join select e.did,count(*) from emp group by e.did;</span><br><span class="line"></span><br><span class="line">//加上条件，给出别名</span><br><span class="line">select d.*,z1.cnt from dept d inner join (select did,count(*) cnt from emp group by e.did) z1 where d.did=z1.did;</span><br></pre></td></tr></table></figure></p><p><strong>2、查询所有员工名称及其直接上级领导名称</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：e.ename，m.mname</span><br><span class="line">2、表：emp e，mgr m</span><br><span class="line">条件：e.emid=m.mid</span><br><span class="line">//查询员工名称</span><br><span class="line">select ename from emp;</span><br><span class="line">//查询领导名称</span><br><span class="line">select mname from mgr;</span><br><span class="line"></span><br><span class="line">select ename from emp e left outer join (select mname from mgr ) m on e.emid = m.mid;</span><br></pre></td></tr></table></figure></p><p><strong>3、列出受雇佣日期早于直接上级的所有员工编号，姓名，以及部门名称</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：e.eid,e.ename,d.dname</span><br><span class="line">2、表：emp，mgr，dept</span><br><span class="line">//查询受雇佣日期早于直接上级领导的员工信息</span><br><span class="line">select etime from emp;</span><br><span class="line">select mtime from mgr;</span><br><span class="line"></span><br><span class="line">select * from emp e</span><br><span class="line">inner join </span><br><span class="line">select mtime from mgr m</span><br><span class="line">on e.emid=m.mid and e.etime&lt;m.mtime</span><br><span class="line"></span><br><span class="line">//再把部门名称加上</span><br><span class="line">(select eid,ename,edid from emp e</span><br><span class="line">inner join </span><br><span class="line">select mtime from mgr m</span><br><span class="line">on e.emid=m.mid and e.etime&lt;m.mtime) z1 </span><br><span class="line">left outer join </span><br><span class="line">select dname from dept d </span><br><span class="line">on z1.edid = d.did;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">select e.eid,e.ename,d.dname</span><br><span class="line">from emp e,mgr m,dept d</span><br><span class="line">where e.emid=m.mid and e.etime&lt;m.mtime and e.edid=d.did;</span><br></pre></td></tr></table></figure></p><p><strong>4、列出部门名称和这些部门的员工信息，同事列出没有员工的部门</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：员工信息，和部门名称，没有员工的部门也要列出来</span><br><span class="line">2、表：emp,dept</span><br><span class="line"></span><br><span class="line">select e.*,d.dname from emp e </span><br><span class="line">right outer join </span><br><span class="line">dept d</span><br><span class="line">on e.edid=d.did;</span><br></pre></td></tr></table></figure></p><p><strong>5、列出最低薪资大于15000的各种工作以及从事此工作的人数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：工作类型，人数</span><br><span class="line">2、表：emp</span><br><span class="line">条件：min(sal)&gt;15000</span><br><span class="line"></span><br><span class="line">select job,count(*)</span><br><span class="line">from emp</span><br><span class="line">group by job</span><br><span class="line">having min(sal)&gt;15000</span><br></pre></td></tr></table></figure></p><p><strong>6、列出在销售部工作的员工姓名，假定不知道销售部的部门编号</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：员工姓名</span><br><span class="line">2、表：emp,dept</span><br><span class="line">条件：e.edid=d.did</span><br><span class="line"></span><br><span class="line">select ename</span><br><span class="line">from emp e</span><br><span class="line">where e.edid=(select did from dept where dname=&apos;销售部&apos;);</span><br></pre></td></tr></table></figure></p><p><strong>7、列出薪资高于公司平均工资的所有员工信息，所在部门名称，上级领导，工资等级</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：员工信息，部门名称，上级领导名称，工资等级</span><br><span class="line">2、表：emp,dept,mgr</span><br><span class="line">条件：sal&gt;avg(sal),e.edid=d.did,e.emid=m.mid</span><br><span class="line">//先查询高出平均工资的员工信息</span><br><span class="line">select * from emp where sal&gt;(select avg(sal) from emp);</span><br><span class="line"></span><br><span class="line">//把后面的表一个一个的加上去</span><br><span class="line">//加部门名称</span><br><span class="line">select e.*,d.dname</span><br><span class="line">from </span><br><span class="line">    emp e left outer join dept d on e.edid=d.did</span><br><span class="line">where e.sal&gt;(select avg(sal) from emp)</span><br><span class="line"></span><br><span class="line">//加上级领导名称</span><br><span class="line">select e.*,d.dname,m.mname</span><br><span class="line">from </span><br><span class="line">    emp e left outer join dept d on e.edid=d.did</span><br><span class="line">    left outer join mgr m on e.emid = m.mid</span><br><span class="line">where e.sal&gt;(select avg(sal) from emp)</span><br><span class="line"></span><br><span class="line">//最后加工资等级</span><br><span class="line">select e.*,d.dname,m.mname,s.grade</span><br><span class="line">from </span><br><span class="line">    emp e left outer join dept d on e.edid=d.did</span><br><span class="line">    left outer join mgr m on e.emid = m.mid</span><br><span class="line">    left outer join salgrade s on e.sal between s.losal and hisal</span><br><span class="line">where e.sal&gt;(select avg(sal) from emp)</span><br></pre></td></tr></table></figure></p><p><strong>8、列出与张三从事相同工作的所有员工以及部门名称</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：所有员工，部门名称</span><br><span class="line">2、表：emp，dept</span><br><span class="line">条件：张三的工作相同，e.edid=d.did</span><br><span class="line"></span><br><span class="line">select e.*,d.dname from emp e </span><br><span class="line">left outer join dept d</span><br><span class="line">on e.edid=d.did</span><br><span class="line">where e.job=(select job from emp where ename=&apos;张三&apos;);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">select e.*,d.dname from emp e,dept d where e.edid=did and e.job=(select job from emp where ename=&apos;张三&apos;);</span><br></pre></td></tr></table></figure></p><p><strong>9、列出薪资高于30部门的所有员工薪资的员工的姓名和薪资，部门名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select e.ename,e.sal,d.dname from emp e left outer join dept d</span><br><span class="line">where e.sal &gt; all (select sal from emp where edid=30) and e.edid = d.did;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;合并结果集-union-all-包含相同行-、union-去除相同行&quot;&gt;&lt;a href=&quot;#合并结果集-union-all-包含相同行-、union-去除相同行&quot; class=&quot;headerlink&quot; title=&quot;合并结果集 union all(包含相同行)、union(去除相同行)&quot;&gt;&lt;/a&gt;合并结果集 &lt;code&gt;union all(包含相同行)、union(去除相同行)&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;把查询的结果合并到一起。&lt;strong&gt;要求：&lt;/strong&gt; &lt;code&gt;查询的结果列数相同，列类型相同&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（四）——多表之间的关系</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（四）——多表之间的关系/</id>
    <published>2018-10-11T14:50:29.000Z</published>
    <updated>2018-10-11T15:03:14.674Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主键与外键"><a href="#主键与外键" class="headerlink" title="主键与外键"></a>主键与外键</h3><p><code>1、一张表可以有多个外键</code></p><p><code>2、外键是表的主键，可以是别的表，也可以是本身（少见）</code></p><p><code>3、外键可以为null，可以重复，但是不能不存在，必须要查的到</code></p><p><strong>创建语法</strong> <code>foreign key(本表的列名) references 关联的表名(关联表的主键)</code></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//创建一个部门表</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">did INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">dname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//插入几条数据</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;销售部&apos;);</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;技术部&apos;);</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;人力部&apos;);</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;保洁部&apos;);</span><br><span class="line"></span><br><span class="line">//创建一个员工表，这里的的edid是一个外键，对应部门表的主键did</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">eid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">ename VARCHAR(50),</span><br><span class="line">edid INT,</span><br><span class="line">CONSTRAINT fk_empl_dept FOREIGN KEY(edid) REFERENCES dept(did)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">eid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">ename VARCHAR(50),</span><br><span class="line">edid INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alter table employee add CONSTRAINT fk_empl_dept FOREIGN KEY(edid) REFERENCES dept(did);</span><br><span class="line"></span><br><span class="line">//上面这样也可以设置外键</span><br></pre></td></tr></table></figure><h3 id="一对一关系-把从表的主键设置成外键与主表的主键关联"><a href="#一对一关系-把从表的主键设置成外键与主表的主键关联" class="headerlink" title="一对一关系 把从表的主键设置成外键与主表的主键关联"></a>一对一关系 <code>把从表的主键设置成外键与主表的主键关联</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">    eid int primary key auto_increment,</span><br><span class="line">    ename varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table hmp(</span><br><span class="line">    hid int primary key auto_increment,</span><br><span class="line">    hname varchar(50),</span><br><span class="line">    constraint fk_hmp_emp foreign key(hid) references emp(eid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//如上，这样创建的两张表emp与hmp就是一对一的关系</span><br><span class="line"></span><br><span class="line">//插入数据</span><br><span class="line">insert into emp values(1,&apos;张三&apos;);</span><br><span class="line">insert into hmp values(1,&apos;李四&apos;);</span><br><span class="line">//这样张三跟李四就对应上了</span><br></pre></td></tr></table></figure><h3 id="多对多关系-两个主表-一个关联表"><a href="#多对多关系-两个主表-一个关联表" class="headerlink" title="多对多关系 两个主表+一个关联表"></a>多对多关系 <code>两个主表+一个关联表</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">create table teacher(</span><br><span class="line">    tid int primary key auto_increment,</span><br><span class="line">    tname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table student(</span><br><span class="line">    sid int primary key auto_increment,</span><br><span class="line">    sname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table stu_tea(</span><br><span class="line">    tid int,</span><br><span class="line">    sid int,</span><br><span class="line">    constraint fk_student foreign key(sid) references student(sid),</span><br><span class="line">    constraint fk_teacher foreign key(tid) references teacher(tid)</span><br><span class="line">);</span><br><span class="line">//这里的stu_tea就是关联表。多对多并不是说多张表对应多张表</span><br><span class="line"></span><br><span class="line">//插入数据</span><br><span class="line">insert into teacher values(1,&apos;黄老师&apos;);</span><br><span class="line">insert into teacher values(2,&apos;李老师&apos;);</span><br><span class="line">insert into teacher values(3,&apos;赵老师&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into student values(1,&apos;张三&apos;);</span><br><span class="line">insert into student values(2,&apos;李四&apos;);</span><br><span class="line">insert into student values(3,&apos;王五&apos;);</span><br><span class="line">insert into student values(4,&apos;赵六&apos;);</span><br><span class="line"></span><br><span class="line">//这里黄老师教过张三，李四</span><br><span class="line">insert into stu_tea values(1,1);</span><br><span class="line">insert into stu_tea values(1,2);</span><br><span class="line">//李老师教过王五，赵六</span><br><span class="line">insert into stu_tea values(2,3);</span><br><span class="line">insert into stu_tea values(2,4);</span><br><span class="line">//赵老师教过张三，李四，王五，赵六</span><br><span class="line">insert into stu_tea values(3,1);</span><br><span class="line">insert into stu_tea values(3,2);</span><br><span class="line">insert into stu_tea values(3,3);</span><br><span class="line">insert into stu_tea values(3,4);</span><br><span class="line"></span><br><span class="line">//上面这样，一个学生对应多个老师，一个老师也对应多个学生，叫做多对多的关系</span><br></pre></td></tr></table></figure><h3 id="一对多关系-一方不变，另一方在变化"><a href="#一对多关系-一方不变，另一方在变化" class="headerlink" title="一对多关系 一方不变，另一方在变化"></a>一对多关系 <code>一方不变，另一方在变化</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//我们一开始创建的员工表与部门表就是一对多</span><br><span class="line">create table dept(</span><br><span class="line">    did int primary key auto_increment,</span><br><span class="line">    dname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">    eid int primary key auto_increment,</span><br><span class="line">    ename varchar(50)</span><br><span class="line">    edid int,</span><br><span class="line">    constraint fk_emp_dept foreign key(edid) references dept(did)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//这里的一就是部门表（主表），多就是员工表（附表）</span><br><span class="line">//插入数据</span><br><span class="line">insert into dept values(10,&apos;技术部&apos;);</span><br><span class="line">insert into dept values(20,&apos;人事部&apos;);</span><br><span class="line"></span><br><span class="line">//张三，李四属于技术部，王五属于人事部</span><br><span class="line">insert into emp values(null,&apos;张三&apos;,10);</span><br><span class="line">insert into emp values(null,&apos;李四&apos;,10);</span><br><span class="line">insert into emp values(null,&apos;王五&apos;,20);</span><br><span class="line"></span><br><span class="line">//一个部门对应多个员工，一对多</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主键与外键&quot;&gt;&lt;a href=&quot;#主键与外键&quot; class=&quot;headerlink&quot; title=&quot;主键与外键&quot;&gt;&lt;/a&gt;主键与外键&lt;/h3&gt;&lt;p&gt;&lt;code&gt;1、一张表可以有多个外键&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2、外键是表的主键，可以是别的表，也可以是本身（少见）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3、外键可以为null，可以重复，但是不能不存在，必须要查的到&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建语法&lt;/strong&gt; &lt;code&gt;foreign key(本表的列名) references 关联的表名(关联表的主键)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（三）——数据库的备份与恢复</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（三）——数据库的备份与恢复/</id>
    <published>2018-10-11T14:50:13.000Z</published>
    <updated>2018-10-11T15:03:20.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库的备份与恢复"><a href="#数据库的备份与恢复" class="headerlink" title="数据库的备份与恢复"></a>数据库的备份与恢复</h3><p><strong>备份</strong>：<code>mysqldump -u用户名 -p密码 数据库名&gt;生成的脚本路径</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//末尾没有分号，也不要登录</span><br><span class="line">mysqldunp -uroot -p123 school&gt;C:a.sql</span><br></pre></td></tr></table></figure><p><strong>恢复</strong>：<code>mysqldump -u用户名 -p密码 数据库名&lt;生成的脚本路径</code></p><p><code>或者：登录之后，切换到需要恢复的数据库，输入：source 生成的脚本路径</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//要先删除school数据库，再重新创建数据库，这两步需要登录</span><br><span class="line">//执行下面sql语句，不要登录，末尾没有分号</span><br><span class="line">mysqldunp -uroot -p123 school&lt;C:a.sql</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><p>找到你的mysql的安装目录，找到my.ini文件，更bin目录同级，修改如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">character-set-server=utf8 </span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"></span><br><span class="line">default-character-set=utf8 </span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"></span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure></p><p><strong>修改完之后，不仅是要重新连接数据库，必须要重启数据库</strong></p><p><strong>修改完之后，不仅是要重新连接数据库，必须要重启数据库</strong></p><p><strong>修改完之后，不仅是要重新连接数据库，必须要重启数据库</strong></p><p><code>net stop mysql</code> <code>net start mysql</code></p><h3 id="主键-primary-key"><a href="#主键-primary-key" class="headerlink" title="主键 primary key"></a>主键 primary key</h3><p><strong>创建表的时候直接设置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid CHAR(12) PRIMARY KEY,</span><br><span class="line">ename VARCHAR(20),</span><br><span class="line">esal INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">esid CHAR(12),</span><br><span class="line">ename VARCHAR(20),</span><br><span class="line">esal INT,</span><br><span class="line">PRIMARY KEY(esid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>修改主键</strong> <code>alter table 表名 add primary key(键名)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp add primary key(esid);</span><br></pre></td></tr></table></figure></p><p><strong>删除主键</strong> <code>alter table 表名 drop primary key</code></p><p><strong>主键自增长</strong> <code>auto_increment</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid int PRIMARY KEY auto_increment,</span><br><span class="line">ename VARCHAR(20),</span><br><span class="line">esal INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>非空约束</strong> <code>not null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid int PRIMARY KEY auto_increment,</span><br><span class="line">ename VARCHAR(20) not null,</span><br><span class="line">esal INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>唯一约束</strong> <code>not null unique</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid int PRIMARY KEY auto_increment,</span><br><span class="line">ename VARCHAR(20) not null unique,</span><br><span class="line">esal INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据库的备份与恢复&quot;&gt;&lt;a href=&quot;#数据库的备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;数据库的备份与恢复&quot;&gt;&lt;/a&gt;数据库的备份与恢复&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;备份&lt;/strong&gt;：&lt;code&gt;mysqldump -u用户名 -p密码 数据库名&amp;gt;生成的脚本路径&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//末尾没有分号，也不要登录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysqldunp -uroot -p123 school&amp;gt;C:a.sql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;恢复&lt;/strong&gt;：&lt;code&gt;mysqldump -u用户名 -p密码 数据库名&amp;lt;生成的脚本路径&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;或者：登录之后，切换到需要恢复的数据库，输入：source 生成的脚本路径&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//要先删除school数据库，再重新创建数据库，这两步需要登录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//执行下面sql语句，不要登录，末尾没有分号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysqldunp -uroot -p123 school&amp;lt;C:a.sql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（二）——DQL</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94DQL/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（二）——DQL/</id>
    <published>2018-10-11T14:49:56.000Z</published>
    <updated>2018-10-11T15:15:53.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>关键字：select、from、where、group by、having、roder by</p><a id="more"></a><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><p>&emsp;&emsp;<strong>查询所有：</strong><code>select * from 表名;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_stu;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>查询部分列</strong><code>select 列名,...列名 from 表名;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select stu_num,stu_name from t_stu;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>查询去除完全重复的列</strong><code>select distinct * from 表名;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select distinct * from t_stu;</span><br><span class="line">select distinct stu_age from t_stu;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>也可以查询同时做加、减、乘、除运算操作</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//把查询出来的年龄都乘以2倍。</span><br><span class="line">select stu_age*2 from t_stu;</span><br><span class="line">//如果查出来的年龄为null，就设置为29</span><br><span class="line">select ifnull(stu_age,29) from t_stu;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>做连接字符串操作：CONCAT</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//把名字和年龄拼接起来</span><br><span class="line">select CONCAT(stu_name,stu_age) from t_stu;</span><br><span class="line"></span><br><span class="line">select CONCAT(&apos;我的名字是：&apos;,stu_name,&apos;，我今年&apos;,stu_age,&apos;岁&apos;) from t_stu;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>给列起别名：as</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select stu_age as 年龄 from t_stu;</span><br><span class="line">select stu_age as 年龄,stu_name as 姓名 from t_stu;</span><br><span class="line">select CONCAT(stu_name,stu_age) as 描述 from t_stu;</span><br></pre></td></tr></table></figure></p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>&emsp;&emsp;跟前面一篇讲的更新，删除里面设置条件的方法是一样的。<code>where</code>后面跟条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查询年龄大于等于20的学生</span><br><span class="line">select * from t_stu where stu_age&gt;=20;</span><br><span class="line">//查询年龄在15到25岁之间的学生</span><br><span class="line">select * from t_stu where stu_age between 15 and 25;</span><br><span class="line">//查询名字叫zhangsan,lisi,wangwu.zhaoliu的学生</span><br><span class="line">select * from t_stu where stu_name in(&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhangliu&apos;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>模糊查询</strong><code>like</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//一个字加一个下划线，两个字就是两个下划线</span><br><span class="line">//查询名字中张开头，并且是两个字的学生.</span><br><span class="line">select * from t_stu where stu_name like &apos;张_&apos;;</span><br><span class="line">//查询名字是三个字的学生</span><br><span class="line">select * from t_stu where stu_name like &apos;___&apos;;</span><br><span class="line"></span><br><span class="line">//百分号%匹配0~N个字符</span><br><span class="line">//查询名字中以雷结尾的学生</span><br><span class="line">select * from t_stu where stu_name like &apos;%雷&apos;;</span><br><span class="line">//查询名字中包含晓的学生</span><br><span class="line">select * from t_stu where stu_name like &apos;%晓%&apos;;</span><br></pre></td></tr></table></figure></p><h4 id="排序-order-by"><a href="#排序-order-by" class="headerlink" title="排序 order by"></a>排序 <code>order by</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// desc:降序，asc：升序</span><br><span class="line">//按学生年龄升序排列</span><br><span class="line">select * from t_stu ORDER BY stu_age ASC;</span><br><span class="line">//按学生年龄降序排列</span><br><span class="line">select * from t_stu ORDER BY stu_age DESC;</span><br><span class="line">//年龄相同的时候，按名字降序排列。可以无限添加排序条件</span><br><span class="line">select * from t_stu ORDER BY stu_age ASC,stu_name DESC;</span><br></pre></td></tr></table></figure><h4 id="聚合函数-纵向查询"><a href="#聚合函数-纵向查询" class="headerlink" title="聚合函数(纵向查询)"></a>聚合函数(纵向查询)</h4><p><code>计数count</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//只要不为null，就+1</span><br><span class="line">select count(*) from t_stu;</span><br><span class="line">select count(stu_age) from t_stu;</span><br></pre></td></tr></table></figure></p><p><code>计算和sum</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//计算学生年龄加起来的总数</span><br><span class="line">select sum(stu_age) from t_stu;</span><br></pre></td></tr></table></figure></p><p><code>最大值max,最小值min</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查询年龄中最大的</span><br><span class="line">select max(stu_age) from t_stu;</span><br><span class="line">//查询年龄中最小的</span><br><span class="line">select min(stu_age) from t_stu;</span><br></pre></td></tr></table></figure></p><p><code>平均值avg</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(stu_age) from t_stu;</span><br></pre></td></tr></table></figure></p><h4 id="分组查询group-by"><a href="#分组查询group-by" class="headerlink" title="分组查询group by"></a>分组查询<code>group by</code></h4><p>写法：<code>select 条件,聚合函数,...,聚合函数 from 表名 group by 条件;</code></p><p>分组查询必须都是聚合函数，并且，上面两个位置的条件必须相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//按老师分组查询，每组老师名下的学生个数</span><br><span class="line">select stu_teacher,count(*) from t_stu group by stu_teacher;</span><br><span class="line"></span><br><span class="line">//分组前条件，不满足条件的没有参加分组</span><br><span class="line">//按老师分组查询，查询每组老师名下年龄大于20岁的学生的个数</span><br><span class="line">select stu_teacher,count(*) from t_stu where stu_age&gt;20 group by stu_teacher;</span><br><span class="line"></span><br><span class="line">//having 分组后条件</span><br><span class="line">//按老师分组查询，查询老师名下年龄大于20岁的学生，并且剔除学生个数小于5个的老师</span><br><span class="line">select stu_teacher,count(*) from t_stu where stu_age&gt;20 group by stu_teacher having count(*)&lt;5;</span><br></pre></td></tr></table></figure><h4 id="limit-MySQL特有的"><a href="#limit-MySQL特有的" class="headerlink" title="limit(MySQL特有的)"></a>limit(MySQL特有的)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//从下标0开始，往后查询5条数据</span><br><span class="line">select * from t_stu limit 0,5;</span><br><span class="line"></span><br><span class="line">//分页查询，比方说如果你要查第N页的数据，每页数据M条</span><br><span class="line">//(当前页-1)*每页的数据数</span><br><span class="line">select * from t_stu limit (N-1)*M,M;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DQL&quot;&gt;&lt;a href=&quot;#DQL&quot; class=&quot;headerlink&quot; title=&quot;DQL&quot;&gt;&lt;/a&gt;DQL&lt;/h3&gt;&lt;p&gt;关键字：select、from、where、group by、having、roder by&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（一）——DDL、DML、DCL</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94DDL%E3%80%81DML%E3%80%81DCL/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（一）——DDL、DML、DCL/</id>
    <published>2018-10-11T14:49:35.000Z</published>
    <updated>2018-10-11T15:03:23.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL:"></a>MySQL:</h3><p>&emsp;&emsp;<strong>启动：</strong><code>net start mysql</code></p><p>&emsp;&emsp;<strong>停止：</strong><code>net stop mysql</code></p><p>&emsp;&emsp;<strong>登录：</strong><code>mysql -u root -p</code> 例如：mysql -uroot -p123 -hlocalhost</p><p>&emsp;&emsp;<strong>退出：</strong><code>exit或者quit</code></p><a id="more"></a><h3 id="DDL操作："><a href="#DDL操作：" class="headerlink" title="DDL操作："></a>DDL操作：</h3><p>&emsp;&emsp;加上if exists或者if not exists：都是如果存在，或者如果不存在，就不做相关操作</p><p>&emsp;&emsp;<strong>查询当前有哪些数据库：</strong><code>show databases;</code></p><p>&emsp;&emsp;<strong>创建数据库：</strong><code>CREATE DATABASE if not exists 数据库的名字 CHARSET=utf8;</code>例如：CREATE DATABASE if not exists employee CHARSET=utf8;创建一个编码为utf-8的employee数据库。不存在就创建，存在就不管。</p><p>&emsp;&emsp;<strong>删除数据库：</strong><code>DRAP DATABASE if exists 数据库名称;</code>例如：DRAP DATABASE if exists employee;删除employee数据库，如果存在就删除，不存在就不管。</p><p>&emsp;&emsp;<strong>修改数据库编码方式：</strong><code>ALTER DATABASE 数据库名称 CHARACTER SET utf8;</code></p><p>&emsp;&emsp;<strong>切换数据库：</strong><code>use 数据库名称;</code></p><p>&emsp;&emsp;<strong>创建表：</strong><code>CREATE TABLE if not exists 表名(列名 列类型,...,列名 列类型);</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE if noe exists t_stu(</span><br><span class="line"></span><br><span class="line">        stu_num char(11),</span><br><span class="line"></span><br><span class="line">        stu_name varchar(50),</span><br><span class="line"></span><br><span class="line">        stu_age int,</span><br><span class="line"></span><br><span class="line">        stu_sex varchar(10)</span><br><span class="line"></span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>显示当前数据库包含的表：</strong><code>show tables;</code></p><p>&emsp;&emsp;<strong>显示当前表结构：</strong><code>desc 表名称;</code></p><p>&emsp;&emsp;<strong>删除表：</strong><code>drop table 表名称;</code></p><p>&emsp;&emsp;<strong>新增列：</strong><code>alter table 表名 add(列名 列类型,...,列名 列类型);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu add(</span><br><span class="line"></span><br><span class="line">        stu_address varchar(100),</span><br><span class="line"></span><br><span class="line">        stu_phone char(11)</span><br><span class="line"></span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改列类型：</strong><code>alter table 表名 modify 列名 列新类型;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu modify stu_address varchar(50);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改列名：</strong><code>alter table 表名 change 原始列名 新列名 列类型;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu change stu_address stu_addr varchar(100);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>删除列：</strong><code>alter table 表名 drop 列名;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu drop stu_address;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>修改表名：</strong><code>alter table 原始表名 rename to 新表名;</code></p><h3 id="DML操作："><a href="#DML操作：" class="headerlink" title="DML操作："></a>DML操作：</h3><p>为了好操作，先用一下查询的命令，查询表的所有记录： select * from 表名;</p><p>&emsp;&emsp;<strong>插入一行记录：</strong><code>INSERT INTO 表名 (列名,...,列名)VALUES(列值,...,列值);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t_stu(</span><br><span class="line"></span><br><span class="line">        stu_num,stu_name,stu_age,stu_sex,stu_phone</span><br><span class="line">        </span><br><span class="line">        )VALUES(</span><br><span class="line">        </span><br><span class="line">        &apos;test_num_001&apos;,&apos;张三&apos;,18,&apos;man&apos;,&apos;13888888888&apos;</span><br><span class="line">        </span><br><span class="line">        );</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>修改所有数据：</strong><code>update 表名 set 列名=列值,...,列名=列值;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t_stu set name=&apos;wangwu&apos;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改数据(单个条件)：</strong><code>update 表名 set 列名=列值,...,列名=列值 where 列名=列值;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t_stu set stu_name=&apos;zhangsan&apos; where stu_num=&apos;testNum_00001&apos;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改数据(多个条件)：</strong><code>update 表名 set 列名=列值,...,列名=列值 where 列名=列值 or 列名=列值;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//or,或者</span><br><span class="line">update t_stu set stu_age=28 where stu_num=&apos;testNum_0001&apos; or stu_name=&apos;zhangliu&apos;;</span><br><span class="line">//and，并且</span><br><span class="line">update t_stu set stu_age=28 where stu_age&gt;=25 and stu_age&lt;=30;</span><br><span class="line">//between...and...在什么区间内</span><br><span class="line">update t_stu set stu_age=28 where stu_age between 25 and 30;</span><br><span class="line">//in(...)</span><br><span class="line">update t_stu set stu_age=28 where stu_name  in (&apos;zhangsan&apos;,&apos;lisi&apos;);</span><br><span class="line">//is null，是null。不能是stu_name=null</span><br><span class="line">update t_stu set stu_age=28 where stu_name  is null;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>删除记录：</strong><code>DELETE FROM 表名 where ...;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这里where后面的条件跟前面的update是一样的写法</span><br><span class="line">DELETE FROM t_stu where stu_age = 28;</span><br></pre></td></tr></table></figure></p><h3 id="DCL操作："><a href="#DCL操作：" class="headerlink" title="DCL操作："></a>DCL操作：</h3><p>&emsp;&emsp;<strong>创建用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//只要是写用户名的位置都可以设置固定ip，或者不固定ip</span><br><span class="line">CREATE USER 用户名@IP地址 IDENTIFIED BY &apos;密码&apos;;//固定ip登录</span><br><span class="line">CREATE USER 用户名@&apos;%&apos; IDENTIFIED BY &apos;密码&apos;;//任意ip登录</span><br><span class="line">CREATE USER zhangSan@&apos;%&apos; IDENTIFIED BY &apos;123&apos;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>给用户授权：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限1,权限2,...,权限n ON 数据库名称.* TO 用户名@ip地址;</span><br><span class="line">GRANT 权限1,权限2,...,权限n ON 数据库名称.* TO 用户名@&apos;%&apos;;</span><br><span class="line"></span><br><span class="line">GRANT CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT ON school.* TO zhangSan@&apos;%&apos;;</span><br><span class="line">//给所有权限</span><br><span class="line">GRANT ALL ON school.* TO zhangSan@&apos;%&apos;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>撤销权限：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE  权限1,权限2,...,权限n ON 数据库名称.* FROM 用户名@&apos;%&apos;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>查看用户权限：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR 用户名@ip地址;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>删除用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER 用户名@ip地址;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL:&quot;&gt;&lt;/a&gt;MySQL:&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;启动：&lt;/strong&gt;&lt;code&gt;net start mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;停止：&lt;/strong&gt;&lt;code&gt;net stop mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;登录：&lt;/strong&gt;&lt;code&gt;mysql -u root -p&lt;/code&gt; 例如：mysql -uroot -p123 -hlocalhost&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;退出：&lt;/strong&gt;&lt;code&gt;exit或者quit&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Android——MQTT推送</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E2%80%94%E2%80%94MQTT%E6%8E%A8%E9%80%81/"/>
    <id>http://haichenyi.com/2018/05/13/Android——MQTT推送/</id>
    <published>2018-05-13T14:28:22.000Z</published>
    <updated>2018-05-13T14:36:43.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h3><p>&emsp;&emsp;最近公司用到的推送MQTT。不想过多的介绍背景什么的，我就直接讲怎么实现这个功能。</p><p>&emsp;&emsp;他这个原理长连接，这个不用多讲，用法类似于EventBus，需要先订阅，然后通过topic再发送消息。topic是什么呢？我先来讲讲整体流程：</p> <a id="more"></a><ol><li><p>先连接服务器，要先建立长连接</p></li><li><p>然后需要订阅topic，连接之后才能订阅topic</p></li><li><p>最后就是通过topic推送消息，接收消息</p></li></ol><p>一步一步讲：</p><h3 id="第一步，与服务器建立连接"><a href="#第一步，与服务器建立连接" class="headerlink" title="第一步，与服务器建立连接"></a>第一步，与服务器建立连接</h3><p>&emsp;&emsp;先丢代码，然后看注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void initPush() &#123;</span><br><span class="line">        // 服务器地址（协议+地址+端口号）</span><br><span class="line">        String uri = host;</span><br><span class="line">        client = new MqttAndroidClient(this, uri, clientId);</span><br><span class="line">        // 设置MQTT监听并且接受消息</span><br><span class="line">        client.setCallback(mqttCallback);</span><br><span class="line">        //Mqtt的一些设置</span><br><span class="line">        conOpt = new MqttConnectOptions();</span><br><span class="line">        conOpt.setAutomaticReconnect(true);</span><br><span class="line">        // 清除缓存</span><br><span class="line">        conOpt.setCleanSession(true);</span><br><span class="line">        // 设置超时时间，单位：秒</span><br><span class="line">        conOpt.setConnectionTimeout(10);</span><br><span class="line">        // 心跳包发送间隔，单位：秒</span><br><span class="line">        conOpt.setKeepAliveInterval(20);</span><br><span class="line">        myTopic = String.format(TOPIC_SUB, mDeviceId);</span><br><span class="line">        Log.e(TAG,&quot;myTopic_________&quot;+myTopic);</span><br><span class="line">        doClientConnection();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><ol><li>第一个问题，与服务器建立连接，你得先有一个服务器吧？我根据网上的步骤，创建了一个apache-apollo服务器，并且启动了，也启动成功了，我建立连接的时候，总是失败。然后，找啊找，找啊找。问题没有解决，但是，我找到了一个可以用的服务器，也就是这里的uri，不要设置MqttConnectOptions的用户名和密码，设置了他会拒绝</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private String host = &quot;tcp://test.mosquitto.org:1883&quot;;</span><br></pre></td></tr></table></figure><ol><li>第二个问题，我连接成功之后，不一会，他就会自动断开连接，或者，推送完消息之后，他就会断开连接。然后，网上搜原因，找啊找，诶，我找到了。MqttAndroidClient的构造方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructor - create an MqttAndroidClient that can be used to communicate with an MQTT server on android</span><br><span class="line"> * </span><br><span class="line"> * @param context </span><br><span class="line"> *            object used to pass context to the callback. </span><br><span class="line"> * @param serverURI</span><br><span class="line"> *            specifies the protocol, host name and port to be used to</span><br><span class="line"> *            connect to an MQTT server</span><br><span class="line"> * @param clientId</span><br><span class="line"> *            specifies the name by which this connection should be</span><br><span class="line"> *            identified to the server</span><br><span class="line"> */</span><br><span class="line">public MqttAndroidClient(Context context, String serverURI,</span><br><span class="line">String clientId) &#123;</span><br><span class="line">this(context, serverURI, clientId, null, Ack.AUTO_ACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看第三个参数，clientId，指定一个名字，用来连接服务器的身份标识。就是说，你设置的这个值，是你在服务器的唯一标识，不能跟其他用户的相同。我把这个clientId直接用uuid生成，就没问题了。</p><h3 id="第二步，订阅topic"><a href="#第二步，订阅topic" class="headerlink" title="第二步，订阅topic"></a>第二步，订阅topic</h3><p>&emsp;&emsp;回到上面，接着往下面走，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 连接MQTT服务器</span><br><span class="line">     */</span><br><span class="line">    private void doClientConnection() &#123;</span><br><span class="line">        if (!client.isConnected() &amp;&amp; isConnectIsNormal()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                client.connect(conOpt, null, iMqttActionListener);</span><br><span class="line">            &#125; catch (MqttException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 判断网络是否连接</span><br><span class="line">     */</span><br><span class="line">    private boolean isConnectIsNormal() &#123;</span><br><span class="line">        ConnectivityManager connectivityManager = (ConnectivityManager) this.getApplicationContext()</span><br><span class="line">                .getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        if (connectivityManager != null) &#123;</span><br><span class="line">            NetworkInfo info = connectivityManager.getActiveNetworkInfo();</span><br><span class="line">            if (info != null &amp;&amp; info.isAvailable()) &#123;</span><br><span class="line">                String name = info.getTypeName();</span><br><span class="line">                Log.e(TAG, &quot;MQTT当前网络名称：&quot; + name);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.e(TAG, &quot;MQTT 没有可用网络&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法就是用来连接服务器的，首先判断是否正在连接，后面那个是判断当前有没有网络。再就是这个iMqttActionListener监听了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// MQTT是否连接成功</span><br><span class="line">    private IMqttActionListener iMqttActionListener = new IMqttActionListener() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onSuccess(IMqttToken arg0) &#123;</span><br><span class="line">            Log.e(TAG, &quot;连接成功 &quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 订阅myTopic话题</span><br><span class="line">                client.subscribe(myTopic, 0);</span><br><span class="line">            &#125; catch (MqttException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onFailure(IMqttToken arg0, Throwable arg1) &#123;</span><br><span class="line">            Log.e(TAG, &quot;连接失败&quot;);</span><br><span class="line">            arg1.printStackTrace();</span><br><span class="line">            // 连接失败，重连</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讷，就是这里，你如果服务器有问题，他一直走onFailure方法。服务器连接成功之后，就是订阅topic。我来说说这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.subscribe(myTopic, 0);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先，这个主题，是你自己跟服务器商量好的，随便什么都可以。为什么要订阅主题呢？我提前给你瞅瞅推送消息是怎么推送的</p><p>&emsp;&emsp;第二个参数，消息的类型qos，有三种：0、1、2</p><ol><li>0代表“至多一次”，消息发布完全依赖底层 TCP/IP 协议。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送</li><li>1代表“至少一次”，确保消息到达，但消息重复可能会发生</li><li>2代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。</li></ol><p>&emsp;&emsp;简单说明下，如果发送的是临时的消息，例如给某topic所有在线的设备发送一条消息，丢失的话也无所谓，0就可以了。如果需要客户端保证能接收消息，需要指定QoS为1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.publish(topic, new MqttMessage(msg.getBytes()));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讷，推送消息，是根据topic推送的，第二个参数，就是你要推送的具体消息。我个人认为，你可以理解成就类似于键值对的形式，</p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p>&emsp;&emsp;这个就是跟其他长连接不同的地方，底层，其实都一样，虽然我没有看底层的代码。想也想的到，服务器肯定是根据这个主题，去找对应的用户，然后推送消息。而其他的长连接就是直接指定用户。跑题了，跑题了。</p><h3 id="第三步，推送、接收消息"><a href="#第三步，推送、接收消息" class="headerlink" title="第三步，推送、接收消息"></a>第三步，推送、接收消息</h3><p>&emsp;&emsp;当你连接服务器成功之后，就要推送消息了，我用的EventBus发的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void publishData(String msg) &#123;</span><br><span class="line">        String topic = myTopic;</span><br><span class="line">        try &#123;</span><br><span class="line">            Log.e(TAG,&quot;给__&quot;+topic+&quot;__topic发送的消息为：&quot;+msg);</span><br><span class="line">            client.publish(topic, new MqttMessage(msg.getBytes()));</span><br><span class="line">        &#125; catch (MqttException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // MQTT监听并且接受消息</span><br><span class="line">    private MqttCallback mqttCallback = new MqttCallback() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void messageArrived(String topic, MqttMessage message) throws Exception &#123;</span><br><span class="line">            Log.e(TAG,&quot;接受到__&quot;+topic+&quot;__topic的消息为：&quot;+new String(message.getPayload()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void deliveryComplete(IMqttDeliveryToken arg0) &#123;</span><br><span class="line">            Log.e(TAG,&quot;deliveryComplete&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void connectionLost(Throwable arg0) &#123;</span><br><span class="line">            // 失去连接，重连</span><br><span class="line">            Log.e(TAG,&quot;失去连接&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当你的clientId重复的时候，他就会一直走connectionLost方法。到这里，基本上就讲完了，要注意的是，退出的时候，记得要释放资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (client != null &amp;&amp; client.isConnected()) &#123;</span><br><span class="line">                client.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (MqttException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        EventBus.getDefault().unregister(this);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>网上很多都是直接讲整体流程，重来不讲中间碰到的问题。难受</p><p><a href="https://download.csdn.net/download/qq_27634797/10408420" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;整体介绍&quot;&gt;&lt;a href=&quot;#整体介绍&quot; class=&quot;headerlink&quot; title=&quot;整体介绍&quot;&gt;&lt;/a&gt;整体介绍&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近公司用到的推送MQTT。不想过多的介绍背景什么的，我就直接讲怎么实现这个功能。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;他这个原理长连接，这个不用多讲，用法类似于EventBus，需要先订阅，然后通过topic再发送消息。topic是什么呢？我先来讲讲整体流程：&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android—React Native编程</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E2%80%94React-Native%E7%BC%96%E7%A8%8B/"/>
    <id>http://haichenyi.com/2018/05/13/Android—React-Native编程/</id>
    <published>2018-05-13T14:28:07.000Z</published>
    <updated>2018-05-13T14:32:04.667Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人博客：haichenyi.com。感谢关注</strong></p><h2 id="新公司，新的开始，新的技术"><a href="#新公司，新的开始，新的技术" class="headerlink" title="新公司，新的开始，新的技术"></a>新公司，新的开始，新的技术</h2><p>&emsp;&emsp;新公司的项目，用到的RN编程，之前完全没有碰到过，遇到新技术，之前完全没有碰到过怎么办？google、百度咯。通过不屑的努力，找到了<a href="https://www.jianshu.com/u/6e613846e1ea" target="_blank" rel="noopener">恋猫月亮 </a>的三篇关于RN的文章。我感觉还是很不错的。</p> <a id="more"></a><p><a href="https://www.jianshu.com/p/97692b1c451d" target="_blank" rel="noopener">从Android到React Native开发（一、入门）</a></p><p><a href="https://www.jianshu.com/p/bec040926db8" target="_blank" rel="noopener">从Android到React Native开发（二、通信与模块实现）</a></p><p><a href="https://www.jianshu.com/p/a488674d55b3" target="_blank" rel="noopener">从Android到React Native开发（三、自定义原生控件支持）</a></p><p>&emsp;&emsp;可以先浏览上面的第一篇入门，再过来看我这篇文章，我这篇文章就是讲怎么运行一个RN，我只是针对我的项目，把RN的部分提取了出来，上面大佬讲的比较全面。</p><h2 id="React-Native环境配置"><a href="#React-Native环境配置" class="headerlink" title="React Native环境配置"></a>React Native环境配置</h2><p><strong>开发工具</strong>：android studio。我不知道为什么要换开发工具。AS不好吗？环境还是跟你之前开发的一样配置，不用变</p><p><strong>python安装</strong>：python官网，下载安装。记得配置环境变量。不用非要按照他那个上面说的去安装。安装完成之后cmd里面敲python然后回车，看到如下界面:</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-a4af2b0fc841a608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="python.png"></p><p><strong>node.js安装</strong>：node也是一样，百度安装,配置完环境变量。cmd里面敲 npm -v然后回车，看到如下界面</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-62ea02b1913843e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="node.png"></p><p>最后，跑如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。</span><br><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br><span class="line">//React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</span><br><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，RN的配置就完成了。记得配置NDK环境，然后就是上你们公司的svn，或者git去down项目下来,应该还会有一个错误，那就是找不到<strong>react.gradle</strong>的路径，找到你添加依赖的那个gradle，在最上面添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: &quot;../../node_modules/react-native/react.gradle&quot;</span><br></pre></td></tr></table></figure><p>这个配置应该是添加greenDao那个是一样的，这样就能找到了<strong>react.gradle</strong></p><p>项目结构如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-86b8e4e093e337da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="project.png"></p><p>&emsp;&emsp;我用箭头标记了，你down下来的项目，应该是没有node_modules文件夹的，这个文件夹是怎么产生的呢？你在cmd进入你down的项目，就是图片上面的文件目录，跑如下命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>当命令运行完，就可以跑项目了。</p><h2 id="React-Native项目搭建"><a href="#React-Native项目搭建" class="headerlink" title="React Native项目搭建"></a>React Native项目搭建</h2><p>&emsp;&emsp;同鞋，你有freeStyle吗？有没有用过WebView？WebView就是在你的xml里面新增了一个WebView控件，RN也一样，他的这个控件就是ReactRootView。所以，这个控件哪里来？当然是添加依赖了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//版本号你自己找</span><br><span class="line">compile &apos;com.facebook.react:react-native:0.50.3&apos;</span><br></pre></td></tr></table></figure><p>最终的作用代码就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mReactRootView.startReactApplication(mReactInstanceManager, &quot;XXX&quot;, null);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个ReacRootView对象，你可以new出来，也可以写在xml里面findViewById。只要你能获取到这个对象就可以了，然后就是这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName, @Nullable Bundle initialProperties)</span><br></pre></td></tr></table></figure><p>三个参数</p><ol><li>ReactInstanceManager reactInstanceManager</li><li>String moduleName</li><li>@Nullable Bundle initialProperties</li></ol><h3 id="第一个参数：ReactInstanceManager"><a href="#第一个参数：ReactInstanceManager" class="headerlink" title="第一个参数：ReactInstanceManager"></a>第一个参数：<strong>ReactInstanceManager</strong></h3><p>就像配置WebView的参数，那些什么配置client允许js弹窗啊，新的页面直接覆盖原来的页面，并不是新建一个页面之类的参数，对应的这里，就是配置<strong>ReactInstanceManager</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReactInstanceManagerBuilder builder = ReactInstanceManager.builder();</span><br><span class="line">        builder = builder</span><br><span class="line">                .setApplication(getApplication())</span><br><span class="line">                .setBundleAssetName(&quot;index.android.bundle&quot;)</span><br><span class="line">                .setJSMainModulePath(&quot;index.android&quot;);</span><br><span class="line"></span><br><span class="line">        mReactInstanceManager = builder</span><br><span class="line">                .addPackage(new MainReactPackage())</span><br><span class="line">                .addPackage(new YzgHDReactPackage())</span><br><span class="line">//                .setUseDeveloperSupport(!Global.ISPRD)</span><br><span class="line">                .setUseDeveloperSupport(true)</span><br><span class="line">              .setInitialLifecycleState(LifecycleState.RESUMED)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;前面的builder的初始化是必须要写的，setApplication，如果你没有自己写application，那就直接getApplication，如果，你有自己实现application那就传你的application对象。</p><p>&emsp;&emsp;setBundleAssetName和setJSMainModulePath都是写死的，后面的名字也是写死的。</p><p>&emsp;&emsp;然后就是添加package，在package里面添加module。这里就是JS和Android相互调用的地方。package里面要实现ReactPackage，在createNativeModules里面去添加moudle</p><h3 id="第二个参数：String-moduleName"><a href="#第二个参数：String-moduleName" class="headerlink" title="第二个参数：String moduleName"></a>第二个参数：<strong>String moduleName</strong></h3><p>这个moudleName是怎么来的？就是我们前面设置的MoudlePath那个JS里面的。这里的路径应该是<strong>index.android.js</strong>，是一个js文件，打开之后，最下面有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppRegistry.registerComponent(&apos;zzz&apos;, () =&gt; XXX);</span><br></pre></td></tr></table></figure><p>这里的zzz就是我们这里需要传的名字</p><h3 id="第三个参数：Bundle-initialProperties"><a href="#第三个参数：Bundle-initialProperties" class="headerlink" title="第三个参数：Bundle initialProperties"></a>第三个参数：<strong>Bundle initialProperties</strong></h3><p>这里应该是传一个bundle，传输的数据，传个null就可以了</p><h2 id="React-Native流程"><a href="#React-Native流程" class="headerlink" title="React Native流程"></a>React Native流程</h2><p>&emsp;&emsp;前面的整个配置都配置完成之后，Android这边只用新建方法，给RN调用就可以了。新建的方法要用@ReactMethod标记。辣么，这个方法新建在哪呢？————Module，就是对应我们前面package里面添加的module。都说RN每个模块是独立的，怎么独立呢？就是这样独立的。每个模块功能对应一个module，每个都有该功能对应的方法。我就拿我这里的UserModule来举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class UserModule extends IModule implements NoticeListener&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static final String MODULE_NAME = &quot;User_Module&quot;;</span><br><span class="line"></span><br><span class="line">    private ReactApplicationContext mContext;</span><br><span class="line"></span><br><span class="line">    public UserModule(ReactApplicationContext reactContext) &#123;</span><br><span class="line">        super(reactContext);</span><br><span class="line">        this.mContext = reactContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return MODULE_NAME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户登录接口</span><br><span class="line">     * @param params</span><br><span class="line">     * @param callback</span><br><span class="line">     */</span><br><span class="line">    @ReactMethod</span><br><span class="line">    public void doLogin(String params, final Callback callback)&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,String&gt; map = GsonTool.gson2Map(params);</span><br><span class="line"></span><br><span class="line">        if(map == null || map.size() &lt;= 0)&#123;</span><br><span class="line">            callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;参数异常&quot;)));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final String userName = map.get(&quot;userName&quot;);</span><br><span class="line">        final String password = map.get(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">        if(TextUtils.isEmpty(userName) || TextUtils.isEmpty(password))&#123;</span><br><span class="line">            callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;用户名或密码不能为空&quot;)));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //登录</span><br><span class="line">        new Handler().post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                String result = new UserBridge().doLogin(userName,password, Global.DEVICE_ID,Global.APP_VERSION_NAME);</span><br><span class="line">                callback.invoke(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我就粘贴出来了部分代码，module要继承IModule，这个是一个抽象类，他继承ReactContextBaseJavaModule，最主要就是继承它，继承之后，我像说的就是这两个方法，getName()和注解的方法doLogin()。</p><p>&emsp;&emsp;我们可以看到，这个getName最终返回的是一个User_Module，这个字符串是怎么确定的呢？这个登录的方法名称是怎么确定的呢？</p><p>&emsp;&emsp;这些东西都是在js里面定义好的，这里是一个登录方法，我们打开登录的js。</p><p><strong>PS:</strong> 这里应该是通过js去确定我们这边的方法名，并不是通过这里的名称去确定js的。</p><p>&emsp;&emsp;我就不把JS代码，贴出来了，只贴出伪代码，打开js之后，搜索NativeModules。你应该会搜到类似的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; User_Module, Shop_Module &#125; = NativeModules;</span><br></pre></td></tr></table></figure><p>这里有两个Module，没错，就是两个。我们这里现在只关注User_Module，然后，我们搜索 User_Module，你会看到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">_onLogIn = () =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        const &#123; username, password &#125; = this.userInfo;</span><br><span class="line">        if (username.length &lt;= 0) return this._modal.Alert(&apos;请输入用户名&apos;);</span><br><span class="line">        if (password.length &lt;= 0) return this._modal.Alert(&apos;请输入密码&apos;);</span><br><span class="line">        this._button.setButton(false, &apos;正在登录...&apos;);</span><br><span class="line">        const params = &#123; userName: username, password &#125;;</span><br><span class="line">        // 登录</span><br><span class="line">        const _dologin = () =&gt; &#123;</span><br><span class="line">            return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123;</span><br><span class="line">                    const data = Other.callHandle(values) || &#123;&#125;;</span><br><span class="line">                    if (data.status) &#123;</span><br><span class="line">                        resolve(&apos;登录成功&apos;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        reject(data.message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>其他的一切，我们都不用管，我们在意的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123;</span><br><span class="line">                    const data = Other.callHandle(values) || &#123;&#125;;</span><br><span class="line">                    if (data.status) &#123;</span><br><span class="line">                        resolve(&apos;登录成功&apos;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        reject(data.message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个是我的项目里面的js，你们搜到的肯定跟我的不一样，我这里要说的是，怎么确定name的返回值，和注解方法。我们看到了，name就是这里的User_Module，方法就是这里的doLogin，android里面写用@ReactMethod标记，然后就是参数了，这里两个参数，一个是String，json格式的。用ArrayMap存储好key—value之后，转成字符串即可。第二个参数就是callback。android与JS通信，发送数据，就是一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback.invoke(&quot;data&quot;)</span><br></pre></td></tr></table></figure><p>他需要什么，你就发送什么。上面是RN主动调用Android方法，辣么，Android怎么主动调用RN方法呢？其实也很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//发送给RN</span><br><span class="line">        if (mReactInstanceManager.getCurrentReactContext() != null) &#123;</span><br><span class="line">            mReactInstanceManager.getCurrentReactContext()</span><br><span class="line">                    .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)</span><br><span class="line">                    .emit(PUSH_DATA_RN, mqttBean.info);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>就是获取ReactContext对象，通过调用getJSModule方法，参数传DeviceEventManagerModule.RCTDeviceEventEmitter.class这个类就可以了，然后通过调用emit方法，第一个参数，就是RN规定的方法名称，第二个参数就是需要传给RN的数据。为什么这样写呢？我们再来看看RN那边是怎么写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DeviceEventEmitter.addListener(&quot;push_data_rn&quot;,(data)=&gt;&#123;</span><br><span class="line">            alert(data)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>他就是通过这DeviceEventEmitter类添加addListener方法，传两个参数，第一个参数就是我们规定的名称，第二个参数就是一个回调，有一个参数，就是用来接收我们的数据，最后做的处理就是简单的弹窗，当然，这是我自己测试用的，最后RN要怎么坐，就是我要担心的问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;个人博客：haichenyi.com。感谢关注&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;新公司，新的开始，新的技术&quot;&gt;&lt;a href=&quot;#新公司，新的开始，新的技术&quot; class=&quot;headerlink&quot; title=&quot;新公司，新的开始，新的技术&quot;&gt;&lt;/a&gt;新公司，新的开始，新的技术&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;新公司的项目，用到的RN编程，之前完全没有碰到过，遇到新技术，之前完全没有碰到过怎么办？google、百度咯。通过不屑的努力，找到了&lt;a href=&quot;https://www.jianshu.com/u/6e613846e1ea&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;恋猫月亮 &lt;/a&gt;的三篇关于RN的文章。我感觉还是很不错的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
</feed>
