<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haichenyi.com/"/>
  <updated>2019-09-11T09:04:34.011Z</updated>
  <id>http://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot系列—Spring Data JPA（十二）</title>
    <link href="http://haichenyi.com/2019/09/11/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Spring-Data-JPA%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/11/SpringBoot系列—Spring-Data-JPA（十二）/</id>
    <published>2019-09-11T09:03:36.000Z</published>
    <updated>2019-09-11T09:04:34.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data"></a>什么是 Spring Data</h3><p>&emsp;&emsp;Spring Data 是 Spring Boot 底层默认进行数据访问的技术 , 为了简化构建基于 Spring 框架应用的数据访问技术，包<br>括非关系数据库、Map-Reduce 框架、云数据服务等；另外也包含对关系数据库的访问支持。</p><a id="more"></a><p>&emsp;&emsp;Spring Data 包含多个模块：</p><ul><li>Spring Data Commons 提供共享的基础框架，适合各个子项目使用，支持跨数据库持久化</li><li>Spring Data JPA</li><li>Spring Data KeyValue</li><li>Spring Data LDAP</li><li>Spring Data MongoDB</li><li>Spring Data Redis</li><li>Spring Data REST</li><li>Spring Data for Apache Cassandra</li><li>Spring Data for Apache Geode</li><li>Spring Data for Apache Solr</li><li>Spring Data for Pivotal GemFire</li><li>Spring Data Couchbase (community module)</li><li>Spring Data Elasticsearch (community module)</li><li>Spring Data Neo4j (community module)</li></ul><h3 id="Spring-Data统一的核心接口"><a href="#Spring-Data统一的核心接口" class="headerlink" title="Spring Data统一的核心接口"></a>Spring Data统一的核心接口</h3><p>&emsp;&emsp;Spring Data项目为大家提供统一的API来对不同的数据访问层进行操作。</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-1ce93a435bc0d30b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Repository继承图.png"></p><ul><li>Repository<t, id="">：统一的根接口即所有接口的父接口，其他接口继承该接口</t,></li><li>CrudRepository<t, id="">：基本的增删改查接口,提供了最基本的对实体类CRUD操作</t,></li><li>PagingAndSortingRepository<t, id="">：增加了分页和排序操作</t,></li><li>JpaRepository<t, id="">：增加了批量操作，并重写了父接口一些方法的返回类型</t,></li></ul><p>&emsp;&emsp;Spring Data JPA、JPA与Hibernate 关系</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d701cf2c06085ea6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关系图.png"></p><p>&emsp;&emsp;JPA是一种规范，而Hibernate是实现这种规范的底层实现，SpringData JPA对持久化接口JPA再抽象一层，针对持久化业务再进一步统一简化。</p><h3 id="SpringData-JPA的简单使用"><a href="#SpringData-JPA的简单使用" class="headerlink" title="SpringData JPA的简单使用"></a>SpringData JPA的简单使用</h3><p>&emsp;&emsp;JPA的底层遵守是ORM(对象关系映射)规范，因此JPA其实也就是java实体对象和关系型数据库建立起映射关系，通过<br>面向对象编程的思想操作关系型数据库的规范。</p><p><strong>首先，导包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.haichenyi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-jpa&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;spring-boot-jpa&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--jdbc的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--jpa的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--web项目的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mysql的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--简化set/get的包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>其次，创建映射bean类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.entity;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.persistence.*;</span><br><span class="line"></span><br><span class="line">//使用JPA注解配置映射关系</span><br><span class="line">@Entity//说明它是和数据表映射的类</span><br><span class="line">@Table(name = &quot;tbl_hobby&quot;)//指定对应映射的表名，省略默认表名就是类名</span><br><span class="line">@Data</span><br><span class="line">public class Hobby &#123;</span><br><span class="line">    @Id//标识主键</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)////标识自增长主键</span><br><span class="line">    private Integer id;</span><br><span class="line">    @Column(name = &quot;name&quot;, length = 10)//这是和数据表对应的一个列即字段名</span><br><span class="line">    private String name;</span><br><span class="line">    @Column//没有写，表字段名与这里的字段名相同</span><br><span class="line">    private Integer time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，这里需要写set/get方法，不然，数据存不进去。这里我用了 <strong>@Data</strong> 注解，所以，就不需要写了。注释写的很清楚了，就不一一解释了。</p><p><strong>接着，写Repository</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.repository;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjpa.entity.Hobby;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义接口继承JpaRepository，就会crud及分页等基本功能</span><br><span class="line"> */</span><br><span class="line">//指定的泛型&lt;操作的实体类，主键的类型&gt;</span><br><span class="line">public interface HobbyRepository extends JpaRepository&lt;Hobby, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再然后，就是Controller，跟之前写的一样</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjpa.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjpa.entity.Hobby;</span><br><span class="line">import com.haichenyi.springbootjpa.repository.HobbyRepository;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HobbyController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    HobbyRepository hobbyRepository;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hobby/&#123;id&#125;&quot;)</span><br><span class="line">    public Hobby getHobbyInfo(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">        Optional&lt;Hobby&gt; hobbyOptional = hobbyRepository.findById(id);</span><br><span class="line">        return hobbyOptional.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/save&quot;)</span><br><span class="line">    public Hobby saveHobby(Hobby hobby) &#123;</span><br><span class="line">        System.out.println(hobby);</span><br><span class="line">        return hobbyRepository.save(hobby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后，就只配置了</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样写完就行了。就这四步：</p><ol><li>映射表</li><li>Repository接口</li><li>Controller</li><li>配置文件</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是-Spring-Data&quot;&gt;&lt;a href=&quot;#什么是-Spring-Data&quot; class=&quot;headerlink&quot; title=&quot;什么是 Spring Data&quot;&gt;&lt;/a&gt;什么是 Spring Data&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Spring Data 是 Spring Boot 底层默认进行数据访问的技术 , 为了简化构建基于 Spring 框架应用的数据访问技术，包&lt;br&gt;括非关系数据库、Map-Reduce 框架、云数据服务等；另外也包含对关系数据库的访问支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—MyBatis（十一）</title>
    <link href="http://haichenyi.com/2019/09/07/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94MyBatis%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/07/SpringBoot系列—MyBatis（十一）/</id>
    <published>2019-09-07T10:56:22.000Z</published>
    <updated>2019-09-07T10:57:38.055Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇，Druid是用于处理数据库连接池与后台监控。</p><a id="more"></a><p>&emsp;&emsp;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。——百度百科</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;MyBatis添加依赖跟SpringBoot的其他启动器不一样，MyBatis需要写版本号，因为，SpringBoot并没有MyBatis的启动器。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="注解的方式"><a href="#注解的方式" class="headerlink" title="注解的方式"></a>注解的方式</h4><p>&emsp;&emsp;先看一下项目结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-010a61ea5cbc26cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构图.png"></p><p>&emsp;&emsp;首先，我们先在连接的数据库里面创建表，添加几条数据。</p><p>&emsp;&emsp;然后，创建pojo类User，对应我的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    public Long UserId;</span><br><span class="line">    public String Username;</span><br><span class="line">    public String password;</span><br><span class="line">    public String nickName;</span><br><span class="line">    public String headImg;</span><br><span class="line">    public Integer age;</span><br><span class="line">    public Integer sex;</span><br><span class="line">    public String address;</span><br><span class="line">    public String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着，创建mapper接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.mapper;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    @Select(&quot;select * from userinfo&quot;)</span><br><span class="line">    List&lt;User&gt; getUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就是一个普通的接口，用 <strong>@Mapper</strong> 标识了。然后写了一个获取用户信息的方法。 <strong>@Select</strong> 里面是sql语句。</p><p>&emsp;&emsp;用 <strong>@Mapper</strong> 标识的接口，在运行的过程中，会帮我们生成实现类，到时候，我们直接通过这个接口的引用调用这个方法即可。我们也可以在入口的位置用 <strong>@MapperScan</strong> 标识包名，应用启动的时候，会给这个包下面的所有接口都生成实现类。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc;</span><br><span class="line"></span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@MapperScan(&quot;com.haichenyi.springbootjdbc.mapper&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootJdbcApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootJdbcApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，就是我们的controller层了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.mapper.UserMapper;</span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/getUserInfo&quot;)</span><br><span class="line">    public List&lt;User&gt; getUserInfo() &#123;</span><br><span class="line">        return userMapper.getUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样，我们就可以通过 <a href="http://localhost:8080/getUserInfo" target="_blank" rel="noopener">http://localhost:8080/getUserInfo</a> 读到数据库中的数据了</p><p>&emsp;&emsp;只这样，我们读到的数据，如果表字段与pojo类的字段不一一对应，我们可能读到的数据为空，所以，我们要开启驼峰命名，开启之后MyBatis会帮我们一一对应好。怎么开启呢？就在我们前面的JdbcConfig中添加如下方法即可。就跟我们前面一篇Druid添加配置类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * MyBatis自定义配置</span><br><span class="line">  *</span><br><span class="line">  * @return ConfigurationCustomizer</span><br><span class="line">  */</span><br><span class="line"> @Bean</span><br><span class="line"> public ConfigurationCustomizer configurationCustomizer() &#123;</span><br><span class="line">     return configuration -&gt; &#123;</span><br><span class="line">         //开启驼峰命名</span><br><span class="line">         configuration.setMapUnderscoreToCamelCase(true);</span><br><span class="line">         //开启二级缓存</span><br><span class="line">         configuration.setCacheEnabled(true);</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样就可以了。</p><h4 id="xml的方式"><a href="#xml的方式" class="headerlink" title="xml的方式"></a>xml的方式</h4><p>&emsp;&emsp;前面和后面都是一样的，就是中间那不创建mapper接口不一样。xml中怎么创建mapper呢？</p><p>&emsp;&emsp;首先，还是创建一个正常的接口，定义方法。如下：注释写的很清楚了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.mapper;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootjdbc.pojo.User;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">//这里如果没有@Mapper注解，那就在启动类添加@MapperScan注解，上面已经说过怎么添加了。两种方式都可以，标记mapper的接口还是需要的</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">//这里的sql语句就不需要了，sql语句在xml里面配置。</span><br><span class="line">//    @Select(&quot;select * from userinfo&quot;)</span><br><span class="line">    List&lt;User&gt; getUserInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后，添加两个xml，一个是config，一个是写sql语句的。路径需要注意，先在resources目录下创建一个mybatis目录，在mybatis目录下创建mybatis-config.xml，在mybatis目录下创建mapper目录，然后在mapper目录下创建你的mapper.xml文件，如下：</p><p>&emsp;&emsp;这个是写mybatis配置文件的，名字我写的是：mybatis-config.xml，这个路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;!--开启驼峰命名--&gt;</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后就是创建mapper.xml，这里，我们以UserMapper.xml为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--namespace要是你前面创建mapper接口的全路径，这样才能对应--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.haichenyi.springbootjdbc.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;!--id：是你前面接口里面创建的方法名--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    resultType：这里的返回类型就是你接口读取数据对应的bean类，不管你需要的是集合，还是单个对象，这里都是你bean类，</span><br><span class="line">    如果你读取的是多条数据，它会自动帮你封装成list，拿到这个list，你再去做你其他的处理</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;getUserInfo&quot; resultType=&quot;com.haichenyi.springbootjdbc.pojo.User&quot;&gt;</span><br><span class="line">        select * from userinfo</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注释写的很清楚了。</p><p>&emsp;&emsp;再就是配置这个两个xml路径了，你需要在你的全局配置文件中配置好，指定对应的路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  #核心配置文件路径</span><br><span class="line">  config-location: classpath:mybatis/mybatis-config.xml</span><br><span class="line">  #映射配置文件路径</span><br><span class="line">  mapper-locations: classpath:mybatis/mapper/*.xml</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为啥非要创建一个mapper目录，再创建mapper文件呢？就是这里好指定。mapper文件肯定不止一个，难道你要一个一个的配置吗？这样写只用指定一个就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇，Druid是用于处理数据库连接池与后台监控。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Druid（十）</title>
    <link href="http://haichenyi.com/2019/09/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Druid%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/05/SpringBoot系列—Druid（十）/</id>
    <published>2019-09-05T08:05:30.000Z</published>
    <updated>2019-09-05T08:06:50.707Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;一个企业项目中最重要的部分那就是数据库了，对数据库的连接，读写是重中之重。在SpringBoot中数据库怎么连接呢？</p><a id="more"></a><h3 id="数据库的连接"><a href="#数据库的连接" class="headerlink" title="数据库的连接"></a>数据库的连接</h3><p>&emsp;&emsp;这里以MySql为例，还不会用MySql数据库的童鞋，可以看我之前的博客，<a href="https://blog.csdn.net/qq_27634797/article/category/8050256" target="_blank" rel="noopener">数据库相关</a>。</p><p>&emsp;&emsp; <strong>第一步，</strong> 我们首先在pom.xml中添加jdbc相关的启动器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--jdbc启动器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--mysql驱动包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; <strong>第二步，</strong> 在配置文件中配置连接数据库的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    #连接数据库的账号</span><br><span class="line">    username: root</span><br><span class="line">    #连接数据库的密码</span><br><span class="line">    password: 123456</span><br><span class="line">    #连接数据库的url</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    #连接数据库的驱动类</span><br><span class="line">    #mysql8之前用的是：com.mysql.jdbc.Driver。</span><br><span class="line">    #mysql8之后用的是：com.mysql.cj.jdbc.Driver</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 添加如上信息，就基本上完成了。测试一下连接就可以了。在我们的测试类中添加如下代码，看看打印的数据即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringBootJdbcApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() throws SQLException &#123;</span><br><span class="line">        System.out.println(&quot;dataSource: &quot; + dataSource.getClass());</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(&quot;connection: &quot; + connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 我们这里是测试数据库是否连接成功，我们才获取的这个连接，打印出来，我们项目里面实际操作数据库的时候，不需要我们获取这个连接，然后通过这个连接再去操作数据库。这是不需要，MyBatis通过Mapping注解直接操作数据库，我们只用写sql语句就可以了。</p><h3 id="Druid连接数据库"><a href="#Druid连接数据库" class="headerlink" title="Druid连接数据库"></a>Druid连接数据库</h3><p>&emsp;&emsp; DRUID是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是目前最好的连接池。</p><p>&emsp;&emsp; <strong>上面的配置继续保留。</strong></p><p>&emsp;&emsp; <strong>第一步：</strong> 我们在pom.xml里面添加druid的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.20&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; <strong>第二步：</strong> 在yml文件中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  # 数据库访问配置</span><br><span class="line">  datasource:</span><br><span class="line">    #账号</span><br><span class="line">    username: root</span><br><span class="line">    #密码</span><br><span class="line">    password: 123456</span><br><span class="line">    #连接的url</span><br><span class="line">    url: jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">    #驱动类</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # 主数据源，默认的</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">    # 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line">    # 初始化大小，最小，最大</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    # 配置获取连接等待超时的时间</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    # 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 25</span><br><span class="line">    # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">    filters: stat,wall,logback</span><br><span class="line">    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="line">    # 合并多个DruidDataSource的监控数据</span><br><span class="line">    useGlobalDataSourceStat: true</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 这样，就可以了。继续运行刚才的测试方法，你会发现，打印数据里面数据源已经变成了DruidDataSource。</p><p>&emsp;&emsp; 你如果是debug运行的，并且，你的断点打在connection那里，你会发现，我们yml文件中的补充配置，没起作用，是为什么呢？</p><p>&emsp;&emsp; 我们按住CTRL，鼠标左键点补充配置里面的任意一个变量，都点不动，我们点上面的type，url等等，都能点，我们点过去看，我们会发现跳到了 <strong>DataSourceProperties</strong> 。这个类，顾名思义这是数据源配置文件类。我们大致看一下这个类的代码：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d45a2867ff44d7f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DataSourceProperties类.png"></p><p>&emsp;&emsp; 用红色框框，框出来的地方是不是很眼熟？</p><p>&emsp;&emsp; 首先，我们先看注解 <strong>@ConfigurationProperties，</strong> 这个注解就是表示这个类是配置类，然后，我们看括号里面的参数 <strong>prefix，</strong> 顾名思义：前缀，前置代码。</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-12d38b8a5cbfc7cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="yml文件.png"></p><p>&emsp;&emsp; 如上图，上面的红色框框的内容，就由prefix决定，下面红色框框的内容，就由这个类的变量决定。我们上面的补充设置不起作用，就是因为这个配置文件里面没有这些变量，SpringBoot识别不了，所以，不起作用。SpringBoot不是万能的，它配置了的东西，可以识别，没有配置的，识别不了。</p><p>&emsp;&emsp; 怎么样让上面的补充配置起作用呢？有多种方式：</p><p>&emsp;&emsp; <strong>第一种方式如下：</strong> 简单粗暴，添加一个配置类即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource()&#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 这个方式就相当于，把我们上面的这个 <strong>DataSourceProperties</strong>配置类，换成了 <strong>DruidDataSource</strong>类。</p><p>&emsp;&emsp; <strong>第二种方式如下：</strong> 比较麻烦，也不算特别麻烦：说白了就是加载局部配置。</p><p>&emsp;&emsp;首先，在resources目录下，新建一个jdbc.properties文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#账号</span><br><span class="line">druid.datasource.username=root</span><br><span class="line">#密码</span><br><span class="line">druid.datasource.password=123456</span><br><span class="line">#连接的url</span><br><span class="line">druid.datasource.url=jdbc:mysql://localhost:3306/company?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">#驱动类</span><br><span class="line">druid.datasource.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line"># 主数据源，默认的</span><br><span class="line"># druid.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"># 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line"># 初始化大小，最小，最大</span><br><span class="line">druid.datasource.initialSize=5</span><br><span class="line">druid.datasource.minIdle=5</span><br><span class="line">druid.datasource.maxActive=20</span><br><span class="line"># 配置获取连接等待超时的时间</span><br><span class="line">druid.datasource.maxWait=60000</span><br><span class="line"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">druid.datasource.timeBetweenEvictionRunsMillis=60000</span><br><span class="line"># 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">druid.datasource.minEvictableIdleTimeMillis=300000</span><br><span class="line">druid.datasource.validationQuery=SELECT 1 FROM DUAL</span><br><span class="line">druid.datasource.testWhileIdle=true</span><br><span class="line">druid.datasource.testOnBorrow=false</span><br><span class="line">druid.datasource.testOnReturn=false</span><br><span class="line"># 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">druid.datasource.poolPreparedStatements=true</span><br><span class="line">druid.datasource.maxPoolPreparedStatementPerConnectionSize=25</span><br><span class="line"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">druid.datasource.filters=stat,wall,logback</span><br><span class="line"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">druid.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="line"># 合并多个DruidDataSource的监控数据</span><br><span class="line">druid.datasource.useGlobalDataSourceStat=true</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就是把我们刚才在全局配置中配置的信息，在专门的jdbc的配置文件中配置一遍。然后，修改我们的JdbcConfig类。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootjdbc.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@PropertySource(value = &quot;classpath:config/jdbc.properties&quot;, ignoreResourceNotFound = true)</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.driverClassName&#125;&quot;)</span><br><span class="line">    private String driverClassName;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.initialSize&#125;&quot;)</span><br><span class="line">    private Integer initialSize;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.minIdle&#125;&quot;)</span><br><span class="line">    private Integer minIdle;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxActive&#125;&quot;)</span><br><span class="line">    private Integer maxActive;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxWait&#125;&quot;)</span><br><span class="line">    private Long maxWait;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.timeBetweenEvictionRunsMillis&#125;&quot;)</span><br><span class="line">    private Long timeBetweenEvictionRunsMillis;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.minEvictableIdleTimeMillis&#125;&quot;)</span><br><span class="line">    private Long minEvictableIdleTimeMillis;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.validationQuery&#125;&quot;)</span><br><span class="line">    private String validationQuery;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testWhileIdle&#125;&quot;)</span><br><span class="line">    private Boolean testWhileIdle;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testOnBorrow&#125;&quot;)</span><br><span class="line">    private Boolean testOnBorrow;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.testOnReturn&#125;&quot;)</span><br><span class="line">    private Boolean testOnReturn;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.maxPoolPreparedStatementPerConnectionSize&#125;&quot;)</span><br><span class="line">    private Integer maxPoolPreparedStatementPerConnectionSize;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.poolPreparedStatements&#125;&quot;)</span><br><span class="line">    private Boolean poolPreparedStatements;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.filters&#125;&quot;)</span><br><span class="line">    private String filters;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.connectionProperties&#125;&quot;)</span><br><span class="line">    private String connectionProperties;</span><br><span class="line">    @Value(&quot;$&#123;druid.datasource.useGlobalDataSourceStat&#125;&quot;)</span><br><span class="line">    private Boolean useGlobalDataSourceStat;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() throws SQLException &#123;</span><br><span class="line">        DruidDataSource druidDataSource = new DruidDataSource();</span><br><span class="line">        druidDataSource.setUsername(username);</span><br><span class="line">        druidDataSource.setPassword(password);</span><br><span class="line">        druidDataSource.setUrl(url);</span><br><span class="line">        druidDataSource.setDriverClassName(driverClassName);</span><br><span class="line">        druidDataSource.setInitialSize(initialSize);</span><br><span class="line">        druidDataSource.setMinIdle(minIdle);</span><br><span class="line">        druidDataSource.setMaxActive(maxActive);</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);</span><br><span class="line">        druidDataSource.setValidationQuery(validationQuery);</span><br><span class="line">        druidDataSource.setTestOnBorrow(testOnBorrow);</span><br><span class="line">        druidDataSource.setTestOnReturn(testOnReturn);</span><br><span class="line">        druidDataSource.setTestWhileIdle(testWhileIdle);</span><br><span class="line">        druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);</span><br><span class="line">        druidDataSource.setPoolPreparedStatements(poolPreparedStatements);</span><br><span class="line">        druidDataSource.setFilters(filters);</span><br><span class="line">        druidDataSource.setConnectionProperties(connectionProperties);</span><br><span class="line">        druidDataSource.setUseGlobalDataSourceStat(useGlobalDataSourceStat);</span><br><span class="line">        return druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就是加载配置文件，然后在DataSource里面赋值。这样，就可以了。</p><h3 id="Druid后台监控"><a href="#Druid后台监控" class="headerlink" title="Druid后台监控"></a>Druid后台监控</h3><p>&emsp;&emsp;之所以用Druid连接池，还有很大一部分原因就是它的监控功能。它能很好的监控DB连接池和SQL语句的执行情况。在上面的JdbcConfig类中添加如下两个方法即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 配置Druid监控</span><br><span class="line"> *</span><br><span class="line"> * @return StatViewServlet</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean servletRegistrationBean() &#123;</span><br><span class="line">    ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //访问的用户名密码</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_USERNAME, &quot;haichenyi&quot;);</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_PASSWORD, &quot;123456&quot;);</span><br><span class="line">    //允许访问的ip，默认是所有ip</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_ALLOW, &quot;&quot;);</span><br><span class="line">    //禁止访问的ip</span><br><span class="line">    map.put(StatViewServlet.PARAM_NAME_DENY, &quot;192.168.1.1&quot;);</span><br><span class="line">    bean.setInitParameters(map);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 配置一个监控的filter</span><br><span class="line"> *</span><br><span class="line"> * @return WebStatFilter</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean filterRegistrationBean() &#123;</span><br><span class="line">    FilterRegistrationBean&lt;WebStatFilter&gt; bean = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">    bean.setFilter(new WebStatFilter());</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //移除这些监听</span><br><span class="line">    map.put(WebStatFilter.PARAM_NAME_EXCLUSIONS, &quot;*.js,*.css,/druid/*,*.gif,*.jpg,*.png&quot;);</span><br><span class="line">    bean.setInitParameters(map);</span><br><span class="line">    //拦截所有请求，全部都要走druid监听</span><br><span class="line">    bean.setUrlPatterns(Collections.singletonList(&quot;/*&quot;));</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注释写的很清楚了，控制台怎么访问呢？ <strong><a href="http://localhost:8080/druid" target="_blank" rel="noopener">http://localhost:8080/druid</a></strong>。访问控制台</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;一个企业项目中最重要的部分那就是数据库了，对数据库的连接，读写是重中之重。在SpringBoot中数据库怎么连接呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—自定义拦截器（九）</title>
    <link href="http://haichenyi.com/2019/09/05/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/05/SpringBoot系列—自定义拦截器（九）/</id>
    <published>2019-09-05T08:05:12.000Z</published>
    <updated>2019-09-05T08:07:12.816Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;拦截器拦截请求做额外的处理。</p><a id="more"></a><p><strong>举个栗子：登录拦截器，拦截所有的请求，必须登录之后才能访问。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.interceptors;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 登录拦截器</span><br><span class="line"> */</span><br><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(&quot;user&quot;);</span><br><span class="line">        if (user != null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(&quot;msg&quot;, &quot;您还没有登录，请先登录！&quot;);</span><br><span class="line">        request.getRequestDispatcher(&quot;/index.html&quot;).forward(request, response);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;新建LoginInterceptor实现HandlerInterceptor接口。这个接口有三个方法，<strong>pre，post，after，</strong>  看这个名字就可以想到这三个方法是怎么调用的，发送请求前，发送过程中，发送请求成功之后，所以，根据自己的需求，实现对应的方法即可。</p><p>&emsp;&emsp;我这里是登录拦截器，所以，在发送请求之前就要拦截，走自己的逻辑，如果，没有登陆过，就跳转登录界面，所以，我这里就实现了发送请求之前的回调，即preHandle方法。</p><p>&emsp;&emsp;然后，在你的SpringMvcConfiguration里面加上拦截器即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.config;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springbootbill.component.MyLocalResolver;</span><br><span class="line">import com.haichenyi.springbootbill.interceptors.LoginInterceptor;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.LocaleResolver;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class MySpringMvcConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebMvcConfigurer webMvcConfigurer() &#123;</span><br><span class="line">        return new WebMvcConfigurer() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">                registry.addViewController(&quot;/&quot;).setViewName(&quot;main/login&quot;);</span><br><span class="line">                registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;main/login&quot;);</span><br><span class="line">                registry.addViewController(&quot;/main/index.html&quot;).setViewName(&quot;main/index&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">                registry.addInterceptor(new LoginInterceptor())</span><br><span class="line">                        .addPathPatterns(&quot;/**&quot;)</span><br><span class="line">                        .excludePathPatterns(&quot;/&quot;, &quot;/index.html&quot;, &quot;/login&quot;)</span><br><span class="line">                        .excludePathPatterns(&quot;/css/*&quot;,&quot;/img/*&quot;,&quot;/images/*&quot;,&quot;/js/*&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public LocaleResolver localeResolver() &#123;</span><br><span class="line">        return new MyLocalResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实现addInterceptors方法，添加拦截器，然后添加了  <strong>addPathPatterns</strong> 拦截所有带这个参数的请求。接着，又添加了 <strong>excludePathPatterns</strong> 不拦截所有带这个参数的请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;拦截器拦截请求做额外的处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—国际化（八）</title>
    <link href="http://haichenyi.com/2019/09/02/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/09/02/SpringBoot系列—国际化（八）/</id>
    <published>2019-09-02T08:14:09.000Z</published>
    <updated>2019-09-02T08:17:26.887Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;所谓的国际化就是语言切换。中文切换到其他语种。</p><p>&emsp;&emsp;国际化的信息，这些都是需要开发人员在配置类中配置好的。SpringBoot会自动加载这些配置类。</p><a id="more"></a><p>举个栗子：以登录界面为例，我们的登录界面输入账号、密码框的左边，会有这两个提示，我们就自动修改这两个提示。</p><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>&emsp;&emsp;首先，你要在你的resources目录下面新建i18n目录，当然，不是必须的，可以不创建，直接创建文件。之所以创建这个目录，只是便于管理。</p><p>&emsp;&emsp;然后，在i18n目录下面创建配置文件，操作如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-255a3a0ff8446f2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建配置文件1.png"></p><p>&emsp;&emsp;在i18n的目录下面，新建一个Resources Bundle类型的文件，名字叫login</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-e1de577b76bc0c69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建配置文件2.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-53656dc0c2eff9f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建配置文件3.png"></p><p>&emsp;&emsp;点击+号，创建中文，英文两种语言的配置文件。中文叫 <strong>zh_CN</strong>，英文叫 <strong>en_US</strong>，这两种类型是写死的。</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-6a80accf3ee735cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建配置文件4.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-6e4ec6138b44e98a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建配置文件5.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-e9881dc3e5e21bbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建配置文件6.png"></p><p>&emsp;&emsp;根据如上操作，分别创建key为login.username，login.password，并且分别创建好对应的内容。这个key，页面会用到。</p><p>PS：不要忘记了，在全局配置文件中配置好，<strong>spring.messages.basename=i18n.login</strong>，这里现在是只有一个登陆页面需要国际化，如果有多个页面需要，比方说注册页面，就在后面添加。如：spring.messages.basename=i18n.login,i19n.register这样的方式，中间用逗号隔开即可。</p><h3 id="修改页面显示内容"><a href="#修改页面显示内容" class="headerlink" title="修改页面显示内容"></a>修改页面显示内容</h3><p>&emsp;&emsp;按照上面的步骤，创建好了之后，在你页面需要国际化的view，分别按如下的方式获取值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--th:text=&quot;#&#123;上面命名的key&#125;&quot;--&gt;</span><br><span class="line">&lt;div class=&quot;inputbox&quot;&gt;</span><br><span class="line">                &lt;label for=&quot;user&quot; th:text=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/label&gt;</span><br><span class="line">                &lt;input id=&quot;user&quot; type=&quot;text&quot; name=&quot;username&quot; required/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;inputbox&quot;&gt;</span><br><span class="line">                &lt;label for=&quot;mima&quot; th:text=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/label&gt;</span><br><span class="line">                &lt;input id=&quot;mima&quot; type=&quot;password&quot; name=&quot;password&quot; required/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义区域解析器"><a href="#自定义区域解析器" class="headerlink" title="自定义区域解析器"></a>自定义区域解析器</h3><p>&emsp;&emsp;区域解析器LocaleResolver，按如下的方式实现即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootbill.component;</span><br><span class="line"></span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line">import org.springframework.web.servlet.LocaleResolver;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义区域解析器</span><br><span class="line"> */</span><br><span class="line">public class MyLocalResolver implements LocaleResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123;</span><br><span class="line">        String l = httpServletRequest.getParameter(&quot;l&quot;);</span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        if (!StringUtils.isEmpty(l)) &#123;</span><br><span class="line">            String[] s = l.split(&quot;_&quot;);</span><br><span class="line">            locale = new Locale(s[0], s[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，在你对应的超链接的地方传 <strong>zh_CN</strong> 和 <strong>en_US</strong> 即可实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;所谓的国际化就是语言切换。中文切换到其他语种。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;国际化的信息，这些都是需要开发人员在配置类中配置好的。SpringBoot会自动加载这些配置类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—热部署与SpringMVC扩展功能（七）</title>
    <link href="http://haichenyi.com/2019/08/30/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E7%83%AD%E9%83%A8%E7%BD%B2%E4%B8%8ESpringMVC%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/30/SpringBoot系列—热部署与SpringMVC扩展功能（七）/</id>
    <published>2019-08-30T02:43:40.000Z</published>
    <updated>2019-08-30T02:44:40.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><p>&emsp;&emsp;默认情况下，在开发中我们修改一个项目文件后，想看到效果不得不重启应用，这会导致浪费大量时间，我们希望不重启应用的情况下，程序可以自动部署（热部署）。</p><a id="more"></a><p>&emsp;&emsp;<strong>第一步：禁用缓存</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#开发环境下关闭thymeleaf模板缓存，thymeleaf默认是开启状态。记得发布的时候要打开</span><br><span class="line">spring.thymeleaf.cache=false</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>第二步：添加热部署依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--热部署--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>第三步：手动编译文件</strong></p><p>&emsp;&emsp;IDEA中，修改文件后都是自动保存的，并不会手动编译，所以，需要手动编译一下。Ctrl + F9 （推荐使用）或 Build -&gt; Build Project。</p><h3 id="SpringMVC-扩展功能"><a href="#SpringMVC-扩展功能" class="headerlink" title="SpringMVC 扩展功能"></a>SpringMVC 扩展功能</h3><p>举个栗子：我要访问前面都是在controller里面，写方法，方法里面可以写逻辑，跳转某一个页面。我现在不需要写逻辑，就直接跳转就行了。我可以这样写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootwebthymeleaf.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        registry.addViewController(&quot;/success&quot;).setViewName(&quot;success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建一个类，继承WebMvcConfigurer，并用@Configuration标识</li><li>实现addViewControllers方法，里面registry里面像上面添加就行了，前面传链接名字，后面传视图名字即可。</li></ul><p>&emsp;&emsp;这只是添加控制层，还有其他的功能。可以看WebMvcConfigurer接口的方法。需要什么功能，实现什么方法就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;热部署&quot;&gt;&lt;a href=&quot;#热部署&quot; class=&quot;headerlink&quot; title=&quot;热部署&quot;&gt;&lt;/a&gt;热部署&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;默认情况下，在开发中我们修改一个项目文件后，想看到效果不得不重启应用，这会导致浪费大量时间，我们希望不重启应用的情况下，程序可以自动部署（热部署）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Thymeleaf（六）</title>
    <link href="http://haichenyi.com/2019/08/29/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Thymeleaf%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/29/SpringBoot系列—Thymeleaf（六）/</id>
    <published>2019-08-29T03:07:39.000Z</published>
    <updated>2019-08-29T03:09:04.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引用公共片段-th-fragment-th-replace-th-insert"><a href="#引用公共片段-th-fragment-th-replace-th-insert" class="headerlink" title="引用公共片段 th:fragment,th:replace,th:insert"></a>引用公共片段 th:fragment,th:replace,th:insert</h3><p>&emsp;&emsp;很多页面有很多相同的内容，比方说header和foot，这样的内容就需要公共片段引用了，修改一个地方就全部都改了。类似于android里面提取公共方法一样的道理。</p><a id="more"></a><p>方式如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-b3e215305db81084.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公共片段1.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-6a45b164e8f2d1ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公共片段2.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;公共片段&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--通过th:fragment申明公共片段--&gt;</span><br><span class="line">&lt;div th:fragment=&quot;header_common&quot;&gt;这里是公共片段的内容&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--通过id申明公共片段--&gt;</span><br><span class="line">&lt;div id=&quot;header_common_id&quot;&gt;这里是公共片段的内容&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--引入公共片段--&gt;</span><br><span class="line">&lt;div th:replace=&quot;header :: header_common&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div th:replace=&quot;header :: #header_common_id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>总共分为两步：</p><ol><li>创建header.html的文件，里面定义公共片段的内容，用th:fragment标明，值为header_common</li><li>在你需要用到这个公共部分的位置，通过th:fragment申明的片段用th:relpace引入，值为 文件名 空格 双冒号 空格 th:fragment的值。也就是这里的 <strong>header :: header_common</strong></li><li>通过id申明的片段用th:replace引入，值为 文件名 空格 双冒号 空格 # th:fragment的值。也就是这里的 <strong>header :: #header_common_id</strong></li></ol><p><strong><em>th:insert 和 th:replace的区别</em></strong></p><p>&emsp;&emsp;th:insert和th:replace都可以引入片段，用的方式是一样的，两者的区别在于 th:insert： 保留引入时使用的标签 th:replace：不保留引入时使用的标签, 将声明片段直接覆盖当前引用标签 </p><h3 id="迭代器-th-each"><a href="#迭代器-th-each" class="headerlink" title="迭代器 th:each"></a>迭代器 th:each</h3><p>&emsp;&emsp; 首先，创建一个实体类User。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootwebthymeleaf.pojo;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private Integer age;</span><br><span class="line">    //1:女，2:男</span><br><span class="line">    private Integer sex;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String username, Integer age, Integer sex) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其次，在controller创建一个获取User的方法。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/userInfo&quot;)</span><br><span class="line">public String getUserInfo(Model model) &#123;</span><br><span class="line">    List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">    userList.add(new User(&quot;小雪&quot;, 18, 1));</span><br><span class="line">    userList.add(new User(&quot;小红&quot;, 18, 1));</span><br><span class="line">    userList.add(new User(&quot;小东&quot;, 18, 2));</span><br><span class="line">    model.addAttribute(&quot;userList&quot;, userList);</span><br><span class="line">    return &quot;userInfo&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里，我用的model返回的数据，添加了一个属性以”userList”为键。页面直接获取这个键，就能拿到对应的值。之后返回userInfo页面。</p><p>&emsp;&emsp;最后页面的使用，如下，创建userInfo.html专门使用这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;用户信息&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;性别&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr th:each=&quot;user:$&#123;userList&#125;&quot;&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.sex==1?&apos;女&apos;:&apos;男&apos;&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li th:each=&quot;user:$&#123;userList&#125;&quot; th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    user : 第1个值,代表每次迭代出对象,名字任意取</span><br><span class="line">    iterStat : 第2个值,代表每次迭代器内置对象, 名字任意取, 并有如下属性:</span><br><span class="line">        index : 当前迭代下标 0 开始</span><br><span class="line">        count : 当前迭代下标 1 开始</span><br><span class="line">        size : 获取总记录数</span><br><span class="line">        current : 当前迭代出的对象</span><br><span class="line">        even/odd : 当前迭代是偶数还是奇数 (1开始算,返回布尔值)</span><br><span class="line">        first : 当前是否为第一个元素</span><br><span class="line">        last : 当前是否为最后一个元素</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;tr th:each=&quot;user,iterStat:$&#123;userList&#125;&quot;&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;user.sex==1?&apos;女&apos;:&apos;男&apos;&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.index&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.count&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.size&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.current&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.even&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.first&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;iterStat.last&#125;&quot;&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意的地方就是：</p><ul><li><strong>th:each=”user:${userList}”</strong>，这里可以参考java里面的foreach循环，冒号前面是当前循环的变量(冒号前面可以有两个值)，冒号后面是集合。这个集合怎么获取到的？就是通过userList这个键。第二步存的。</li><li>拿到这个集合中的每一个变量值了，用就很简单了。</li></ul><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3 th:if=&quot;not $&#123;#lists.isEmpty(userList)&#125;&quot;&gt;th:if判断,如果此文字显示说明有值&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3 th:unless=&quot;$&#123;#lists.isEmpty(userList)&#125;&quot;&gt;th:unless判断,如果此文字显示说明有值&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;div th:switch=&quot;$&#123;flag&#125;&quot;&gt;</span><br><span class="line">        &lt;p th:case=&quot;1&quot; th:text=&quot;女&quot;&gt;&lt;/p&gt;</span><br><span class="line">        &lt;p th:case=&quot;2&quot; th:text=&quot;男&quot;&gt;&lt;/p&gt;</span><br><span class="line">        &lt;!--上面两条都不生效，则下面th:case=&quot;*&quot;生效，类似于default--&gt;</span><br><span class="line">        &lt;p th:case=&quot;*&quot; th:text=&quot;未知&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引用公共片段-th-fragment-th-replace-th-insert&quot;&gt;&lt;a href=&quot;#引用公共片段-th-fragment-th-replace-th-insert&quot; class=&quot;headerlink&quot; title=&quot;引用公共片段 th:fragment,th:replace,th:insert&quot;&gt;&lt;/a&gt;引用公共片段 th:fragment,th:replace,th:insert&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;很多页面有很多相同的内容，比方说header和foot，这样的内容就需要公共片段引用了，修改一个地方就全部都改了。类似于android里面提取公共方法一样的道理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Thymeleaf（五）</title>
    <link href="http://haichenyi.com/2019/08/27/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Thymeleaf%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/27/SpringBoot系列—Thymeleaf（五）/</id>
    <published>2019-08-27T03:23:20.000Z</published>
    <updated>2019-08-27T03:24:19.573Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;SpringBoot官方不推荐使用JSP，因为内嵌Tomcat，Jetty容器不支持以jar的方式运行JSP。SpringBoot中提供了大量模板引擎，包含Freemarker，Mastache，Thymeleaf等。而SpringBoot官方推荐使用Thymeleaf作为模板引擎，因为Thymeleaf提供了完美的SpringMVC的支持。</p><a id="more"></a><h3 id="添加启动器"><a href="#添加启动器" class="headerlink" title="添加启动器"></a>添加启动器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- thymeleaf 模板启动器 --&gt; </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="添加模板文件"><a href="#添加模板文件" class="headerlink" title="添加模板文件"></a>添加模板文件</h3><h4 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h4><p>&emsp;&emsp; 模板文件，就是我们创建的HTML文件，将创建好的 HTML 页面放到 <strong>classpath:/templates/</strong> 目录下， Thymeleaf 就能自动渲染。就是我们的 <strong>resources/templates/</strong>目录。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>&emsp;&emsp; 自动渲染数据从哪里来呢？跟写APP端的接口差不多，就是少了响应@ResponseBody注解。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springbootwebthymeleaf.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * APP接口</span><br><span class="line">     * @return 返回一个字符串</span><br><span class="line">     */</span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String sayHello() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回模板文件</span><br><span class="line">     * @return 返回名字叫success的HTML页面</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/hello1&quot;)</span><br><span class="line">    public String sayHello1() &#123;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目结构图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-e2d0fb8a7dabe9b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构图.png"></p><p>&emsp;&emsp; 如上所示，当访问 <strong><a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></strong>的时候，返回的是一个字符串叫hello。当访问<br><strong><a href="http://localhost:8080/hello1" target="_blank" rel="noopener">http://localhost:8080/hello1</a></strong>的时候，他会转到我们上面说的templates目录下的success.html页面。</p><h3 id="thymeleaf语法使用"><a href="#thymeleaf语法使用" class="headerlink" title="thymeleaf语法使用"></a>thymeleaf语法使用</h3><h4 id="HTML中添加命名空间"><a href="#HTML中添加命名空间" class="headerlink" title="HTML中添加命名空间"></a>HTML中添加命名空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:th=&quot;http://www.thymeleaf.org&quot;</span><br></pre></td></tr></table></figure><h4 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 返回模板文件</span><br><span class="line">     * @return 返回名字叫success的HTML页面</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/hello1&quot;)</span><br><span class="line">    public String sayHello1(Map&lt;String,Object&gt; map) &#123;</span><br><span class="line">        map.put(&quot;name&quot;,&quot;我是海晨忆&quot;);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;还上啊上面的那个方法，添加了一个map参数。这个参数就是返回给success界面的数据存放容器。存放了一个键值对，键是name</p><p>&emsp;&emsp;界面怎么使用呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;success模板文件&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;success 模板文件&lt;/p&gt;</span><br><span class="line">&lt;p2 th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/p2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就这样，直接使用这个键即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;SpringBoot官方不推荐使用JSP，因为内嵌Tomcat，Jetty容器不支持以jar的方式运行JSP。SpringBoot中提供了大量模板引擎，包含Freemarker，Mastache，Thymeleaf等。而SpringBoot官方推荐使用Thymeleaf作为模板引擎，因为Thymeleaf提供了完美的SpringMVC的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—全局配置（四）</title>
    <link href="http://haichenyi.com/2019/08/23/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/23/SpringBoot系列—全局配置（四）/</id>
    <published>2019-08-23T07:18:39.000Z</published>
    <updated>2019-08-23T07:20:41.326Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;用IDEA可以直接创建SpringBoot项目，创建Moudle的时候，在选Maven的地方，选择Sping Initializr即可，很简单。前面讲过了IDEA生成Maven项目，并且嵌入SpringBoot，直接创建Spring Boot项目就是IDEA直接帮我们依赖，并且生成Application和properties文件。其它，也没啥大的区别，就不多说了。</p><a id="more"></a><p>&emsp;&emsp;本篇要讲的是SpringBoot的配置文件，分为两种：</p><ul><li>properties</li><li>yml</li></ul><p>&emsp;&emsp;之前，搜SpringBoot的配置文件怎么写的时候，看到网上很多博客都有文件内容，但是有两种写法，就是这两种配置文件的不同写法。</p><p>&emsp;&emsp;举个栗子，我现在要修改服务器启动的端口号，用properties怎么修改呢？很简单：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-76e2361266076b75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="properties修改端口号.png"></p><p>&emsp;&emsp;如上图所示，是不是很简单？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用yml怎么修改呢？也不难：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-232396ecff53ce0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="yml修改端口号.png"></p><p>&emsp;&emsp;如上图所示：也不难</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 808</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>看到了上面两个图片，应该也已经发现了，两个配置文件存放位置都在resource目录下面。或者在类路径的”/config”路径下</strong></p><p>&emsp;&emsp;这两种写法要怎么写呢？</p><p><strong>properties：</strong> 等号连接，右边是值</p><p><strong>yml：key:</strong></p><ul><li>value 表示一对键值对（冒号后面必须要有空格）</li><li>使用空格缩进表示层级关系</li><li>左侧缩进的空格数目不重要，只要同一层级的元素左侧对齐即可</li><li>key 与 value 大小写敏感</li></ul><p>PS: yml不管是存map，还是list，都要记得<strong>key后面的冒号一定要跟空格，再写值</strong></p><p>&emsp;&emsp;举个栗子，我们定义一个bean类，在配置文件里面赋值，在项目里面取出来用。比方说：我们项目里面定义一个Userbean类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.PropertySource;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;user&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String nickname;</span><br><span class="line">    private String password;</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里有几点需要注意：</p><ol><li>这里的bean类，必须要有写set/get方法，不然赋不了值，我这里没写是因为我用的@Data这个注解，它默认帮我们创建了set/get方法</li><li>@ConfigurationProperties注解就是 告诉SpringBoot将配置文件中对应属性的值，映射到这个组件类中,进行一 一绑定，prefix = “user”的作用就是配置文件中的前缀名，哪个前缀与下面的所有属性进行一一映射</li><li>@Component 注解就是将当前组件也就是这个bean类作为SpringBoot中的一个组件，才能使用容器提供的</li></ol><p>然后就是在配置文件中赋值，properties或者是yml，都可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">properties中：</span><br><span class="line"></span><br><span class="line"> server.port=8081</span><br><span class="line">user.username=s19734682s</span><br><span class="line">user.age=20</span><br><span class="line">user.password=123456</span><br><span class="line">user.nickname=林汐痕</span><br><span class="line"></span><br><span class="line">yml中：</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8088</span><br><span class="line">  </span><br><span class="line">//这个user就是上面说的配置文件中的前缀名</span><br><span class="line">user:</span><br><span class="line">  nickname: 海晨忆</span><br><span class="line">  username: pk19734682</span><br><span class="line">  password: 123456</span><br><span class="line">  age: 18</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;怎么使用呢？直接在controller中用这个user就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.controller;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboot.pojo.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class SayController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/say&quot;)</span><br><span class="line">    public String say() &#123;</span><br><span class="line">        return &quot;hello &quot; +user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就这样，请求这个接口就能打印值。</p><p>&emsp;&emsp;还有通过@Value指定值的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class SayController &#123;</span><br><span class="line">    @Value(&quot;$&#123;user.nickname&#125;&quot;)</span><br><span class="line">    private String nickname;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/say&quot;)</span><br><span class="line">    public String say() &#123;</span><br><span class="line">        return &quot;hello &quot; + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PropertySource-加载局部配置文件"><a href="#PropertySource-加载局部配置文件" class="headerlink" title="@PropertySource 加载局部配置文件"></a>@PropertySource 加载局部配置文件</h3><p>&emsp;&emsp;什么叫加载局部配置文件呢？就是加载指定的配置文件，并不是从properties或者是yml中加载。怎么加载呢？如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-fe36cc730ce0d98f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="局部配置文件.png"></p><p><strong>第一步，</strong> 在resources目录下创建xxx.properties/xxx.yml，这个xxx你自己命名。我这里创建的是user.properties/user.yml。记得语法不要写错了</p><p><strong>第二步，</strong> 在你的组件的地方加上@PropertySource注解。图上有，可以导入多个局部配置，用逗号隔开，每个局部配置的写法就是 <strong>“classpath:文件名”</strong> 之前导入全局的配置的时候加的注解也需要，不能删除。</p><p><strong>第三步，</strong> 之前是怎么使用的，现在还是怎么使用。</p><h3 id="ImportResource加载xml配置文件"><a href="#ImportResource加载xml配置文件" class="headerlink" title="@ImportResource加载xml配置文件"></a>@ImportResource加载xml配置文件</h3><p>&emsp;&emsp;Spring Boot框架并不推荐用xml加载配置文件，这个是Spring加载文件的方式。项目中如果必须要用到xml加载文件，要怎么办呢？</p><p>举个栗子：我要加载一个Service类到项目中。Spring Boot有注解可以直接使用，这里，我们通过xml加载。</p><p><strong>第一步，</strong> 创建一个service。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.service;</span><br><span class="line"></span><br><span class="line">public class UserService &#123;</span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;xml...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步，</strong> 在resources目录下，创建spring config的xml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;userService&quot; class=&quot;com.haichenyi.springboot.service.UserService&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，添加了一个bean类，两个属性，id和class。class指向刚才创建的类，id用于获取这个类。</p><p><strong>第三步，</strong> 在我们的引导类中加上 <strong>@ImportResource</strong> 注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line">@ImportResource(locations = &quot;classpath:springboot01.xml&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBootInitApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBootInitApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步，</strong> 通过ApplicationContext的getBean方法获取，传的参数就是在xml中定义的id。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboot.pojo.User;</span><br><span class="line">import com.haichenyi.springboot.service.UserService;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringBootInitApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void textXml() &#123;</span><br><span class="line">        UserService userService = (UserService) context.getBean(&quot;userService&quot;);</span><br><span class="line">        userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义配置类向容器中注入组件-SpringBoot推荐"><a href="#自定义配置类向容器中注入组件-SpringBoot推荐" class="headerlink" title="自定义配置类向容器中注入组件(SpringBoot推荐)"></a>自定义配置类向容器中注入组件(SpringBoot推荐)</h3><p>举个栗子：跟上面xml的例子一样。</p><p><strong>第一步，</strong> 跟上面一样，创建一个service</p><p><strong>第二步，</strong> 创建配置类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.springboot.custom;</span><br><span class="line"></span><br><span class="line">import com.haichenyi.springboot.service.UserService;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class UserConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userService2() &#123;</span><br><span class="line">        return new UserService();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的地方：</strong></p><ul><li>@Configuration 用于标识当前类是一个配置类，用来表示对应spring配置文件</li><li>@Bean 标识的方法用于向容器注入组件</li><li>方法的返回值就是注入容器中的组件对象</li><li>方法名是这个组件对象的 id值</li></ul><p><strong>第三步，</strong> 就是使用了，跟上面第四步一样。不需要上面的第三步。</p><h3 id="Profile多环境支持"><a href="#Profile多环境支持" class="headerlink" title="Profile多环境支持"></a>Profile多环境支持</h3><p>&emsp;&emsp;profile是Sping用来针对不同的环境要求，提供不同的配置支持。什么不同的环境呢？比方说：开发环境，生产环境。</p><p>&emsp;&emsp;全局 Profile 配置使用的文件名可以是<br>application-{profile}.properties / application-{profile}.yml 。如：application-dev.properties / application-prod.properties</p><p><strong>举个栗子：</strong></p><p>&emsp;&emsp;我们的项目环境分为 开发 （dev）和 生产（prod）环境 ，开发环境下端口号为 8081，<br>生产环境下端口号为8082。</p><h4 id="通过properties文件指定"><a href="#通过properties文件指定" class="headerlink" title="通过properties文件指定"></a>通过properties文件指定</h4><p><img src="https://upload-images.jianshu.io/upload_images/7041675-5c46596d9f105dd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="profile-properties.png"></p><p>&emsp;&emsp;如上图，创建了两个文件：application-dev.properties，application-prod.properties，里面内容很简单，就是指定端口号。server.port=8081</p><p>&emsp;&emsp;然后，我们在application.properties文件中指定激活哪一个文件即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//激活application-dev.properties配置</span><br><span class="line">spring.profiles.active=dev</span><br><span class="line"></span><br><span class="line">//激活application-prod.properties配置</span><br><span class="line">spring.profiles.active=prod</span><br></pre></td></tr></table></figure><h4 id="通过yml文件指定"><a href="#通过yml文件指定" class="headerlink" title="通过yml文件指定"></a>通过yml文件指定</h4><p>&emsp;&emsp;不用新建文件，直接在application.yml写就可以了。</p><p><strong>PS:需要用三个减号隔开，表示不同的文档块。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod #激活哪个profile , 当前激活的是 prod 开发环境</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: dev #指定属于哪个环境, dev 环境时使用</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: prod #指定属于哪个环境, prod 环境时使用</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;用IDEA可以直接创建SpringBoot项目，创建Moudle的时候，在选Maven的地方，选择Sping Initializr即可，很简单。前面讲过了IDEA生成Maven项目，并且嵌入SpringBoot，直接创建Spring Boot项目就是IDEA直接帮我们依赖，并且生成Application和properties文件。其它，也没啥大的区别，就不多说了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—@SpringBootApplication源码解析（三）</title>
    <link href="http://haichenyi.com/2019/08/22/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94-SpringBootApplication%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/22/SpringBoot系列—-SpringBootApplication源码解析（三）/</id>
    <published>2019-08-22T08:20:22.000Z</published>
    <updated>2019-08-22T08:21:25.307Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇，内容很少，说了一下SpringBoot的底层是怎么依赖的。这一篇讲一下SpringBoot底层源码是怎么实现的。</p><a id="more"></a><p>&emsp;&emsp;从SpringBoot的入口开始。第一篇的时候说过了，最好把入口文件放在最外层的包下面，至于原因就不多阐述了。</p><p>&emsp;&emsp;说说这个 <strong>@SpringBootApplication</strong>注解的原理,点进去看一下：</p><p>如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-a3f5cc4478dcff2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="springbootapplication注解.png"></p><p>主要就是这三个注解：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>&emsp;&emsp;SpringBootConfiguration这个注解是由Configuration注解实现的。</p><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>&emsp;&emsp;从名字上就可以判断出，这个注解是跟SpringBoot配置相关的，<strong>@Configuration</strong>，这个注解是Spring底层的一个注解，之前都是配置xml，SpringBoot推荐我们用配置类来描述配置，配置类是什么呢？就用@Configuration标记的类。</p><p>&emsp;&emsp;Configuration这个注解是由Component注解实现。</p><h5 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h5><p>&emsp;&emsp;这个注解的意义就是，把当前的配置类添加到spring容器中，表示是一个组件。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>&emsp;&emsp;EnableAutoConfiguration这个注解是由<strong>AutoConfigurationPackage</strong>和<strong>@Import({AutoConfigurationImportSelector.class})</strong>注解实现</p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>&emsp;&emsp;这个注解从名字上面看出来是自动配置包，这是什么意思呢？在第一篇我们就说过了入口要放在最外层的包，至于原因，已经讲过了，因为SpringBoot会自动将引导类 <strong>@SpringBootApplication标注的类</strong>所在的包以及下面所有子包里面所有的组件扫描到Spring容器中统一管理。就是这个注解实现的。那么，这个注解是怎么实现的呢？就是通过它的这个 <strong>@Import({Registrar.class})</strong>，下面就是Registrar类的源码了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;</span><br><span class="line">        Registrar() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">            AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">            return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就是通过下面这个代码注册进去的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());</span><br></pre></td></tr></table></figure><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p>&emsp;&emsp;这个注解是干什么用的呢？</p><ol><li>它会把项目里面所有需要导入的组件以全类名的方式返回，将这些组件添加到容器中。</li><li>会给容器中注入非常多的自动配置类，就是导入并配置好当前项目中<br>所需要的组件,省去我们手动编写配置去注入组件。</li></ol><p>&emsp;&emsp;怎么实现的呢？打开AutoConfigurationImportSelector类，找到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br></pre></td></tr></table></figure><p>找到getCandidateConfigurations方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">        return configurations;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>找到loadFactoryNames方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">        String factoryClassName = factoryClass.getName();</span><br><span class="line">        return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>找到loadSpringFactories方法，里面有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);</span><br></pre></td></tr></table></figure><p>这里就是我们的配置，我们这个配置具体是在哪呢？如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-041b65a5da3b0aec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="autoConfigure.png"></p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>&emsp;&emsp;这个注解的主要作用就是，被该注解标识的类会被Spring容器纳入管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇，内容很少，说了一下SpringBoot的底层是怎么依赖的。这一篇讲一下SpringBoot底层源码是怎么实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—底层依赖（二）</title>
    <link href="http://haichenyi.com/2019/08/22/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94%E5%BA%95%E5%B1%82%E4%BE%9D%E8%B5%96%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/22/SpringBoot系列—底层依赖（二）/</id>
    <published>2019-08-22T07:01:05.000Z</published>
    <updated>2019-08-22T07:05:28.913Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前面，我们创建了一个Spring Boot的hello world，我们仅仅添加了一个<strong>spring-boot-starter-parent</strong>，它是怎么帮我们实现这个依赖的呢？我们可以点进去看一下<strong>Ctrl+鼠标左键</strong>，如下图：</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/7041675-ab0e7668fd2e1a0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="parent的pom文件1.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-4a0a4fe1b86f57de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="parent的pom文件2.png"></p><p>&emsp;&emsp;我们发现它，还有一个父级依赖<strong>spring-boot-dependencies</strong>，我们继续点进去看，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-ef877b011a93bb32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dependencies的pom文件.png"></p><p>&emsp;&emsp;在这个pom文件里面，我们发现了，它定义很多个框架的版本号，这里就是，我们在自己项目里面引入框架不需要加版本号的原因。因为，它帮我们定义好了，它会自动依赖这里定义的版本。spring测试通过的，不会有冲突。</p><p>&emsp;&emsp;我们后面还依赖了一个<strong>spring-boot-starter-web</strong>这个框架，这里分两部分：</p><ul><li>spring-boot-starter：spring boot的场景启动器</li><li>web：web相关的如：Tomcat、springMVC等等</li></ul><p>&emsp;&emsp;我们可以看一下，我们这里的web启动器的内容是什么。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-6988d693f665a4da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="web场景启动器.png"></p><p>&emsp;&emsp;我们可以看到，它帮我们依赖了很多框架，这就是为什么，我们只添加了一个依赖，我们的项目就依赖的很多个框架的原因，这些都是spring boot帮我们依赖好的。所以，没什么特殊的，一切都是从最简单的开始的。</p><p>&emsp;&emsp;spring boot有很多的<a href="https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/html/using-boot-build-systems.html#using-boot-starter" target="_blank" rel="noopener">场景启动器</a>，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-b5f299b5d6676a64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景启动器.png"></p><p>&emsp;&emsp;你需要用到什么样的功能，依赖响应的场景启动器即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前面，我们创建了一个Spring Boot的hello world，我们仅仅添加了一个&lt;strong&gt;spring-boot-starter-parent&lt;/strong&gt;，它是怎么帮我们实现这个依赖的呢？我们可以点进去看一下&lt;strong&gt;Ctrl+鼠标左键&lt;/strong&gt;，如下图：&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot系列—Hello World（一）</title>
    <link href="http://haichenyi.com/2019/08/22/SpringBoot%E7%B3%BB%E5%88%97%E2%80%94Hello-World%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/08/22/SpringBoot系列—Hello-World（一）/</id>
    <published>2019-08-22T06:00:44.000Z</published>
    <updated>2019-08-22T07:44:38.671Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;终于要正式开始了java后台之路，虽然，之前断断续续的看过过黑马的java web视频，但是，都是好几年前的视频，很老了，感觉用处比较大的就是MySQL数据库操作，之前也写过几篇关于<a href="https://blog.csdn.net/qq_27634797/article/category/8050256" target="_blank" rel="noopener">MySQL数据库操作的博客</a>。目前，java后台最火的框架就属<a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener">Spring Boot</a>了。它是<a href="https://spring.io/" target="_blank" rel="noopener">spring</a>家族的衍生框架，并不是加强某个功能，它是为了简化配置，提高开发效率。</p><a id="more"></a><h3 id="Spring-Boot概要"><a href="#Spring-Boot概要" class="headerlink" title="Spring Boot概要"></a>Spring Boot概要</h3><h4 id="Spring-Boot-介绍"><a href="#Spring-Boot-介绍" class="headerlink" title="Spring Boot 介绍"></a>Spring Boot 介绍</h4><p>&emsp;&emsp;随着动态语言的流行(Ruby,Node.js等等)，java作为静态语言，他的开发显得格外的笨重；繁多的配置、低效的开发效率、复杂的部署流程以及第三方技术整合难度大。</p><p>&emsp;&emsp;在上述环境下，Spring Boot由此诞生，它的设计是为了尽快的启动和运行。它使用”习惯优于配置”(就是Spring Boot初始化了大量的配置，让你可以无需配置就能直接运行，当然，你也可以更改)的理念让你的项目快速的运行起来。并且，使用Spring Boot可以让你很容易创建一个独立运行(运行jar，内嵌servlet容器即Tomcat)、准生产力强的基于spring的项目。</p><h4 id="Spring-Boot-优点"><a href="#Spring-Boot-优点" class="headerlink" title="Spring Boot 优点"></a>Spring Boot 优点</h4><ol><li>快速构建spring项目</li><li>无需依赖外部servlet容器即Tomcat，应用无需打成WAR包；项目可以打成Jar包直接运行</li><li>提供一系列的 start pom来简化maven的依赖加载</li><li>无需配置XML，开箱即用，简化开发，同时也可以修改默认值来满足特定需求</li><li>Spring Boot并不是对Spring功能上的加强，而是提供了一种快速使用Spring的方式</li><li>极大的提高了开发和部署效率</li></ol><h3 id="Spring-Boot-入门开发"><a href="#Spring-Boot-入门开发" class="headerlink" title="Spring Boot 入门开发"></a>Spring Boot 入门开发</h3><h4 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h4><p>&emsp;&emsp;每一个版本的Spring Boot，对系统的环境要求都不一样。我这里用的<a href="https://spring.io/projects/spring-boot#learn" target="_blank" rel="noopener">Spring Boot 2.1.7版本</a>，它需要的</p><ul><li>jdk8，兼容12</li><li>Maven 3.3+</li></ul><h4 id="修改Maven配置文件"><a href="#修改Maven配置文件" class="headerlink" title="修改Maven配置文件"></a>修改Maven配置文件</h4><p>&emsp;&emsp;首先，你需要先下载<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven</a>，然后安装。找到安装目录下的config文件夹，点进去找到setting.xml配置文件，进行如下修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--开始处更改下载依赖的存放路径， 以下目录需要已经创建--&gt;</span><br><span class="line">&lt;localRepository&gt;D:\apache-maven-3.6.1\repository&lt;/localRepository&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--在 mirrors 标签下 添加阿里云maven私服库--&gt;</span><br><span class="line">  &lt;mirrors&gt;</span><br><span class="line">&lt;id&gt;nexus-aliyun&lt;/id&gt;    </span><br><span class="line">&lt;name&gt;nexus-aliyun&lt;/name&gt;  </span><br><span class="line">&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;    </span><br><span class="line">&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  </span><br><span class="line">  &lt;/mirrors&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--在 profiles 标签下指定jdk版本--&gt;</span><br><span class="line">&lt;profiles&gt;  </span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">&lt;id&gt;jdk-1.8&lt;/id&gt;</span><br><span class="line"></span><br><span class="line">&lt;activation&gt;</span><br><span class="line">&lt;activeByDefault&gt;true&lt;/activeByDefault&gt; </span><br><span class="line">&lt;jdk&gt;1.8&lt;/jdk&gt;</span><br><span class="line">&lt;/activation&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure><h4 id="修改IDEA配置"><a href="#修改IDEA配置" class="headerlink" title="修改IDEA配置"></a>修改IDEA配置</h4><p><img src="https://upload-images.jianshu.io/upload_images/7041675-ac898c5be4c55359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IDEA配置.png"></p><p>&emsp;&emsp;如上图，我们打开IDEA的setting界面，找到MAVEN，在Maven Home Directory这一栏选择，我们刚才Maven安装的路径，当这一栏选好之后，第三栏的本地仓库路径会自动修改，然后，我们修改第二栏，选择我们上面修改的setting.xml文件。这样修改完成之后，我们maven项目在线依赖的库都存放在我们自己定义的存放文件夹下面。</p><h4 id="创建SpringBoot项目"><a href="#创建SpringBoot项目" class="headerlink" title="创建SpringBoot项目"></a>创建SpringBoot项目</h4><p>&emsp;&emsp;这里创建的是Maven项目，然后嵌入SpringBoot框架，这样你就不会因为直接创建SpringBoot项目生成的文件不知道是干什么用的造成的困惑。创建Maven项目之后的项目结构，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-50d3df67f83f2ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Maven项目结构图.png"></p><p>&emsp;&emsp;如上图，有三个文件夹和一个pom.xml文件。</p><ul><li>java文件夹：存放java代码</li><li>resources文件夹：存放资源文件</li><li>test文件夹：单元测试</li><li>pom.xml：依赖库</li></ul><p>&emsp;&emsp;Maven项目会自动帮我们<a href="https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/html/getting-started-first-application.html#getting-started-first-application-pom" target="_blank" rel="noopener">创建pom.xml文件</a>，不用我们手动创建，我们先在pom.xml文件下添加如下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;关于这个我想说的就是，spring-boot-starter-parent是一个父级依赖，它是一个特殊的starter，这个依赖提供了常用的SpringBoot依赖库，使用它之后，我们SpringBoot常用库就不需要指定Version，这样，我们就避免了冲突，不兼容等问题。之前Android项目总是碰到依赖包冲突，这一点SpringBoot很nice。</p><p>&emsp;&emsp;添加完成这两个之后，我们就可以创建controller，也就是接口了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.POST)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello world!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我这里类用@RestController注解标明，你也可以用@Controller，当你用@Controller的时候，你的方法上面还要加另外一个注解@ResponseBody。</p><p>&emsp;&emsp;再就是方法名称，在你的方法上面加@RequestMapping，里面的value值就是你的接口名称，后面的method就是你需要访问接口的方式。</p><p>&emsp;&emsp;再就是最后一步，创建一个引导类，它的主要作用就是启动我们的SpringBoot项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class HelloApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到这里，我们就完成了，我们最后看一下项目结构图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-6344d27b06363891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构图.png"></p><p>PS:在这里，我们需要注意的是我们这个启动类最好放在最外层的包下面，因为这个启动类在启动的时候，会加载它这个包下面及其所有子包下面所有组件到spring容器中统一管理，你如果把这个启动类写在其它包下面，有可能就加载不到有的组件。</p><p>&emsp;&emsp;启动项目，不用我们手动部署到Tomcat，我们直接点击这个启动类的main方法，左边的启动按钮，run application就可以了。</p><p>&emsp;&emsp;最后，请求接口，因为，我这里定义的方式是post请求，所以，不能直接浏览器访问，你也可以把这个方式去掉，就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//http协议+ip+port+接口名</span><br><span class="line">http://localhost:8080/hello</span><br></pre></td></tr></table></figure><h4 id="项目打jar包"><a href="#项目打jar包" class="headerlink" title="项目打jar包"></a>项目打jar包</h4><p>添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;选择项目右边的Maven—moudle名称—Lifecycle—package—run maven build即可。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-91fbdbeb0444e048.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打jar包.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-178028b6d437ea14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jar包路径.png"></p><p>&emsp;&emsp;然后，在控制台找到这个jar的路径，在我们的DOS命令界面用如下命令运行，即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar 刚才打好的jar包全名称包括后缀名</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;终于要正式开始了java后台之路，虽然，之前断断续续的看过过黑马的java web视频，但是，都是好几年前的视频，很老了，感觉用处比较大的就是MySQL数据库操作，之前也写过几篇关于&lt;a href=&quot;https://blog.csdn.net/qq_27634797/article/category/8050256&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL数据库操作的博客&lt;/a&gt;。目前，java后台最火的框架就属&lt;a href=&quot;https://spring.io/projects/spring-boot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot&lt;/a&gt;了。它是&lt;a href=&quot;https://spring.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring&lt;/a&gt;家族的衍生框架，并不是加强某个功能，它是为了简化配置，提高开发效率。&lt;/p&gt;
    
    </summary>
    
      <category term="Java -SpringBoot" scheme="http://haichenyi.com/categories/Java-SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>dagger2整个流程解析（一）</title>
    <link href="http://haichenyi.com/2019/07/31/dagger2%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/07/31/dagger2整个流程解析（一）/</id>
    <published>2019-07-31T12:17:33.000Z</published>
    <updated>2019-07-31T12:18:30.985Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;众所周知，dagger的入门是比较难的，在嵌入之前，我先说一下这个dagger必要的东西，也是比较常见的东西，几个注解 <strong>@Component</strong>，<strong>@Singleton</strong>，<strong>@Module</strong>，<strong>@Provides</strong>，<strong>@Inject</strong></p><a id="more"></a><p>&emsp;&emsp;<strong>大致的整个流程如下：</strong></p><ol><li>编译的时候，先找构造方法由@Inject标记的类，生成对应的Factory.class类，这个类里面通过new生成对应的对象</li><li>然后，moudle里面，每一个由@Provider标记的方法，都会生成一个对应的Factory.class文件，这里返回的对象，就是刚才由new生成的对象</li><li>最后，我们通过component获取对象的时候，就找moudle去取。moudle取的对象就是之前new生成的</li></ol><p>&emsp;&emsp;<strong>也可以这样理解：</strong></p><ol><li>@Component直到桥梁的作用，告诉application,activity我能给你提供哪些对象</li><li>当Component中返回对象时，它会到@Module中去找这个对象创建没</li><li>@Module中的方法很多，它不可以每个方法的识别一次，它只找@Provider标记的方法</li></ol><p>&emsp;&emsp;<strong>后文的说明都是依赖于<a href="https://github.com/haichenyi/KotlinMvp" target="_blank" rel="noopener">kotlin框架</a></strong></p><p>&emsp;&emsp;这里我拿如下方法来说明整个流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-5848942509707b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图一.png"></p><p>如上图：在AppComponent里面的getSpHelper()方法，返回对象就是SpHelper，前面我们说了，component里面需要的对象要在moudle里面找，moudle里面需要的对象要在@Inject的地方生成，所以，moudle里面也要有对应的方法：如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-ee65722ac7acc82f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图五.png"></p><p>这里的，整个SpHelper是个什么东西呢？参数SpReal又是个什么东西呢？他就是一个sharePreference的接口。SpReal是SpHelper的实现类，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-f93a02df4c98209a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二.png"></p><p>这个就是一个普通的接口，与dagger2搭不上边。我们看他的实现类：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-19f754529d696ff4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图三.png"></p><p>如上图：类SpReal实现SpHelper接口，并且，它的构造方法用@Inject标记了。这里就跟我们的dagger2搭上关系了，我们就需要找SpReal对应的Factory.clss文件。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8557df97bc0e57f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图四.png"></p><p>如上图，SpReal_Factory类有三个方法，两个get()方法返回SpReal对象，静态的newInstance()方法也是返回SpReal对象，静态的create()方法，返回的是当前类的对象。那么，这里的调用顺序是什么呢？</p><p>我们在转过头来看看moudle里面方法对应的Factory：如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-b11fe1ea3fcb642b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图六.png"></p><p>如上图，左边我们看到AppMoudle生成了三个对应的Factory文件，为什么会生成三个？因为，我们的AppMoudle里面有三个方法是用注解@Provides标记的，可以回过头去看一下AppMoudle的内容。</p><p>我们仔细看一下，我们需要的这个类的内容AppModule_ProvideSpHelperFactory，一共有四个方法：一个构造方法，一个get方法，一个create方法，一个provideSpHelper方法。</p><p>是不是很眼熟这个providerSpHelper方法，并且他的返回值也是SpHelper，没错，这个方法就是我们AppMoudle里面定义的方法，在这里生成的对应的方法，它只是参数多了一个AppModule，为什么会多了这个参数呢？带着这个问题，我们看这个方法的实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-197b292b4a70e56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图七.png"></p><p>可以点击跳转这个方法，你会发现，它跳转回我们的AppMoudle方法里面对应的provideSpHelper()方法。回过头来想，我们的AppMoudle就是一个类，里面的provideSpHelper()就是一个普通的方法，怎么调用这个方法呢？就只有用 <strong>对象.方法名()</strong> 调用，所以，这里参数就多加了一个AppMoudle。</p><p>上面解释了为什么多了一个参数，我们再来看一下这个方法的实现。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-ba6cdeaaa4a2c6d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图八.png"></p><p>如上图，就是一个非空判断，如果为空就抛出空指针异常，如果不为空，就返回第一个参数。第一个参数是什么呢？第一个参数，不就是，我们上面说的对象调用方法名么？我们来看一下它这里是怎么实现的。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-9e69d44dfd05c27b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图九.png"></p><p>咦，怎么又返回来了？回到AppMoudle类了，它没有给我们实现啊？我们再想想，首先这个方法，返回的是第一个参数的值，第一个参数又是一个调用我们AppMoudle里面的方法，我们AppMoudle这个方法的返回值，就是这里这个方法的返回值。我们看一下，我们方法的返回值是什么？</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-9e69d44dfd05c27b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十.png"></p><p>我们方法的返回值，不就是传进来的参数么？那我们再看看这里方法传进来的参数是什么？</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-eb0d6d0c5c648f77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十一.png"></p><p>它这里的传的参数，就是这个方法的第二个参数。到这里，我们又断了，依然不知道，这个参数从哪来的。</p><p>冷静下来想一想，调用方法，参数从哪里来？我们从方法里面实现怎么看的到，我们肯定是要在调用方法的地方看。所以，我们就要找到在哪调用这个方法的。既然是写在AppComponent里面，那我们就找他的编译后生成的文件，也就是DaggerAppComponent，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-c3afc3041e959418.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十二.png"></p><p>一眼看过去，这么多东西，怎么看？我又想到，这个DaggerAppComponent类是由AppComponent生成的类，通过上面的判断，这个类里面也应该有我在AppComponent定义的方法的实现才对，搜一下getSpHelper方法，果不其然。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d570e9598aba5e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十三.png"></p><p>如上图，我们可以看到这个方法的实现，类点方法名，说明整个方法是静态的，我们点过去一看。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-9825f1f6dba4e603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十四.png"></p><p>不就是，我们前面说的那个静态方法吗？这样就跟我们前面分析的都串起来了。我们前面的问题是什么？不就是不知道这个方法的第二个参数从哪来的吗？现在，我们看到了，就是在这里new出来的。</p><p>至于第一个参数AppMoudle从哪来的？我们可以接着分析一下。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-c731742fe5d1aa48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十五.png"></p><p>我们可以看到这个appMoudle定义的是一个全局的变量，我们就要找，在哪里初始化的？如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-a156ff943b621cfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十六.png"></p><p>我们发现它是在构造方法里面初始化的，我们就要找在哪里调用的这个构造方法。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-1d5cc745a0c96bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十七.png"></p><p>我们发现，在这个Builder类里面的build()方法调用的这个构造方法，我们就找在哪里调用的这个build()方法。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-1f317b639c2c6082.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十八.png"></p><p>我们发现，是AndroidInjector这个接口里面的抽象Builder类，这个抽象Builder类实现的是AndroidInjector.Factory，我们要找的就是这个create()方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8d816d6035b16ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图十九.png"></p><p>所以，这里在我们的Application里面初始化的，也就是我这里的MyApp里面初始化的。这个参数怎么传递的？如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-89398696cffd1c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十.png"></p><p>在create方法里面调用build()之前还调用了seedInstance()方法，这里是抽象类的方法，要想知道这个方法是怎么实现的，那就得看他的实现类。这个Builder<t>的实现类是谁？想一想上面是怎么跳转过来的？不想这个，我们也可以点这个类进行跳转。如下图</t></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8ef9ff91c7c700c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十一.png"></p><p>如上图，我们可以看到有两个地方调用，一个是ActComponent，一个是AppComponent，前面一个是activity相关的，我们还没有说到，我们现在一直说的都是Application相关的。所以，这里跳转的地方，肯定是Application。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-785da091381f46bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十二.png"></p><p>这个方法还过时了，正好，我们这个Builder<t>抽象类还用@Deprecated标记了。诶？那这里还是没有实现啊，这也是一个抽象类。这个是抽象类，AppComponent又是一个接口，所以，我们要找这个AppComponent接口的实现类。如下图：</t></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-f791b0ac17b7937a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十三.png"></p><p>如上图，AppComponent的实现类，就是DaggerAppComponent类。我们在这个类里面找Builder<t>的实现类就可以了。找找找，如下图</t></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d6f726948fd5d5dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十四.png"></p><p>如上图，这里有seedInstance方法和build两个方法，而且都是@Override的，从父类继承过来的，我们在看看AndroidInjector类。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-fcbdcca6f62275f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十五.png"></p><p>正好，它有这两个方法，并且还都是抽象方法。所以，这个类就是它的实现类。所以，调用的seedInstance方法，就是这里的这个方法。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-37db29d8250698ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十六.png"></p><p>这个方法就是做了一个赋值操作，赋值之前做了一个非空检验。所以，在执行build()的时候这个seedInstance对象已经赋值了，不是空。所以这里就走通了。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-a638e6ef80bfdf05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十七.png"></p><p>如上的构造方法就走通了，那么appMoudle就有值了，那么我们前面的问题。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-96c53c9b44324478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二十八.png"></p><p>我们之前就是在这里，不知道这个appMoudle是怎么赋值的，这里已经走通了。这就是通过AppComponent过去getSpHelper()的整个流程了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;众所周知，dagger的入门是比较难的，在嵌入之前，我先说一下这个dagger必要的东西，也是比较常见的东西，几个注解 &lt;strong&gt;@Component&lt;/strong&gt;，&lt;strong&gt;@Singleton&lt;/strong&gt;，&lt;strong&gt;@Module&lt;/strong&gt;，&lt;strong&gt;@Provides&lt;/strong&gt;，&lt;strong&gt;@Inject&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -源码解析" scheme="http://haichenyi.com/categories/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>一场由dagger2引发的一些思考</title>
    <link href="http://haichenyi.com/2019/07/31/%E4%B8%80%E5%9C%BA%E7%94%B1dagger2%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://haichenyi.com/2019/07/31/一场由dagger2引发的一些思考/</id>
    <published>2019-07-31T09:40:23.000Z</published>
    <updated>2019-07-31T09:42:37.760Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;用了好几年的dagger2，从dagger2.android。就只有当时刚开始用dagger的时候深入的了解过，后来就再也没有深入的时候研究过。这几天又研究了一下，做个总结。</p><p>&emsp;&emsp;就拿之前写的<a href="https://github.com/haichenyi/KotlinMvp" target="_blank" rel="noopener">kotlin的框架</a>来说，它用的是dagger2.android。从dagger2.android。最明显的就是，需要我们自己写的东西越来越少了，框架帮我们做的事情越来越多了，以至于，我们对这个过程越来越看不懂了。也就有了我这篇博客。</p> <a id="more"></a><p>先说这嵌入过程吧。</p><h3 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a>1.依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//dagger2_start</span><br><span class="line">def dagger = &quot;2.23.2&quot;</span><br><span class="line">implementation &quot;com.google.dagger:dagger-android:$dagger&quot;</span><br><span class="line">implementation &quot;com.google.dagger:dagger-android-support:$dagger&quot; // if you use the support libraries</span><br><span class="line">kapt &quot;com.google.dagger:dagger-android-processor:$dagger&quot;</span><br><span class="line">implementation &quot;com.google.dagger:dagger:$dagger&quot;</span><br><span class="line">kapt &quot;com.google.dagger:dagger-compiler:$dagger&quot;</span><br><span class="line">//dagger2_end</span><br></pre></td></tr></table></figure><h3 id="2-DaggerApplication"><a href="#2-DaggerApplication" class="headerlink" title="2.DaggerApplication"></a>2.DaggerApplication</h3><p>&emsp;&emsp;新建类AppMoudle，并用注解@Moudle标记，暂时先不添加任何内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">class AppModule &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;新建接口AppComponent，并实现AndroidInjector<t>接口，泛型先空着，添加如下代码：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Singleton</span><br><span class="line">@Component(modules = [AndroidSupportInjectionModule::classAppModule::class])</span><br><span class="line">interface AppComponent : AndroidInjector&lt;MyApp&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Component.Builder</span><br><span class="line">    abstract class Builder : AndroidInjector.Builder&lt;MyApp&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的MyAPP是我们下面新建的Application</p><p>&emsp;&emsp;新建MyApp，继承DaggerApplication并实现它的抽象方法，添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyApp : DaggerApplication() &#123;</span><br><span class="line"></span><br><span class="line">    override fun applicationInjector(): AndroidInjector&lt;out DaggerApplication&gt; =</span><br><span class="line">        DaggerAppComponent.builder().create(this)</span><br><span class="line"></span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个时候，你的项目应该报错，因为你没有DaggerAppComponent这个类，你现在编译一遍，应该就是能生成</p><h3 id="DaggerAppCompatActivity"><a href="#DaggerAppCompatActivity" class="headerlink" title="DaggerAppCompatActivity"></a>DaggerAppCompatActivity</h3><p>&emsp;&emsp;让你的BaseActivity类，继承这个DaggerAppCompatActivity</p><p>&emsp;&emsp;新建ActComponent接口，并且实现AndroidInjector<t>接口，泛型传你的BaseActivity，如下：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Subcomponent(modules = [AndroidSupportInjectionModule::class])</span><br><span class="line">interface ActComponent : AndroidInjector&lt;BaseActivity&lt;BasePresenter&lt;BaseView&gt;&gt;&gt; &#123;</span><br><span class="line">    @Subcomponent.Builder</span><br><span class="line">    abstract class Builder : AndroidInjector.Builder&lt;BaseActivity&lt;BasePresenter&lt;BaseView&gt;&gt;&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;新建AllActivityModule类，添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Module(subcomponents = [ActComponent::class])</span><br><span class="line">abstract class AllActivitiesModule &#123;</span><br><span class="line">    @ContributesAndroidInjector</span><br><span class="line">    internal abstract fun contributeMainActivityInjector(): MainActivity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个MainActivity是你的主页面，并且继承你的BaseActivity。</p><p>&emsp;&emsp;至此，配置就完成了，你就可以像之前一样，用@Inject标记构造方法，然后，定义变量的地方用@Inject就可以直接用了。</p><p><strong>PS:</strong> 我这里用的kotlin，kotlin参数默认是private，dagger2需要参数是public，这里需要加上JvmField注解。并且，要var类型，不能val，因为，val不能二次赋值。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@JvmField</span><br><span class="line">@Inject</span><br><span class="line">var presenter: P? = null</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们之前用dagger2，没有用dagger2.android的时候，application和activity并不是实现的DaggerApplication，DaggerAppCompatActivity这两个，我们做了很多额外的操作，现在，我们都没有做了，为什么一样可以能运行？因为，我们之前做的额外的操作，现在都是这两个继承的类帮我们做了，可以点进去看一下源码。</p><h3 id="引发的思考"><a href="#引发的思考" class="headerlink" title="引发的思考"></a>引发的思考</h3><p>&emsp;&emsp;如标题，引发的思考是什么呢？它这个注解到底是怎么做到的呢？</p><h4 id="问，这里为什么会分AppComponent，ActivityComponent，FragmentComponent，写一个component不好吗？"><a href="#问，这里为什么会分AppComponent，ActivityComponent，FragmentComponent，写一个component不好吗？" class="headerlink" title="问，这里为什么会分AppComponent，ActivityComponent，FragmentComponent，写一个component不好吗？"></a>问，这里为什么会分AppComponent，ActivityComponent，FragmentComponent，写一个component不好吗？</h4><p>&emsp;&emsp;<strong><em>答：</em></strong> 我不知道对不对，我的理解是：与整个APP生命周期同步即放在AppComponent中，与Activity生命周期同步即放在ActComponent中，<br>与Fragment生命周期同步即放在FragComponent中。</p><p>&emsp;&emsp;从这里引申出什么问题呢？那就是生命周期，我的<a href="https://github.com/haichenyi/KotlinMvp" target="_blank" rel="noopener">kotlin框架</a>整个生命周期都有处理，框架的README也有说明。说到生命周期同步，就要说到不同步，不同步造成的结果就是内存泄漏，至于常见的什么情况下回造成内存泄漏我就不说了，想到内存泄漏，就联想到了内存，想到内存，我就想到了内存分配。这就是我想说的，内存分配。</p><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>&emsp;&emsp;说到内存分配，我们就先说三个名词：<strong>栈，堆，方法区</strong></p><ol><li>栈：存放变量的引用</li><li>堆：存放new的对象，堆是最占内存的</li><li>方法区：存储字节码信息(类，方法等等字节码)，常量，静态变量等等。常量池在方法区中</li></ol><p>举个栗子：<strong>String b = new String(“a”)</strong> 和 <strong>String c = “a”</strong>，他们内存是怎么分配的？如图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-73a4d29d6483e6c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存分配1.png"></p><ol><li>等于号左边 <strong>String b，String c</strong>这里的b，c都是引用，所以放在栈中。栈存放引用</li><li>等于号右边，new的过程，就是在堆中创建内存的过程，这里的0x123456789就是我们常说的内存地址</li><li>常量池里面才是放字符串a</li></ol><p>&emsp;&emsp;很多面试题都会出这个问题，<strong>b==c和b.equal(a)</strong> ，他们两个的结果结果都知道，前面是false，后面是true。<strong>==</strong> 比较的是整个对象，而<strong>equals</strong>比较的是值。这里b指向的是堆内存中的地址，这个地址才是指向常量池中的字符串a，而c是直接指向常量池中的字符串a</p><p>&emsp;&emsp;想多说一句就是 <strong>==</strong> 是怎么比较物理地址的呢？通过比较hashCode的值，在java中是获取不到地址的，不过Object中有个identityHashCodeNative方法，它虽然不是地址，但你可以理解为一个地址对应一个值，这个值就能过identityHashCodeNative来获取，具体怎么算了，这是个native方法我们不知道。不过没关系，只要知道一个地址对应一个值就行了，地址相同这个值就相同。而hashCode默认就是返回这个值，那么如果我们重写了hashCode,按我们的规则来写，可以达到不同的地址，hashCode的值相同，从而得到两个不同的地址用==比较是相同的。</p><p>&emsp;&emsp; <strong>PS:</strong> 我们平时说的 <strong><em>把某某对象置为空，释放内存。这种说法是错误的。</em></strong> 比方说这里，b=null，首先，我们只是把某个对象的引用置为空，并不是把某个对象置为空。释放内存，是java的GC回收机制，释放内存，并不是我们释放内存。当GC扫描到，某个对象没有引用指向它了，它就会释放这个对象占用的内存。说到这里，就又想到GC回收机制与强软弱虚四大引用</p><h4 id="GC回收和强软弱虚四大引用"><a href="#GC回收和强软弱虚四大引用" class="headerlink" title="GC回收和强软弱虚四大引用"></a>GC回收和强软弱虚四大引用</h4><p><strong>强软弱虚四大引用</strong></p><p>&emsp;&emsp; 其实我也不知道说啥，就是上面理解了内存分配，这里再看这几句话，应该印象更加深刻一些。</p><ol><li>强引用：不论什么情况下，GC回收机制扫描到强引用，都不会管，如果内存不足，则抛出OOM异常</li><li>软引用(SoftReference)：GC回收机制扫描到软引用时，当内存足够的时候，不会管，当内存不足的时候，则会回收对应内存</li><li>弱引用(WeakReference)：不论什么情况下，只要GC回收机制扫描到弱引用，都会回收对应的内存。</li><li>虚引用(PhantomReference)：顾名思义，形同虚设，前面三种都是与生命周期相关，而虚引用不会决定对象的生命周期，如果，一个对象仅持有虚引用，那这个对象就跟没有引用是一样的，不管什么时候，GC回收机制扫描到了这个对象，都有可能会回收对应的内存。为什么说是有可能呢？虚引用必须和引用队列连用，当GC回收机制扫描到一个对象，并准备回收它的时候，发现它还存在虚引用，那么，GC会把这个虚引用先加入到与它关联的引用队列中。所以，当GC发现一个对象有虚引用，并且，这个虚引用已经存在与之关联的引用队列当中了，就会回收这个对象。</li></ol><p>&emsp;&emsp; GC回收机制判断是否回收内存，都是先判断对象的引用是否存在，引用存放在栈中。</p><p><strong>GC回收机制</strong></p><p>&emsp;&emsp; 说到GC回收机制，就先聊聊JVM堆的相关知识，一说要JAVA虚拟机，那就要聊聊java是跨平台语言了，它是怎么实现跨平台的呢？</p><p>&emsp;&emsp; java程序是跨平台的语言，它是怎么实现跨平台的？</p><p>&emsp;&emsp;java程序依赖于JVM（java虚拟机），java程序必须运行在JVM上，JVM是用C、C++开发的，不同的平台是不同的JVM，但是，不管是什么类型的JVM都能运行java程序，这就是所谓的java跨平台。但是，不同JVM编译java程序生成的字节码是一样的，但是编译生成的机器码是不一样的，所以跨平台的是java程序，而不是编译生成的机器码。</p><p>&emsp;&emsp;JVM堆，也就是我们上面那个图的堆，JVM堆分为三部分</p><ol><li>新域：也就是年轻代，分为三部分，一部分：Eden，另两个部分是辅助空间分别是：From Space，To Space</li><li>旧域：也就是老年代</li><li>永久域：从配置角度看，永久域是独立于JVM的，大小为4M</li></ol><p>&emsp;&emsp;程序员无法手动释放内存，只能释放引用，内存释放只能由GC释放，程序员可以手动触发GC：<strong><em>System.gc()，</em></strong> 或者是当内存不够用的时候，GC会自动启动，或者是APP空闲的时候，也会启动回收机制。</p><p>&emsp;&emsp;GC执行的过程：</p><ol><li>新建的对象都首先存放在Eden中，如果对象太大，可能直接进入老年代，也就是旧域中。</li><li>GC开始执行，都是从Eden或者是From Space把对象copy到To Space中，至于中间的算法，有好几种，标记算法，标记幸存次数，还有复制算法，具体怎么实现的，我不知道。当把对象移动到To Spce之后，此时的To Space变成了From Space，之前的From Space变成了To Space。然后，继续循环</li><li>循环一次次数之后，对象达到了移动到旧域的条件，就把对象移动到旧域。</li><li>最后，GC就会释放旧域的对象所占用的内存</li></ol><p>PS：以上都是个人观点，不保证完全正确，没有漏洞。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;用了好几年的dagger2，从dagger2.android。就只有当时刚开始用dagger的时候深入的了解过，后来就再也没有深入的时候研究过。这几天又研究了一下，做个总结。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;就拿之前写的&lt;a href=&quot;https://github.com/haichenyi/KotlinMvp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kotlin的框架&lt;/a&gt;来说，它用的是dagger2.android。从dagger2.android。最明显的就是，需要我们自己写的东西越来越少了，框架帮我们做的事情越来越多了，以至于，我们对这个过程越来越看不懂了。也就有了我这篇博客。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Tomcat安装与启动</title>
    <link href="http://haichenyi.com/2019/07/25/Tomcat%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
    <id>http://haichenyi.com/2019/07/25/Tomcat安装与启动/</id>
    <published>2019-07-25T12:22:47.000Z</published>
    <updated>2019-07-25T12:51:18.998Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;搭建android框架的时候总是会遇到测试网络请求没有接口的问题，今天就自己搭建一个服务器Tomcat。不用写web项目就能直接获取到数据</p><a id="more"></a><p>&emsp;&emsp;一.Tomcat主页跳转<a href="https://tomcat.apache.org/" target="_blank" rel="noopener">下载</a></p><p>&emsp;&emsp;二.Download——版本(点击)——Binary Distributions——Core——zip(点击)，该版本是解压版，解压就可以用，无需安装。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-00a048db46aed79e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="步骤1.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-2843477983ad2d7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="步骤2.png"></p><p>&emsp;&emsp;三.下载完成之后，我把zip放在Dpan根目录，解压到当前文件夹即可。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-91cbbc3a3c2ef45d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解压.png"></p><p>&emsp;&emsp;四.配置环境变量。两个地方要注意</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建环境变量：CATALINA_HOME=D:\apache-tomcat-9.0.22</span><br><span class="line">如下图：</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8258261aaa0caa19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建环境变量.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">修改Path变量：</span><br><span class="line"></span><br><span class="line">%CATALINA_HOME%\lib</span><br><span class="line"></span><br><span class="line">%CATALINA_HOME%\lib\servlet-api.jar</span><br><span class="line"></span><br><span class="line">%CATALINA_HOME%\lib\jsp-api.jar</span><br><span class="line"></span><br><span class="line">把上面三个放在Path后面</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8b6e28c8c5323a3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改path.png"></p><p>&emsp;&emsp;五.添加用户，进入config目录，我这里是D:\apache-tomcat-9.0.22\conf，找到tomcat-users.xml，新增如下用户，我这里把它的注释都去掉了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;tomcat-users xmlns=&quot;http://tomcat.apache.org/xml&quot;</span><br><span class="line">              xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">              xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;</span><br><span class="line">              version=&quot;1.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;role rolename=&quot;manager-wz&quot;/&gt; </span><br><span class="line"></span><br><span class="line">&lt;role rolename=&quot;admin-wz&quot;/&gt;  </span><br><span class="line"></span><br><span class="line">&lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;admin-wz&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;admin&quot; roles=&quot;manager-wz&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/tomcat-users&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;六.进入D:\apache-tomcat-9.0.22\bin目录下，双击<strong>startup.bat</strong>文件，即可启动Tomcat</p><p>&emsp;&emsp;七.浏览器输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080</span><br><span class="line"></span><br><span class="line">http://127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>即可访问主页</p><p>PS:启动的时候控制台中文乱码：找到confi目录下的<strong>logging.properties</strong>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.util.logging.ConsoleHandler.encoding = utf-8</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line"></span><br><span class="line">java.util.logging.ConsoleHandler.encoding = GBK</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;八.新建json文件。进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\apache-tomcat-9.0.22\webapps\examples</span><br></pre></td></tr></table></figure><p>新建txt文件，修改内容为json格式的字符串，我这里是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;code&quot;:&quot;200&quot;,&quot;msg&quot;:&quot;请求成功&quot;,&quot;data&quot;:&quot;asdf&quot;&#125;</span><br></pre></td></tr></table></figure><p>修改名字，并且把.txt改成.json</p><p>&emsp;&emsp;九.重启Tomcat，浏览器输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/examples/xxx.json</span><br></pre></td></tr></table></figure><p>即可访问到文件</p><p>&emsp;&emsp;十.手机访问电脑Tomcat</p><ol><li>电脑，手机都连接到同一局域网内</li><li>需要关闭防火墙。需要关闭防火墙。需要关闭防火墙。控制面板–&gt;系统和安全–&gt;Windows防火墙–&gt;启用或关闭Windows防火墙–&gt;关闭</li><li>手机浏览器输入地址：<a href="http://电脑IP地址:8080/，" target="_blank" rel="noopener">http://电脑IP地址:8080/，</a> 即可访问tomcat主页</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;搭建android框架的时候总是会遇到测试网络请求没有接口的问题，今天就自己搭建一个服务器Tomcat。不用写web项目就能直接获取到数据&lt;/p&gt;
    
    </summary>
    
      <category term="Tomcat" scheme="http://haichenyi.com/categories/Tomcat/"/>
    
    
  </entry>
  
  <entry>
    <title>Android开发中的小技巧（持续更新...）</title>
    <link href="http://haichenyi.com/2019/07/25/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/07/25/Android开发中的小技巧（持续更新-）/</id>
    <published>2019-07-25T12:22:29.000Z</published>
    <updated>2019-07-25T12:54:32.183Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;android开发中那些不为人知的小技巧</p><a id="more"></a><h3 id="1-不需要读写权限就可以操作的目录"><a href="#1-不需要读写权限就可以操作的目录" class="headerlink" title="1. 不需要读写权限就可以操作的目录"></a>1. 不需要读写权限就可以操作的目录</h3><p>&emsp;&emsp;一谈起要做文件的读写操作，应在脑海中的就是先申请读写权限，没有读写权限就不让对应的操作。那为什么SP也是把数据存本地，缺不需要读写权限呢？</p><p>&emsp;&emsp;只要是存储在你的APP目录下面，就不需要读写权限。而，手机上面APP目录有两种：一种是手机内部，一种是SD卡目录。怎么获取呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//手机内部：APP目录下默认有两个文件夹，一个是cache，一个是files</span><br><span class="line">//cache目录</span><br><span class="line">cacheDir.absolutePath</span><br><span class="line">//files目录</span><br><span class="line">filesDir.absolutePath</span><br><span class="line">//手机内部的APP目录怎么获取呢？</span><br><span class="line">cacheDir.parent</span><br><span class="line">filesDir.parent</span><br><span class="line"></span><br><span class="line">//手机外部APP目录</span><br><span class="line">//cache目录</span><br><span class="line">externalCacheDir.absolutePath</span><br><span class="line">//APP目录</span><br><span class="line">externalCacheDir.parent</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上这些目录不需要存储权限就可以做操作。但是，在APP卸载的时候，这些数据都会被删除。其他的目录都是需要存储权限的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Environment.getDataDirectory():     /data</span><br><span class="line">Environment.getRootDirectory():    /system</span><br><span class="line">Environment.getDownloadCacheDirectory():     /cache</span><br><span class="line">Environment.getExternalStorageDirectory():   /storage/emulated/0</span><br><span class="line">--------------------- </span><br><span class="line">作者：海晨忆 </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https://blog.csdn.net/qq_27634797/article/details/49495611 </span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上这些目录都需要存储权限。我们可以这样理解：</p><ol><li>只要是通过Context.get能获取到的目录，都不需要存储权限。</li><li>只要是通过Environment.get能获取到的目录，都需要存储权限。</li></ol><h3 id="2-dp转px不需要context也能转"><a href="#2-dp转px不需要context也能转" class="headerlink" title="2. dp转px不需要context也能转"></a>2. dp转px不需要context也能转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回你需要的值：如：这里你传20，单位你传dp，返回值就是你这个手机对应的20dp</span><br><span class="line"> *</span><br><span class="line"> * @param value 数据</span><br><span class="line"> * @param unit  单位：dp为&#123;@link TypedValue#COMPLEX_UNIT_DIP&#125;,</span><br><span class="line"> *              sp为&#123;@link TypedValue#COMPLEX_UNIT_SP&#125;,</span><br><span class="line"> *              px为&#123;@link TypedValue#COMPLEX_UNIT_PX&#125;,</span><br><span class="line"> *              其它请看&#123;@link TypedValue#applyDimension(int, float, DisplayMetrics)&#125;</span><br><span class="line"> * @return 具体长度数值</span><br><span class="line"> */</span><br><span class="line">public static float digitValue(final float value, final int unit) &#123;</span><br><span class="line">    return TypedValue.applyDimension(unit, value, Resources.getSystem().getDisplayMetrics());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>持续更新…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;android开发中那些不为人知的小技巧&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之协程一简单使用</title>
    <link href="http://haichenyi.com/2019/07/16/kotlin%E4%B9%8B%E5%8D%8F%E7%A8%8B%E4%B8%80%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://haichenyi.com/2019/07/16/kotlin之协程一简单使用/</id>
    <published>2019-07-16T10:17:14.000Z</published>
    <updated>2019-07-18T06:41:59.052Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;kotlin协程用于线程切换，kotlin里面不需要new Thread，并且，协程的开销小于new Thread。有三种写法：<strong><em>runBlocking，launch，async</em></strong></p><a id="more"></a><p>既然协程的出现可以取代Thread，我们这里想要验证的是：</p><ol><li>会不会阻塞主线程？</li><li>协程里面的代码是怎么执行的？按顺序执行还是并行?</li><li>协程里面能不能更新页面？</li></ol><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>&emsp;&emsp;协程需要额外依赖一个库协程用于android的库，它会自动依赖官方提供的那个协程的代码库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.0-M2&apos;</span><br></pre></td></tr></table></figure></p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_start&quot;)</span><br><span class="line">            for (i in 0..5) &#123;</span><br><span class="line">                Log.e(&quot;wz&quot;, i.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_end&quot;)</span><br><span class="line">            tvName.text =  &quot;for_end&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, &quot;runBocking外&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="https://upload-images.jianshu.io/upload_images/7041675-e04c10bdd88c256f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="runBlocking.png"></p><p>&emsp;&emsp;从打印顺序上看，runBlocking的执行顺序是从上往下执行的，并且能更新页面。回答上面的三个问题：</p><ol><li>会阻塞线程</li><li>从上往下按顺序执行的</li><li>可以更新页面</li></ol><p>&emsp;&emsp;java里面有Thread，所以线程休眠用Thread.sleep()。kotlin里面既然协程可以取代Thread，所以，kotlin也有自己的休眠方法，也就是上面的delay()，注意，这里delay只能用在协程里面，不能用在外面。</p><h3 id="GlobalScope-launch"><a href="#GlobalScope-launch" class="headerlink" title="GlobalScope.launch"></a>GlobalScope.launch</h3><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_start&quot;)</span><br><span class="line">            for (i in 0..5) &#123;</span><br><span class="line">                Log.e(&quot;wz&quot;, i.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_end&quot;)</span><br><span class="line">            tvName.text =  &quot;for_end&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, &quot;协程外&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-4a79c1067a2b3c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="launch.png"></p><p>&emsp;&emsp;从打印顺序上面看，launch是先执行外面的代码，然后执行协程里面的代码，并且更新了页面。回答上面的三个问题:</p><ol><li>不会阻塞线程</li><li>既然不会阻塞线程，那就是并行的</li><li>能更新页面</li></ol><h3 id="GlobalScope-async"><a href="#GlobalScope-async" class="headerlink" title="GlobalScope.async"></a>GlobalScope.async</h3><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        GlobalScope.async &#123;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_start&quot;)</span><br><span class="line">            for (i in 0..5) &#123;</span><br><span class="line">                Log.e(&quot;wz&quot;, i.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_end&quot;)</span><br><span class="line">            tvName.text =  &quot;for_end&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, &quot;协程外&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-4a79c1067a2b3c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="async.png"></p><p>&emsp;&emsp;从打印顺序上看，跟launch是一样的，并且也更新了页面。所以结论更launch是一样的。</p><p>&emsp;&emsp;都一样的话，那么launch和async有什么区别呢？他们俩的返回值不一样。launch的返回值：Job，而async的返回值：Deferred<t>。async与await()联用。</t></p><p>&emsp;&emsp;Job是一个接口，有join，cancel，cancelAndJoin等等方法，Deferred实现了Job接口。</p><p>&emsp;&emsp;launch和async的区别：launch返回值是job，而async的返回值是：把async的最后一行封装成Deferred返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val job = GlobalScope.launch &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, job.toString())</span><br><span class="line"></span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            val b = GlobalScope.async &#123;</span><br><span class="line">                1111</span><br><span class="line">            &#125;.await()</span><br><span class="line">            Log.e(&quot;wz&quot;, b.toString())</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="async并发"><a href="#async并发" class="headerlink" title="async并发"></a>async并发</h3><p>&emsp;&emsp;我们项目里面有时候会碰到，我们做某个功能的时候，需要拿到两个数据A,B。我们要先算出A，接着算出B，最后，拿到这两个数据再做处理。那么，time(总) = time(A)+time(B)。</p><p>&emsp;&emsp;用async，我们可以怎么处理呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">            measureTimeMillis &#123;</span><br><span class="line">                val n1 = GlobalScope.async &#123; doA() &#125;</span><br><span class="line">                val n2 = GlobalScope.async &#123; doB() &#125;</span><br><span class="line">                val time = n1.await() + n2.await()</span><br><span class="line">                Log.e(&quot;wz&quot;, time.toString())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">suspend fun doA(): Int &#123;</span><br><span class="line">        //做其他操作花费2秒钟</span><br><span class="line">        return 3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">suspend fun doB(): Int &#123;</span><br><span class="line">        //做其他操作花费4秒钟</span><br><span class="line">        return 4</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面，我们得到结论async是不阻塞线程的，所以，doA和doB是同时进行的。当同时获取到A,B的结果所花费的时间，是doA和doB中花费时间长的那一个，所以，这里花费的总时间是4秒钟，而不是6秒</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;kotlin协程用于线程切换，kotlin里面不需要new Thread，并且，协程的开销小于new Thread。有三种写法：&lt;strong&gt;&lt;em&gt;runBlocking，launch，async&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之内部类，匿名内部类与伴生对象</title>
    <link href="http://haichenyi.com/2019/06/14/kotlin%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/"/>
    <id>http://haichenyi.com/2019/06/14/kotlin之内部类，匿名内部类与伴生对象/</id>
    <published>2019-06-14T12:57:56.000Z</published>
    <updated>2019-06-14T12:59:55.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>&emsp;&emsp;kotlin的内部类与java的内部类有点不同<strong><em>java的内部类可以直接访问外部类的成员，kotlin的内部类不能直接访问外部类的成员，必须用inner标记之后才能访问外部类的成员</em></strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AAA&#123;</span><br><span class="line">    var a = 0</span><br><span class="line">    class BBB&#123;</span><br><span class="line">        //此时，BBB类的内部是不能直接用a变量的</span><br><span class="line">        var b = a //编译无法通过</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AAA&#123;</span><br><span class="line">    var a = 0</span><br><span class="line">    inner class BBB&#123;</span><br><span class="line">        //此时，BBB类的内部是可以直接用a变量的</span><br><span class="line">        var b = a //编译可以通过</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>&emsp;&emsp;匿名内部类主要是针对那些获取抽象类或者接口对象而来的。最常见的匿名内部类点击事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//java,匿名内部类的写法</span><br><span class="line">btn.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个是java匿名内部类的写法，kotlin没有new关键字，那么kotlin的匿名内部类该怎么写呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn1.setOnClickListener(object : View.OnClickListener&#123;</span><br><span class="line">            override fun onClick(v: View?) &#123;</span><br><span class="line">                print(&quot;1111&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;方法的参数是一个匿名内部类，先写object:，然后写你的参数类型View.OnClickListener{}，然后编译器会出提示，让你补齐即可。</p><p>&emsp;&emsp;kotlin还有一个写法<strong>lambda 表达式</strong>，非常之方便，这个是java，jdk1.8里面包含的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn1.setOnClickListener &#123; print(&quot;1111&quot;) &#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式-object"><a href="#单例模式-object" class="headerlink" title="单例模式(object)"></a>单例模式(object)</h3><p>&emsp;&emsp;说道这个object就让我想到了kotlin里面的单例模式，kotlin里面用object标记的类，默认在初始化时候自己生成单例，这也是为什么我们再混合开发的时候，java里面调用会有INSTANCE这个东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object AAA&#123;</span><br><span class="line">    var a = 10</span><br><span class="line">    fun getName() : String&#123;</span><br><span class="line">        return &quot;海晨忆&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个类AAA，默认就有单例，所以可以直接AAA.getName()，这样调用方法。AAA.a这样直接使用变量，混合模式的时候，我们的调用方式是”AAA.INSTANCE.getName()”</p><p>&emsp;&emsp;我们java里面写的工具类都是用static表示，kotlin里面就不需要，直接把你的工具类的class表示换成object，然后在这个工具类里面正常写方法，就可以直接用<strong>类.方法</strong>调用，常量也是一样的</p><h3 id="伴生对象-companion-object"><a href="#伴生对象-companion-object" class="headerlink" title="伴生对象(companion object)"></a>伴生对象(companion object)</h3><p>&emsp;&emsp;伴生对象对应的java里面的就是一个类中的静态变量，静态方法。但是，这里编译之后对应的java文件，并不是静态的，而是通过单例调用的。伴生对象的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class SecondActivity : AppCompatActivity() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        var c: Int = 10</span><br><span class="line"></span><br><span class="line">        fun getName(): String &#123;</span><br><span class="line">            return c.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        class CCC &#123;</span><br><span class="line">            var d: Int = 11</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//在其他位置的调用方式：</span><br><span class="line">SecondActivity.c</span><br><span class="line">SecondActivity.getName()</span><br><span class="line">SecondActivity.Companion.CCC().d</span><br></pre></td></tr></table></figure><h3 id="object，companion-object，扩展方法的区别"><a href="#object，companion-object，扩展方法的区别" class="headerlink" title="object，companion object，扩展方法的区别"></a>object，companion object，扩展方法的区别</h3><p>&emsp;&emsp;昨天写的<strong>扩展方法</strong>，我们说到，它编译之后对应的java文件生成的方法都加上了<strong>final static</strong>，所以，我们说它是静态的。</p><p>&emsp;&emsp;今天的这两个<strong>object和伴生对象</strong>，通过查看它编译之后的java文件，他的属性，方法都是加了<strong>final</strong>，并没有static，但是，<strong><em>object标识的类在初始化的时候生成了final static类型的INSTANCE变量 ，伴生对象在初始化的时候生成了final static类型的Companion变量</em></strong></p><p><strong>PS:最好写个demo看一下对应的java文件，印象深刻，查看方式：Tools –&gt; Kotlin –&gt; Show Kotlin ByteCodes</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;kotlin的内部类与java的内部类有点不同&lt;strong&gt;&lt;em&gt;java的内部类可以直接访问外部类的成员，kotlin的内部类不能直接访问外部类的成员，必须用inner标记之后才能访问外部类的成员&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之扩展方法</title>
    <link href="http://haichenyi.com/2019/06/14/kotlin%E4%B9%8B%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/"/>
    <id>http://haichenyi.com/2019/06/14/kotlin之扩展方法/</id>
    <published>2019-06-14T12:57:34.000Z</published>
    <updated>2019-06-14T12:59:06.644Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;kotlin的扩展方法类似于java工具类，但是又优于java的工具类。</p><a id="more"></a><h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>&emsp;&emsp;扩展方法的写法，<strong><em>新建一个File类型的kt文件，不是Class类型，不是Interface类型，不是枚举类型，不是Object类型，就是File类型</em></strong></p><p>&emsp;&emsp;然后直接定义方法，跟kotlin定义方法相同，需要什么方法就定义什么方法，唯一的区别就是在方法名的前面可以加上”类型.”，格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//类型可以省略，即任意类型</span><br><span class="line">fun 类型.方法名(参数...):返回值&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//两个数相加，任意类型都可以调用</span><br><span class="line">fun add(a: Int, b: Int): Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//加载图片，只有ImageView类型可以调用</span><br><span class="line">fun ImageView.loadUrl(imgUrl: String) &#123;</span><br><span class="line">    Glide.with(this.context).load(imgUrl).into(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.aloe.mykotlin</span><br><span class="line"></span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.support.v7.app.AppCompatActivity</span><br><span class="line">import kotlinx.android.synthetic.main.activity_second.*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SecondActivity : AppCompatActivity()&#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_second)</span><br><span class="line">        val a = 1</span><br><span class="line">        val b = 2</span><br><span class="line">        //调用两个数相加</span><br><span class="line">        add(a, b)</span><br><span class="line">        //调用加载图片</span><br><span class="line">        img.loadUrl(&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是：</p><ol><li>如果方法没有加类型，就是随便什么类型都能调用，就是只要是项目在内的其他任意地方都可以调用这个方法</li><li>第二个是ImageView类型才能调用，要记得是变量调用，而不是类型调用，变量调用方法。就像我这里的img变量，就是ImageView类型的</li><li>写法我们都知道用Glide加载图片，最后into方法传递的是一个ImageView类型的view，我上面写的this，这里的this就是指的是当前方法前面类型的变量，也就是这里的ImageView类型的变量，也就是我们调用的时候的img变量</li><li>扩展方法，其实最后生成java文件的时候，就是在方法的前面加上了static final ，没什么神奇的，最后跟我们java里面工具类的原理是一样的。</li></ol><h3 id="Activity间的跳转"><a href="#Activity间的跳转" class="headerlink" title="Activity间的跳转"></a>Activity间的跳转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(Intent(this@MainActivity,SecondActivity::class.java))</span><br></pre></td></tr></table></figure><h3 id="密封类sealed"><a href="#密封类sealed" class="headerlink" title="密封类sealed"></a>密封类sealed</h3><p>&emsp;&emsp;java中没有密封类的概念，这个是kotlin独有的，他能使我们的代码更加安全。</p><p>&emsp;&emsp;kotlin的类默认是final，不能被继承，sealed修饰的类可以被继承，因为它修饰的是open，这里只是把open隐藏了。</p><p>&emsp;&emsp;为什么说它能使我们的代码更加安全呐？举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lateinit var obj : Any</span><br><span class="line">var b = when(obj)&#123;</span><br><span class="line">    1 -&gt; 2</span><br><span class="line">    is String -&gt; 3</span><br><span class="line">    3,4 -&gt; &quot;obj等于3或者等于4&quot;</span><br><span class="line">    in 10..20 -&gt; &quot;obj在10到20之间&quot;</span><br><span class="line">    else -&gt; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个是我们之前说过的when的表达式，我们之前讲过when表达式最后必须要加else，不然编译通过不了。或者你能保证else前面的条件语句包括else条件的情况，那就不用加。一般情况下，我们都加else。我们看一下下面这个写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sealed class AAA &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BBB : AAA() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CCC : AAA() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun QQQ(aaa: AAA): Int =</span><br><span class="line">        when (aaa) &#123;</span><br><span class="line">            is BBB -&gt; 10</span><br><span class="line"></span><br><span class="line">            is CCC -&gt; 11</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们这里类AAA是用sealed标识的，类BBB,CCC都继承AAA。我们方法QQQ需要传递一个AAA对象，里面用when做判断，这里就不需要加else，因为这里的条件只有两种，一种是类BBB,一种是类CCC，没有第三种。如果AAA，没有用sealed标识，这里还可以加其他条件，编译都可以通过，因为判断不出来，所以，代码就不安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;kotlin的扩展方法类似于java工具类，但是又优于java的工具类。&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之构造函数(constructor)</title>
    <link href="http://haichenyi.com/2019/06/12/kotlin%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-constructor/"/>
    <id>http://haichenyi.com/2019/06/12/kotlin之构造函数-constructor/</id>
    <published>2019-06-12T14:27:43.000Z</published>
    <updated>2019-06-12T14:29:05.172Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;java中的构造函数是与类名相同即可，kotlin里面的构造函数是用constructor关键字表示。</p><a id="more"></a><p>&emsp;&emsp;kotlin里面的构造函数分为主构造函数和次构造函数。<strong>主构造函数只能有一个，次构造函数个数不限制，可以有一个或者多个</strong></p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>&emsp;&emsp;啥是主构造方法？啥是次构造方法呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//主构造方法如下，跟在类名后面</span><br><span class="line">class Person constructor(name:String)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person constructor()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//当主构造方法没有任何注解或者可见性修饰符时，可以省略，写成下面这样</span><br><span class="line">class Person &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这种就是有注解标记的主构造方法，不能省略</span><br><span class="line">class Person @Inject internal constructor()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//次构造方法，一个无参的次构造方法，一个有一个参数的次构造方法</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    constructor(name:String)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到主构造方法是没有方法体的，那么，我们需要初始化的数据应该放到哪呢？kotlin提供了init方法，给我们初始化数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor()&#123;</span><br><span class="line">    init&#123;</span><br><span class="line">        print(&quot;111&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        println()</span><br><span class="line">        print(&quot;222&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person()</span><br><span class="line">//这里我们会看到打印台打印:111，换行打印222</span><br><span class="line">//这里构造方法是按顺序执行的</span><br><span class="line">//我都是自己写代码跑的结果，不想贴图了，自己写了跑一边，印象会更加深刻</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么，问题来了，次构造方法有方法体，会执行这个init模块吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        println()</span><br><span class="line">        print(&quot;111&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        print(&quot;222&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里我们会看到打印台打印:222，换行打印111</span><br></pre></td></tr></table></figure><p>结论：<strong><em>不管是什么构造方法，先执行init模块逻辑，后执行构造方法的逻辑</em></strong></p><h3 id="this，super"><a href="#this，super" class="headerlink" title="this，super"></a>this，super</h3><p>&emsp;&emsp;简单的说一下继承,this和super两个关键字，跟java差不多；</p><p>&emsp;&emsp;this是调用自己的，super是调用父类的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">open class AAA &#123;</span><br><span class="line">        constructor(name: String) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;$name A&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        constructor(name: String, age: Int) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;我是AAA的两个参数的构造方法&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        init &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;222&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class BBB : AAA &#123;</span><br><span class="line">        constructor(name: String) : this(name, 0) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;我是BBB的一个参数的构造方法&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        constructor(name: String, age: Int) : super(name, age) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;我是BBB的两个参数的构造方法&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var b = BBB(&quot;小王&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;类BBB继承类AAA，其中BBB分别有一个参数的构造方法和两个参数的构造方法；一个参数的构造方法用的this关键字调用自己的两个参数的构造；而两个参数的构造方法用的super关键字调用的父类两个参数的构造方法；这里控制台打印的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">222</span><br><span class="line">我是AAA的两个参数的构造方法</span><br><span class="line">我是BBB的两个参数的构造方法</span><br><span class="line">我是BBB的一个参数的构造方法</span><br></pre></td></tr></table></figure><h3 id="重写set-get方法"><a href="#重写set-get方法" class="headerlink" title="重写set/get方法"></a>重写set/get方法</h3><p>说到了这个类，讲一下怎么重写属性的set/get方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">open class Person &#123;</span><br><span class="line">        var name: String = &quot;&quot;</span><br><span class="line">            set(value) &#123;</span><br><span class="line">                field = value + &quot;www&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            get() &#123;</span><br><span class="line">                return field + &quot;zzz&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        var age: Int = 0</span><br><span class="line">            set(value) &#123;</span><br><span class="line">                field = if (value &gt;= 20) 20 else value</span><br><span class="line">            &#125;</span><br><span class="line">            get() &#123;</span><br><span class="line">                return field * 2</span><br><span class="line">            &#125;</span><br><span class="line">        var address: String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里一个person类，里面有三个属性：name，age，address；在name和age下面分别写了set，get方法，address没写。</p><p><strong>重点：</strong></p><ol><li>你想重写哪个属性的set，get方法，就在哪个属性下方写set，get方法，不用成对出现，可以只重写set方法，也可以只重写get方法</li><li>用field表示你想要的值</li></ol><p>&emsp;&emsp;这里，我就只重写了name和age的set，get方法，没有重写address的set，get方法</p><p>&emsp;&emsp;这里，我再存名字的时候在名字的后面加上了www，在获取的时候又加上了zzz，也就是说，如果你这里name传的是”小王”，那么你用get方法取到的name的值应该是”小王wwwzzz”</p><p>&emsp;&emsp;存age的时候，自己分析一下吧，很简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;java中的构造函数是与类名相同即可，kotlin里面的构造函数是用constructor关键字表示。&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
</feed>
