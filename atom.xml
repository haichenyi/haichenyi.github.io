<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>海晨忆的博客</title>
  
  <subtitle>技术源于生活！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haichenyi.com/"/>
  <updated>2019-07-16T10:18:33.512Z</updated>
  <id>http://haichenyi.com/</id>
  
  <author>
    <name>海晨忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kotlin之协程（一）</title>
    <link href="http://haichenyi.com/2019/07/16/kotlin%E4%B9%8B%E5%8D%8F%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://haichenyi.com/2019/07/16/kotlin之协程（一）/</id>
    <published>2019-07-16T10:17:14.000Z</published>
    <updated>2019-07-16T10:18:33.512Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;kotlin协程用于线程切换，kotlin里面不需要new Thread，并且，协程的开销小于new Thread。有三种写法：<strong><em>runBlocking，launch，async</em></strong></p><a id="more"></a><p>既然协程的出现可以取代Thread，我们这里想要验证的是：</p><ol><li>会不会阻塞主线程，能不能做耗时操作？</li><li>协程里面的代码是怎么执行的？按顺序执行还是并行?</li><li>协程里面能不能更新页面？</li></ol><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>&emsp;&emsp;协程需要额外依赖一个库协程用于android的库，它会自动依赖官方提供的那个协程的代码库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.0-M2&apos;</span><br></pre></td></tr></table></figure></p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_start&quot;)</span><br><span class="line">            for (i in 0..5) &#123;</span><br><span class="line">                delay(500)</span><br><span class="line">                Log.e(&quot;wz&quot;, i.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_end&quot;)</span><br><span class="line">            tvName.text =  &quot;for_end&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, &quot;runBocking外&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="https://upload-images.jianshu.io/upload_images/7041675-11e4e6518a2ae60a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="runBlocking.png"></p><p>&emsp;&emsp;从打印顺序上看，runBlocking的执行顺序是从上往下执行的，并且能更新页面，所以，runBlocking可以理解成在主线程中执行。回答上面的三个问题：</p><ol><li>会阻塞线程，可以做耗时操作</li><li>从上往下按顺序执行的</li><li>可以更新页面</li></ol><p>&emsp;&emsp;java里面有Thread，所以线程休眠用Thread.sleep()。kotlin里面既然协程可以取代Thread，所以，kotlin也有自己的休眠方法，也就是上面的delay()，注意，这里delay只能用在协程里面，不能用在外面。</p><h3 id="GlobalScope-launch"><a href="#GlobalScope-launch" class="headerlink" title="GlobalScope.launch"></a>GlobalScope.launch</h3><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_start&quot;)</span><br><span class="line">            for (i in 0..5) &#123;</span><br><span class="line">                delay(500)</span><br><span class="line">                Log.e(&quot;wz&quot;, i.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_end&quot;)</span><br><span class="line">            tvName.text =  &quot;for_end&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, &quot;runBocking外&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-5ca88fb171a13ac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="launch.png"></p><p>&emsp;&emsp;从打印顺序上面看，launch是先执行外面的代码，然后执行协程里面的代码，最后在设置text的时候程序崩掉了。所以，launch可以理解成新开了一个线程执行，但是，协程的开销小于新开线程。回答上面的三个问题:</p><ol><li>不会阻塞线程，可以做耗时操作</li><li>既然会阻塞线程，那就是并行的</li><li>不能更新页面</li></ol><h3 id="GlobalScope-async"><a href="#GlobalScope-async" class="headerlink" title="GlobalScope.async"></a>GlobalScope.async</h3><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        GlobalScope.async &#123;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_start&quot;)</span><br><span class="line">            for (i in 0..5) &#123;</span><br><span class="line">                delay(500)</span><br><span class="line">                Log.e(&quot;wz&quot;, i.toString())</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(&quot;wz&quot;, &quot;for_end&quot;)</span><br><span class="line">            tvName.text =  &quot;for_end&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, &quot;runBocking外&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="https://upload-images.jianshu.io/upload_images/7041675-88ae9ed7f521dfca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="async.png"></p><p>&emsp;&emsp;从打印顺序上看，跟launch是一样的，只是async的程序没有崩溃，但是页面一样没有更新。所以结论更launch是一样的。</p><p>&emsp;&emsp;都一样的话，那么launch和async有什么区别呢？他们俩的返回值不一样。launch的返回值：Job，而async的返回值：Deferred<t> 这也是我们用于线程切换，更新页面的原因。</t></p><p>&emsp;&emsp;那么，问题来了，既然可以代替Thread，怎么更新页面呢？我们实际项目里面很多时候，都是拿到数据之后，对数据做完操作就更新页面。协程要怎么做呢？async一般都是与await成对出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">            tvName.text = GlobalScope.async(Dispatchers.IO) &#123;</span><br><span class="line">                var index = 0</span><br><span class="line">                for (index1 in 0..10) &#123;</span><br><span class="line">                    index++</span><br><span class="line">                    delay(500)</span><br><span class="line">                    Log.e(&quot;wz&quot;, &quot;index的值为：$&#123;index&#125;&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                return@async &quot;index的值为：$&#123;index&#125;&quot;</span><br><span class="line">            &#125;.await()</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;wz&quot;, &quot;runBocking外&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上面的代码所示：</p><ol><li>launch(Dispatchers.Main)的意思就是在主线程中执行</li><li>async(Dispatchers.IO)的意思就是在IO线程中执行，并且用await方法获取到返回值，赋值给text</li></ol><p>&emsp;&emsp;所以，上面的意思就是launch里面套了一个async，launch的构造方法里面传的Main，意思就是在主线程中执行，async的构造方法里面传IO，意思就是在IO线程中执行。并且拿到返回值，赋值给text。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;kotlin协程用于线程切换，kotlin里面不需要new Thread，并且，协程的开销小于new Thread。有三种写法：&lt;strong&gt;&lt;em&gt;runBlocking，launch，async&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之内部类，匿名内部类与伴生对象</title>
    <link href="http://haichenyi.com/2019/06/14/kotlin%E4%B9%8B%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/"/>
    <id>http://haichenyi.com/2019/06/14/kotlin之内部类，匿名内部类与伴生对象/</id>
    <published>2019-06-14T12:57:56.000Z</published>
    <updated>2019-06-14T12:59:55.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>&emsp;&emsp;kotlin的内部类与java的内部类有点不同<strong><em>java的内部类可以直接访问外部类的成员，kotlin的内部类不能直接访问外部类的成员，必须用inner标记之后才能访问外部类的成员</em></strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AAA&#123;</span><br><span class="line">    var a = 0</span><br><span class="line">    class BBB&#123;</span><br><span class="line">        //此时，BBB类的内部是不能直接用a变量的</span><br><span class="line">        var b = a //编译无法通过</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AAA&#123;</span><br><span class="line">    var a = 0</span><br><span class="line">    inner class BBB&#123;</span><br><span class="line">        //此时，BBB类的内部是可以直接用a变量的</span><br><span class="line">        var b = a //编译可以通过</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>&emsp;&emsp;匿名内部类主要是针对那些获取抽象类或者接口对象而来的。最常见的匿名内部类点击事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//java,匿名内部类的写法</span><br><span class="line">btn.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个是java匿名内部类的写法，kotlin没有new关键字，那么kotlin的匿名内部类该怎么写呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn1.setOnClickListener(object : View.OnClickListener&#123;</span><br><span class="line">            override fun onClick(v: View?) &#123;</span><br><span class="line">                print(&quot;1111&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;方法的参数是一个匿名内部类，先写object:，然后写你的参数类型View.OnClickListener{}，然后编译器会出提示，让你补齐即可。</p><p>&emsp;&emsp;kotlin还有一个写法<strong>lambda 表达式</strong>，非常之方便，这个是java，jdk1.8里面包含的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn1.setOnClickListener &#123; print(&quot;1111&quot;) &#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式-object"><a href="#单例模式-object" class="headerlink" title="单例模式(object)"></a>单例模式(object)</h3><p>&emsp;&emsp;说道这个object就让我想到了kotlin里面的单例模式，kotlin里面用object标记的类，默认在初始化时候自己生成单例，这也是为什么我们再混合开发的时候，java里面调用会有INSTANCE这个东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object AAA&#123;</span><br><span class="line">    var a = 10</span><br><span class="line">    fun getName() : String&#123;</span><br><span class="line">        return &quot;海晨忆&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个类AAA，默认就有单例，所以可以直接AAA.getName()，这样调用方法。AAA.a这样直接使用变量，混合模式的时候，我们的调用方式是”AAA.INSTANCE.getName()”</p><p>&emsp;&emsp;我们java里面写的工具类都是用static表示，kotlin里面就不需要，直接把你的工具类的class表示换成object，然后在这个工具类里面正常写方法，就可以直接用<strong>类.方法</strong>调用，常量也是一样的</p><h3 id="伴生对象-companion-object"><a href="#伴生对象-companion-object" class="headerlink" title="伴生对象(companion object)"></a>伴生对象(companion object)</h3><p>&emsp;&emsp;伴生对象对应的java里面的就是一个类中的静态变量，静态方法。但是，这里编译之后对应的java文件，并不是静态的，而是通过单例调用的。伴生对象的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class SecondActivity : AppCompatActivity() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        var c: Int = 10</span><br><span class="line"></span><br><span class="line">        fun getName(): String &#123;</span><br><span class="line">            return c.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        class CCC &#123;</span><br><span class="line">            var d: Int = 11</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//在其他位置的调用方式：</span><br><span class="line">SecondActivity.c</span><br><span class="line">SecondActivity.getName()</span><br><span class="line">SecondActivity.Companion.CCC().d</span><br></pre></td></tr></table></figure><h3 id="object，companion-object，扩展方法的区别"><a href="#object，companion-object，扩展方法的区别" class="headerlink" title="object，companion object，扩展方法的区别"></a>object，companion object，扩展方法的区别</h3><p>&emsp;&emsp;昨天写的<strong>扩展方法</strong>，我们说到，它编译之后对应的java文件生成的方法都加上了<strong>final static</strong>，所以，我们说它是静态的。</p><p>&emsp;&emsp;今天的这两个<strong>object和伴生对象</strong>，通过查看它编译之后的java文件，他的属性，方法都是加了<strong>final</strong>，并没有static，但是，<strong><em>object标识的类在初始化的时候生成了final static类型的INSTANCE变量 ，伴生对象在初始化的时候生成了final static类型的Companion变量</em></strong></p><p><strong>PS:最好写个demo看一下对应的java文件，印象深刻，查看方式：Tools –&gt; Kotlin –&gt; Show Kotlin ByteCodes</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;kotlin的内部类与java的内部类有点不同&lt;strong&gt;&lt;em&gt;java的内部类可以直接访问外部类的成员，kotlin的内部类不能直接访问外部类的成员，必须用inner标记之后才能访问外部类的成员&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之扩展方法</title>
    <link href="http://haichenyi.com/2019/06/14/kotlin%E4%B9%8B%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95/"/>
    <id>http://haichenyi.com/2019/06/14/kotlin之扩展方法/</id>
    <published>2019-06-14T12:57:34.000Z</published>
    <updated>2019-06-14T12:59:06.644Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;kotlin的扩展方法类似于java工具类，但是又优于java的工具类。</p><a id="more"></a><h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>&emsp;&emsp;扩展方法的写法，<strong><em>新建一个File类型的kt文件，不是Class类型，不是Interface类型，不是枚举类型，不是Object类型，就是File类型</em></strong></p><p>&emsp;&emsp;然后直接定义方法，跟kotlin定义方法相同，需要什么方法就定义什么方法，唯一的区别就是在方法名的前面可以加上”类型.”，格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//类型可以省略，即任意类型</span><br><span class="line">fun 类型.方法名(参数...):返回值&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//两个数相加，任意类型都可以调用</span><br><span class="line">fun add(a: Int, b: Int): Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//加载图片，只有ImageView类型可以调用</span><br><span class="line">fun ImageView.loadUrl(imgUrl: String) &#123;</span><br><span class="line">    Glide.with(this.context).load(imgUrl).into(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.haichenyi.aloe.mykotlin</span><br><span class="line"></span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.support.v7.app.AppCompatActivity</span><br><span class="line">import kotlinx.android.synthetic.main.activity_second.*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SecondActivity : AppCompatActivity()&#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_second)</span><br><span class="line">        val a = 1</span><br><span class="line">        val b = 2</span><br><span class="line">        //调用两个数相加</span><br><span class="line">        add(a, b)</span><br><span class="line">        //调用加载图片</span><br><span class="line">        img.loadUrl(&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是：</p><ol><li>如果方法没有加类型，就是随便什么类型都能调用，就是只要是项目在内的其他任意地方都可以调用这个方法</li><li>第二个是ImageView类型才能调用，要记得是变量调用，而不是类型调用，变量调用方法。就像我这里的img变量，就是ImageView类型的</li><li>写法我们都知道用Glide加载图片，最后into方法传递的是一个ImageView类型的view，我上面写的this，这里的this就是指的是当前方法前面类型的变量，也就是这里的ImageView类型的变量，也就是我们调用的时候的img变量</li><li>扩展方法，其实最后生成java文件的时候，就是在方法的前面加上了static final ，没什么神奇的，最后跟我们java里面工具类的原理是一样的。</li></ol><h3 id="Activity间的跳转"><a href="#Activity间的跳转" class="headerlink" title="Activity间的跳转"></a>Activity间的跳转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(Intent(this@MainActivity,SecondActivity::class.java))</span><br></pre></td></tr></table></figure><h3 id="密封类sealed"><a href="#密封类sealed" class="headerlink" title="密封类sealed"></a>密封类sealed</h3><p>&emsp;&emsp;java中没有密封类的概念，这个是kotlin独有的，他能使我们的代码更加安全。</p><p>&emsp;&emsp;kotlin的类默认是final，不能被继承，sealed修饰的类可以被继承，因为它修饰的是open，这里只是把open隐藏了。</p><p>&emsp;&emsp;为什么说它能使我们的代码更加安全呐？举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lateinit var obj : Any</span><br><span class="line">var b = when(obj)&#123;</span><br><span class="line">    1 -&gt; 2</span><br><span class="line">    is String -&gt; 3</span><br><span class="line">    3,4 -&gt; &quot;obj等于3或者等于4&quot;</span><br><span class="line">    in 10..20 -&gt; &quot;obj在10到20之间&quot;</span><br><span class="line">    else -&gt; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个是我们之前说过的when的表达式，我们之前讲过when表达式最后必须要加else，不然编译通过不了。或者你能保证else前面的条件语句包括else条件的情况，那就不用加。一般情况下，我们都加else。我们看一下下面这个写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sealed class AAA &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BBB : AAA() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CCC : AAA() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun QQQ(aaa: AAA): Int =</span><br><span class="line">        when (aaa) &#123;</span><br><span class="line">            is BBB -&gt; 10</span><br><span class="line"></span><br><span class="line">            is CCC -&gt; 11</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们这里类AAA是用sealed标识的，类BBB,CCC都继承AAA。我们方法QQQ需要传递一个AAA对象，里面用when做判断，这里就不需要加else，因为这里的条件只有两种，一种是类BBB,一种是类CCC，没有第三种。如果AAA，没有用sealed标识，这里还可以加其他条件，编译都可以通过，因为判断不出来，所以，代码就不安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;kotlin的扩展方法类似于java工具类，但是又优于java的工具类。&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之构造函数(constructor)</title>
    <link href="http://haichenyi.com/2019/06/12/kotlin%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-constructor/"/>
    <id>http://haichenyi.com/2019/06/12/kotlin之构造函数-constructor/</id>
    <published>2019-06-12T14:27:43.000Z</published>
    <updated>2019-06-12T14:29:05.172Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;java中的构造函数是与类名相同即可，kotlin里面的构造函数是用constructor关键字表示。</p><a id="more"></a><p>&emsp;&emsp;kotlin里面的构造函数分为主构造函数和次构造函数。<strong>主构造函数只能有一个，次构造函数个数不限制，可以有一个或者多个</strong></p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>&emsp;&emsp;啥是主构造方法？啥是次构造方法呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//主构造方法如下，跟在类名后面</span><br><span class="line">class Person constructor(name:String)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person constructor()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//当主构造方法没有任何注解或者可见性修饰符时，可以省略，写成下面这样</span><br><span class="line">class Person &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这种就是有注解标记的主构造方法，不能省略</span><br><span class="line">class Person @Inject internal constructor()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//次构造方法，一个无参的次构造方法，一个有一个参数的次构造方法</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    constructor(name:String)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到主构造方法是没有方法体的，那么，我们需要初始化的数据应该放到哪呢？kotlin提供了init方法，给我们初始化数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor()&#123;</span><br><span class="line">    init&#123;</span><br><span class="line">        print(&quot;111&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        println()</span><br><span class="line">        print(&quot;222&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person()</span><br><span class="line">//这里我们会看到打印台打印:111，换行打印222</span><br><span class="line">//这里构造方法是按顺序执行的</span><br><span class="line">//我都是自己写代码跑的结果，不想贴图了，自己写了跑一边，印象会更加深刻</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么，问题来了，次构造方法有方法体，会执行这个init模块吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        println()</span><br><span class="line">        print(&quot;111&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        print(&quot;222&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里我们会看到打印台打印:222，换行打印111</span><br></pre></td></tr></table></figure><p>结论：<strong><em>不管是什么构造方法，先执行init模块逻辑，后执行构造方法的逻辑</em></strong></p><h3 id="this，super"><a href="#this，super" class="headerlink" title="this，super"></a>this，super</h3><p>&emsp;&emsp;简单的说一下继承,this和super两个关键字，跟java差不多；</p><p>&emsp;&emsp;this是调用自己的，super是调用父类的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">open class AAA &#123;</span><br><span class="line">        constructor(name: String) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;$name A&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        constructor(name: String, age: Int) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;我是AAA的两个参数的构造方法&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        init &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;222&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class BBB : AAA &#123;</span><br><span class="line">        constructor(name: String) : this(name, 0) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;我是BBB的一个参数的构造方法&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        constructor(name: String, age: Int) : super(name, age) &#123;</span><br><span class="line">            Log.v(&quot;wz&quot;, &quot;我是BBB的两个参数的构造方法&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var b = BBB(&quot;小王&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;类BBB继承类AAA，其中BBB分别有一个参数的构造方法和两个参数的构造方法；一个参数的构造方法用的this关键字调用自己的两个参数的构造；而两个参数的构造方法用的super关键字调用的父类两个参数的构造方法；这里控制台打印的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">222</span><br><span class="line">我是AAA的两个参数的构造方法</span><br><span class="line">我是BBB的两个参数的构造方法</span><br><span class="line">我是BBB的一个参数的构造方法</span><br></pre></td></tr></table></figure><h3 id="重写set-get方法"><a href="#重写set-get方法" class="headerlink" title="重写set/get方法"></a>重写set/get方法</h3><p>说到了这个类，讲一下怎么重写属性的set/get方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">open class Person &#123;</span><br><span class="line">        var name: String = &quot;&quot;</span><br><span class="line">            set(value) &#123;</span><br><span class="line">                field = value + &quot;www&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            get() &#123;</span><br><span class="line">                return field + &quot;zzz&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        var age: Int = 0</span><br><span class="line">            set(value) &#123;</span><br><span class="line">                field = if (value &gt;= 20) 20 else value</span><br><span class="line">            &#125;</span><br><span class="line">            get() &#123;</span><br><span class="line">                return field * 2</span><br><span class="line">            &#125;</span><br><span class="line">        var address: String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里一个person类，里面有三个属性：name，age，address；在name和age下面分别写了set，get方法，address没写。</p><p><strong>重点：</strong></p><ol><li>你想重写哪个属性的set，get方法，就在哪个属性下方写set，get方法，不用成对出现，可以只重写set方法，也可以只重写get方法</li><li>用field表示你想要的值</li></ol><p>&emsp;&emsp;这里，我就只重写了name和age的set，get方法，没有重写address的set，get方法</p><p>&emsp;&emsp;这里，我再存名字的时候在名字的后面加上了www，在获取的时候又加上了zzz，也就是说，如果你这里name传的是”小王”，那么你用get方法取到的name的值应该是”小王wwwzzz”</p><p>&emsp;&emsp;存age的时候，自己分析一下吧，很简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;java中的构造函数是与类名相同即可，kotlin里面的构造函数是用constructor关键字表示。&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之扩展函数let，run，also，apply</title>
    <link href="http://haichenyi.com/2019/06/11/kotlin%E4%B9%8B%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0let%EF%BC%8Crun%EF%BC%8Calso%EF%BC%8Capply/"/>
    <id>http://haichenyi.com/2019/06/11/kotlin之扩展函数let，run，also，apply/</id>
    <published>2019-06-11T14:33:50.000Z</published>
    <updated>2019-06-11T14:46:13.881Z</updated>
    
    <content type="html"><![CDATA[<p>举个例子</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">open class Person &#123;</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">    var age: Int = 0</span><br><span class="line">    var address: String = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    override fun toString(): String &#123;</span><br><span class="line">        return &quot;Person($name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;新建一个Person类，有三个属性，重写了toString方法。</p><p>&emsp;&emsp;这里有个关键字open，只有用open标识的类才能被继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var person1 = Person().let &#123;</span><br><span class="line">    it.name = &quot;张三let&quot;</span><br><span class="line">    it.age = 24</span><br><span class="line">    it.address = &quot;浦东新区&quot;</span><br><span class="line">    10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log.v(&quot;wz&quot;, person1.toString())//10</span><br><span class="line">var person2 = Person().run &#123;</span><br><span class="line">    this.name = &quot;张思run&quot;</span><br><span class="line">    this.age = 25</span><br><span class="line">    this.address = &quot;青浦区&quot;</span><br><span class="line">    20</span><br><span class="line">&#125;</span><br><span class="line">Log.v(&quot;wz&quot;, person2.toString())//20</span><br><span class="line"></span><br><span class="line">var person3 = Person().also &#123;</span><br><span class="line">    it.name = &quot;张武also&quot;</span><br><span class="line">    it.age = 26</span><br><span class="line">    it.address = &quot;黄浦区&quot;</span><br><span class="line">    30</span><br><span class="line">&#125;</span><br><span class="line">Log.v(&quot;wz&quot;,person3.toString())//Person(张武also)</span><br><span class="line"></span><br><span class="line">var person4 = Person().apply &#123;</span><br><span class="line">    this.name = &quot;张柳apply&quot;</span><br><span class="line">    this.age = 27</span><br><span class="line">    this.address = &quot;崇明区&quot;</span><br><span class="line">    40</span><br><span class="line">&#125;</span><br><span class="line">Log.v(&quot;wz&quot;,person4.toString())//Person(张柳apply)</span><br></pre></td></tr></table></figure><p>上面打印的结果：</p><pre><code>person1——let——10person2——run——20person3——also——Person(张武also)person4——apply——Person(张柳apply)</code></pre><p>总结：</p><ol><li>let,run以最后一行的结果为返回值；also,apply返回对象本身。</li><li>在他们的方法体中，let,also用it代指本身；run,apply用this代指本身。</li></ol><p>PS:充分了解他们的用法，以及返回值的区别，可以实现链式调用实现功能模块，使代码清晰，一目了然。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;举个例子&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin之基础</title>
    <link href="http://haichenyi.com/2019/06/11/kotlin%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://haichenyi.com/2019/06/11/kotlin之基础/</id>
    <published>2019-06-11T14:33:36.000Z</published>
    <updated>2019-06-11T14:43:21.986Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;自从18年上一家公司用kotlin做了项目之后，新公司就没有用过kotlin了，都快要忘完了，最近又想起来了，再捡了一下吧。</p><a id="more"></a><h3 id="定义变量的方式"><a href="#定义变量的方式" class="headerlink" title="定义变量的方式"></a>定义变量的方式</h3><p>&emsp;&emsp;java：类型+变量名+值+逗号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;kotlin：var/val+变量名+(:类型)+值(ps:类型可省略)</p><p>&emsp;&emsp;var：可变变量（可以重新分配值）</p><p>&emsp;&emsp;val：只读变量（初始化的时候必须赋值，不能修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var c:int</span><br><span class="line">    c = 5</span><br><span class="line">var c = 5    </span><br><span class="line">val b = 5</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>&emsp;&emsp;java：public/private/protected+返回类型+方法名+括号参数+大括号方法体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void add(int a ,int b)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public int add1(int a,int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;kotlin：fun+方法名+括号参数+(:返回类型)+大括号方法体</p><p>&emsp;&emsp;返回类型Unit类型，对应java的void，即无返回值，可省略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun add(a:int,b:int):Unit&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun add(a:int,b:int)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun add1(a:int,b:int):int&#123;</span><br><span class="line">  return a+b  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if表达式-java中三目运算符"><a href="#if表达式-java中三目运算符" class="headerlink" title="if表达式(java中三目运算符)"></a>if表达式(java中三目运算符)</h3><p>&emsp;&emsp;把a和b两个数中值大的赋值给c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java：三目运算符</span><br><span class="line">int c = a &gt; b ? a : b</span><br><span class="line">kotlin：if表达式</span><br><span class="line">val c = if( a &gt; b) a else b</span><br></pre></td></tr></table></figure></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//java</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">list.add(&quot;b&quot;);</span><br><span class="line">list.add(&quot;c&quot;);</span><br><span class="line">list.add(&quot;d&quot;);</span><br><span class="line">for (int j = 0; j &lt;= list.size(); j++) &#123;</span><br><span class="line">    Log.v(&quot;wz&quot;, list.get(j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//kotlin</span><br><span class="line">val list = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)</span><br><span class="line">for(item in list)&#123;</span><br><span class="line">    Log.v(&quot;wz&quot;,item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上面这个for循环等同于forEach</span><br><span class="line"></span><br><span class="line">list.forEach&#123;</span><br><span class="line">    Log.v(&quot;wz&quot;,it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上面两种循环拿不到下标</span><br><span class="line"></span><br><span class="line">for(index in list.indices)&#123;</span><br><span class="line">    //美元符号的用法见后面</span><br><span class="line">    Log.v(&quot;wz&quot;,&quot;第$index 个item的值是$&#123;list[index]&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//上面这种就可以拿到for循环的下标</span><br><span class="line">//kotlin中String类型的变量也可以for循环遍历每一个char的值</span><br></pre></td></tr></table></figure><h3 id="美元符号"><a href="#美元符号" class="headerlink" title="美元符号($)"></a>美元符号($)</h3><p>&emsp;&emsp;把$符号放在变量前面，输出的就是变量的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val i = 3</span><br><span class="line">Log.v(&quot;wz&quot;,&quot;i的值是：$i&quot;)</span><br><span class="line">//输出的是：i的值是：3</span><br><span class="line"></span><br><span class="line">Log.v(&quot;wz&quot;,&quot;i的值是：$3&quot;)</span><br><span class="line">//输出的是：i的值是：$3</span><br></pre></td></tr></table></figure></p><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="== 和 ===的区别"></a>== 和 ===的区别</h3><p>&emsp;&emsp;类似于java中的==和equals的区别</p><p>&emsp;&emsp;java：==判断值是否相等，equals判断物理地址是否相等</p><p>&emsp;&emsp;kotlin：==判断物理地址是否相等，===判断值是否相等</p><h3 id="数据类型的转换-toInt-toBoolean-等等"><a href="#数据类型的转换-toInt-toBoolean-等等" class="headerlink" title="数据类型的转换:toInt(),toBoolean()等等"></a>数据类型的转换:toInt(),toBoolean()等等</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//java中不同数据类型的相互转换是强转</span><br><span class="line">String s = &quot;1&quot;;</span><br><span class="line">int a = (int)s;</span><br><span class="line"></span><br><span class="line">//kotlin中没有强转提供了转换的方法</span><br><span class="line">var s = &quot;1&quot;</span><br><span class="line">var a = s.toInt()</span><br><span class="line">var a1 = s.toBoolean()</span><br></pre></td></tr></table></figure><h3 id="is运算符"><a href="#is运算符" class="headerlink" title="is运算符"></a>is运算符</h3><p>&emsp;&emsp;个人觉得is运算符类似于java中的instanceof关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//java：判断某个变量是否是某个类型的</span><br><span class="line">String s = &quot;1&quot;;</span><br><span class="line">if(s instanceof String)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//kotlin：判断某个变量是否是某个类型</span><br><span class="line">var s = &quot;1&quot;</span><br><span class="line">if(s is String)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//既然上面说了is是个运算符，运算符当然可以加非</span><br><span class="line">if(s !is String)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="空指针和lateinit"><a href="#空指针和lateinit" class="headerlink" title="空指针和lateinit"></a>空指针和lateinit</h3><p>&emsp;&emsp;要明确一点：java中才会有空指针异常，kotlin中不存在空指针异常，因为它有非空判断机制</p><p>&emsp;&emsp;比方说，我们如果要在kotlin定义一个Bitmap变量，我们知道Bitmap是非常占内存的，用完之后我们要手动置空</p><p>&emsp;&emsp;在类型的后面加上问号，用的时候也要加问号才能用，表示不为空的时候才会往下走，如果为空就不会往下走了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var bitmap:Bitmap? = null</span><br><span class="line">var w = bitmap?.width</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么，我们如果要定义一个不可能为空的对象怎么定义呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lateinit var bitmap:Bitmap</span><br><span class="line">bitmap.width</span><br></pre></td></tr></table></figure><h3 id="黑科技：when表达式和Any-任意类型"><a href="#黑科技：when表达式和Any-任意类型" class="headerlink" title="黑科技：when表达式和Any(任意类型)"></a>黑科技：when表达式和Any(任意类型)</h3><p>&emsp;&emsp;when表达式取代java中的switch，when的返回值依据每一个条件的返回值来定，可以返回任意类型，从上往下按顺序执行，else不能少</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lateinit var obj : Any</span><br><span class="line">var b = when(obj)&#123;</span><br><span class="line">    1 -&gt; 2</span><br><span class="line">    is String -&gt; 3</span><br><span class="line">    3,4 -&gt; &quot;obj等于3或者等于4&quot;</span><br><span class="line">    in 10..20 -&gt; &quot;obj在10到20之间&quot;</span><br><span class="line">    else -&gt; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比方说这里，先定义个可以是任意类型变量的的obj，如果传进来的是Int类型的1，则返回int类型的2。如果传进来的是String类型的变量，则返回int类型的3。其他，则返回boolean类型的true</p><p>&emsp;&emsp;when可以取代 if-else if链。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val x = 10</span><br><span class="line">when &#123;</span><br><span class="line">    x &lt; 10 -&gt; &quot;x小于10&quot;</span><br><span class="line">    x in 10..20 -&gt; &quot;x在10到20之间&quot;</span><br><span class="line">    x in 21..40 -&gt; &quot;x在21到40之间&quot;</span><br><span class="line">    else -&gt; &quot;x大于40&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><p>&emsp;&emsp;顾名思义：在某个范围内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//等同于 x &gt;= 1 &amp;&amp; x &lt;= 4(包括1，包括4)，从1到4</span><br><span class="line">x in 1..4 //1，2，3，4</span><br><span class="line"></span><br><span class="line">//等同于 x &gt;= 1 &amp;&amp; x &lt; 4(包括1，不包括4)，从1到4</span><br><span class="line">x in 1 until 4 //1，2，3</span><br><span class="line"></span><br><span class="line">//包括1，包括4 ，从4到1</span><br><span class="line">x in 4 downTo 1 //4，3，2，1</span><br><span class="line"></span><br><span class="line">//从1到8，每隔两个循环一次，也就是1，3，5，7</span><br><span class="line">i in 1..8 step 2</span><br><span class="line"></span><br><span class="line">//从8到1，每隔两个循环一次，也就是8，6，4，2</span><br><span class="line">i in 8 downTo 1 step 2</span><br><span class="line"></span><br><span class="line">//从8到1，每隔两个，并且要满足能整除3的，这里就是6</span><br><span class="line">i in (8 downTo 1 step 2).filter &#123; it % 3 == 0 &#125;</span><br><span class="line">//上面的关键字filter，还有map等，用过RxJava的应该很眼熟</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;自从18年上一家公司用kotlin做了项目之后，新公司就没有用过kotlin了，都快要忘完了，最近又想起来了，再捡了一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="kotlin" scheme="http://haichenyi.com/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>Android——Tensorflow-Lite简单使用</title>
    <link href="http://haichenyi.com/2019/06/11/Android%E2%80%94%E2%80%94Tensorflow-Lite%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://haichenyi.com/2019/06/11/Android——Tensorflow-Lite简单使用/</id>
    <published>2019-06-11T14:33:16.000Z</published>
    <updated>2019-06-11T14:40:00.369Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;项目里面用到了tflite，用于做简单的图片处理，不是判断图片是什么类型，就是传进去图片，生成新图片，类似于前面一篇讲的GPUImage的滤镜功能，但是比滤镜功能更加强大。</p><a id="more"></a><p>&emsp;&emsp;我这里要做的就是集成，拿人家训练好的模型直接来用，我不用去训练模型。</p><h3 id="第一步-依赖"><a href="#第一步-依赖" class="headerlink" title="第一步 依赖"></a>第一步 依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//依赖库</span><br><span class="line">implementation &apos;org.tensorflow:tensorflow-lite:0.0.0-nightly&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ···</span><br><span class="line">    //set no compress models</span><br><span class="line">    aaptOptions &#123;</span><br><span class="line">        noCompress &quot;tflite&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步-加载训练模型"><a href="#第二步-加载训练模型" class="headerlink" title="第二步 加载训练模型"></a>第二步 加载训练模型</h3><p>&emsp;&emsp;网上很多介绍资料都是把训练模型直接copy到项目main目录下的assets目录（不存在就创建）与java目录平级，自然，这样的加载方式就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// load infer model</span><br><span class="line">    private void loadModel(String model) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            tflite = new Interpreter(loadModelFile(model));</span><br><span class="line">            Log.d(TAG, model + &quot; model load success&quot;);</span><br><span class="line">            tflite.setNumThreads(4);</span><br><span class="line">            load_result = true;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            Log.d(TAG, model + &quot; model load fail&quot;);</span><br><span class="line">            load_result = false;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Memory-map the model file in Assets.</span><br><span class="line">     */</span><br><span class="line">    private MappedByteBuffer loadModelFile(String model) throws IOException &#123;</span><br><span class="line">        AssetFileDescriptor fileDescriptor = getApplicationContext().getAssets().openFd(model + &quot;.tflite&quot;);</span><br><span class="line">        FileInputStream inputStream = new FileInputStream(fileDescriptor.getFileDescriptor());</span><br><span class="line">        FileChannel fileChannel = inputStream.getChannel();</span><br><span class="line">        long startOffset = fileDescriptor.getStartOffset();</span><br><span class="line">        long declaredLength = fileDescriptor.getDeclaredLength();</span><br><span class="line">        return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个tflite文件就好几M，甚至十几M，全部copy到项目里面不显示，所以，我们一般项目里面用都是先下载，然后再使用，那，这样的方式，我们要怎么加载训练模型呢？</p><p>&emsp;&emsp;我们先分析一下再assets目录下面怎么加载的？说白了就是新建一个Interpreter对象，就是加载模型。上面的方法都过时了，我们可以找到Interpreter类，里面你会看到如下的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数传tflite文件，第二个参数传一个Interpreter静态内部类对象</span><br><span class="line">public Interpreter(@NonNull File modelFile, Interpreter.Options options) &#123;</span><br><span class="line">        this.wrapper = new NativeInterpreterWrapper(modelFile.getAbsolutePath(), options);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">//所以，我们自己项目里面加载模型，用如下方式即可</span><br><span class="line">Interpreter.Options options = new Interpreter.Options();</span><br><span class="line">options.setNumThreads(4);</span><br><span class="line">tflite = new Interpreter(new File(&quot;&quot;), options);</span><br></pre></td></tr></table></figure><h3 id="第三步-执行run方法"><a href="#第三步-执行run方法" class="headerlink" title="第三步 执行run方法"></a>第三步 执行run方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tflite.run(in, out);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过执行这个run方法，获取我们需要的东西，第一个参数，输入对象，第二个参数，输出参数。</p><p><strong><em>重点，敲黑板</em></strong></p><p><strong><em>重点，敲黑板</em></strong></p><p><strong><em>重点，敲黑板</em></strong></p><p>&emsp;&emsp;重点就在这里，这里的输入和输出参数要怎么传？我这里训练模型是用Python做的，它需要传入一个四维数组，所以，输出我们自然也要用一个四维数组接收。</p><p>&emsp;&emsp;这里的四维数组怎么传递呐？就要说到Android里面的bitmap知识了，它的每个像素点都是一个ARGB数组。即透明度，红色，绿色，蓝色。我们前面的灰色滤镜之类的东西，实际上就是改变RGB三原色的值，让颜色变成灰色，然后改变亮度之类的就是改变每个管道的透明度。网上有很多这样的知识。</p><p>&emsp;&emsp;再来说说这个四维数组，我项目里面用到的这个四维数组：<strong><em>1 X 256 X 256 X 3</em></strong>，这几个值怎么理解呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：表示一张图片</span><br><span class="line"></span><br><span class="line">256X256：表示图片的宽高</span><br><span class="line"></span><br><span class="line">3：表示RGB色值</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那我们怎么把bitmap对象，转换成我们需要的四维数组呐？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//定义了一个一维数组，里面就是我们需要的参数，便于修改</span><br><span class="line">private int[] ddims = &#123;1, 256, 256, 3&#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取图片的四维数组</span><br><span class="line">     * @param bitmap bitmap对象</span><br><span class="line">     * @param ddims 参数数组</span><br><span class="line">     * @return 图片四维数组</span><br><span class="line">     */</span><br><span class="line">public float[][][][] getScaledMatrix(Bitmap bitmap, int[] ddims) &#123;</span><br><span class="line">        //新建一个1*256*256*3的四维数组</span><br><span class="line">        float[][][][] inFloat = new float[ddims[0]][ddims[1]][ddims[2]][ddims[3]];</span><br><span class="line">        //新建一个一维数组，长度是图片像素点的数量</span><br><span class="line">        int[] pixels = new int[ddims[1] * ddims[2]];</span><br><span class="line">        //把原图缩放成我们需要的图片大小</span><br><span class="line">        Bitmap bm = Bitmap.createScaledBitmap(bitmap, ddims[1], ddims[2], false);</span><br><span class="line">        //把图片的每个像素点的值放到我们前面新建的一维数组中</span><br><span class="line">        bm.getPixels(pixels, 0, bm.getWidth(), 0, 0, ddims[1], ddims[2]);</span><br><span class="line">        int pixel = 0;</span><br><span class="line">        //for循环，把每个像素点的值转换成RBG的值，存放到我们的目标数组中</span><br><span class="line">        for (int i = 0; i &lt; ddims[1]; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; ddims[2]; ++j) &#123;</span><br><span class="line">                final int val = pixels[pixel++];</span><br><span class="line">                float red = ((val &gt;&gt; 16) &amp; 0xFF);</span><br><span class="line">                float green = ((val &gt;&gt; 8) &amp; 0xFF);</span><br><span class="line">                float blue = (val &amp; 0xFF);</span><br><span class="line">                float[] arr = &#123;red, green, blue&#125;;</span><br><span class="line">                inFloat[0][i][j] = arr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bm.isRecycled()) &#123;</span><br><span class="line">            bm.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        return inFloat;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面代码注释写的很清楚了吧？每一行都有注释，for循环的作用也标的很清楚，通过这个方法，我们得到的就是我们想要的四维数组了，这里的四维数组的格式，图片的大小，都是tflite文件建模型的时候设置好的，看你们训练模型的工程师是怎么定义的，你就怎么传。</p><p>&emsp;&emsp;然后，新建一个一模一样格式的数组去接收输出值，也是一个四维数组，那么，我们怎么把这个四维数组转换成我们需要的bitmap呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//创建bitmap的方法，</span><br><span class="line">Bitmap.createBitmap(@NonNull @ColorInt int[] colors,</span><br><span class="line">            int width, int height, Config config);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就是这个方法，传一个一维颜色数组，图片的宽高，还有一个图片的格式，那我们这里就是要把这个四维数组转成一个一维的颜色数组了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 四维数组转成bitmap对象</span><br><span class="line"> * @param outArr 数组</span><br><span class="line"> * @param ddims 格式</span><br><span class="line"> * @return bitmap</span><br><span class="line"> */</span><br><span class="line">public Bitmap getBitmap(float[][][][] outArr, int[] ddims) &#123;</span><br><span class="line">    //获取图片的三维数组</span><br><span class="line">    float[][][] temp = outArr[0];</span><br><span class="line">    int n = 0;</span><br><span class="line">    //新建一个接收的颜色数组，长度就是图片的宽高之积，类似于上面的像素那个数组</span><br><span class="line">    int[] colorArr = new int[ddims[1] * ddims[2]];</span><br><span class="line">    //for循环遍历把图片的ARGB色值转成一个颜色值，放入颜色数组中</span><br><span class="line">    for (int i = 0; i &lt; ddims[1]; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; ddims[2]; j++) &#123;</span><br><span class="line">            float[] arr = temp[i][j];</span><br><span class="line">            int alpha = 255;</span><br><span class="line">            int red = (int) arr[0];</span><br><span class="line">            int green = (int) arr[1];</span><br><span class="line">            int blue = (int) arr[2];</span><br><span class="line">            int tempARGB = (alpha &lt;&lt; 24) | (red &lt;&lt; 16) | (green &lt;&lt; 8) | blue;</span><br><span class="line">            colorArr[n++] = tempARGB;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建bitmap对象</span><br><span class="line">    return Bitmap.createBitmap(colorArr, ddims[1], ddims[2], Bitmap.Config.ARGB_8888);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，我们就拿到了，我们需要的bitmap对象了，然后再做后续的逻辑即可。</p><p><a href="https://download.csdn.net/download/qq_27634797/11199751" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;项目里面用到了tflite，用于做简单的图片处理，不是判断图片是什么类型，就是传进去图片，生成新图片，类似于前面一篇讲的GPUImage的滤镜功能，但是比滤镜功能更加强大。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>图片滤镜——GPUImage</title>
    <link href="http://haichenyi.com/2019/06/11/%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E2%80%94%E2%80%94GPUImage/"/>
    <id>http://haichenyi.com/2019/06/11/图片滤镜——GPUImage/</id>
    <published>2019-06-11T14:32:53.000Z</published>
    <updated>2019-06-11T14:38:34.991Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<a href="https://github.com/cats-oss/android-gpuimage" target="_blank" rel="noopener">GPUImage</a>图片滤镜处理的第三方开源库，对照IOS版的GPUImage写的,部分功能尚未完善，目前也有很多种滤镜，常用的滤镜基本上都有，请先浏览一遍github上面的用法。</p><a id="more"></a><h2 id="依赖的库"><a href="#依赖的库" class="headerlink" title="依赖的库"></a>依赖的库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">//这个版本号2.x.x，具体的数字看，github官方说明</span><br><span class="line">//README.md下方Download后面的版本号</span><br><span class="line">    implementation &apos;jp.co.cyberagent.android:gpuimage:2.x.x&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="一、图片变形"><a href="#一、图片变形" class="headerlink" title="一、图片变形"></a>一、图片变形</h3><p>&emsp;&emsp;Android版目前没有IOS那么多类，那么多用法，我们用的最多的就是GPUImageView这个自定义view，继承的FrameLayout，并不是继承的ImageView，所以，它这里显示图片的时候，会有<strong>图片变形的问题</strong>。我的<strong><em>处理方法：</em></strong></p><ol><li>先用Glide获取图片的宽高</li><li>然后获取GPUImageView的LayoutParams，动态设置控件的宽高</li></ol><h3 id="二、内存溢出"><a href="#二、内存溢出" class="headerlink" title="二、内存溢出"></a>二、内存溢出</h3><ol><li>图片过大造成的内存溢出，压缩图片，推荐使用鲁班压缩</li><li>频繁使用GPUImage获取Bitmap的getBitmapWithFilterApplied()方法，造成Bitmap过多的内存泄漏，推荐用WeakReference(弱引用)标记Bitmap，GC自动回收</li><li>显示大图和缩略图，一般都是一个大图和多种添加滤镜后的效果图(这个是缩略图)，这里缩略图再通过getBitmapWithFilterApplied获取之前，最好吧原图按照规则缩小之后再获取显示，这样也能尽可能的减少内存的占用，点击缩略图显示大的效果图的时候，并不是改变bitmap，是给gpuIamgeView对象设置你点击目标图使用滤镜即可，这样也可以避免内存过多的消耗</li></ol><h3 id="三、滤镜添加"><a href="#三、滤镜添加" class="headerlink" title="三、滤镜添加"></a>三、滤镜添加</h3><ol><li>单一滤镜的添加</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这里以添加黑白滤镜为例</span><br><span class="line">GPUImageView gpuImageView = findViewById(R.id.img);</span><br><span class="line">gpuImageView.setImage(bitmap);</span><br><span class="line">gpuImageView.setFilter(new GPUImageGrayscaleFilter());</span><br></pre></td></tr></table></figure><ol><li>组合滤镜的添加GPUImageFilterGroup</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GPUImageView gpuImageView = findViewById(R.id.img);</span><br><span class="line">gpuImageView.setImage(bitmap);</span><br><span class="line">GPUImageFilterGroup filterGroup = new GPUImageFilterGroup();</span><br><span class="line">//把你需要添加的滤镜放到GPUImageFilterGroup容器里面，</span><br><span class="line">//这里我添加了灰色滤镜，曝光度滤镜和饱和度滤镜理论上可以添加无数个</span><br><span class="line">filterGroup.add(new GPUImageGrayscaleFilter());</span><br><span class="line">filterGroup.add(new GPUImageExposureFilter());</span><br><span class="line">filterGroup.add(new GPUImageSaturationFilter());</span><br><span class="line">//把这个容器添加到GPUImageView</span><br><span class="line">gpuImageView.setFilter(filterGroup);</span><br></pre></td></tr></table></figure><ol><li>多张图片的滤镜</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//这里以GPUImageTwoInputFilter为例（可以加到组合滤镜里面）,它有多个子类</span><br><span class="line">//我们这里用GPUImageChromaKeyBlendFilter为例</span><br><span class="line">//实现的效果是一个过渡效果，从原图过渡到目标图</span><br><span class="line">GPUImageView gpuImageView = findViewById(R.id.img);</span><br><span class="line">//设置原图</span><br><span class="line">gpuImageView.setImage(bitmap);</span><br><span class="line">//新建滤镜对象，并且把目标图设置给滤镜</span><br><span class="line">GPUImageChromaKeyBlendFilter keyBlendFilter = new GPUImageChromaKeyBlendFilter();</span><br><span class="line">//设置目标图</span><br><span class="line">keyBlendFilter.setBitmap(bitmap1);</span><br><span class="line">//平滑的过渡方法，改变参数的值即可</span><br><span class="line">keyBlendFilter.setSmoothing(progressFloat);</span><br><span class="line">//把滤镜设置给GPUImageView</span><br><span class="line">gpuImageView.setFilter(keyBlendFilter);</span><br></pre></td></tr></table></figure><h3 id="四、微调（敏感度问题）"><a href="#四、微调（敏感度问题）" class="headerlink" title="四、微调（敏感度问题）"></a>四、微调（敏感度问题）</h3><p>&emsp;&emsp;只要构造方法，方法带参数的，都可以微调，这里微调的取值范围，Filter源码的类注释上面都有。如果，我们把seekBar的取值范围设置成类注释上面的范围，你滑动很小距离的seekBar，图片变化就会很大，所以，我们一般都是缩小范围再使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数seekBar是最大值，第二个参数是最小值，第三个参数是默认值，第四个参数是seekbar分几段</span><br><span class="line">//mapSeekBarBean.put(TYPE_SATURATION, new SeekBarBean(2, 0, 0.5f, 10));</span><br><span class="line">mapSeekBarBean.put(TYPE_SATURATION, new SeekBarBean(100, 0, 50f, 2));</span><br><span class="line">//mapSeekBarBean.put(TYPE_BRIGHTNESS, new SeekBarBean(1, -1, 0.5f, 10));</span><br><span class="line">mapSeekBarBean.put(TYPE_BRIGHTNESS, new SeekBarBean(100, 0, 50f, 2));</span><br><span class="line">//mapSeekBarBean.put(TYPE_EXPOSURE, new SeekBarBean(10, -10, 0.5f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_EXPOSURE, new SeekBarBean(100, 0, 50f, 2));</span><br><span class="line">//mapSeekBarBean.put(TYPE_CONTRAST, new SeekBarBean(4, 0, 0.25f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_CONTRAST, new SeekBarBean(100, 0, 25f, 2));</span><br><span class="line">mapSeekBarBean.put(TYPE_POSTERIZE, new SeekBarBean(256, 0, 100f, 3));</span><br><span class="line">//mapSeekBarBean.put(TYPE_HIGH_LIGHT_SHADOW, new SeekBarBean(1, 0, 0f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_HIGH_LIGHT_SHADOW, new SeekBarBean(100, 0, 0f, 2));</span><br><span class="line">mapSeekBarBean.put(TYPE_SHARPEN, new SeekBarBean(100, 0, 50f, 3));</span><br><span class="line">//mapSeekBarBean.put(TYPE_GAMMA, new SeekBarBean(3, 0, 0.33f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_GAMMA, new SeekBarBean(100, 0, 33f, 3));</span><br><span class="line">//mapSeekBarBean.put(TYPE_OPACITY, new SeekBarBean(1, 0, 1f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_OPACITY, new SeekBarBean(100, 0, 100f, 2));</span><br><span class="line">//mapSeekBarBean.put(TYPE_VIBRANCE, new SeekBarBean(1, 0, 0f, 0));</span><br><span class="line">mapSeekBarBean.put(TYPE_VIBRANCE, new SeekBarBean(100, 0, 0f, 2));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//这里是最终设置的值</span><br><span class="line">switch (entrySet.getKey()) &#123;</span><br><span class="line">                case TYPE_SATURATION:</span><br><span class="line">                    //最后面*2是范围（0,2）</span><br><span class="line">                    float f1 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 2;</span><br><span class="line">                    filters.add(new GPUImageSaturationFilter(f1));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_BRIGHTNESS:</span><br><span class="line">                    float f2 = entrySet.getValue().getProgress();</span><br><span class="line">                    if (f2 == 50) &#123;</span><br><span class="line">                        f2 = 0f;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //后面的*0.7是范围（-1,1），以中间0为准，分成两部分（-1,0），（0,1）</span><br><span class="line">                        //负数为变暗，正数为变亮,本应该*1</span><br><span class="line">                        f2 = (float) (((f2 - 50) / 50) * 0.4);</span><br><span class="line">                    &#125;</span><br><span class="line">                    filters.add(new GPUImageBrightnessFilter(f2));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_EXPOSURE:</span><br><span class="line">                    float f3 = entrySet.getValue().getProgress();</span><br><span class="line">                    if (f3 == 50) &#123;</span><br><span class="line">                        f3 = 0f;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //后面的*1是范围（-10,10），以中间0为准，分成两部分（-10,0），（0,10）</span><br><span class="line">                        //负数为变暗，正数为变亮，本应该*10</span><br><span class="line">                        f3 = ((f3 - 50) / 50) * 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    filters.add(new GPUImageExposureFilter(f3));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_CONTRAST:</span><br><span class="line">                    //最后面*4是范围（0,4）</span><br><span class="line">                    float f4 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 4;</span><br><span class="line">                    filters.add(new GPUImageContrastFilter(f4));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_POSTERIZE:</span><br><span class="line">                    filters.add(new GPUImagePosterizeFilter((int) entrySet.getValue().getProgress()));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_HIGH_LIGHT_SHADOW:</span><br><span class="line">                    GPUImageHighlightShadowFilter highlightShadowFilter = new GPUImageHighlightShadowFilter();</span><br><span class="line">                    float f9 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1;</span><br><span class="line">                    highlightShadowFilter.setHighlights(1 - f9);</span><br><span class="line">                    highlightShadowFilter.setShadows(f9);</span><br><span class="line">                    filters.add(highlightShadowFilter);</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_SHARPEN:</span><br><span class="line">                    float f5 = entrySet.getValue().getProgress();</span><br><span class="line">                    if (f5 == 50) &#123;</span><br><span class="line">                        f5 = 0f;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //后面的*4是范围（-4,4），以中间0为准，分成两部分（-4,0），（0,4）</span><br><span class="line">                        //负数为变暗，正数为变亮，本应该*4</span><br><span class="line">                        f5 = ((f5 - 50) / 50) * 4;</span><br><span class="line">                    &#125;</span><br><span class="line">                    filters.add(new GPUImageSharpenFilter(f5));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_GAMMA:</span><br><span class="line">                    //最后面*3是范围（0,3）</span><br><span class="line">                    float f6 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 3;</span><br><span class="line">                    filters.add(new GPUImageGammaFilter(f6));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_OPACITY:</span><br><span class="line">                    float f7 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1;</span><br><span class="line">                    filters.add(new GPUImageOpacityFilter(f7));</span><br><span class="line">                    break;</span><br><span class="line">                case TYPE_VIBRANCE:</span><br><span class="line">                    float f8 = (entrySet.getValue().getProgress() / entrySet.getValue().getMax()) * 1;</span><br><span class="line">                    filters.add(new GPUImageVibranceFilter(f8));</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>&emsp;&emsp;上面的注意事项里面已经说了简单的用法了，怎么获取滤镜后的图片呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//这个方法是获取bitmap对象，至于怎么保存，那就是你自己做了</span><br><span class="line">gpuImageView.getGPUImage().getBitmapWithFilterApplied();</span><br><span class="line"></span><br><span class="line">//当然，库也提供了保存图片的方法：保存的文件夹名称，文件名字，回调方法</span><br><span class="line">gpuImageView.saveToPictures(folderName,fileName,OnPictureSavedListener)</span><br><span class="line">//其中回调方法里面返回的uri，不能直接传给File，会找不到路径，需要转换一下</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 根据Uri获取文件的路径</span><br><span class="line">     *</span><br><span class="line">     * @param context    context</span><br><span class="line">     * @param contentURI uri</span><br><span class="line">     * @return 文件路径</span><br><span class="line">     */</span><br><span class="line">    public static String getRealPathFromURI(Context context, Uri contentURI) &#123;</span><br><span class="line">        String result;</span><br><span class="line">        Cursor cursor = context.getContentResolver().query(contentURI,</span><br><span class="line">                new String[]&#123;MediaStore.Images.ImageColumns.DATA&#125;,</span><br><span class="line">                null, null, null);</span><br><span class="line">        if (cursor == null) &#123;</span><br><span class="line">            result = contentURI.getPath();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cursor.moveToFirst();</span><br><span class="line">            int index = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);</span><br><span class="line">            result = cursor.getString(index);</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>项目就不贴出来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;https://github.com/cats-oss/android-gpuimage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GPUImage&lt;/a&gt;图片滤镜处理的第三方开源库，对照IOS版的GPUImage写的,部分功能尚未完善，目前也有很多种滤镜，常用的滤镜基本上都有，请先浏览一遍github上面的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>JDBC的简单使用——MySQL</title>
    <link href="http://haichenyi.com/2018/10/11/JDBC%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E2%80%94%E2%80%94MySQL/"/>
    <id>http://haichenyi.com/2018/10/11/JDBC的简单使用——MySQL/</id>
    <published>2018-10-11T14:51:00.000Z</published>
    <updated>2018-10-11T15:03:08.367Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前面几篇学了基本的SQL语句和用工具操作数据库，今天讲一下用代码操作数据库。</p><h4 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h4><p>&emsp;&emsp;<strong><em>首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java</em></strong></p><p>&emsp;&emsp;<strong><em>首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java</em></strong></p><p>&emsp;&emsp;<strong><em>首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java</em></strong></p><a id="more"></a><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1、获取驱动类,路动类路径：com.mysql.jdbc.Driver</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//获取url：jdbc:mysql://ip:端口号/数据库名称</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">//用户名</span><br><span class="line">String username = &quot;root&quot;;</span><br><span class="line">//密码</span><br><span class="line">String password = &quot;123&quot;;</span><br><span class="line">//获取Connection对象</span><br><span class="line">Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">System.out.print(connection);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总的来说，先要获取驱动类，然后就是获取Connection对象，就是一行代码<code>DriverManager.getConnection(url, username, password);</code>能走通，就说明连接上了。</p><h4 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test1() throws ClassNotFoundException, SQLException &#123;</span><br><span class="line">        //获取驱动类</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        //获取url</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">        //用户名</span><br><span class="line">        String username = &quot;root&quot;;</span><br><span class="line">        //密码</span><br><span class="line">        String password = &quot;123&quot;;</span><br><span class="line">        //获取Connection对象</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">        System.out.print(connection);</span><br><span class="line">        //获取Statement对象</span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        //String sql=&quot;INSERT INTO employee (eid,ename,edid) VALUES(null,&apos;小红&apos;,2)&quot;;</span><br><span class="line">        String sql = &quot;UPDATE employee SET edid=1 WHERE ename=&apos;小红&apos;&quot;;</span><br><span class="line">        statement.executeUpdate(sql);</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就是在连接数据库之后，通过Connection对象获取Statement对象，通过Statement对象的execute方法执行对应的SQL语句，最后记得关闭</p><h4 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        Connection con = null;</span><br><span class="line">        Statement state = null;</span><br><span class="line">        ResultSet resultSet = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String driverClassName = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">            String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">            String username = &quot;root&quot;;</span><br><span class="line">            String password = &quot;123&quot;;</span><br><span class="line">            Class.forName(driverClassName);</span><br><span class="line">            con = DriverManager.getConnection(url, username, password);</span><br><span class="line">            state = con.createStatement();</span><br><span class="line">            String querySQL = &quot;SELECT * FROM employee&quot;;</span><br><span class="line">            resultSet = state.executeQuery(querySQL);</span><br><span class="line">            List&lt;Map&lt;String, String&gt;&gt; mapList = new ArrayList&lt;&gt;();</span><br><span class="line">            while (resultSet.next()) &#123;</span><br><span class="line">                Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">                map.put(&quot;ename&quot;, resultSet.getString(&quot;ename&quot;));</span><br><span class="line">                map.put(&quot;edid&quot;, String.valueOf(resultSet.getInt(&quot;edid&quot;)));</span><br><span class="line">                mapList.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(mapList.size());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (resultSet != null) &#123;</span><br><span class="line">                    resultSet.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (state != null) &#123;</span><br><span class="line">                    state.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if (con != null) &#123;</span><br><span class="line">                    con.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;查询数据库需要注意的地方就是：</p><ol><li><p>执行SQL语句的方法是<code>executeQuery()</code>，只能执行查询语句。</p></li><li><p>他有一个返回值ResultSet，然后循环这个Set对象，获取数据，他提供了一个移动光标的方法<code>next()</code>，当他为null的时候，返回false，结束循环。</p></li><li><p>还提供了一系列的get方法，传表每一栏的下标index，或者每一栏的名称，获取对应的值。值的类型要与get的类型相同。值为int，就用getInt，值为String就用getString</p></li><li><p>最后记得关闭连接，倒着关闭。</p></li></ol><h4 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h4><p>&emsp;&emsp;上面用自己拼接sql语句的方式查询数据库，会容易被sql攻击。所以，我们需要用<code>PreparedStatement</code>来防止被sql攻击，具体方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean login(String username, String password) throws Exception &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement pstat = null;</span><br><span class="line">        ResultSet rs = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">            String url = &quot;jdbc:mysql://localhost:3306/test4&quot;;</span><br><span class="line">            String user = &quot;root&quot;;</span><br><span class="line">            String psw = &quot;123&quot;;</span><br><span class="line">            connection = DriverManager.getConnection(url, user, psw);</span><br><span class="line">            String sql = &quot;select * from t_user where username=? and psw=?&quot;;</span><br><span class="line">            pstat = connection.prepareStatement(sql);</span><br><span class="line">            pstat.setString(1, username);</span><br><span class="line">            pstat.setString(2, password);</span><br><span class="line">            rs = pstat.executeQuery();</span><br><span class="line">            return rs.next();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (rs != null) rs.close();</span><br><span class="line">            if (pstat != null) pstat.close();</span><br><span class="line">            if (connection != null) connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，是一个登录接口，传用户名，密码给后台，后台查询数据库，我们在获取了connection之后，通过connection调用prepareStatement方法，需要传一个sql模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;select * from t_user where username=? and psw=?&quot;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;什么是sql模板呢？就是吧需要动态传的参数用问好代替。我们上面这个查询语句，需要动态变化的就是username和psw。然后，我们调用PreparedStatement的setXxx方法，去设置值，第一个参数表示给第几个值赋值，第二个参数就是需要赋值的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//给第一个参数赋值为username</span><br><span class="line">pstat.setString(1, username);</span><br><span class="line">//给第二个参数赋值为password</span><br><span class="line">pstat.setString(2, password);</span><br></pre></td></tr></table></figure><h4 id="大数据存储"><a href="#大数据存储" class="headerlink" title="大数据存储"></a>大数据存储</h4><p>&emsp;&emsp;这里以存mp3为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_binary(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(50),</span><br><span class="line">DATA MEDIUMBLOB</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，首先创建一张表去存数据，数据类型不要错了，BLOB类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test1() throws SQLException, IOException &#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql=&quot;INSERT INTO t_binary VALUE(?,?,?)&quot;;</span><br><span class="line">        PreparedStatement pstat = connection.prepareStatement(sql);</span><br><span class="line">        pstat.setInt(1,1);</span><br><span class="line">        pstat.setString(2,&quot;KenT - 唱给谁听.mp3&quot;);</span><br><span class="line">        byte[] bytes= IOUtils.toByteArray(new FileInputStream(&quot;D:/CloudMusic/KenT - 唱给谁听.mp3&quot;));</span><br><span class="line">        Blob blob=new SerialBlob(bytes);</span><br><span class="line">        pstat.setBlob(3,blob);</span><br><span class="line">        pstat.executeLargeUpdate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面test1就是存的方法，步骤：</p><ol><li><p>先连接数据库，获取Connection对象</p></li><li><p>然后，获取PreparedStatement对象，设置参数，其中blob参数，Blob是一个接口，先获取他的实现类SerialBlob，这个实现类的构造方法需要传一个byte[]数组，所以，我们只用把需要存储的文件转成byte[]数组就可以了</p></li><li><p>最后，执行sql语句就可以了</p></li></ol><p>这里需要注意的是，要在my.ini服务器配置文件中设置最大存储<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个大小大于你的存储文件即可</span><br><span class="line">max_allowed_packet=20M</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;[mysqld]下边的是服务器配置，[mysql]下边的是客户端配置</p><p>&emsp;&emsp;接下来就是怎么取文件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test2() throws SQLException, IOException &#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql=&quot;SELECT * FROM t_binary WHERE name=?&quot;;</span><br><span class="line">        PreparedStatement pstat = connection.prepareStatement(sql);</span><br><span class="line">        pstat.setString(1,&quot;KenT - 唱给谁听.mp3&quot;);</span><br><span class="line">        ResultSet rs = pstat.executeQuery();</span><br><span class="line">        if (rs.next())&#123;</span><br><span class="line">            Blob blob = rs.getBlob(&quot;data&quot;);</span><br><span class="line">            InputStream in = blob.getBinaryStream();</span><br><span class="line">            FileOutputStream out = new FileOutputStream(&quot;D:/cgst.mp3&quot;);</span><br><span class="line">            IOUtils.copy(in,out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要说的就是获取到ResultSet之后，获取到Blob，通过他的getBinaryStream()方法，转成输入流，拿到输入流之后，转成File即可</p><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test6() throws SQLException &#123;</span><br><span class="line">        Connection connection = JDBCUtils.getConnection();</span><br><span class="line">        String sql = &quot;INSERT INTO t_user VALUE(?,?,?)&quot;;</span><br><span class="line">        PreparedStatement pstat = connection.prepareStatement(sql);</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            pstat.setInt(1, i + 1);</span><br><span class="line">            pstat.setString(2, &quot;user&quot; + i);</span><br><span class="line">            pstat.setString(3, i % 2 == 0 ? &quot;男&quot; : &quot;女&quot;);</span><br><span class="line">            pstat.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        pstat.executeBatch();</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.print(end - start);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意点：</p><ol><li>每添加一条数据，调用一遍pstat.addBatch();</li><li>当数据添加完以后，调用pstat.executeBatch();执行sql语句</li><li>mysql要开启批处理功能，不然慢到你无法想象。在获取Connection传的url后面，添加<code>rewriteBatchedStatements=true</code>。完整url<code>jdbc:mysql://localhost:3306/test4?rewriteBatchedStatements=true</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前面几篇学了基本的SQL语句和用工具操作数据库，今天讲一下用代码操作数据库。&lt;/p&gt;
&lt;h4 id=&quot;连接MySQL&quot;&gt;&lt;a href=&quot;#连接MySQL&quot; class=&quot;headerlink&quot; title=&quot;连接MySQL&quot;&gt;&lt;/a&gt;连接MySQL&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;em&gt;首先记得需要导包，jdbc连接MySQL数据库的jar包，名字：mysql-connector-java&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -JDBC" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（五）——多表查询</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（五）——多表查询/</id>
    <published>2018-10-11T14:50:45.000Z</published>
    <updated>2018-10-11T15:03:11.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并结果集-union-all-包含相同行-、union-去除相同行"><a href="#合并结果集-union-all-包含相同行-、union-去除相同行" class="headerlink" title="合并结果集 union all(包含相同行)、union(去除相同行)"></a>合并结果集 <code>union all(包含相同行)、union(去除相同行)</code></h3><p>&emsp;&emsp;把查询的结果合并到一起。<strong>要求：</strong> <code>查询的结果列数相同，列类型相同</code></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">    eid int,</span><br><span class="line">    ename varchar(50),</span><br><span class="line">    eage int</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table stu(</span><br><span class="line">    sid int,</span><br><span class="line">    sname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//合并结果集（加上all，包含相同的行）</span><br><span class="line">select eid,ename from emp</span><br><span class="line">union all</span><br><span class="line">select * from stu;</span><br><span class="line"></span><br><span class="line">//合并结果集（去掉all，去除相同行）</span><br><span class="line">select eid,ename from emp</span><br><span class="line">union</span><br><span class="line">select * from stu;</span><br></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p><strong>方言：</strong> <code>select * from 表1,表2 where 条件</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表a有三条数据：q，w，e</span><br><span class="line">表b有两条数据：h，j</span><br><span class="line">select * from a,b;</span><br><span class="line">得出的结果是表a与表b的笛卡尔集，也就是会得到6条数据，</span><br><span class="line">分别：qh,qj,wh,wj,eh,ej</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">去除无用的笛卡尔集，加上where后面的条件</span><br><span class="line">连表查询会有附表的外键=主表的主键这个条件</span><br><span class="line"></span><br><span class="line">select * from student,teacher where student.tid=teacher.tid;</span><br><span class="line"></span><br><span class="line">查询学生的全部信息，需要查询学生表和老师表，</span><br><span class="line">条件是学生表里面的老师id等于老师表里面的老师id，</span><br><span class="line">这样查出来的结果就是我们想要的结果</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例子：要求打印员工姓名，工资以及部分名称</span><br><span class="line">     员工姓名，工资在emp表，部门名称在dept表</span><br><span class="line">select emp.ename,emp.sal,dept.dname</span><br><span class="line">from emp,dept</span><br><span class="line">where emp.did=dept.did;</span><br><span class="line"></span><br><span class="line">如果嫌弃表名字太长了可以这样：</span><br><span class="line">select e.ename,e.sal,d.dname</span><br><span class="line">from emp e,dept d</span><br><span class="line">where e.did=d.did;</span><br></pre></td></tr></table></figure><p><strong>标准：</strong> <code>select * from 表1 别名1 inner join 表2 别名2 on 条件</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">别名都是可选的，条件跟上面写的一样。两者的区别就只有二个：</span><br><span class="line">1、方言连接两个表是用逗号，标准连接两个表是用 inner join</span><br><span class="line">2、条件：方言用where，标准用on</span><br><span class="line"></span><br><span class="line">select e.ename,e.sal,d.dname</span><br><span class="line">from emp e inner join dept d</span><br><span class="line">where e.did=d.did;</span><br></pre></td></tr></table></figure></p><h4 id="外连接-一主一次"><a href="#外连接-一主一次" class="headerlink" title="外连接 一主一次"></a>外连接 <code>一主一次</code></h4><p><strong>左外连接</strong> <code>left outer join ,左表为主表，右表为次表,左表中不论满足不满足条件都查询出来，右表中对应的位置用null补位</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询所有员工名称，工资以及部门名称，部门名称为null的填无部分</span><br><span class="line">select e.ename as 姓名,e.sal as 工资,d.ifnull(dname,&apos;无部门&apos;) as 部门名称</span><br><span class="line">from emp e left outer join dept d</span><br><span class="line">where e.did=d.did;</span><br></pre></td></tr></table></figure></p><p><strong>右外连接</strong> <code>right outer join 与左外对应</code></p><h3 id="子查询-一条sql语句中有多个select关键字-ALL-ANY-IN"><a href="#子查询-一条sql语句中有多个select关键字-ALL-ANY-IN" class="headerlink" title="子查询 一条sql语句中有多个select关键字,ALL,ANY,IN"></a>子查询 <code>一条sql语句中有多个select关键字,ALL,ANY,IN</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查询员工中最高工资员工的详细信息</span><br><span class="line">select * from emp where sal=MAX(sal);</span><br><span class="line">//上面这个写法是错误的，条件中是不能出现集合函数</span><br><span class="line">//上面这个写法是错误的，条件中是不能出现集合函数</span><br><span class="line">//上面这个写法是错误的，条件中是不能出现集合函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1、先查最高工资</span><br><span class="line">select MAX(sal) from emp;</span><br><span class="line">//2、最高工资的员工信息</span><br><span class="line">select * from emp where sal=(select MAX(sal) from emp);</span><br><span class="line">//上面这个写法才是正确的</span><br><span class="line">//上面这个写法才是正确的</span><br><span class="line">//上面这个写法才是正确的</span><br></pre></td></tr></table></figure><p><strong>出现的位置：</strong> <code>1、from后作为表 2、where后作为条件</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上面那条sql语句就是作为条件</span><br><span class="line">//查询部门等于30的员工的姓名和年龄</span><br><span class="line">select e.name,e.age from (select * from emp where did=30) e;</span><br><span class="line">//上面这条就是from后面作为表</span><br></pre></td></tr></table></figure></p><p><strong>1、打印高于平均工资的所有人的信息(单行单列作为条件)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where (sal&gt;select AVG(sal) from emp);</span><br></pre></td></tr></table></figure></p><p><strong>2、打印大于30部门的所有员工工资的员工信息(多行单列作为条件)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where sal &gt; ALL (select sal from emp where did=30);</span><br></pre></td></tr></table></figure></p><p><strong>3、打印大于30部门任意一人员工工资的员工信息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where sal&gt; ANY (select sal from emp where did = 30);</span><br></pre></td></tr></table></figure></p><p><strong>4、打印工作和部门与张三相同的员工信息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where (job,did) IN (select job,did from emp where ename=&apos;张三&apos;);</span><br></pre></td></tr></table></figure></p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p><strong><em>前提条件已知四张表</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">员工表emp(eid,ename,job,emid,etime,sal,edid)</span><br><span class="line">部门表dept(did,dname,dloc)</span><br><span class="line">薪资等级表salgrade(grade,losal,hisal)</span><br><span class="line">领导表mgr(mid,mname,mtime)</span><br></pre></td></tr></table></figure></p><p><strong>1、查询至少有一个员工的部门，显示部门编号，部门名称，部门位置，部门人数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：d.did，d.dname，d.dloc，部门人数</span><br><span class="line">2、表：dept d，emp e</span><br><span class="line">条件：e.did=d.did</span><br><span class="line"></span><br><span class="line">//查询部门编号，部门名称，部门位置</span><br><span class="line">select * from dept;</span><br><span class="line"></span><br><span class="line">//查询部门人数</span><br><span class="line">select e.did,count(*) from emp group by e.did;</span><br><span class="line"></span><br><span class="line">//把上面查询的两张表内连接</span><br><span class="line">select * from dept inner join select e.did,count(*) from emp group by e.did;</span><br><span class="line"></span><br><span class="line">//加上条件，给出别名</span><br><span class="line">select d.*,z1.cnt from dept d inner join (select did,count(*) cnt from emp group by e.did) z1 where d.did=z1.did;</span><br></pre></td></tr></table></figure></p><p><strong>2、查询所有员工名称及其直接上级领导名称</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：e.ename，m.mname</span><br><span class="line">2、表：emp e，mgr m</span><br><span class="line">条件：e.emid=m.mid</span><br><span class="line">//查询员工名称</span><br><span class="line">select ename from emp;</span><br><span class="line">//查询领导名称</span><br><span class="line">select mname from mgr;</span><br><span class="line"></span><br><span class="line">select ename from emp e left outer join (select mname from mgr ) m on e.emid = m.mid;</span><br></pre></td></tr></table></figure></p><p><strong>3、列出受雇佣日期早于直接上级的所有员工编号，姓名，以及部门名称</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：e.eid,e.ename,d.dname</span><br><span class="line">2、表：emp，mgr，dept</span><br><span class="line">//查询受雇佣日期早于直接上级领导的员工信息</span><br><span class="line">select etime from emp;</span><br><span class="line">select mtime from mgr;</span><br><span class="line"></span><br><span class="line">select * from emp e</span><br><span class="line">inner join </span><br><span class="line">select mtime from mgr m</span><br><span class="line">on e.emid=m.mid and e.etime&lt;m.mtime</span><br><span class="line"></span><br><span class="line">//再把部门名称加上</span><br><span class="line">(select eid,ename,edid from emp e</span><br><span class="line">inner join </span><br><span class="line">select mtime from mgr m</span><br><span class="line">on e.emid=m.mid and e.etime&lt;m.mtime) z1 </span><br><span class="line">left outer join </span><br><span class="line">select dname from dept d </span><br><span class="line">on z1.edid = d.did;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">select e.eid,e.ename,d.dname</span><br><span class="line">from emp e,mgr m,dept d</span><br><span class="line">where e.emid=m.mid and e.etime&lt;m.mtime and e.edid=d.did;</span><br></pre></td></tr></table></figure></p><p><strong>4、列出部门名称和这些部门的员工信息，同事列出没有员工的部门</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：员工信息，和部门名称，没有员工的部门也要列出来</span><br><span class="line">2、表：emp,dept</span><br><span class="line"></span><br><span class="line">select e.*,d.dname from emp e </span><br><span class="line">right outer join </span><br><span class="line">dept d</span><br><span class="line">on e.edid=d.did;</span><br></pre></td></tr></table></figure></p><p><strong>5、列出最低薪资大于15000的各种工作以及从事此工作的人数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：工作类型，人数</span><br><span class="line">2、表：emp</span><br><span class="line">条件：min(sal)&gt;15000</span><br><span class="line"></span><br><span class="line">select job,count(*)</span><br><span class="line">from emp</span><br><span class="line">group by job</span><br><span class="line">having min(sal)&gt;15000</span><br></pre></td></tr></table></figure></p><p><strong>6、列出在销售部工作的员工姓名，假定不知道销售部的部门编号</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：员工姓名</span><br><span class="line">2、表：emp,dept</span><br><span class="line">条件：e.edid=d.did</span><br><span class="line"></span><br><span class="line">select ename</span><br><span class="line">from emp e</span><br><span class="line">where e.edid=(select did from dept where dname=&apos;销售部&apos;);</span><br></pre></td></tr></table></figure></p><p><strong>7、列出薪资高于公司平均工资的所有员工信息，所在部门名称，上级领导，工资等级</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：员工信息，部门名称，上级领导名称，工资等级</span><br><span class="line">2、表：emp,dept,mgr</span><br><span class="line">条件：sal&gt;avg(sal),e.edid=d.did,e.emid=m.mid</span><br><span class="line">//先查询高出平均工资的员工信息</span><br><span class="line">select * from emp where sal&gt;(select avg(sal) from emp);</span><br><span class="line"></span><br><span class="line">//把后面的表一个一个的加上去</span><br><span class="line">//加部门名称</span><br><span class="line">select e.*,d.dname</span><br><span class="line">from </span><br><span class="line">    emp e left outer join dept d on e.edid=d.did</span><br><span class="line">where e.sal&gt;(select avg(sal) from emp)</span><br><span class="line"></span><br><span class="line">//加上级领导名称</span><br><span class="line">select e.*,d.dname,m.mname</span><br><span class="line">from </span><br><span class="line">    emp e left outer join dept d on e.edid=d.did</span><br><span class="line">    left outer join mgr m on e.emid = m.mid</span><br><span class="line">where e.sal&gt;(select avg(sal) from emp)</span><br><span class="line"></span><br><span class="line">//最后加工资等级</span><br><span class="line">select e.*,d.dname,m.mname,s.grade</span><br><span class="line">from </span><br><span class="line">    emp e left outer join dept d on e.edid=d.did</span><br><span class="line">    left outer join mgr m on e.emid = m.mid</span><br><span class="line">    left outer join salgrade s on e.sal between s.losal and hisal</span><br><span class="line">where e.sal&gt;(select avg(sal) from emp)</span><br></pre></td></tr></table></figure></p><p><strong>8、列出与张三从事相同工作的所有员工以及部门名称</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">1、列：所有员工，部门名称</span><br><span class="line">2、表：emp，dept</span><br><span class="line">条件：张三的工作相同，e.edid=d.did</span><br><span class="line"></span><br><span class="line">select e.*,d.dname from emp e </span><br><span class="line">left outer join dept d</span><br><span class="line">on e.edid=d.did</span><br><span class="line">where e.job=(select job from emp where ename=&apos;张三&apos;);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">select e.*,d.dname from emp e,dept d where e.edid=did and e.job=(select job from emp where ename=&apos;张三&apos;);</span><br></pre></td></tr></table></figure></p><p><strong>9、列出薪资高于30部门的所有员工薪资的员工的姓名和薪资，部门名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select e.ename,e.sal,d.dname from emp e left outer join dept d</span><br><span class="line">where e.sal &gt; all (select sal from emp where edid=30) and e.edid = d.did;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;合并结果集-union-all-包含相同行-、union-去除相同行&quot;&gt;&lt;a href=&quot;#合并结果集-union-all-包含相同行-、union-去除相同行&quot; class=&quot;headerlink&quot; title=&quot;合并结果集 union all(包含相同行)、union(去除相同行)&quot;&gt;&lt;/a&gt;合并结果集 &lt;code&gt;union all(包含相同行)、union(去除相同行)&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;把查询的结果合并到一起。&lt;strong&gt;要求：&lt;/strong&gt; &lt;code&gt;查询的结果列数相同，列类型相同&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（四）——多表之间的关系</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（四）——多表之间的关系/</id>
    <published>2018-10-11T14:50:29.000Z</published>
    <updated>2018-10-11T15:03:14.674Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主键与外键"><a href="#主键与外键" class="headerlink" title="主键与外键"></a>主键与外键</h3><p><code>1、一张表可以有多个外键</code></p><p><code>2、外键是表的主键，可以是别的表，也可以是本身（少见）</code></p><p><code>3、外键可以为null，可以重复，但是不能不存在，必须要查的到</code></p><p><strong>创建语法</strong> <code>foreign key(本表的列名) references 关联的表名(关联表的主键)</code></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//创建一个部门表</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">did INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">dname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//插入几条数据</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;销售部&apos;);</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;技术部&apos;);</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;人力部&apos;);</span><br><span class="line">INSERT INTO dept(did,dname) VALUE(NULL,&apos;保洁部&apos;);</span><br><span class="line"></span><br><span class="line">//创建一个员工表，这里的的edid是一个外键，对应部门表的主键did</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">eid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">ename VARCHAR(50),</span><br><span class="line">edid INT,</span><br><span class="line">CONSTRAINT fk_empl_dept FOREIGN KEY(edid) REFERENCES dept(did)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">eid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">ename VARCHAR(50),</span><br><span class="line">edid INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alter table employee add CONSTRAINT fk_empl_dept FOREIGN KEY(edid) REFERENCES dept(did);</span><br><span class="line"></span><br><span class="line">//上面这样也可以设置外键</span><br></pre></td></tr></table></figure><h3 id="一对一关系-把从表的主键设置成外键与主表的主键关联"><a href="#一对一关系-把从表的主键设置成外键与主表的主键关联" class="headerlink" title="一对一关系 把从表的主键设置成外键与主表的主键关联"></a>一对一关系 <code>把从表的主键设置成外键与主表的主键关联</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">    eid int primary key auto_increment,</span><br><span class="line">    ename varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table hmp(</span><br><span class="line">    hid int primary key auto_increment,</span><br><span class="line">    hname varchar(50),</span><br><span class="line">    constraint fk_hmp_emp foreign key(hid) references emp(eid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//如上，这样创建的两张表emp与hmp就是一对一的关系</span><br><span class="line"></span><br><span class="line">//插入数据</span><br><span class="line">insert into emp values(1,&apos;张三&apos;);</span><br><span class="line">insert into hmp values(1,&apos;李四&apos;);</span><br><span class="line">//这样张三跟李四就对应上了</span><br></pre></td></tr></table></figure><h3 id="多对多关系-两个主表-一个关联表"><a href="#多对多关系-两个主表-一个关联表" class="headerlink" title="多对多关系 两个主表+一个关联表"></a>多对多关系 <code>两个主表+一个关联表</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">create table teacher(</span><br><span class="line">    tid int primary key auto_increment,</span><br><span class="line">    tname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table student(</span><br><span class="line">    sid int primary key auto_increment,</span><br><span class="line">    sname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table stu_tea(</span><br><span class="line">    tid int,</span><br><span class="line">    sid int,</span><br><span class="line">    constraint fk_student foreign key(sid) references student(sid),</span><br><span class="line">    constraint fk_teacher foreign key(tid) references teacher(tid)</span><br><span class="line">);</span><br><span class="line">//这里的stu_tea就是关联表。多对多并不是说多张表对应多张表</span><br><span class="line"></span><br><span class="line">//插入数据</span><br><span class="line">insert into teacher values(1,&apos;黄老师&apos;);</span><br><span class="line">insert into teacher values(2,&apos;李老师&apos;);</span><br><span class="line">insert into teacher values(3,&apos;赵老师&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into student values(1,&apos;张三&apos;);</span><br><span class="line">insert into student values(2,&apos;李四&apos;);</span><br><span class="line">insert into student values(3,&apos;王五&apos;);</span><br><span class="line">insert into student values(4,&apos;赵六&apos;);</span><br><span class="line"></span><br><span class="line">//这里黄老师教过张三，李四</span><br><span class="line">insert into stu_tea values(1,1);</span><br><span class="line">insert into stu_tea values(1,2);</span><br><span class="line">//李老师教过王五，赵六</span><br><span class="line">insert into stu_tea values(2,3);</span><br><span class="line">insert into stu_tea values(2,4);</span><br><span class="line">//赵老师教过张三，李四，王五，赵六</span><br><span class="line">insert into stu_tea values(3,1);</span><br><span class="line">insert into stu_tea values(3,2);</span><br><span class="line">insert into stu_tea values(3,3);</span><br><span class="line">insert into stu_tea values(3,4);</span><br><span class="line"></span><br><span class="line">//上面这样，一个学生对应多个老师，一个老师也对应多个学生，叫做多对多的关系</span><br></pre></td></tr></table></figure><h3 id="一对多关系-一方不变，另一方在变化"><a href="#一对多关系-一方不变，另一方在变化" class="headerlink" title="一对多关系 一方不变，另一方在变化"></a>一对多关系 <code>一方不变，另一方在变化</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//我们一开始创建的员工表与部门表就是一对多</span><br><span class="line">create table dept(</span><br><span class="line">    did int primary key auto_increment,</span><br><span class="line">    dname varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">    eid int primary key auto_increment,</span><br><span class="line">    ename varchar(50)</span><br><span class="line">    edid int,</span><br><span class="line">    constraint fk_emp_dept foreign key(edid) references dept(did)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//这里的一就是部门表（主表），多就是员工表（附表）</span><br><span class="line">//插入数据</span><br><span class="line">insert into dept values(10,&apos;技术部&apos;);</span><br><span class="line">insert into dept values(20,&apos;人事部&apos;);</span><br><span class="line"></span><br><span class="line">//张三，李四属于技术部，王五属于人事部</span><br><span class="line">insert into emp values(null,&apos;张三&apos;,10);</span><br><span class="line">insert into emp values(null,&apos;李四&apos;,10);</span><br><span class="line">insert into emp values(null,&apos;王五&apos;,20);</span><br><span class="line"></span><br><span class="line">//一个部门对应多个员工，一对多</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主键与外键&quot;&gt;&lt;a href=&quot;#主键与外键&quot; class=&quot;headerlink&quot; title=&quot;主键与外键&quot;&gt;&lt;/a&gt;主键与外键&lt;/h3&gt;&lt;p&gt;&lt;code&gt;1、一张表可以有多个外键&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2、外键是表的主键，可以是别的表，也可以是本身（少见）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3、外键可以为null，可以重复，但是不能不存在，必须要查的到&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建语法&lt;/strong&gt; &lt;code&gt;foreign key(本表的列名) references 关联的表名(关联表的主键)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（三）——数据库的备份与恢复</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（三）——数据库的备份与恢复/</id>
    <published>2018-10-11T14:50:13.000Z</published>
    <updated>2018-10-11T15:03:20.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库的备份与恢复"><a href="#数据库的备份与恢复" class="headerlink" title="数据库的备份与恢复"></a>数据库的备份与恢复</h3><p><strong>备份</strong>：<code>mysqldump -u用户名 -p密码 数据库名&gt;生成的脚本路径</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//末尾没有分号，也不要登录</span><br><span class="line">mysqldunp -uroot -p123 school&gt;C:a.sql</span><br></pre></td></tr></table></figure><p><strong>恢复</strong>：<code>mysqldump -u用户名 -p密码 数据库名&lt;生成的脚本路径</code></p><p><code>或者：登录之后，切换到需要恢复的数据库，输入：source 生成的脚本路径</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//要先删除school数据库，再重新创建数据库，这两步需要登录</span><br><span class="line">//执行下面sql语句，不要登录，末尾没有分号</span><br><span class="line">mysqldunp -uroot -p123 school&lt;C:a.sql</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><p>找到你的mysql的安装目录，找到my.ini文件，更bin目录同级，修改如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">character-set-server=utf8 </span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"></span><br><span class="line">default-character-set=utf8 </span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"></span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure></p><p><strong>修改完之后，不仅是要重新连接数据库，必须要重启数据库</strong></p><p><strong>修改完之后，不仅是要重新连接数据库，必须要重启数据库</strong></p><p><strong>修改完之后，不仅是要重新连接数据库，必须要重启数据库</strong></p><p><code>net stop mysql</code> <code>net start mysql</code></p><h3 id="主键-primary-key"><a href="#主键-primary-key" class="headerlink" title="主键 primary key"></a>主键 primary key</h3><p><strong>创建表的时候直接设置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid CHAR(12) PRIMARY KEY,</span><br><span class="line">ename VARCHAR(20),</span><br><span class="line">esal INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">esid CHAR(12),</span><br><span class="line">ename VARCHAR(20),</span><br><span class="line">esal INT,</span><br><span class="line">PRIMARY KEY(esid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>修改主键</strong> <code>alter table 表名 add primary key(键名)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp add primary key(esid);</span><br></pre></td></tr></table></figure></p><p><strong>删除主键</strong> <code>alter table 表名 drop primary key</code></p><p><strong>主键自增长</strong> <code>auto_increment</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid int PRIMARY KEY auto_increment,</span><br><span class="line">ename VARCHAR(20),</span><br><span class="line">esal INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>非空约束</strong> <code>not null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid int PRIMARY KEY auto_increment,</span><br><span class="line">ename VARCHAR(20) not null,</span><br><span class="line">esal INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>唯一约束</strong> <code>not null unique</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">esid int PRIMARY KEY auto_increment,</span><br><span class="line">ename VARCHAR(20) not null unique,</span><br><span class="line">esal INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据库的备份与恢复&quot;&gt;&lt;a href=&quot;#数据库的备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;数据库的备份与恢复&quot;&gt;&lt;/a&gt;数据库的备份与恢复&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;备份&lt;/strong&gt;：&lt;code&gt;mysqldump -u用户名 -p密码 数据库名&amp;gt;生成的脚本路径&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//末尾没有分号，也不要登录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysqldunp -uroot -p123 school&amp;gt;C:a.sql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;恢复&lt;/strong&gt;：&lt;code&gt;mysqldump -u用户名 -p密码 数据库名&amp;lt;生成的脚本路径&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;或者：登录之后，切换到需要恢复的数据库，输入：source 生成的脚本路径&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//要先删除school数据库，再重新创建数据库，这两步需要登录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//执行下面sql语句，不要登录，末尾没有分号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysqldunp -uroot -p123 school&amp;lt;C:a.sql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（二）——DQL</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94DQL/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（二）——DQL/</id>
    <published>2018-10-11T14:49:56.000Z</published>
    <updated>2018-10-11T15:15:53.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>关键字：select、from、where、group by、having、roder by</p><a id="more"></a><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><p>&emsp;&emsp;<strong>查询所有：</strong><code>select * from 表名;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_stu;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>查询部分列</strong><code>select 列名,...列名 from 表名;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select stu_num,stu_name from t_stu;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>查询去除完全重复的列</strong><code>select distinct * from 表名;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select distinct * from t_stu;</span><br><span class="line">select distinct stu_age from t_stu;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>也可以查询同时做加、减、乘、除运算操作</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//把查询出来的年龄都乘以2倍。</span><br><span class="line">select stu_age*2 from t_stu;</span><br><span class="line">//如果查出来的年龄为null，就设置为29</span><br><span class="line">select ifnull(stu_age,29) from t_stu;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>做连接字符串操作：CONCAT</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//把名字和年龄拼接起来</span><br><span class="line">select CONCAT(stu_name,stu_age) from t_stu;</span><br><span class="line"></span><br><span class="line">select CONCAT(&apos;我的名字是：&apos;,stu_name,&apos;，我今年&apos;,stu_age,&apos;岁&apos;) from t_stu;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>给列起别名：as</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select stu_age as 年龄 from t_stu;</span><br><span class="line">select stu_age as 年龄,stu_name as 姓名 from t_stu;</span><br><span class="line">select CONCAT(stu_name,stu_age) as 描述 from t_stu;</span><br></pre></td></tr></table></figure></p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>&emsp;&emsp;跟前面一篇讲的更新，删除里面设置条件的方法是一样的。<code>where</code>后面跟条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查询年龄大于等于20的学生</span><br><span class="line">select * from t_stu where stu_age&gt;=20;</span><br><span class="line">//查询年龄在15到25岁之间的学生</span><br><span class="line">select * from t_stu where stu_age between 15 and 25;</span><br><span class="line">//查询名字叫zhangsan,lisi,wangwu.zhaoliu的学生</span><br><span class="line">select * from t_stu where stu_name in(&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wangwu&apos;,&apos;zhangliu&apos;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>模糊查询</strong><code>like</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//一个字加一个下划线，两个字就是两个下划线</span><br><span class="line">//查询名字中张开头，并且是两个字的学生.</span><br><span class="line">select * from t_stu where stu_name like &apos;张_&apos;;</span><br><span class="line">//查询名字是三个字的学生</span><br><span class="line">select * from t_stu where stu_name like &apos;___&apos;;</span><br><span class="line"></span><br><span class="line">//百分号%匹配0~N个字符</span><br><span class="line">//查询名字中以雷结尾的学生</span><br><span class="line">select * from t_stu where stu_name like &apos;%雷&apos;;</span><br><span class="line">//查询名字中包含晓的学生</span><br><span class="line">select * from t_stu where stu_name like &apos;%晓%&apos;;</span><br></pre></td></tr></table></figure></p><h4 id="排序-order-by"><a href="#排序-order-by" class="headerlink" title="排序 order by"></a>排序 <code>order by</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// desc:降序，asc：升序</span><br><span class="line">//按学生年龄升序排列</span><br><span class="line">select * from t_stu ORDER BY stu_age ASC;</span><br><span class="line">//按学生年龄降序排列</span><br><span class="line">select * from t_stu ORDER BY stu_age DESC;</span><br><span class="line">//年龄相同的时候，按名字降序排列。可以无限添加排序条件</span><br><span class="line">select * from t_stu ORDER BY stu_age ASC,stu_name DESC;</span><br></pre></td></tr></table></figure><h4 id="聚合函数-纵向查询"><a href="#聚合函数-纵向查询" class="headerlink" title="聚合函数(纵向查询)"></a>聚合函数(纵向查询)</h4><p><code>计数count</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//只要不为null，就+1</span><br><span class="line">select count(*) from t_stu;</span><br><span class="line">select count(stu_age) from t_stu;</span><br></pre></td></tr></table></figure></p><p><code>计算和sum</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//计算学生年龄加起来的总数</span><br><span class="line">select sum(stu_age) from t_stu;</span><br></pre></td></tr></table></figure></p><p><code>最大值max,最小值min</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查询年龄中最大的</span><br><span class="line">select max(stu_age) from t_stu;</span><br><span class="line">//查询年龄中最小的</span><br><span class="line">select min(stu_age) from t_stu;</span><br></pre></td></tr></table></figure></p><p><code>平均值avg</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(stu_age) from t_stu;</span><br></pre></td></tr></table></figure></p><h4 id="分组查询group-by"><a href="#分组查询group-by" class="headerlink" title="分组查询group by"></a>分组查询<code>group by</code></h4><p>写法：<code>select 条件,聚合函数,...,聚合函数 from 表名 group by 条件;</code></p><p>分组查询必须都是聚合函数，并且，上面两个位置的条件必须相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//按老师分组查询，每组老师名下的学生个数</span><br><span class="line">select stu_teacher,count(*) from t_stu group by stu_teacher;</span><br><span class="line"></span><br><span class="line">//分组前条件，不满足条件的没有参加分组</span><br><span class="line">//按老师分组查询，查询每组老师名下年龄大于20岁的学生的个数</span><br><span class="line">select stu_teacher,count(*) from t_stu where stu_age&gt;20 group by stu_teacher;</span><br><span class="line"></span><br><span class="line">//having 分组后条件</span><br><span class="line">//按老师分组查询，查询老师名下年龄大于20岁的学生，并且剔除学生个数小于5个的老师</span><br><span class="line">select stu_teacher,count(*) from t_stu where stu_age&gt;20 group by stu_teacher having count(*)&lt;5;</span><br></pre></td></tr></table></figure><h4 id="limit-MySQL特有的"><a href="#limit-MySQL特有的" class="headerlink" title="limit(MySQL特有的)"></a>limit(MySQL特有的)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//从下标0开始，往后查询5条数据</span><br><span class="line">select * from t_stu limit 0,5;</span><br><span class="line"></span><br><span class="line">//分页查询，比方说如果你要查第N页的数据，每页数据M条</span><br><span class="line">//(当前页-1)*每页的数据数</span><br><span class="line">select * from t_stu limit (N-1)*M,M;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DQL&quot;&gt;&lt;a href=&quot;#DQL&quot; class=&quot;headerlink&quot; title=&quot;DQL&quot;&gt;&lt;/a&gt;DQL&lt;/h3&gt;&lt;p&gt;关键字：select、from、where、group by、having、roder by&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库操作（一）——DDL、DML、DCL</title>
    <link href="http://haichenyi.com/2018/10/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94DDL%E3%80%81DML%E3%80%81DCL/"/>
    <id>http://haichenyi.com/2018/10/11/MySQL数据库操作（一）——DDL、DML、DCL/</id>
    <published>2018-10-11T14:49:35.000Z</published>
    <updated>2018-10-11T15:03:23.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL:"></a>MySQL:</h3><p>&emsp;&emsp;<strong>启动：</strong><code>net start mysql</code></p><p>&emsp;&emsp;<strong>停止：</strong><code>net stop mysql</code></p><p>&emsp;&emsp;<strong>登录：</strong><code>mysql -u root -p</code> 例如：mysql -uroot -p123 -hlocalhost</p><p>&emsp;&emsp;<strong>退出：</strong><code>exit或者quit</code></p><a id="more"></a><h3 id="DDL操作："><a href="#DDL操作：" class="headerlink" title="DDL操作："></a>DDL操作：</h3><p>&emsp;&emsp;加上if exists或者if not exists：都是如果存在，或者如果不存在，就不做相关操作</p><p>&emsp;&emsp;<strong>查询当前有哪些数据库：</strong><code>show databases;</code></p><p>&emsp;&emsp;<strong>创建数据库：</strong><code>CREATE DATABASE if not exists 数据库的名字 CHARSET=utf8;</code>例如：CREATE DATABASE if not exists employee CHARSET=utf8;创建一个编码为utf-8的employee数据库。不存在就创建，存在就不管。</p><p>&emsp;&emsp;<strong>删除数据库：</strong><code>DRAP DATABASE if exists 数据库名称;</code>例如：DRAP DATABASE if exists employee;删除employee数据库，如果存在就删除，不存在就不管。</p><p>&emsp;&emsp;<strong>修改数据库编码方式：</strong><code>ALTER DATABASE 数据库名称 CHARACTER SET utf8;</code></p><p>&emsp;&emsp;<strong>切换数据库：</strong><code>use 数据库名称;</code></p><p>&emsp;&emsp;<strong>创建表：</strong><code>CREATE TABLE if not exists 表名(列名 列类型,...,列名 列类型);</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE if noe exists t_stu(</span><br><span class="line"></span><br><span class="line">        stu_num char(11),</span><br><span class="line"></span><br><span class="line">        stu_name varchar(50),</span><br><span class="line"></span><br><span class="line">        stu_age int,</span><br><span class="line"></span><br><span class="line">        stu_sex varchar(10)</span><br><span class="line"></span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>显示当前数据库包含的表：</strong><code>show tables;</code></p><p>&emsp;&emsp;<strong>显示当前表结构：</strong><code>desc 表名称;</code></p><p>&emsp;&emsp;<strong>删除表：</strong><code>drop table 表名称;</code></p><p>&emsp;&emsp;<strong>新增列：</strong><code>alter table 表名 add(列名 列类型,...,列名 列类型);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu add(</span><br><span class="line"></span><br><span class="line">        stu_address varchar(100),</span><br><span class="line"></span><br><span class="line">        stu_phone char(11)</span><br><span class="line"></span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改列类型：</strong><code>alter table 表名 modify 列名 列新类型;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu modify stu_address varchar(50);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改列名：</strong><code>alter table 表名 change 原始列名 新列名 列类型;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu change stu_address stu_addr varchar(100);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>删除列：</strong><code>alter table 表名 drop 列名;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_stu drop stu_address;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>修改表名：</strong><code>alter table 原始表名 rename to 新表名;</code></p><h3 id="DML操作："><a href="#DML操作：" class="headerlink" title="DML操作："></a>DML操作：</h3><p>为了好操作，先用一下查询的命令，查询表的所有记录： select * from 表名;</p><p>&emsp;&emsp;<strong>插入一行记录：</strong><code>INSERT INTO 表名 (列名,...,列名)VALUES(列值,...,列值);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t_stu(</span><br><span class="line"></span><br><span class="line">        stu_num,stu_name,stu_age,stu_sex,stu_phone</span><br><span class="line">        </span><br><span class="line">        )VALUES(</span><br><span class="line">        </span><br><span class="line">        &apos;test_num_001&apos;,&apos;张三&apos;,18,&apos;man&apos;,&apos;13888888888&apos;</span><br><span class="line">        </span><br><span class="line">        );</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>修改所有数据：</strong><code>update 表名 set 列名=列值,...,列名=列值;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t_stu set name=&apos;wangwu&apos;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改数据(单个条件)：</strong><code>update 表名 set 列名=列值,...,列名=列值 where 列名=列值;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t_stu set stu_name=&apos;zhangsan&apos; where stu_num=&apos;testNum_00001&apos;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>修改数据(多个条件)：</strong><code>update 表名 set 列名=列值,...,列名=列值 where 列名=列值 or 列名=列值;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//or,或者</span><br><span class="line">update t_stu set stu_age=28 where stu_num=&apos;testNum_0001&apos; or stu_name=&apos;zhangliu&apos;;</span><br><span class="line">//and，并且</span><br><span class="line">update t_stu set stu_age=28 where stu_age&gt;=25 and stu_age&lt;=30;</span><br><span class="line">//between...and...在什么区间内</span><br><span class="line">update t_stu set stu_age=28 where stu_age between 25 and 30;</span><br><span class="line">//in(...)</span><br><span class="line">update t_stu set stu_age=28 where stu_name  in (&apos;zhangsan&apos;,&apos;lisi&apos;);</span><br><span class="line">//is null，是null。不能是stu_name=null</span><br><span class="line">update t_stu set stu_age=28 where stu_name  is null;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>删除记录：</strong><code>DELETE FROM 表名 where ...;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这里where后面的条件跟前面的update是一样的写法</span><br><span class="line">DELETE FROM t_stu where stu_age = 28;</span><br></pre></td></tr></table></figure></p><h3 id="DCL操作："><a href="#DCL操作：" class="headerlink" title="DCL操作："></a>DCL操作：</h3><p>&emsp;&emsp;<strong>创建用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//只要是写用户名的位置都可以设置固定ip，或者不固定ip</span><br><span class="line">CREATE USER 用户名@IP地址 IDENTIFIED BY &apos;密码&apos;;//固定ip登录</span><br><span class="line">CREATE USER 用户名@&apos;%&apos; IDENTIFIED BY &apos;密码&apos;;//任意ip登录</span><br><span class="line">CREATE USER zhangSan@&apos;%&apos; IDENTIFIED BY &apos;123&apos;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>给用户授权：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限1,权限2,...,权限n ON 数据库名称.* TO 用户名@ip地址;</span><br><span class="line">GRANT 权限1,权限2,...,权限n ON 数据库名称.* TO 用户名@&apos;%&apos;;</span><br><span class="line"></span><br><span class="line">GRANT CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT ON school.* TO zhangSan@&apos;%&apos;;</span><br><span class="line">//给所有权限</span><br><span class="line">GRANT ALL ON school.* TO zhangSan@&apos;%&apos;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>撤销权限：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE  权限1,权限2,...,权限n ON 数据库名称.* FROM 用户名@&apos;%&apos;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>查看用户权限：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR 用户名@ip地址;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>删除用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER 用户名@ip地址;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL:&quot;&gt;&lt;/a&gt;MySQL:&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;启动：&lt;/strong&gt;&lt;code&gt;net start mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;停止：&lt;/strong&gt;&lt;code&gt;net stop mysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;登录：&lt;/strong&gt;&lt;code&gt;mysql -u root -p&lt;/code&gt; 例如：mysql -uroot -p123 -hlocalhost&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;退出：&lt;/strong&gt;&lt;code&gt;exit或者quit&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库 -MySQL" scheme="http://haichenyi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Android——MQTT推送</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E2%80%94%E2%80%94MQTT%E6%8E%A8%E9%80%81/"/>
    <id>http://haichenyi.com/2018/05/13/Android——MQTT推送/</id>
    <published>2018-05-13T14:28:22.000Z</published>
    <updated>2018-05-13T14:36:43.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h3><p>&emsp;&emsp;最近公司用到的推送MQTT。不想过多的介绍背景什么的，我就直接讲怎么实现这个功能。</p><p>&emsp;&emsp;他这个原理长连接，这个不用多讲，用法类似于EventBus，需要先订阅，然后通过topic再发送消息。topic是什么呢？我先来讲讲整体流程：</p> <a id="more"></a><ol><li><p>先连接服务器，要先建立长连接</p></li><li><p>然后需要订阅topic，连接之后才能订阅topic</p></li><li><p>最后就是通过topic推送消息，接收消息</p></li></ol><p>一步一步讲：</p><h3 id="第一步，与服务器建立连接"><a href="#第一步，与服务器建立连接" class="headerlink" title="第一步，与服务器建立连接"></a>第一步，与服务器建立连接</h3><p>&emsp;&emsp;先丢代码，然后看注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void initPush() &#123;</span><br><span class="line">        // 服务器地址（协议+地址+端口号）</span><br><span class="line">        String uri = host;</span><br><span class="line">        client = new MqttAndroidClient(this, uri, clientId);</span><br><span class="line">        // 设置MQTT监听并且接受消息</span><br><span class="line">        client.setCallback(mqttCallback);</span><br><span class="line">        //Mqtt的一些设置</span><br><span class="line">        conOpt = new MqttConnectOptions();</span><br><span class="line">        conOpt.setAutomaticReconnect(true);</span><br><span class="line">        // 清除缓存</span><br><span class="line">        conOpt.setCleanSession(true);</span><br><span class="line">        // 设置超时时间，单位：秒</span><br><span class="line">        conOpt.setConnectionTimeout(10);</span><br><span class="line">        // 心跳包发送间隔，单位：秒</span><br><span class="line">        conOpt.setKeepAliveInterval(20);</span><br><span class="line">        myTopic = String.format(TOPIC_SUB, mDeviceId);</span><br><span class="line">        Log.e(TAG,&quot;myTopic_________&quot;+myTopic);</span><br><span class="line">        doClientConnection();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><p>&emsp;&emsp;上面的这些参数，我碰到了两个问题。</p><ol><li>第一个问题，与服务器建立连接，你得先有一个服务器吧？我根据网上的步骤，创建了一个apache-apollo服务器，并且启动了，也启动成功了，我建立连接的时候，总是失败。然后，找啊找，找啊找。问题没有解决，但是，我找到了一个可以用的服务器，也就是这里的uri，不要设置MqttConnectOptions的用户名和密码，设置了他会拒绝</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private String host = &quot;tcp://test.mosquitto.org:1883&quot;;</span><br></pre></td></tr></table></figure><ol><li>第二个问题，我连接成功之后，不一会，他就会自动断开连接，或者，推送完消息之后，他就会断开连接。然后，网上搜原因，找啊找，诶，我找到了。MqttAndroidClient的构造方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructor - create an MqttAndroidClient that can be used to communicate with an MQTT server on android</span><br><span class="line"> * </span><br><span class="line"> * @param context </span><br><span class="line"> *            object used to pass context to the callback. </span><br><span class="line"> * @param serverURI</span><br><span class="line"> *            specifies the protocol, host name and port to be used to</span><br><span class="line"> *            connect to an MQTT server</span><br><span class="line"> * @param clientId</span><br><span class="line"> *            specifies the name by which this connection should be</span><br><span class="line"> *            identified to the server</span><br><span class="line"> */</span><br><span class="line">public MqttAndroidClient(Context context, String serverURI,</span><br><span class="line">String clientId) &#123;</span><br><span class="line">this(context, serverURI, clientId, null, Ack.AUTO_ACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看第三个参数，clientId，指定一个名字，用来连接服务器的身份标识。就是说，你设置的这个值，是你在服务器的唯一标识，不能跟其他用户的相同。我把这个clientId直接用uuid生成，就没问题了。</p><h3 id="第二步，订阅topic"><a href="#第二步，订阅topic" class="headerlink" title="第二步，订阅topic"></a>第二步，订阅topic</h3><p>&emsp;&emsp;回到上面，接着往下面走，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 连接MQTT服务器</span><br><span class="line">     */</span><br><span class="line">    private void doClientConnection() &#123;</span><br><span class="line">        if (!client.isConnected() &amp;&amp; isConnectIsNormal()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                client.connect(conOpt, null, iMqttActionListener);</span><br><span class="line">            &#125; catch (MqttException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 判断网络是否连接</span><br><span class="line">     */</span><br><span class="line">    private boolean isConnectIsNormal() &#123;</span><br><span class="line">        ConnectivityManager connectivityManager = (ConnectivityManager) this.getApplicationContext()</span><br><span class="line">                .getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        if (connectivityManager != null) &#123;</span><br><span class="line">            NetworkInfo info = connectivityManager.getActiveNetworkInfo();</span><br><span class="line">            if (info != null &amp;&amp; info.isAvailable()) &#123;</span><br><span class="line">                String name = info.getTypeName();</span><br><span class="line">                Log.e(TAG, &quot;MQTT当前网络名称：&quot; + name);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.e(TAG, &quot;MQTT 没有可用网络&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法就是用来连接服务器的，首先判断是否正在连接，后面那个是判断当前有没有网络。再就是这个iMqttActionListener监听了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// MQTT是否连接成功</span><br><span class="line">    private IMqttActionListener iMqttActionListener = new IMqttActionListener() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onSuccess(IMqttToken arg0) &#123;</span><br><span class="line">            Log.e(TAG, &quot;连接成功 &quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 订阅myTopic话题</span><br><span class="line">                client.subscribe(myTopic, 0);</span><br><span class="line">            &#125; catch (MqttException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onFailure(IMqttToken arg0, Throwable arg1) &#123;</span><br><span class="line">            Log.e(TAG, &quot;连接失败&quot;);</span><br><span class="line">            arg1.printStackTrace();</span><br><span class="line">            // 连接失败，重连</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讷，就是这里，你如果服务器有问题，他一直走onFailure方法。服务器连接成功之后，就是订阅topic。我来说说这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.subscribe(myTopic, 0);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先，这个主题，是你自己跟服务器商量好的，随便什么都可以。为什么要订阅主题呢？我提前给你瞅瞅推送消息是怎么推送的</p><p>&emsp;&emsp;第二个参数，消息的类型qos，有三种：0、1、2</p><ol><li>0代表“至多一次”，消息发布完全依赖底层 TCP/IP 协议。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送</li><li>1代表“至少一次”，确保消息到达，但消息重复可能会发生</li><li>2代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。</li></ol><p>&emsp;&emsp;简单说明下，如果发送的是临时的消息，例如给某topic所有在线的设备发送一条消息，丢失的话也无所谓，0就可以了。如果需要客户端保证能接收消息，需要指定QoS为1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.publish(topic, new MqttMessage(msg.getBytes()));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;讷，推送消息，是根据topic推送的，第二个参数，就是你要推送的具体消息。我个人认为，你可以理解成就类似于键值对的形式，</p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p><strong><em>不同的用户可以订阅相同的主题</em></strong></p><p>&emsp;&emsp;这个就是跟其他长连接不同的地方，底层，其实都一样，虽然我没有看底层的代码。想也想的到，服务器肯定是根据这个主题，去找对应的用户，然后推送消息。而其他的长连接就是直接指定用户。跑题了，跑题了。</p><h3 id="第三步，推送、接收消息"><a href="#第三步，推送、接收消息" class="headerlink" title="第三步，推送、接收消息"></a>第三步，推送、接收消息</h3><p>&emsp;&emsp;当你连接服务器成功之后，就要推送消息了，我用的EventBus发的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void publishData(String msg) &#123;</span><br><span class="line">        String topic = myTopic;</span><br><span class="line">        try &#123;</span><br><span class="line">            Log.e(TAG,&quot;给__&quot;+topic+&quot;__topic发送的消息为：&quot;+msg);</span><br><span class="line">            client.publish(topic, new MqttMessage(msg.getBytes()));</span><br><span class="line">        &#125; catch (MqttException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // MQTT监听并且接受消息</span><br><span class="line">    private MqttCallback mqttCallback = new MqttCallback() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void messageArrived(String topic, MqttMessage message) throws Exception &#123;</span><br><span class="line">            Log.e(TAG,&quot;接受到__&quot;+topic+&quot;__topic的消息为：&quot;+new String(message.getPayload()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void deliveryComplete(IMqttDeliveryToken arg0) &#123;</span><br><span class="line">            Log.e(TAG,&quot;deliveryComplete&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void connectionLost(Throwable arg0) &#123;</span><br><span class="line">            // 失去连接，重连</span><br><span class="line">            Log.e(TAG,&quot;失去连接&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当你的clientId重复的时候，他就会一直走connectionLost方法。到这里，基本上就讲完了，要注意的是，退出的时候，记得要释放资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (client != null &amp;&amp; client.isConnected()) &#123;</span><br><span class="line">                client.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (MqttException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        EventBus.getDefault().unregister(this);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>网上很多都是直接讲整体流程，重来不讲中间碰到的问题。难受</p><p><a href="https://download.csdn.net/download/qq_27634797/10408420" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;整体介绍&quot;&gt;&lt;a href=&quot;#整体介绍&quot; class=&quot;headerlink&quot; title=&quot;整体介绍&quot;&gt;&lt;/a&gt;整体介绍&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近公司用到的推送MQTT。不想过多的介绍背景什么的，我就直接讲怎么实现这个功能。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;他这个原理长连接，这个不用多讲，用法类似于EventBus，需要先订阅，然后通过topic再发送消息。topic是什么呢？我先来讲讲整体流程：&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android—React Native编程</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E2%80%94React-Native%E7%BC%96%E7%A8%8B/"/>
    <id>http://haichenyi.com/2018/05/13/Android—React-Native编程/</id>
    <published>2018-05-13T14:28:07.000Z</published>
    <updated>2018-05-13T14:32:04.667Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人博客：haichenyi.com。感谢关注</strong></p><h2 id="新公司，新的开始，新的技术"><a href="#新公司，新的开始，新的技术" class="headerlink" title="新公司，新的开始，新的技术"></a>新公司，新的开始，新的技术</h2><p>&emsp;&emsp;新公司的项目，用到的RN编程，之前完全没有碰到过，遇到新技术，之前完全没有碰到过怎么办？google、百度咯。通过不屑的努力，找到了<a href="https://www.jianshu.com/u/6e613846e1ea" target="_blank" rel="noopener">恋猫月亮 </a>的三篇关于RN的文章。我感觉还是很不错的。</p> <a id="more"></a><p><a href="https://www.jianshu.com/p/97692b1c451d" target="_blank" rel="noopener">从Android到React Native开发（一、入门）</a></p><p><a href="https://www.jianshu.com/p/bec040926db8" target="_blank" rel="noopener">从Android到React Native开发（二、通信与模块实现）</a></p><p><a href="https://www.jianshu.com/p/a488674d55b3" target="_blank" rel="noopener">从Android到React Native开发（三、自定义原生控件支持）</a></p><p>&emsp;&emsp;可以先浏览上面的第一篇入门，再过来看我这篇文章，我这篇文章就是讲怎么运行一个RN，我只是针对我的项目，把RN的部分提取了出来，上面大佬讲的比较全面。</p><h2 id="React-Native环境配置"><a href="#React-Native环境配置" class="headerlink" title="React Native环境配置"></a>React Native环境配置</h2><p><strong>开发工具</strong>：android studio。我不知道为什么要换开发工具。AS不好吗？环境还是跟你之前开发的一样配置，不用变</p><p><strong>python安装</strong>：python官网，下载安装。记得配置环境变量。不用非要按照他那个上面说的去安装。安装完成之后cmd里面敲python然后回车，看到如下界面:</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-a4af2b0fc841a608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="python.png"></p><p><strong>node.js安装</strong>：node也是一样，百度安装,配置完环境变量。cmd里面敲 npm -v然后回车，看到如下界面</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-62ea02b1913843e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="node.png"></p><p>最后，跑如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。</span><br><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br><span class="line">//React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</span><br><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，RN的配置就完成了。记得配置NDK环境，然后就是上你们公司的svn，或者git去down项目下来,应该还会有一个错误，那就是找不到<strong>react.gradle</strong>的路径，找到你添加依赖的那个gradle，在最上面添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: &quot;../../node_modules/react-native/react.gradle&quot;</span><br></pre></td></tr></table></figure><p>这个配置应该是添加greenDao那个是一样的，这样就能找到了<strong>react.gradle</strong></p><p>项目结构如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-86b8e4e093e337da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="project.png"></p><p>&emsp;&emsp;我用箭头标记了，你down下来的项目，应该是没有node_modules文件夹的，这个文件夹是怎么产生的呢？你在cmd进入你down的项目，就是图片上面的文件目录，跑如下命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>当命令运行完，就可以跑项目了。</p><h2 id="React-Native项目搭建"><a href="#React-Native项目搭建" class="headerlink" title="React Native项目搭建"></a>React Native项目搭建</h2><p>&emsp;&emsp;同鞋，你有freeStyle吗？有没有用过WebView？WebView就是在你的xml里面新增了一个WebView控件，RN也一样，他的这个控件就是ReactRootView。所以，这个控件哪里来？当然是添加依赖了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//版本号你自己找</span><br><span class="line">compile &apos;com.facebook.react:react-native:0.50.3&apos;</span><br></pre></td></tr></table></figure><p>最终的作用代码就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mReactRootView.startReactApplication(mReactInstanceManager, &quot;XXX&quot;, null);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个ReacRootView对象，你可以new出来，也可以写在xml里面findViewById。只要你能获取到这个对象就可以了，然后就是这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName, @Nullable Bundle initialProperties)</span><br></pre></td></tr></table></figure><p>三个参数</p><ol><li>ReactInstanceManager reactInstanceManager</li><li>String moduleName</li><li>@Nullable Bundle initialProperties</li></ol><h3 id="第一个参数：ReactInstanceManager"><a href="#第一个参数：ReactInstanceManager" class="headerlink" title="第一个参数：ReactInstanceManager"></a>第一个参数：<strong>ReactInstanceManager</strong></h3><p>就像配置WebView的参数，那些什么配置client允许js弹窗啊，新的页面直接覆盖原来的页面，并不是新建一个页面之类的参数，对应的这里，就是配置<strong>ReactInstanceManager</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReactInstanceManagerBuilder builder = ReactInstanceManager.builder();</span><br><span class="line">        builder = builder</span><br><span class="line">                .setApplication(getApplication())</span><br><span class="line">                .setBundleAssetName(&quot;index.android.bundle&quot;)</span><br><span class="line">                .setJSMainModulePath(&quot;index.android&quot;);</span><br><span class="line"></span><br><span class="line">        mReactInstanceManager = builder</span><br><span class="line">                .addPackage(new MainReactPackage())</span><br><span class="line">                .addPackage(new YzgHDReactPackage())</span><br><span class="line">//                .setUseDeveloperSupport(!Global.ISPRD)</span><br><span class="line">                .setUseDeveloperSupport(true)</span><br><span class="line">              .setInitialLifecycleState(LifecycleState.RESUMED)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;前面的builder的初始化是必须要写的，setApplication，如果你没有自己写application，那就直接getApplication，如果，你有自己实现application那就传你的application对象。</p><p>&emsp;&emsp;setBundleAssetName和setJSMainModulePath都是写死的，后面的名字也是写死的。</p><p>&emsp;&emsp;然后就是添加package，在package里面添加module。这里就是JS和Android相互调用的地方。package里面要实现ReactPackage，在createNativeModules里面去添加moudle</p><h3 id="第二个参数：String-moduleName"><a href="#第二个参数：String-moduleName" class="headerlink" title="第二个参数：String moduleName"></a>第二个参数：<strong>String moduleName</strong></h3><p>这个moudleName是怎么来的？就是我们前面设置的MoudlePath那个JS里面的。这里的路径应该是<strong>index.android.js</strong>，是一个js文件，打开之后，最下面有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppRegistry.registerComponent(&apos;zzz&apos;, () =&gt; XXX);</span><br></pre></td></tr></table></figure><p>这里的zzz就是我们这里需要传的名字</p><h3 id="第三个参数：Bundle-initialProperties"><a href="#第三个参数：Bundle-initialProperties" class="headerlink" title="第三个参数：Bundle initialProperties"></a>第三个参数：<strong>Bundle initialProperties</strong></h3><p>这里应该是传一个bundle，传输的数据，传个null就可以了</p><h2 id="React-Native流程"><a href="#React-Native流程" class="headerlink" title="React Native流程"></a>React Native流程</h2><p>&emsp;&emsp;前面的整个配置都配置完成之后，Android这边只用新建方法，给RN调用就可以了。新建的方法要用@ReactMethod标记。辣么，这个方法新建在哪呢？————Module，就是对应我们前面package里面添加的module。都说RN每个模块是独立的，怎么独立呢？就是这样独立的。每个模块功能对应一个module，每个都有该功能对应的方法。我就拿我这里的UserModule来举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class UserModule extends IModule implements NoticeListener&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static final String MODULE_NAME = &quot;User_Module&quot;;</span><br><span class="line"></span><br><span class="line">    private ReactApplicationContext mContext;</span><br><span class="line"></span><br><span class="line">    public UserModule(ReactApplicationContext reactContext) &#123;</span><br><span class="line">        super(reactContext);</span><br><span class="line">        this.mContext = reactContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return MODULE_NAME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户登录接口</span><br><span class="line">     * @param params</span><br><span class="line">     * @param callback</span><br><span class="line">     */</span><br><span class="line">    @ReactMethod</span><br><span class="line">    public void doLogin(String params, final Callback callback)&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,String&gt; map = GsonTool.gson2Map(params);</span><br><span class="line"></span><br><span class="line">        if(map == null || map.size() &lt;= 0)&#123;</span><br><span class="line">            callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;参数异常&quot;)));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final String userName = map.get(&quot;userName&quot;);</span><br><span class="line">        final String password = map.get(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">        if(TextUtils.isEmpty(userName) || TextUtils.isEmpty(password))&#123;</span><br><span class="line">            callback.invoke(new GsonBuilder().create().toJson(new BaseBean(false,&quot;用户名或密码不能为空&quot;)));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //登录</span><br><span class="line">        new Handler().post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                String result = new UserBridge().doLogin(userName,password, Global.DEVICE_ID,Global.APP_VERSION_NAME);</span><br><span class="line">                callback.invoke(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我就粘贴出来了部分代码，module要继承IModule，这个是一个抽象类，他继承ReactContextBaseJavaModule，最主要就是继承它，继承之后，我像说的就是这两个方法，getName()和注解的方法doLogin()。</p><p>&emsp;&emsp;我们可以看到，这个getName最终返回的是一个User_Module，这个字符串是怎么确定的呢？这个登录的方法名称是怎么确定的呢？</p><p>&emsp;&emsp;这些东西都是在js里面定义好的，这里是一个登录方法，我们打开登录的js。</p><p><strong>PS:</strong> 这里应该是通过js去确定我们这边的方法名，并不是通过这里的名称去确定js的。</p><p>&emsp;&emsp;我就不把JS代码，贴出来了，只贴出伪代码，打开js之后，搜索NativeModules。你应该会搜到类似的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; User_Module, Shop_Module &#125; = NativeModules;</span><br></pre></td></tr></table></figure><p>这里有两个Module，没错，就是两个。我们这里现在只关注User_Module，然后，我们搜索 User_Module，你会看到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">_onLogIn = () =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        const &#123; username, password &#125; = this.userInfo;</span><br><span class="line">        if (username.length &lt;= 0) return this._modal.Alert(&apos;请输入用户名&apos;);</span><br><span class="line">        if (password.length &lt;= 0) return this._modal.Alert(&apos;请输入密码&apos;);</span><br><span class="line">        this._button.setButton(false, &apos;正在登录...&apos;);</span><br><span class="line">        const params = &#123; userName: username, password &#125;;</span><br><span class="line">        // 登录</span><br><span class="line">        const _dologin = () =&gt; &#123;</span><br><span class="line">            return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">                User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123;</span><br><span class="line">                    const data = Other.callHandle(values) || &#123;&#125;;</span><br><span class="line">                    if (data.status) &#123;</span><br><span class="line">                        resolve(&apos;登录成功&apos;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        reject(data.message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>其他的一切，我们都不用管，我们在意的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User_Module.doLogin(JSON.stringify(params), (...values) =&gt; &#123;</span><br><span class="line">                    const data = Other.callHandle(values) || &#123;&#125;;</span><br><span class="line">                    if (data.status) &#123;</span><br><span class="line">                        resolve(&apos;登录成功&apos;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        reject(data.message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面这个是我的项目里面的js，你们搜到的肯定跟我的不一样，我这里要说的是，怎么确定name的返回值，和注解方法。我们看到了，name就是这里的User_Module，方法就是这里的doLogin，android里面写用@ReactMethod标记，然后就是参数了，这里两个参数，一个是String，json格式的。用ArrayMap存储好key—value之后，转成字符串即可。第二个参数就是callback。android与JS通信，发送数据，就是一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback.invoke(&quot;data&quot;)</span><br></pre></td></tr></table></figure><p>他需要什么，你就发送什么。上面是RN主动调用Android方法，辣么，Android怎么主动调用RN方法呢？其实也很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//发送给RN</span><br><span class="line">        if (mReactInstanceManager.getCurrentReactContext() != null) &#123;</span><br><span class="line">            mReactInstanceManager.getCurrentReactContext()</span><br><span class="line">                    .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)</span><br><span class="line">                    .emit(PUSH_DATA_RN, mqttBean.info);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>就是获取ReactContext对象，通过调用getJSModule方法，参数传DeviceEventManagerModule.RCTDeviceEventEmitter.class这个类就可以了，然后通过调用emit方法，第一个参数，就是RN规定的方法名称，第二个参数就是需要传给RN的数据。为什么这样写呢？我们再来看看RN那边是怎么写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DeviceEventEmitter.addListener(&quot;push_data_rn&quot;,(data)=&gt;&#123;</span><br><span class="line">            alert(data)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>他就是通过这DeviceEventEmitter类添加addListener方法，传两个参数，第一个参数就是我们规定的名称，第二个参数就是一个回调，有一个参数，就是用来接收我们的数据，最后做的处理就是简单的弹窗，当然，这是我自己测试用的，最后RN要怎么坐，就是我要担心的问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;个人博客：haichenyi.com。感谢关注&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;新公司，新的开始，新的技术&quot;&gt;&lt;a href=&quot;#新公司，新的开始，新的技术&quot; class=&quot;headerlink&quot; title=&quot;新公司，新的开始，新的技术&quot;&gt;&lt;/a&gt;新公司，新的开始，新的技术&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;新公司的项目，用到的RN编程，之前完全没有碰到过，遇到新技术，之前完全没有碰到过怎么办？google、百度咯。通过不屑的努力，找到了&lt;a href=&quot;https://www.jianshu.com/u/6e613846e1ea&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;恋猫月亮 &lt;/a&gt;的三篇关于RN的文章。我感觉还是很不错的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android转场动画——共享元素</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0/"/>
    <id>http://haichenyi.com/2018/05/13/Android转场动画——共享元素/</id>
    <published>2018-05-13T14:27:52.000Z</published>
    <updated>2018-05-13T14:33:04.328Z</updated>
    
    <content type="html"><![CDATA[<p>这个东西其实很简单，我这里只是做一个简单的记录。</p> <a id="more"></a><p>XML代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--第一个Activity的xml布局，需要共享的元素，加上transitionName属性。至于名字，你随便定义，要保持相同--&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:gravity=&quot;bottom&quot;</span><br><span class="line">    tools:context=&quot;com.haichenyi.activitytransitionanimation.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/img&quot;</span><br><span class="line">        android:layout_width=&quot;300dp&quot;</span><br><span class="line">        android:layout_height=&quot;200dp&quot;</span><br><span class="line">        android:transitionName=&quot;wang&quot;</span><br><span class="line">        android:src=&quot;@mipmap/bg&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/btn&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;跳转&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--第二个activity的xml布局--&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/img&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;300dp&quot;</span><br><span class="line">        android:src=&quot;@mipmap/bg&quot;</span><br><span class="line">        android:transitionName=&quot;wang&quot;/&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/btn&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;back&quot;/&gt;</span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><p>java代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆.</span><br><span class="line"> * Date: 2018/3/29</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onClick(View v) &#123;</span><br><span class="line">      //共享元素转场动画，只支持android 5.0，所以加一个判断</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">          startActivity(new Intent(MainActivity.this, Step1Activity.class),</span><br><span class="line">              ActivityOptions.makeSceneTransitionAnimation(MainActivity.this,</span><br><span class="line">                  findViewById(R.id.img), &quot;wang&quot;).toBundle());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          startActivity(new Intent(MainActivity.this, Step1Activity.class));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，就是一个Button点击跳转。这个共享元素的核型代码，就是一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions.makeSceneTransitionAnimation(Activity activity,</span><br><span class="line">            View sharedElement, String sharedElementName)</span><br></pre></td></tr></table></figure><p>三个参数：</p><ol><li>Activity activity：activity对象，这个不用多说了</li><li>View sharedElement：共享元素的那个控件</li><li>String sharedElementName：共享元素控件的那个transitionName属性的值。前面xml里面的注释讲过要相同，有三个位置用到这个：跳转activity的xml里面，跳转的目标activity的xml里面，再就是这里，跳转的代码这里需要设置。</li></ol><p>就这么简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个东西其实很简单，我这里只是做一个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Android——PorterDuffXfermode</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E2%80%94%E2%80%94PorterDuffXfermode/"/>
    <id>http://haichenyi.com/2018/05/13/Android——PorterDuffXfermode/</id>
    <published>2018-05-13T14:27:36.000Z</published>
    <updated>2018-05-13T14:35:37.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;PorterDuffXfermode是什么鬼？个人理解，简单的来讲就是做两个Bitmap操作的，什么操作呢？有裁剪，合并等等，有16种图形混合模式。先举一个简单的例子，我们在慢慢讲：</p> <a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/28</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MyCustomView extends View &#123;</span><br><span class="line">  private int width = 300;</span><br><span class="line">  private int height = 300;</span><br><span class="line">  private Bitmap dstBmp;</span><br><span class="line">  private Bitmap srcBmp;</span><br><span class="line">  private Paint mPaint;</span><br><span class="line"></span><br><span class="line">  public MyCustomView(Context context) &#123;</span><br><span class="line">    this(context, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">    super(context, attrs, defStyleAttr);</span><br><span class="line">    initView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void initView() &#123;</span><br><span class="line">    setLayerType(View.LAYER_TYPE_SOFTWARE, null);</span><br><span class="line">    srcBmp = makeSrc(width, height);</span><br><span class="line">    dstBmp = makeDst(width, height);</span><br><span class="line">    mPaint = new Paint();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2);</span><br><span class="line">    canvas.drawColor(Color.BLUE);</span><br><span class="line">    int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG);</span><br><span class="line">    canvas.drawBitmap(dstBmp, 0, 0, mPaint);</span><br><span class="line">    @SuppressLint(&quot;DrawAllocation&quot;) PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);</span><br><span class="line">    mPaint.setXfermode(xfermode);</span><br><span class="line">    canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint);</span><br><span class="line">    mPaint.setXfermode(null);</span><br><span class="line">    canvas.restoreToCount(layerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Bitmap makeDst(int w, int h) &#123;</span><br><span class="line">    Bitmap dst = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas mCanvas = new Canvas(dst);</span><br><span class="line">    Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(Color.RED);</span><br><span class="line">    mCanvas.drawOval(new RectF(0, 0, w, h), mPaint);</span><br><span class="line">    return dst;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Bitmap makeSrc(int w, int h) &#123;</span><br><span class="line">    Bitmap src = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas mCanvas = new Canvas(src);</span><br><span class="line">    Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(Color.YELLOW);</span><br><span class="line">    mCanvas.drawRect(0, 0, w, h, mPaint);</span><br><span class="line">    return src;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/7041675-a473668793539882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="简介demo图.png"></p><p>&emsp;&emsp;上面画了一个圆形bitmap，画了一个矩形bitmap，设置了一个模式 <strong><em>PorterDuff.Mode.SRC_IN</em></strong> 就变成了上面的形状，这是怎么做到的呢？带着我们的问题，进入我们的主题。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong><em>注意点</em></strong></h2><p>&emsp;&emsp;为什么我要拿一个大标题来写这个呢？因为，我当时卡在这里很久，然后踩着巨人的肩膀，我才踏过去的。</p><ol><li><p>首先，两个图形必须都是Bitmap，直接用Canvas画形状，做操作，是达不到效果的。重要的事情说三遍：<strong><em>两个图形必须都是Bitmap。两个图形必须都是Bitmap。两个图形必须都是Bitmap</em></strong></p></li><li><p>其次，避免不必要的麻烦，请先关闭硬件加速。重要的事情说三遍：<strong><em>请先关闭硬件加速。请先关闭硬件加速。请先关闭硬件加速</em></strong></p></li><li><p>然后，两个bitmap的大小最好一样。</p></li><li><p>最后，我要强调的是：<strong><em>先绘制的是目标图，后绘制的是源图。</em></strong></p></li></ol><p>&emsp;&emsp;这里一直说bitmap，辣么，怎么生成这个bitmap，生成这个bitmap之后怎么画图形呢？如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//第一步，我们先创建一个bitmap对象</span><br><span class="line">Bitmap dst = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line">//第二步，我们通过这个bitmap对象创建一个画布，</span><br><span class="line">//说白了，就是new 一个画布，把bitmap放到画布的构造方法里面</span><br><span class="line">    Canvas mCanvas = new Canvas(dst);</span><br><span class="line">    Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(Color.RED);</span><br><span class="line">//最后，在这个画布上面的所有操作，最后都是呈现在bitmap上面。</span><br><span class="line">//就像这里的，在这个画布上面画了一个椭圆，其实，最后我们的bitmap就是一个椭圆</span><br><span class="line">    mCanvas.drawOval(new RectF(0, 0, w, h), mPaint);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以，bitmap会创建了，再就是我们前面说的两个bitmap，<strong><em>先绘制的是目标图，后绘制的是源图</em></strong>，一个是dst（目标图片，下层，先画），一个是src（源图片，上层，后画）。就是我们上面的自定view里面的onDraw()方法里面，用onDraw的canvas画的东西。</p><p>&emsp;&emsp;我们如果不用这个xfermode模式，我们的代码应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2);</span><br><span class="line">    canvas.drawColor(Color.BLUE);</span><br><span class="line">    canvas.drawBitmap(dstBmp, 0, 0, mPaint);</span><br><span class="line">    canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很简单的几行代码，把画布移到正中间，给画布加一个背景蓝色，先画dst，后画src，跑出来的效果图应该是下面这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-eae7b8c745ec218e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意点1.png"></p><p>&emsp;&emsp;我们如果加上这个xfermode模式里面的 <strong><em>PorterDuff.Mode.SRC_IN</em></strong>模式，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    canvas.translate(getWidth() / 2 - width / 2, getHeight() / 2 - height / 2);</span><br><span class="line">    canvas.drawColor(Color.BLUE);</span><br><span class="line">    int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG);</span><br><span class="line">    canvas.drawBitmap(dstBmp, 0, 0, mPaint);</span><br><span class="line">    @SuppressLint(&quot;DrawAllocation&quot;) PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);</span><br><span class="line">    mPaint.setXfermode(xfermode);</span><br><span class="line">    canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint);</span><br><span class="line">    mPaint.setXfermode(null);</span><br><span class="line">    canvas.restoreToCount(layerID);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比上面的代码，就多加了一个xfermode模式，他们要是同一个画笔，用完之后，记得要把这个模式置null这个saveLayer等会讲，先不说。跑出来的效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-f1b34b7fb8df357e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意点2.png"></p><p>&emsp;&emsp;前面，我们一直都在强调dst先画，src后画，如果调换一下，会是什么样的结果呢？代码我就不贴出来了，就把那两个drawBitmap调换一个位置，跑出来的效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-e8ad2cf4229095fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意点3.png"></p><p>&emsp;&emsp;很明显，跟我们的预期结果不一样。这是为什么呢？带着我们的问题进入下一节。</p><h2 id="十六种模式和saveLayer"><a href="#十六种模式和saveLayer" class="headerlink" title="十六种模式和saveLayer()"></a>十六种模式和saveLayer()</h2><h3 id="十六种模式"><a href="#十六种模式" class="headerlink" title="十六种模式"></a>十六种模式</h3><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">含义</th><th style="text-align:center">名字</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">CLEAR</td><td style="text-align:center">清除模式［0，0］，即最终所有点的像素的alpha 和color 都为 0，所以画出来的效果只有白色背景</td><td style="text-align:center">SRC</td><td style="text-align:center">显示上层绘制图片</td></tr><tr><td style="text-align:center">DST</td><td style="text-align:center">显示下层绘制图片</td><td style="text-align:center">SRC_OVER</td><td style="text-align:center">正常绘制显示，上下层绘制叠盖</td></tr><tr><td style="text-align:center">DST_OVER</td><td style="text-align:center">上下层都显示，下层居上显示</td><td style="text-align:center">SRC_IN</td><td style="text-align:center">取两层绘制交集。显示上层</td></tr><tr><td style="text-align:center">DST_IN</td><td style="text-align:center">取两层绘制交集，显示下层</td><td style="text-align:center">SRC_OUT</td><td style="text-align:center">取上层绘制非交集部分</td></tr><tr><td style="text-align:center">DST_OUT</td><td style="text-align:center">取下层绘制非交集部分</td><td style="text-align:center">SRC_ATOP</td><td style="text-align:center">取下层非交集部分与上层交集部分</td></tr><tr><td style="text-align:center">DST_ATOP</td><td style="text-align:center">取上层非交集部分与下层交集部分</td><td style="text-align:center">XOR</td><td style="text-align:center">异或：去除两图层交集部分</td></tr><tr><td style="text-align:center">DARKEN</td><td style="text-align:center">取两图层全部区域，交集部分颜色加深</td><td style="text-align:center">LIGHTEN</td><td style="text-align:center">取两图层全部，点亮交集部分颜色</td></tr><tr><td style="text-align:center">MULTIPLY</td><td style="text-align:center">取两图层交集部分叠加后颜色</td><td style="text-align:center">SCREEN</td><td style="text-align:center">取两图层全部区域，交集部分变为透明色</td></tr></tbody></table><p>PS：名称前面都应该有：<strong><em>PorterDuff.Mode</em></strong> ，例如：PorterDuff.Mode.CLEAR</p><p>&emsp;&emsp;什么？有的看不懂什么意思？没关系，我也没指望你一次就看懂，我们先来说一说saveLayer()，且听我娓娓道来。</p><h3 id="saveLayer"><a href="#saveLayer" class="headerlink" title="saveLayer()"></a>saveLayer()</h3><p>&emsp;&emsp;这个方法是干嘛用的？保存指定区域内画布的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public int saveLayer(RectF bounds, Paint paint, int saveFlags)  </span><br><span class="line">public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;后面的saveFlags，有6个值，我们这里用到的 <strong><em>Canvas.ALL_SAVE_FLAG</em></strong>，很明显，表示保存所有内容。我们这里如果把这个方法去掉，会是什么样的结果呢？代码就不贴出来了，就直接注释掉saveLayer的两行代码。还是先画dst，后画src，跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-85a4080bc042c63c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="去掉saveLayer().png"></p><p>我们先规定两点：</p><ol><li>先画dst，也就是目标图像，是一个圆形。</li><li>后画src，也就是源图像，是一个矩形。</li></ol><table><thead><tr><th style="text-align:center">代码名称1</th><th style="text-align:center">顺序</th><th style="text-align:center">中文名称</th><th style="text-align:center">形状</th></tr></thead><tbody><tr><td style="text-align:center">dst</td><td style="text-align:center">先画</td><td style="text-align:center">目标图像</td><td style="text-align:center">红色圆形</td></tr><tr><td style="text-align:center">src</td><td style="text-align:center">后画</td><td style="text-align:center">源图像</td><td style="text-align:center">黄色矩形</td></tr></tbody></table><p>&emsp;&emsp;规定好之后，我们再来说一说这个 <strong><em>SRC_IN</em></strong>，我们前面说了：取两层绘制交集。显示上层。首先IN是取交集部分，OUT是取非交集部分。这个就是说最后显示的图形，他们的交集部分，显示src，也就是矩形的颜色，也就是黄色。先画的dst，他自然在src的上层。所以，显示dst的形状，两者交集部分显示src的颜色。可以看下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-0b1c817304fec954.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="saveLayer.png"></p><p>&emsp;&emsp;我们再来说说saveLayer的绘制流程：如上图所示，它会创建一个全新图名的bitmap，大小跟你前面指定的保存区域相同，然后，绘制的图形会保存在这个全新透明的bitmap上面，最后把这个透明的bitmap画在画布上面。</p><p>&emsp;&emsp;辣么，没有savelayer()方法的绘制流程呢？如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-38b1242793a0807b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="no_saveLayer.png"></p><p>他是直接作用在画布上面的。</p><h2 id="常用的PorterDuffXfermode模式介绍"><a href="#常用的PorterDuffXfermode模式介绍" class="headerlink" title="常用的PorterDuffXfermode模式介绍"></a>常用的PorterDuffXfermode模式介绍</h2><h3 id="SRC模式"><a href="#SRC模式" class="headerlink" title="SRC模式"></a>SRC模式</h3><p>&emsp;&emsp;只保留源图像的 alpha 和 color ，所以绘制出来只有源图，有时候会感觉分不清先绘制的是源图还是后绘制的是源图，这个时候可以这么记，先绘制的是目标图，不管任何时候，一定要做一个有目标的人，目标在前！（未达到我们的预期效果，感觉有问题）</p><h3 id="DST模式"><a href="#DST模式" class="headerlink" title="DST模式"></a>DST模式</h3><p>&emsp;&emsp;只显示目标图片，也就是只显示红色的圆形。</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-5a78edd1ea287820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST.png"></p><h3 id="SRC-OVER模式"><a href="#SRC-OVER模式" class="headerlink" title="SRC_OVER模式"></a>SRC_OVER模式</h3><p>&emsp;&emsp;在目标图片顶部绘制源图像,从命名上也可以看出来就是把源图像绘制在上方，也就是把黄色长方形，画在红色圆形的上面。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-efa828311c86ebcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SRC_OVER.png"></p><h3 id="DST-OVER模式"><a href="#DST-OVER模式" class="headerlink" title="DST_OVER模式"></a>DST_OVER模式</h3><p>&emsp;&emsp;把目标图像绘制在上方。与前一个相反，把红色圆形画在长方形上面。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d715a0025e2c1baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST_OVER.png"></p><h3 id="SRC-IN模式"><a href="#SRC-IN模式" class="headerlink" title="SRC_IN模式"></a>SRC_IN模式</h3><p>&emsp;&emsp;在两者相交的地方绘制源图像，并且绘制的效果会受到目标图像对应地方透明度的影响。</p><p>&emsp;&emsp;有点绕，我分成几段讲出来：</p><p>&emsp;&emsp;也就是说，两者相交的位置，显示源图像，也就是黄色的矩形，目标图像的透明度为0，然后，&emsp;源图像的其他位置的透明度&emsp;&emsp;会跟源图像与目标图像相交的地方&emsp;&emsp;的目标图像的透明度一样。</p><p>&emsp;&emsp;有点绕。其实，就是说源图像的其他地方隐藏，就显示相交的位置。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-7e2826c64c63d907.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SRC_IN.png"></p><h3 id="DST-IN模式"><a href="#DST-IN模式" class="headerlink" title="DST_IN模式"></a>DST_IN模式</h3><p>&emsp;&emsp;跟前面刚好对应，在两者相交的地方绘制目标图像，并且，绘制效果会受到源图像对应地方透明度的影响。我们最是绘制目标图像。效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-4bea3004d59f8260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST_IN.png"></p><h3 id="SRC-OUT模式"><a href="#SRC-OUT模式" class="headerlink" title="SRC_OUT模式"></a>SRC_OUT模式</h3><p>&emsp;&emsp;在不相交的地方绘制源图像，相交处根据目标alpha进行过滤，目标色完全不透明时则完全过滤，完全透明则不过滤；</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-306477eebd6a23d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SRC_OUT.png"></p><h3 id="DST-OUT模式"><a href="#DST-OUT模式" class="headerlink" title="DST_OUT模式"></a>DST_OUT模式</h3><p>&emsp;&emsp;同样，可以类比SRC_OUT , 在不相交的地方绘制目标图像，相交处根据源图像alpha进行过滤，完全不透明处则完全过滤，完全透明则不过滤；</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-05650d7d10021591.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DST_OUT.png"></p><p>太多了，后面就不写了，用的也比较少。</p><p>用途，加上上一篇的贝赛尔曲线的水波纹。很明显，我就想做如下效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-dcdb3859d8e4fbf8.gif?imageMogr2/auto-orient/strip" alt="圆形水波纹.gif"></p><p>这个圆只是一种，这只是一个demo，这个圆，你可以换成任意的形状。你知道水波纹用贝赛尔曲线怎么做，知道了，PorterDuffXfermode这个模式，两张图片是怎么切割。像这样的，还不就是一个道理。随手拈来。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-946eca2d7f94cdcf.gif?imageMogr2/auto-orient/strip" alt="自定义背景.gif"></p><p>这个水波纹的，已经全部封装好了。任意改变背景图片。<a href="https://download.csdn.net/download/qq_27634797/10314335" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;PorterDuffXfermode是什么鬼？个人理解，简单的来讲就是做两个Bitmap操作的，什么操作呢？有裁剪，合并等等，有16种图形混合模式。先举一个简单的例子，我们在慢慢讲：&lt;/p&gt;
    
    </summary>
    
      <category term="Android -自定义view" scheme="http://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>Android自定义View——贝赛尔曲线</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E8%87%AA%E5%AE%9A%E4%B9%89View%E2%80%94%E2%80%94%E8%B4%9D%E8%B5%9B%E5%B0%94%E6%9B%B2%E7%BA%BF/"/>
    <id>http://haichenyi.com/2018/05/13/Android自定义View——贝赛尔曲线/</id>
    <published>2018-05-13T14:27:18.000Z</published>
    <updated>2018-05-13T14:35:32.961Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文针对有一定自定义View的童鞋，最好对贝赛尔曲线有辣么一丢丢了解，不了解也没关系。花5分钟看一下 <strong><em>GcsSloop</em></strong>的 <a href="http://www.gcssloop.com/customview/Path_Bezier" target="_blank" rel="noopener">安卓自定义View进阶-Path之贝塞尔曲线</a>。</p><p>本文的最终效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-bb761f08bb5704c5.gif?imageMogr2/auto-orient/strip" alt="最终效果图.gif"></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>首先他是一个只有上半部分的正弦形状的水波纹，很规则。</li><li>其次，他这个正弦图左右在移动。</li><li>然后，就是它这个自定义View，上下也在移动，是慢慢增加的</li><li>最后，优化点：一开始刚出来的时候，它那个水波纹的角度，更达到一定角度后，最后面，快要完成的时候的角度是不一样的。</li></ol><h2 id="第一步：画正弦形状的水波纹"><a href="#第一步：画正弦形状的水波纹" class="headerlink" title="第一步：画正弦形状的水波纹"></a>第一步：画正弦形状的水波纹</h2><p>&emsp;&emsp;有一定自定义View基础的童鞋都知道，一阶贝赛尔画直线，这里的正弦图形是用二阶贝赛尔曲线。至于三阶，四阶，五阶用的都比较少。</p><p>&emsp;&emsp;我们这里知道了，这是用的二阶贝赛尔曲线，辣么，方法呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)</span><br><span class="line">mPath.rQuadTo(dx1, dy1, dx2, dy2);</span><br><span class="line">//mPath.quadTo(dx1, dy1, dx2, dy2);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Path调用该方法，这里就是传的两个点，也就是四个值，参数的含义：第一个点是控制点，第二个点是终点。前面还有一个起点，通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPath.moveTo(x,y);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个方法是确定起点。不懂的童鞋，看一下文章开头推荐的文章。我们效果的是一排波浪线，我们上面这个方法只是一个。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//构造方法里面初始化</span><br><span class="line">private void initView() &#123;</span><br><span class="line">    path = new Path();</span><br><span class="line">    paint = new Paint();</span><br><span class="line">    paint1 = new Paint();</span><br><span class="line">    paint.setColor(Color.GREEN);</span><br><span class="line">    paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    paint.setStrokeWidth(10);</span><br><span class="line">    paint1.set(paint);</span><br><span class="line">    paint1.setColor(Color.RED);</span><br><span class="line">  &#125;</span><br><span class="line">//onDraw里面去画出来</span><br><span class="line">    @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.moveTo(0,300);</span><br><span class="line">    path.quadTo(150, 150, 300, 300);</span><br><span class="line">    path.quadTo(450, 450, 600, 300);</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line"></span><br><span class="line">    canvas.drawCircle(0,300,5,paint1);</span><br><span class="line">    canvas.drawCircle(150,150,5,paint1);</span><br><span class="line">    canvas.drawCircle(300,300,5,paint1);</span><br><span class="line">    canvas.drawCircle(450,450,5,paint1);</span><br><span class="line">    canvas.drawCircle(600,300,5,paint1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面就是简单的初始化paint，和path，然后画出path，另外，我还画出了5个点，帮助理解。跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-9343cb6e4066e3ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个水波纹效果图.png"></p><p>&emsp;&emsp;转换成对应的坐标系，手画的，有点丑，知道是这个意思就行了。如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-8215466464df72f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个水波纹放入坐标系中.png"></p><p><strong>画一个正弦图的思路：</strong></p><ol><li><p>首先，把path移动到起点，对应的也就是moveTo(0,300)</p></li><li><p>然后，确定终点，也就是我们前面说的quadTo()方法的第二个点(300,300)</p></li><li><p>最后，我们确定控制点，也就是我们前面说的quadTo()方法的第一个点。 <strong><em>辣么，这个控制点是怎么确定的呢？问题就在这里。敲黑板</em></strong> 因为我们画的是一个规则的正弦图，所以，控制点的x坐标肯定是终点x坐标300的一半，也就是150。再就是他的y坐标，其实y坐标是随便定义的。y坐标只是约束这个正弦图形的坡度，对坡度。你把y坐标定义的离终点的y坐标远一点，他的坡度就大一点。离他近一点，坡度就小一点。你如果定义控制点是（150,100），他相对于控制点是(150,150)的坡度就会大一点。因为100距300相差200，150距300相差150。200大于150。对，就是这样。辣么，怎么控制是上半部分的正弦图还是下半部分的正弦图呢？ <strong><em>|y控|&gt;|y终|，上半部分；相反，则是下半部分。</em></strong></p></li></ol><p>&emsp;&emsp;对了，这里我需要说明的是，上面我们调用了两次quadTo()方法，第二次调用的起点，就是第一次的终点。</p><p>&emsp;&emsp;上面效果是调用quadTo()方法，我们再来说一说rQuadTo()方法。上面的注释里面，我们也标明了两者的区别。 <strong><em>辣么，什么叫相对于原点的坐标系？什么叫相对于当前点的坐标系呢？</em></strong> 我们知道android的坐标系原点是左上角，你可以这样理解，第一种，不带r的方法quadTo()，他的坐标原点(0,0)点始终在左上角，第二种带r的方法rQuadTo()，我们第一次移动到起点(0,300)的时候，这个时候的原点就是(0,300)，所以说此时的终点应该是(300,0),然后确定我们的控制点(150,-150)。辣么，我们调用第二次的时候，此时的终点就是(300,0)，这个时候的终点就是(300,0)，在确定此时的控制点(150,150)。两次的终点都是(300,0)，但是，意义是不一样的。有点绕，但是你理解了相对于原点坐标系，和相对于当前点的坐标系，就很简单了。理解一下，思考5分钟。辣么，上面用带r的怎么写呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">path.moveTo(0,300);</span><br><span class="line">//    path.quadTo(150, 150, 300, 300);</span><br><span class="line">//    path.quadTo(450, 450, 600, 300);</span><br><span class="line">    path.rQuadTo(150,-150,300,0);</span><br><span class="line">    path.rQuadTo(150,150,300,0);</span><br><span class="line">    canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;至此，怎么换一个正弦图，以及，两个方法的区别，已经讲完了，我觉得已经讲的非常清楚了。感觉，没有谁比我讲的还要清楚了。手把手教学。我们这个效果，画一个，肯定不行。要画满一个屏幕。怎么画呢？</p><p>&emsp;&emsp;找规律，一个正弦图，我们上面都是围绕这三个点，起点，控制点，终点。要想规则，控制点的x坐标是终点x坐标的一半。再就是，要画满一个屏幕，要在屏幕内部，所以，终点x坐标要小于屏幕宽度。综上所述。</p><ol><li><p>三个点：起点，终点，控制点</p></li><li><p>控制点的x坐标是终点x坐标的一半</p></li><li><p>终点x坐标要小于屏幕宽度</p></li></ol><p>我们就开始写代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  private int startY = 300;//定义起始点的y坐标</span><br><span class="line"></span><br><span class="line">  private int endX = 300;//定义终点的x坐标</span><br><span class="line"></span><br><span class="line">  private int controlY = 150;//定义控制点的y坐标</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.moveTo(0, 300);</span><br><span class="line">    path.moveTo(0, startY);</span><br><span class="line">//    path.quadTo(150, 150, 300, 300);</span><br><span class="line">//    path.quadTo(450, 450, 600, 300);</span><br><span class="line">//这里的for循环为什么每次要加2倍的终点x坐标呢？</span><br><span class="line">    //你想一想，我们一次for循环，画的图的终点x坐标在哪？</span><br><span class="line">    for (int i = 0; i &lt; getWidth(); i += 2*endX) &#123;</span><br><span class="line">//      path.rQuadTo(150, -150, 300, 0);</span><br><span class="line">//      path.rQuadTo(150, 150, 300, 0);</span><br><span class="line">      path.rQuadTo(endX/2, -controlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX/2, controlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d302f33c39805efe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整个屏幕的水波纹效果图.png"></p><p>&emsp;&emsp;好，到这里，第一步完成了，满屏的水波纹出来了。</p><h2 id="第二步，正弦图左右在移动"><a href="#第二步，正弦图左右在移动" class="headerlink" title="第二步，正弦图左右在移动"></a>第二步，正弦图左右在移动</h2><p>&emsp;&emsp;想一想，这个动画，想一想，想一想，像不像水平位移动画？像不像？越想越像。辣么，我们就去验证一下。写一个动画，这种，明显就是属性动画。既然是左右移动，辣么就肯定是改变x轴的坐标值，改变谁的呢？肯定是起点的啊，只有改变起点的x左边的值，水波纹才会有动的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void startAnimation()&#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofFloat(0, 1);</span><br><span class="line">    animator.setDuration(1000);</span><br><span class="line">    animator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">        Float animatedValue = (Float) animation.getAnimatedValue();</span><br><span class="line">        currentStartX = (int) (endX * animatedValue);</span><br><span class="line">        postInvalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();//不加会有重影，不是我们想要的</span><br><span class="line">//    path.moveTo(0, 300);</span><br><span class="line">//    path.moveTo(0, startY);</span><br><span class="line">    path.moveTo(currentStartX, startY);</span><br><span class="line">      ...//其他的不变</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-d38f9817410a015c.gif?imageMogr2/auto-orient/strip" alt="移动有空白.gif"></p><p>&emsp;&emsp;尼玛，什么鬼？动是动起来了，为啥左边还有一段空白？不要急，想一想为什么？我们之前是从Y轴开始画的，我们这个动画是从左向又移动一个endx的值，所以，我们设置起点的时候，也向左偏移一个endx的值不就好了么？我们再试一试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();</span><br><span class="line">//    path.moveTo(0, 300);</span><br><span class="line">//    path.moveTo(0, startY);</span><br><span class="line">    path.moveTo(-endX + currentStartX, startY);</span><br><span class="line">//    path.quadTo(150, 150, 300, 300);</span><br><span class="line">//    path.quadTo(450, 450, 600, 300);</span><br><span class="line">    //这里的for循环为什么每次要加2倍的终点x坐标呢？</span><br><span class="line">    //你想一想，我们一次for循环，画的图的终点x坐标在哪？</span><br><span class="line">    for (int i = -endX; i &lt; getWidth() + endX; i += 2 * endX) &#123;</span><br><span class="line">//      path.rQuadTo(150, -150, 300, 0);</span><br><span class="line">//      path.rQuadTo(150, 150, 300, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, -controlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, controlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-f84524374a6c4273.gif?imageMogr2/auto-orient/strip" alt="移动会闪一下.gif"></p><p>&emsp;&emsp;咦，满脸的嫌弃，这是什么东西啊，空白虽然没了，为什么会卡一下，并且这个也不是我们想要的效果。我们再想一想，我们这个无线循环的动画的原理是什么？ <strong><em>敲黑板，其实，我们就是多画了一个正弦波形，我们移动之后，跟移动之前一样，也就是位移了两个正弦图，结束后的图形，跟结束前的图形重合，然后一直重复动画，从而让用户感觉是无线循环的动画。</em></strong> 辣么，哪里出问题呢？想一想，为什么达不到我们的效果，肯定是我们水平移动距离的有问题啊。找啊找啊找，找到了，我们这里的endx坐标，是一个完整正弦图形的一半。所以，我们动画移动的距离要乘以2。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">currentStartX = (int) (2 * endX * animatedValue);//动画里面的</span><br><span class="line">//动画还要加上插值器，从而达到平滑的效果</span><br><span class="line">animator.setInterpolator(new LinearInterpolator());</span><br><span class="line"></span><br><span class="line">辣么，这里距离变了，我们起始点的距离，循环的距离也要变。要不然会有空白</span><br><span class="line">path.moveTo(-endX*2 + currentStartX, startY);</span><br><span class="line"></span><br><span class="line">for (int i = -endX*2; i &lt; getWidth() + endX*2; i += 2 * endX) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;综上所述，去除无关代码之后的完整代码，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/27</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class WaveView1 extends View &#123;</span><br><span class="line">  private Path path;</span><br><span class="line">  private Paint paint;</span><br><span class="line">  private Paint paint1;</span><br><span class="line"></span><br><span class="line">  private int startY = 300;</span><br><span class="line"></span><br><span class="line">  private int endX = 300;</span><br><span class="line"></span><br><span class="line">  private int controlY = 150;</span><br><span class="line"></span><br><span class="line">  private int currentStartX;</span><br><span class="line"></span><br><span class="line">  public WaveView1(Context context) &#123;</span><br><span class="line">    this(context, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public WaveView1(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public WaveView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">    super(context, attrs, defStyleAttr);</span><br><span class="line">    initView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void initView() &#123;</span><br><span class="line">    path = new Path();</span><br><span class="line">    paint = new Paint();</span><br><span class="line">    paint1 = new Paint();</span><br><span class="line">    paint.setColor(Color.GREEN);</span><br><span class="line">    paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    paint.setStrokeWidth(10);</span><br><span class="line">    paint1.set(paint);</span><br><span class="line">    paint1.setColor(Color.RED);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();</span><br><span class="line">    path.moveTo(-endX*2 + currentStartX, startY);</span><br><span class="line">    for (int i = -endX*2; i &lt; getWidth() + endX*2; i += 2 * endX) &#123;</span><br><span class="line">      path.rQuadTo(endX / 2, -controlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, controlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void startAnimation() &#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofFloat(0, 1);</span><br><span class="line">    animator.setDuration(1000);</span><br><span class="line">    animator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">    animator.setInterpolator(new LinearInterpolator());</span><br><span class="line">    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">        Float animatedValue = (Float) animation.getAnimatedValue();</span><br><span class="line">        currentStartX = (int) (2 * endX * animatedValue);</span><br><span class="line">        postInvalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑出来的效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-aefa92a1ca8a1026.gif?imageMogr2/auto-orient/strip" alt="移动水波纹.gif"></p><p>完美达到了我们的预期效果。</p><h2 id="第三步：自定义View上下移动"><a href="#第三步：自定义View上下移动" class="headerlink" title="第三步：自定义View上下移动"></a>第三步：自定义View上下移动</h2><p>&emsp;&emsp;经过上面的左右动画，现在这个上下移动的动画就很简单了，很明显是改变起始点y坐标的值，当然，肯定是属性动画。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void startAnimation() &#123;</span><br><span class="line">    </span><br><span class="line">    ...//这是我们的左移动画，没写上来</span><br><span class="line">    </span><br><span class="line">    //这就是我们的竖着移动的动画</span><br><span class="line">    ValueAnimator animator1 = ValueAnimator.ofFloat(0, 1);</span><br><span class="line">    animator1.setDuration(5000);</span><br><span class="line">    animator1.setInterpolator(new LinearInterpolator());</span><br><span class="line">    animator1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">        Float animatedValue = (Float) animation.getAnimatedValue();</span><br><span class="line">        currentStartY = (int) (getHeight() * animatedValue);</span><br><span class="line">        postInvalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator1.start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //改变我们的初始点的y坐标。不要只写个currentStartY，</span><br><span class="line">  //光写这个是从下往上移动，你要的是从上往下移动</span><br><span class="line">  path.moveTo(-endX*2 + currentStartX, getHeight()-currentStartY);</span><br><span class="line">  </span><br><span class="line">  //再就是修改画笔为填充</span><br><span class="line">  paint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">  </span><br><span class="line">  //并且把path连接成一个闭合图形</span><br><span class="line">  ...//这里是onDraw里面的for循环画正弦图形</span><br><span class="line">  path.lineTo(getWidth(),getHeight());</span><br><span class="line">    path.lineTo(0,getHeight());</span><br><span class="line">    path.close();</span><br><span class="line">    canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure><p>跑出来的效果图，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-54f3ea96e5dc33a5.gif?imageMogr2/auto-orient/strip" alt="上下移动有bug.gif"></p><p>&emsp;&emsp;到这个位置，基本上已经完成了百分之九十了。我们可以看到开始会有一个问题，结束的时候也有一个问题，这个问题是怎么产生的呢？</p><h2 id="第四步：优化开始和结束的动画"><a href="#第四步：优化开始和结束的动画" class="headerlink" title="第四步：优化开始和结束的动画"></a>第四步：优化开始和结束的动画</h2><p>&emsp;&emsp;其实，我们可以想一想，一开始，我们这个控制点的Y值，不应该一出来就是写死的，显得太突兀了，一开始，我们应该是慢慢涨，涨到我们规定的值，然后快结束的时候，我们应该是慢慢减，减到0为止。应该是这样才对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">    path.reset();</span><br><span class="line">    int currentControlY = 0;</span><br><span class="line">    if (currentStartY &lt; controlY) &#123;</span><br><span class="line">      currentControlY = currentStartY;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      currentControlY = controlY;</span><br><span class="line">    &#125;</span><br><span class="line">    if (getHeight() - currentStartY &lt; controlY) &#123;</span><br><span class="line">      currentControlY = getHeight() - currentStartY;</span><br><span class="line">    &#125;</span><br><span class="line">    path.moveTo(-endX * 2 + currentStartX, getHeight() - currentStartY);</span><br><span class="line">    for (int i = -endX * 2; i &lt; getWidth() + endX * 2; i += 2 * endX) &#123;</span><br><span class="line">      path.rQuadTo(endX / 2, -currentControlY, endX, 0);</span><br><span class="line">      path.rQuadTo(endX / 2, currentControlY, endX, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    path.lineTo(getWidth(), getHeight());</span><br><span class="line">    path.lineTo(0, getHeight());</span><br><span class="line">    path.close();</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7041675-bb761f08bb5704c5.gif?imageMogr2/auto-orient/strip" alt="最终效果图.gif"></p><p>经过上面的操作，就完美的达到了我们的预期效果。(PS：把画笔的宽度去掉)</p><p>把这个自定义View优化一下，把方法封装好了。<a href="https://download.csdn.net/download/qq_27634797/10312090" target="_blank" rel="noopener">项目链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本文针对有一定自定义View的童鞋，最好对贝赛尔曲线有辣么一丢丢了解，不了解也没关系。花5分钟看一下 &lt;strong&gt;&lt;em&gt;GcsSloop&lt;/em&gt;&lt;/strong&gt;的 &lt;a href=&quot;http://www.gcssloop.com/customview/Path_Bezier&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安卓自定义View进阶-Path之贝塞尔曲线&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文的最终效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7041675-bb761f08bb5704c5.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;最终效果图.gif&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android -自定义view" scheme="http://haichenyi.com/categories/Android-%E8%87%AA%E5%AE%9A%E4%B9%89view/"/>
    
    
  </entry>
  
  <entry>
    <title>Android自定义刷新布局——Ultra-Pull-To-Refresh-With-Load-More（二））</title>
    <link href="http://haichenyi.com/2018/05/13/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%B7%E6%96%B0%E5%B8%83%E5%B1%80%E2%80%94%E2%80%94Ultra-Pull-To-Refresh-With-Load-More%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%89/"/>
    <id>http://haichenyi.com/2018/05/13/Android自定义刷新布局——Ultra-Pull-To-Refresh-With-Load-More（二））/</id>
    <published>2018-05-13T14:26:56.000Z</published>
    <updated>2018-05-13T14:37:02.365Z</updated>
    
    <content type="html"><![CDATA[<p><strong>个人博客：haichenyi.com。感谢关注</strong></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>上一篇，我们讲到了Ultra-Pull-To-Refresh的基本用法。分成四步：</p><ol><li><p>xml里面定义控件PtrFrameLayout</p></li><li><p>设置相关属性</p></li><li><p>添加Header，Footer，并监听</p></li><li><p>监听刷新过程</p><a id="more"></a></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&emsp;&emsp;<strong>目的：</strong> 做一个我们自己的自定义刷新的动画（我们先不管动画是什么，不同的需求，动画都不一样）</p><p>&emsp;&emsp;我们前面讲到的主要类无非就是两个： <strong><em>PtrFrameLayout</em></strong>，<strong><em>Header（Footer）</em></strong>，前者是刷新控件，监听刷新过程，后者是头布局（脚布局），以添加头布局为例：我们这里首先就会想到重写这个布局。辣么？怎么重写这个头布局呢？我们先来看看怎么添加这个头布局的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setHeaderView(View header) &#123;</span><br><span class="line">        if (mHeaderView != null &amp;&amp; header != null &amp;&amp; mHeaderView != header) &#123;</span><br><span class="line">            removeView(mHeaderView);</span><br><span class="line">        &#125;</span><br><span class="line">        ViewGroup.LayoutParams lp = header.getLayoutParams();</span><br><span class="line">        if (lp == null) &#123;</span><br><span class="line">            lp = new LayoutParams(-1, -2);</span><br><span class="line">            header.setLayoutParams(lp);</span><br><span class="line">        &#125;</span><br><span class="line">        mHeaderView = header;</span><br><span class="line">        addView(header);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它这里实际上就是添加了一个View，所以，我们随便写一个自定义View，继承View就可以传进来</p><p>&emsp;&emsp;我们，再来看看另一个方法，就是监听的方法，这里好像也是传的View对象，因为，我们前面写的时候就是传的header：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void addPtrUIHandler(PtrUIHandler ptrUIHandler) &#123;</span><br><span class="line">        PtrUIHandlerHolder.addHandler(mPtrUIHandlerHolder, ptrUIHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;咦，不对啊，这里不是应该传的View对象么？怎么是PtrUIHandler类型的。其实，你看名字就应该看的出来，他这里传的是一个PtrUIHandler对象，点进去看，他就是一个接口。里面是下拉刷新的回调。讲到这里，我们就应该明了了，就是一个自定义View，继承View，实现PtrUIHandler接口。辣么，就开始撸了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Author: 海晨忆</span><br><span class="line"> * Date: 2018/3/23</span><br><span class="line"> * Desc:</span><br><span class="line"> */</span><br><span class="line">public class MyCustomHeader extends FrameLayout implements PtrUIHandler &#123;</span><br><span class="line">  public MyCustomHeader(@NonNull Context context) &#123;</span><br><span class="line">    this(context, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomHeader(@NonNull Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">    this(context, attrs, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public MyCustomHeader(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">    super(context, attrs, defStyleAttr);</span><br><span class="line">    initView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void initView() &#123;</span><br><span class="line">    LayoutInflater.from(getContext()).inflate(R.layout.header_layout, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIReset(PtrFrameLayout frame) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshPrepare(PtrFrameLayout frame) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshBegin(PtrFrameLayout frame) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshComplete(PtrFrameLayout frame, boolean isHeader) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIPositionChange(PtrFrameLayout frame, boolean isUnderTouch, byte status,</span><br><span class="line">                                 PtrIndicator ptrIndicator) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，我这里面什么都没有，就是继承了FrameLayout布局，实现了PtrUIHandler接口，然后在构造方法里面加载了一个布局，添加进来，布局也很简单，里面就只有一个ImageView。布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;200dp&quot;</span><br><span class="line">        android:src=&quot;@drawable/psb17&quot;/&gt;</span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再就是调用了，跟上一篇的调用方式一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final PtrFrameLayout ptrFrameLayout = findViewById(R.id.ptr_frame_layout);</span><br><span class="line">    MyCustomHeader myCustomHeader = new MyCustomHeader(this);</span><br><span class="line">    ptrFrameLayout.setHeaderView(myCustomHeader);</span><br><span class="line">    ptrFrameLayout.addPtrUIHandler(myCustomHeader);</span><br><span class="line">    ptrFrameLayout.setPtrHandler(new PtrDefaultHandler2() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onRefreshBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">        frame.postDelayed(ptrFrameLayout::refreshComplete, 2000);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onLoadMoreBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">        frame.postDelayed(ptrFrameLayout::refreshComplete, 2000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后运行，你就会看到，刷新的header就是你的自定义view。到此，自定义刷新布局就完成了，脚布局方式类似。</p><p>&emsp;&emsp;什么鬼？这就没了？刷新布局就一个ImageView就没了？这么敷衍。好歹你也加个动画啊。可以可以，那就加个动画。</p><p>&emsp;&emsp;如你所愿，我加了一个帧动画。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/refresh1&quot; android:duration=&quot;100&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/refresh2&quot; android:duration=&quot;100&quot;/&gt;</span><br><span class="line">    &lt;item android:drawable=&quot;@drawable/refresh3&quot; android:duration=&quot;100&quot;/&gt;</span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure><p>header里面的改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void initView() &#123;</span><br><span class="line">    LayoutInflater.from(getContext()).inflate(R.layout.header_layout, this);</span><br><span class="line">    imageView = findViewById(R.id.img);</span><br><span class="line">    animationDrawable = (AnimationDrawable) imageView.getDrawable();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   @Override</span><br><span class="line">  public void onUIRefreshBegin(PtrFrameLayout frame) &#123;</span><br><span class="line">    imageView.setImageDrawable(animationDrawable);</span><br><span class="line">    animationDrawable.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onUIRefreshComplete(PtrFrameLayout frame, boolean isHeader) &#123;</span><br><span class="line">    animationDrawable.stop();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在初始化的时候，把动画获取到，然后在刷新的时候开始动画，在刷新完成的时候停止动画。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;个人博客：haichenyi.com。感谢关注&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;上一篇，我们讲到了Ultra-Pull-To-Refresh的基本用法。分成四步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;xml里面定义控件PtrFrameLayout&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置相关属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加Header，Footer，并监听&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监听刷新过程&lt;/p&gt;
    
    </summary>
    
      <category term="Android -常用功能" scheme="http://haichenyi.com/categories/Android-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    
    
  </entry>
  
</feed>
